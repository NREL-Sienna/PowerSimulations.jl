var documenterSearchIndex = {"docs":
[{"location":"formulation_library/Network/#Network-Formulations","page":"Network","title":"Network Formulations","text":"","category":"section"},{"location":"formulation_library/Network/","page":"Network","title":"Network","text":"TODO","category":"page"},{"location":"modeler_guide/simulation_recorder/#Simulation-Recorder","page":"Simulation Recorder","title":"Simulation Recorder","text":"","category":"section"},{"location":"modeler_guide/simulation_recorder/","page":"Simulation Recorder","title":"Simulation Recorder","text":"PowerSimulations.jl provides the ability to record structured data as events during a simulation. These events can be post-processed to help debug problems.","category":"page"},{"location":"modeler_guide/simulation_recorder/","page":"Simulation Recorder","title":"Simulation Recorder","text":"By default only SimulationStepEvent and ProblemExecutionEvent are recorded.  Here is an example.","category":"page"},{"location":"modeler_guide/simulation_recorder/","page":"Simulation Recorder","title":"Simulation Recorder","text":"Suppose a simulation is run in the directory ./output.","category":"page"},{"location":"modeler_guide/simulation_recorder/","page":"Simulation Recorder","title":"Simulation Recorder","text":"Assume that setup commands have been run:","category":"page"},{"location":"modeler_guide/simulation_recorder/","page":"Simulation Recorder","title":"Simulation Recorder","text":"using PowerSimulations\nconst PSI = PowerSimulations","category":"page"},{"location":"modeler_guide/simulation_recorder/","page":"Simulation Recorder","title":"Simulation Recorder","text":"Note that for all functions below you can optionally specify a function to filter events. The function must accept the event type and return true or false.","category":"page"},{"location":"modeler_guide/simulation_recorder/#Show-all-events-of-type-PSI.SimulationStepEvent","page":"Simulation Recorder","title":"Show all events of type PSI.SimulationStepEvent","text":"","category":"section"},{"location":"modeler_guide/simulation_recorder/","page":"Simulation Recorder","title":"Simulation Recorder","text":"julia> show_simulation_events(PSI.SimulationStepEvent, \"./output/aggregation/1\")\n┌─────────────────────┬─────────────────────┬──────┬────────┐\n│                name │     simulation_time │ step │ status │\n├─────────────────────┼─────────────────────┼──────┼────────┤\n│ SimulationStepEvent │ 2024-01-01T00:00:00 │    1 │  start │\n│ SimulationStepEvent │ 2024-01-01T23:00:00 │    1 │   done │\n│ SimulationStepEvent │ 2024-01-01T23:00:00 │    2 │  start │\n│ SimulationStepEvent │ 2024-01-02T23:00:00 │    2 │   done │\n└─────────────────────┴─────────────────────┴──────┴────────┘","category":"page"},{"location":"modeler_guide/simulation_recorder/#Show-events-of-type-PSI.ProblemExecutionEvent-for-a-specific-step-and-stage.","page":"Simulation Recorder","title":"Show events of type PSI.ProblemExecutionEvent for a specific step and stage.","text":"","category":"section"},{"location":"modeler_guide/simulation_recorder/","page":"Simulation Recorder","title":"Simulation Recorder","text":"show_simulation_events(\n    PSI.ProblemExecutionEvent,\n    \"./output/aggregation/1\",\n    x -> x.step == 1 && x.stage == 2 && x.status == \"start\"\n)\n┌──────────────────────┬─────────────────────┬──────┬───────┬────────┐\n│                 name │     simulation_time │ step │ stage │ status │\n├──────────────────────┼─────────────────────┼──────┼───────┼────────┤\n│ ProblemExecutionEvent │ 2024-01-01T00:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T00:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T01:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T02:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T03:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T04:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T05:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T06:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T07:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T08:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T09:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T10:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T11:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T12:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T13:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T14:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T15:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T16:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T17:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T18:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T19:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T20:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T21:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T22:00:00 │    1 │     2 │  start │\n└──────────────────────┴─────────────────────┴──────┴───────┴────────┘","category":"page"},{"location":"modeler_guide/parallel_simulations/#Parallel-Simulations","page":"Parallel Simulations","title":"Parallel Simulations","text":"","category":"section"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"This section contains instructions to:","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Run a Simulation in Parallel on a local computer\nRun a Simulation in Parallel on an HPC","category":"page"},{"location":"modeler_guide/parallel_simulations/#Run-a-Simulation-in-Parallel-on-a-local-computer","page":"Parallel Simulations","title":"Run a Simulation in Parallel on a local computer","text":"","category":"section"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"This page describes how to split a simulation into partitions, run each partition in parallel, and then join the results.","category":"page"},{"location":"modeler_guide/parallel_simulations/#Setup","page":"Parallel Simulations","title":"Setup","text":"","category":"section"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Create a Julia script to build and run simulations. It must meet the requirements below. A full example is in the PowerSimulations repository in test/run_partitioned_simulation.jl.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Call using PowerSimulations.\nImplement a build function that matches the signature below. It must construct a Simulation, call build!, and then return the Simulation instance. It must throw an exception if the build fails.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"function build_simulation(\n    output_dir::AbstractString,\n    simulation_name::AbstractString,\n    partitions::SimulationPartitions,\n    index::Union{Nothing, Integer}=nothing,\n)","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Here is example code to construct the Simulation with these parameters:","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"    sim = Simulation(\n        name=simulation_name,\n        steps=partitions.num_steps,\n        models=models,\n        sequence=sequence,\n        simulation_folder=output_dir,\n    )\n    status = build!(sim; partitions=partitions, index=index, serialize=isnothing(index))\n    if status != PSI.BuildStatus.BUILT\n        error(\"Failed to build simulation: status=$status\")\n    end","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Implement an execute function that matches the signature below. It must throw an exception if the execute fails.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"function execute_simulation(sim, args...; kwargs...)\n    status = execute!(sim)\n    if status != PSI.RunStatus.SUCCESSFUL\n        error(\"Simulation failed to execute: status=$status\")\n    end\nend","category":"page"},{"location":"modeler_guide/parallel_simulations/#Execution","page":"Parallel Simulations","title":"Execution","text":"","category":"section"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"After loading your script, call the function run_parallel_simulation as shown below.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"This example splits a year-long simulation into weekly partitions for a total of 53 individual jobs and then runs them four at a time.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"julia> include(\"my_simulation.jl\")\njulia> run_parallel_simulation(\n        build_simulation,\n        execute_simulation,\n        script=\"my_simulation.jl\",\n        output_dir=\"my_simulation_output\",\n        name=\"my_simulation\",\n        num_steps=365,\n        period=7,\n        num_overlap_steps=1,\n        num_parallel_processes=4,\n        exeflags=\"--project=<path-to-your-julia-environment>\",\n    )","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"The final results will be in ./my_simulation_otuput/my_simulation","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Note the log files and results for each partition are located in ./my_simulation_otuput/my_simulation/simulation_partitions","category":"page"},{"location":"modeler_guide/parallel_simulations/#Run-a-Simulation-in-Parallel-on-an-HPC","page":"Parallel Simulations","title":"Run a Simulation in Parallel on an HPC","text":"","category":"section"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"This page describes how to split a simulation into partitions, run each partition in parallel on HPC compute nodes, and then join the results.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"These steps can be used on a local computer or any HPC supported by the submission software. Some steps may be specific to NREL's HPC Eagle cluster.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Note: Some instructions are preliminary and will change if functionality is moved to a new Julia package.","category":"page"},{"location":"modeler_guide/parallel_simulations/#Setup-2","page":"Parallel Simulations","title":"Setup","text":"","category":"section"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Create a conda environment and install the Python package NREL-jade: https://nrel.github.io/jade/installation.html. The rest of this page assumes that the environment is called jade.\nActivate the environment with conda activate jade.\nLocate the path to that conda environment. It will likely be ~/.conda-envs/jade or ~/.conda/envs/jade.\nLoad the Julia environment that you use to run simulations. Add the packages Conda and PyCall.\nSetup Conda to use the existing jade environment by running these commands:","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"julia> run(`conda create -n conda_jl python conda`)\njulia> ENV[\"CONDA_JL_HOME\"] = joinpath(ENV[\"HOME\"], \".conda-envs\", \"jade\")  # change this to your path\npkg> build Conda","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Copy the code below into a Julia file called configure_parallel_simulation.jl. This is an interface to Jade through PyCall. It will be used to create a Jade configuration. (It may eventually be moved to a separate package.)","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"function configure_parallel_simulation(\n    script::AbstractString,\n    num_steps::Integer,\n    num_period_steps::Integer;\n    num_overlap_steps::Integer=0,\n    project_path=nothing,\n    simulation_name=\"simulation\",\n    config_file=\"config.json\",\n    force=false,\n)\n    partitions = SimulationPartitions(num_steps, num_period_steps, num_overlap_steps)\n    jgc = pyimport(\"jade.extensions.generic_command\")\n    julia_cmd = isnothing(project_path) ? \"julia\" : \"julia --project=$project_path\"\n    setup_command = \"$julia_cmd $script setup --simulation-name=$simulation_name \" *\n    \"--num-steps=$num_steps --num-period-steps=$num_period_steps \" *\n    \"--num-overlap-steps=$num_overlap_steps\"\n    teardown_command = \"$julia_cmd $script join --simulation-name=$simulation_name\"\n    config = jgc.GenericCommandConfiguration(\n        setup_command=setup_command,\n        teardown_command=teardown_command,\n    )\n\n    for i in 1:get_num_partitions(partitions)\n        cmd = \"$julia_cmd $script execute --simulation-name=$simulation_name --index=$i\"\n        job = jgc.GenericCommandParameters(command=cmd, name=\"execute-$i\")\n        config.add_job(job)\n    end\n\n    config.dump(config_file, indent=2)\n    println(\"Created Jade configuration in $config_file. \" *\n            \"Run 'jade submit-jobs [options] $config_file' to execute them.\")\nend","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Create a Julia script to build and run simulations. It must meet the requirements below. A full example is in the PowerSimulations repository in test/run_partitioned_simulation.jl.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Call using PowerSimulations.\nImplement a build function that matches the signature below. It must construct a Simulation, call build!, and then return the Simulation instance. It must throw an exception if the build fails.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"function build_simulation(\n    output_dir::AbstractString,\n    simulation_name::AbstractString,\n    partitions::SimulationPartitions,\n    index::Union{Nothing, Integer}=nothing,\n)","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Here is example code to construct the Simulation with these parameters:","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"    sim = Simulation(\n        name=simulation_name,\n        steps=partitions.num_steps,\n        models=models,\n        sequence=sequence,\n        simulation_folder=output_dir,\n    )\n    status = build!(sim; partitions=partitions, index=index, serialize=isnothing(index))\n    if status != PSI.BuildStatus.BUILT\n        error(\"Failed to build simulation: status=$status\")\n    end","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Implement an execute function that matches the signature below. It must throw an exception if the execute fails.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"function execute_simulation(sim, args...; kwargs...)\n    status = execute!(sim)\n    if status != PSI.RunStatus.SUCCESSFUL\n        error(\"Simulation failed to execute: status=$status\")\n    end\nend","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Make the script runnable as a CLI command by including the following code at the bottom of the","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"file.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"function main()\n    process_simulation_partition_cli_args(build_simulation, execute_simulation, ARGS...)\nend\n\nif abspath(PROGRAM_FILE) == @__FILE__\n    main()\nend","category":"page"},{"location":"modeler_guide/parallel_simulations/#Execution-2","page":"Parallel Simulations","title":"Execution","text":"","category":"section"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Create a Jade configuration that defines the partitioned simulation jobs. Load your Julia environment.\nThis example splits a year-long simulation into weekly partitions for a total of 53 individual jobs.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"julia> include(\"configure_parallel_simulation.jl\")\njulia> num_steps = 365\njulia> period = 7\njulia> num_overlap_steps = 1\njulia> configure_parallel_simulation(\n    \"my_simulation.jl\",  # this is your build/execute script\n    num_steps,\n    period,\n    num_overlap_steps=1,\n    project_path=\".\",  # This optionally specifies the Julia project environment to load.\n)\nCreated Jade configuration in config.json. Run 'jade submit-jobs [options] config.json' to execute them.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Exit Julia.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"View the configuration for accuracy.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"$ jade config show config.json","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Start an interactive session on a debug node. Do not submit the jobs on a login node! The submission step will run a full build of the simulation and that may consume too many CPU and memory resources for the login node.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"$ salloc -t 01:00:00 -N1 --account=<your-account> --partition=debug","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Follow the instructions at https://nrel.github.io/jade/tutorial.html to submit the jobs. The example below will configure Jade to run each partition on its own compute node. Depending on the compute and memory constraints of your simulation, you may be able to pack more jobs on each node.\nAdjust the walltime as necessary.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"$ jade config hpc -c hpc_config.toml -t slurm  --walltime=04:00:00 -a <your-account>\n$ jade submit-jobs config.json --per-node-batch-size=1 -o output","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"If you are unsure about how much memory and CPU resources your simulation consumes, add these options:","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"$ jade submit-jobs config.json --per-node-batch-size=1 -o output --resource-monitor-type periodic --resource-monitor-interval 3","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Jade will create HTML plots of the resource utilization in output/stats. You may be able to customize --per-node-batch-size and --num-processes to finish the simulations more quickly.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Jade will run a final command to join the simulation partitions into one unified file. You can load the results as you normally would.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"julia> results = SimulationResults(\"<output-dir>/job-outputs/<simulation-name>\")","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Note the log files and results for each partition are located in <output-dir>/job-outputs/<simulation-name>/simulation_partitions","category":"page"},{"location":"quick_start_guide/#Quick-Start-Guide","page":"Quick Start Guide","title":"Quick Start Guide","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Julia: If this is your first time using Julia visit our Introduction to Julia and the officialGetting started with Julia.\nPackage Installation: If you want to install packages check the Package Manager instructions, or you can refer to the PowerSimulations installation instructions. \nPowerSystems: PowerSystems.jl manages the data and is a fundamental dependency of PowerSimulations.jl. Check the Understanding PowerSystems.jl page and PowerSystems.jl documentation to understand how the inputs to the models are organized.\nDataset Library: If you don't have a data set to start using PowerSimulations.jl check the test systems provided in PowerSystemCaseBuilder.jl","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"tip: Tip\nIf you need to develop a dataset for a simulation check the tutorials on how to parse data and attach time series","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Tutorial: If you are eager to run your first simulation visit the Solve a Day Ahead Market Scheduling Problem using PowerSimulations.jl tutorial","category":"page"},{"location":"code_base_developer_guide/troubleshooting/#Troubleshooting-code-development","page":"Troubleshooting","title":"Troubleshooting code development","text":"","category":"section"},{"location":"formulation_library/Storage/#PowerSystems.Storage-Formulations","page":"Storage","title":"PowerSystems.Storage Formulations","text":"","category":"section"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"Valid DeviceModels for subtypes of Storage include the following:","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"using PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.generate_device_formulation_combinations()\nfilter!(x -> x[\"device_type\"] <: Storage, combos)\ncombo_table = DataFrame(\n    \"Valid DeviceModel\" => [\"`DeviceModel($(c[\"device_type\"]), $(c[\"formulation\"]))`\" for c in combos],\n    \"Device Type\" => [\"[$(c[\"device_type\"])](https://nrel-siip.github.io/PowerSystems.jl/stable/model_library/generated_$(c[\"device_type\"])/)\" for c in combos],\n    \"Formulation\" => [\"[$(c[\"formulation\"])](@ref)\" for c in combos],\n    )\nmdtable(combo_table, latex = false)","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"","category":"page"},{"location":"formulation_library/Storage/#BookKeeping","page":"Storage","title":"BookKeeping","text":"","category":"section"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"BookKeeping","category":"page"},{"location":"formulation_library/Storage/#PowerSimulations.BookKeeping","page":"Storage","title":"PowerSimulations.BookKeeping","text":"Formulation type to add basic storage formulation. With attributes=Dict(\"reservation\"=>true) the formulation is augmented with abinary variable to prevent simultanious charging and discharging\n\nBookKeeping()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:149.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"Variables:","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"ActivePowerInVariable:\nBounds: [0.0, ]\nDefault initial value: -1 * PowerSystems.get_active_power(device)\nActivePowerOutVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_active_power(device)\nReactivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_reactive_power(device)\nEnergyVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_initial_storage(device)\nReservationVariable:\nonly included if DeviceModel(HydroPumpedStorage, HydroDispatchPumpedStorage; attributes = Dict(reservation => true))\nBounds: {0, 1}\nDefault initial value: 1","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"Static Parameters:","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"Pg^textmin = PowerSystems.get_active_power_limits(device).min\nQg^textmin = PowerSystems.get_reactive_power_limits(device).min\nQg^textmax = PowerSystems.get_reactive_power_limits(device).max\nE^textmax = PowerSystems.get_storage_capacity(device)","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"Objective:","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"Creates an objective function term based on the VariableCost Options where the quantity term is defined as Pg_t.","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"Expressions:","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"Adds Pg and Qg terms to the respective active and reactive power balance expressions created by the selected Network Formulations","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"Constraints:","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"beginaligned\n  E_t+1 = E_t + (Pg^in_t - Pg^out_t) cdot Delta T \n  Pg^in_t - r * Pg^textin max le Pg^textin max \n  Pg^out_t + r * Pg^textout max le Pg^textout max \n  Qg^textmin le Qg_t le Qg^textmax \n  E_t le E^textmax\nendaligned","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"","category":"page"},{"location":"formulation_library/Storage/#EnergyTarget","page":"Storage","title":"EnergyTarget","text":"","category":"section"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"EnergyTarget","category":"page"},{"location":"formulation_library/Storage/#PowerSimulations.EnergyTarget","page":"Storage","title":"PowerSimulations.EnergyTarget","text":"Formulation type to add storage formulation that respects end of horizon energy state of charge target. With attributes=Dict(\"reservation\"=>true) the formulation is augmented with abinary variable to prevent simultanious charging and discharging\n\nEnergyTarget()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:159.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"Variables:","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"ActivePowerInVariable:\nBounds: [0.0, ]\nDefault initial value: -1 * PowerSystems.get_active_power(device)\nActivePowerOutVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_active_power(device)\nReactivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_reactive_power(device)\nEnergyVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_initial_storage(device)\nEnergyShortageVariable:\nBounds: [ , 0.0]\nDefault initial value: 0.0\nEnergySurplusVariable:\nBounds: [0.0, ]\nDefault initial value: 0.0\nReservationVariable:\nonly included if DeviceModel(HydroPumpedStorage, HydroDispatchPumpedStorage; attributes = Dict(reservation => true))\nBounds: {0, 1}\nDefault initial value: 1","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"Static Parameters:","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"Pg^textmin = PowerSystems.get_active_power_limits(device).min\nQg^textmin = PowerSystems.get_reactive_power_limits(device).min\nQg^textmax = PowerSystems.get_reactive_power_limits(device).max\nE^textmax = PowerSystems.get_storage_capacity(device)","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"Time Series Parameters:","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"using PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.get_default_time_series_names(Storage, EnergyTarget)\ncombo_table = DataFrame(\n    \"Parameter\" => map(x -> \"[`$x`](@ref)\", collect(keys(combos))),\n    \"Default Time Series Name\" => map(x -> \"`$x`\", collect(values(combos))),\n    )\nmdtable(combo_table, latex = false)","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"Objective:","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"Creates an objective function term based on the VariableCost Options where the quantity term is defined as Pg_t, and objective function terms for StorageManagementCost.","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"Expressions:","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"Adds Pg and Qg terms to the respective active and reactive power balance expressions created by the selected Network Formulations","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"Constraints:","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"beginaligned\n  E_t+1 = E_t + (Pg^in_t - Pg^out_t) cdot Delta T \n  E_t - E^surplus_t + E^shortage_t = EnergyTargetTimeSeriesParameter_t \n  Pg^in_t - r * Pg^textin max le Pg^textin max \n  Pg^out_t + r * Pg^textout max le Pg^textout max \n  Qg^textmin le Qg_t le Qg^textmax\n  E_t le E^textmax\nendaligned","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"","category":"page"},{"location":"formulation_library/Storage/#BatteryAncillaryServices","page":"Storage","title":"BatteryAncillaryServices","text":"","category":"section"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"BatteryAncillaryServices","category":"page"},{"location":"formulation_library/Storage/#PowerSimulations.BatteryAncillaryServices","page":"Storage","title":"PowerSimulations.BatteryAncillaryServices","text":"Formulation type to add storage formulation than can provide ancillary services. With attributes=Dict(\"reservation\"=>true) the formulation is augmented with abinary variable to prevent simultanious charging and discharging\n\nBatteryAncillaryServices()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:154.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"Variables:","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"ActivePowerInVariable:\nBounds: [0.0, ]\nDefault initial value: -1 * PowerSystems.get_active_power(device)\nActivePowerOutVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_active_power(device)\nReactivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_reactive_power(device)\nEnergyVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_initial_storage(device)\nReservationVariable:\nonly included if DeviceModel(HydroPumpedStorage, HydroDispatchPumpedStorage; attributes = Dict(reservation => true))\nBounds: {0, 1}\nDefault initial value: 1","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"Static Parameters:","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"Pg^textmin = PowerSystems.get_active_power_limits(device).min\nQg^textmin = PowerSystems.get_reactive_power_limits(device).min\nQg^textmax = PowerSystems.get_reactive_power_limits(device).max\nE^textmax = PowerSystems.get_storage_capacity(device)","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"Time Series Parameters:","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"using PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.get_default_time_series_names(Storage, EnergyTarget)\ncombo_table = DataFrame(\n    \"Parameter\" => map(x -> \"[`$x`](@ref)\", collect(keys(combos))),\n    \"Default Time Series Name\" => map(x -> \"`$x`\", collect(values(combos))),\n    )\nmdtable(combo_table, latex = false)","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"Objective:","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"Creates an objective function term based on the VariableCost Options where the quantity term is defined as Pg_t, and objective function terms for StorageManagementCost.","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"Expressions:","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"Adds Pg and Qg terms to the respective active and reactive power balance expressions created by the selected Network Formulations","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"Constraints:","category":"page"},{"location":"formulation_library/Storage/","page":"Storage","title":"Storage","text":"beginaligned\n  E_t+1 = E_t + (Pg^in_t - Pg^out_t) cdot Delta T \n  E_t - E^surplus_t + E^shortage_t = EnergyTargetTimeSeriesParameter_t \n  Pg^in_t - r * Pg^textin max le Pg^textin max \n  Pg^out_t + r * Pg^textout max le Pg^textout max \n  Qg^textmin le Qg_t le Qg^textmax\n  E_t le E^textmax\nendaligned","category":"page"},{"location":"modeler_guide/tips_and_tricks/#Tips-and-tricks","page":"Tips and tricks","title":"Tips and tricks","text":"","category":"section"},{"location":"formulation_library/ThermalGen/#ThermalGen-Formulations","page":"Thermal Generation","title":"ThermalGen Formulations","text":"","category":"section"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"Valid DeviceModels for subtypes of ThermalGen include the following:","category":"page"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"using PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.generate_device_formulation_combinations()\nfilter!(x -> x[\"device_type\"] <: ThermalGen, combos)\ncombo_table = DataFrame(\n    \"Valid DeviceModel\" => [\"`DeviceModel($(c[\"device_type\"]), $(c[\"formulation\"]))`\" for c in combos],\n    \"Device Type\" => [\"[$(c[\"device_type\"])](https://nrel-siip.github.io/PowerSystems.jl/stable/model_library/generated_$(c[\"device_type\"])/)\" for c in combos],\n    \"Formulation\" => [\"[$(c[\"formulation\"])](@ref)\" for c in combos],\n    )\nmdtable(combo_table, latex = false)","category":"page"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"","category":"page"},{"location":"formulation_library/ThermalGen/#ThermalBasicDispatch","page":"Thermal Generation","title":"ThermalBasicDispatch","text":"","category":"section"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"ThermalBasicDispatch","category":"page"},{"location":"formulation_library/ThermalGen/#PowerSimulations.ThermalBasicDispatch","page":"Thermal Generation","title":"PowerSimulations.ThermalBasicDispatch","text":"Formulation type to enable basic dispatch without any intertemporal (ramp) constraints\n\nThermalBasicDispatch()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:30.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"TODO","category":"page"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"","category":"page"},{"location":"formulation_library/ThermalGen/#ThermalCompactDispatch","page":"Thermal Generation","title":"ThermalCompactDispatch","text":"","category":"section"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"ThermalCompactDispatch","category":"page"},{"location":"formulation_library/ThermalGen/#PowerSimulations.ThermalCompactDispatch","page":"Thermal Generation","title":"PowerSimulations.ThermalCompactDispatch","text":"Formulation type to enable thermal compact dispatch\n\nThermalCompactDispatch()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:54.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"TODO","category":"page"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"","category":"page"},{"location":"formulation_library/ThermalGen/#ThermalDispatchNoMin","page":"Thermal Generation","title":"ThermalDispatchNoMin","text":"","category":"section"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"ThermalDispatchNoMin","category":"page"},{"location":"formulation_library/ThermalGen/#PowerSimulations.ThermalDispatchNoMin","page":"Thermal Generation","title":"PowerSimulations.ThermalDispatchNoMin","text":"Formulation type to enable basic dispatch without any intertemporal constraints and relaxed minimum generation. may not work with PWL cost definitions\n\nThermalDispatchNoMin()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:38.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"TODO","category":"page"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"","category":"page"},{"location":"formulation_library/ThermalGen/#ThermalStandardDispatch","page":"Thermal Generation","title":"ThermalStandardDispatch","text":"","category":"section"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"ThermalStandardDispatch","category":"page"},{"location":"formulation_library/ThermalGen/#PowerSimulations.ThermalStandardDispatch","page":"Thermal Generation","title":"PowerSimulations.ThermalStandardDispatch","text":"Formulation type to enable standard dispatch with a range and enforce intertemporal ramp constraints\n\nThermalStandardDispatch()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:34.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"TODO","category":"page"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"","category":"page"},{"location":"formulation_library/ThermalGen/#ThermalBasicCompactUnitCommitment","page":"Thermal Generation","title":"ThermalBasicCompactUnitCommitment","text":"","category":"section"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"ThermalBasicCompactUnitCommitment","category":"page"},{"location":"formulation_library/ThermalGen/#PowerSimulations.ThermalBasicCompactUnitCommitment","page":"Thermal Generation","title":"PowerSimulations.ThermalBasicCompactUnitCommitment","text":"Formulation type to enable thermal compact commitment without intertemporal (ramp, min on/off time) constraints\n\nThermalBasicCompactUnitCommitment()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:50.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"TODO","category":"page"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"","category":"page"},{"location":"formulation_library/ThermalGen/#ThermalCompactUnitCommitment","page":"Thermal Generation","title":"ThermalCompactUnitCommitment","text":"","category":"section"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"ThermalCompactUnitCommitment","category":"page"},{"location":"formulation_library/ThermalGen/#PowerSimulations.ThermalCompactUnitCommitment","page":"Thermal Generation","title":"PowerSimulations.ThermalCompactUnitCommitment","text":"Formulation type to enable thermal compact commitment\n\nThermalCompactUnitCommitment()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:46.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"TODO","category":"page"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"","category":"page"},{"location":"formulation_library/ThermalGen/#ThermalMultiStartUnitCommitment","page":"Thermal Generation","title":"ThermalMultiStartUnitCommitment","text":"","category":"section"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"ThermalMultiStartUnitCommitment","category":"page"},{"location":"formulation_library/ThermalGen/#PowerSimulations.ThermalMultiStartUnitCommitment","page":"Thermal Generation","title":"PowerSimulations.ThermalMultiStartUnitCommitment","text":"Formulation type to enable pg-lib commitment formulation with startup/shutdown profiles\n\nThermalMultiStartUnitCommitment()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:42.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"TODO","category":"page"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"","category":"page"},{"location":"formulation_library/ThermalGen/#ThermalBasicUnitCommitment","page":"Thermal Generation","title":"ThermalBasicUnitCommitment","text":"","category":"section"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"ThermalBasicUnitCommitment","category":"page"},{"location":"formulation_library/ThermalGen/#PowerSimulations.ThermalBasicUnitCommitment","page":"Thermal Generation","title":"PowerSimulations.ThermalBasicUnitCommitment","text":"Formulation type to enable basic unit commitment representation without any intertemporal (ramp, min on/off time) constraints\n\nThermalBasicUnitCommitment()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:22.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"TODO","category":"page"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"","category":"page"},{"location":"formulation_library/ThermalGen/#ThermalStandardUnitCommitment","page":"Thermal Generation","title":"ThermalStandardUnitCommitment","text":"","category":"section"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"ThermalStandardUnitCommitment","category":"page"},{"location":"formulation_library/ThermalGen/#PowerSimulations.ThermalStandardUnitCommitment","page":"Thermal Generation","title":"PowerSimulations.ThermalStandardUnitCommitment","text":"Formulaiton type to enable standard unit commitment with intertemporal constraints and simplified startup profiles\n\nThermalStandardUnitCommitment()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:26.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"TODO","category":"page"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"","category":"page"},{"location":"formulation_library/Branch/#PowerSystems.Branch-Formulations","page":"Branch","title":"PowerSystems.Branch Formulations","text":"","category":"section"},{"location":"formulation_library/Branch/","page":"Branch","title":"Branch","text":"Valid DeviceModels for subtypes of Branch include the following:","category":"page"},{"location":"formulation_library/Branch/","page":"Branch","title":"Branch","text":"using PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.generate_device_formulation_combinations()\nfilter!(x -> x[\"device_type\"] <: Branch, combos)\ncombo_table = DataFrame(\n    \"Valid DeviceModel\" => [\"`DeviceModel($(c[\"device_type\"]), $(c[\"formulation\"]))`\" for c in combos],\n    \"Device Type\" => [\"[$(c[\"device_type\"])](https://nrel-siip.github.io/PowerSystems.jl/stable/model_library/generated_$(c[\"device_type\"])/)\" for c in combos],\n    \"Formulation\" => [\"[$(c[\"formulation\"])](@ref)\" for c in combos],\n    )\nmdtable(combo_table, latex = false)","category":"page"},{"location":"formulation_library/Branch/","page":"Branch","title":"Branch","text":"","category":"page"},{"location":"formulation_library/Branch/#StaticBranch","page":"Branch","title":"StaticBranch","text":"","category":"section"},{"location":"formulation_library/Branch/","page":"Branch","title":"Branch","text":"StaticBranch","category":"page"},{"location":"formulation_library/Branch/#PowerSimulations.StaticBranch","page":"Branch","title":"PowerSimulations.StaticBranch","text":"Branch type to add unbounded flow variables and use flow constraints\n\nStaticBranch()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:176.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Branch/","page":"Branch","title":"Branch","text":"","category":"page"},{"location":"formulation_library/Branch/#StaticBranchBounds","page":"Branch","title":"StaticBranchBounds","text":"","category":"section"},{"location":"formulation_library/Branch/","page":"Branch","title":"Branch","text":"StaticBranchBounds","category":"page"},{"location":"formulation_library/Branch/#PowerSimulations.StaticBranchBounds","page":"Branch","title":"PowerSimulations.StaticBranchBounds","text":"Branch type to add bounded flow variables and use flow constraints\n\nStaticBranchBounds()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:180.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Branch/","page":"Branch","title":"Branch","text":"","category":"page"},{"location":"formulation_library/Branch/#StaticBranchUnbounded","page":"Branch","title":"StaticBranchUnbounded","text":"","category":"section"},{"location":"formulation_library/Branch/","page":"Branch","title":"Branch","text":"StaticBranchUnbounded","category":"page"},{"location":"formulation_library/Branch/#PowerSimulations.StaticBranchUnbounded","page":"Branch","title":"PowerSimulations.StaticBranchUnbounded","text":"Branch type to avoid flow constraints\n\nStaticBranchUnbounded()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:184.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Branch/","page":"Branch","title":"Branch","text":"","category":"page"},{"location":"formulation_library/Branch/#HVDCLossless","page":"Branch","title":"HVDCLossless","text":"","category":"section"},{"location":"formulation_library/Branch/","page":"Branch","title":"Branch","text":"HVDCLossless","category":"page"},{"location":"formulation_library/Branch/#PowerSimulations.HVDCLossless","page":"Branch","title":"PowerSimulations.HVDCLossless","text":"Branch type to represent lossless power flow on DC lines\n\nHVDCLossless()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:195.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Branch/","page":"Branch","title":"Branch","text":"","category":"page"},{"location":"formulation_library/Branch/#HVDCDispatch","page":"Branch","title":"HVDCDispatch","text":"","category":"section"},{"location":"formulation_library/Branch/","page":"Branch","title":"Branch","text":"HVDCDispatch","category":"page"},{"location":"formulation_library/Branch/#PowerSimulations.HVDCDispatch","page":"Branch","title":"PowerSimulations.HVDCDispatch","text":"Branch type to represent lossy power flow on DC lines\n\nHVDCDispatch()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:199.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Branch/","page":"Branch","title":"Branch","text":"","category":"page"},{"location":"formulation_library/Branch/#HVDCUnbounded","page":"Branch","title":"HVDCUnbounded","text":"","category":"section"},{"location":"formulation_library/Branch/","page":"Branch","title":"Branch","text":"HVDCUnbounded","category":"page"},{"location":"formulation_library/Branch/#PowerSimulations.HVDCUnbounded","page":"Branch","title":"PowerSimulations.HVDCUnbounded","text":"Branch type to avoid flow constraints\n\nHVDCUnbounded()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:191.\n\n\n\n\n\n","category":"type"},{"location":"modeler_guide/problem_templates/#op_problem_template","page":"Operations ProblemTemplates","title":"Operations ProblemTemplates","text":"","category":"section"},{"location":"modeler_guide/problem_templates/","page":"Operations ProblemTemplates","title":"Operations ProblemTemplates","text":"Templates are used to specify the modeling properties of the devices and network that are going to he used to specify a problem. A ProblemTemplate is just a collection of DeviceModels that allows the user to specify the formulations of each set of devices (by device type) independently so that the modeler can adjust the level of detail according to the question of interest and the available data. For more information about valid DeviceModels and their mathematical representations, check out the Formulation Library.","category":"page"},{"location":"modeler_guide/problem_templates/#Building-a-ProblemTemplate","page":"Operations ProblemTemplates","title":"Building a ProblemTemplate","text":"","category":"section"},{"location":"modeler_guide/problem_templates/","page":"Operations ProblemTemplates","title":"Operations ProblemTemplates","text":"You can build a ProblemTemplate by adding a NetworkModel, DeviceModels, and ServiceModels.","category":"page"},{"location":"modeler_guide/problem_templates/","page":"Operations ProblemTemplates","title":"Operations ProblemTemplates","text":"template = ProblemTemplate()\nset_network_model!(template, NetworkModel(CopperPlatePowerModel))\nset_device_model!(template, PowerLoad, StaticPowerLoad)\nset_device_model!(template, ThermalStandard, ThermalBasicUnitCommitment)\nset_service_model!(template, VariableReserve{ReserveUp}, RangeReserve)","category":"page"},{"location":"modeler_guide/problem_templates/#Default-Templates","page":"Operations ProblemTemplates","title":"Default Templates","text":"","category":"section"},{"location":"modeler_guide/problem_templates/","page":"Operations ProblemTemplates","title":"Operations ProblemTemplates","text":"PowerSimulations.jl provides default templates for common operation problems. You can retrieve a default template and modify it according to your requirements. Currently supported default templates are:","category":"page"},{"location":"modeler_guide/problem_templates/","page":"Operations ProblemTemplates","title":"Operations ProblemTemplates","text":"template_economic_dispatch","category":"page"},{"location":"modeler_guide/problem_templates/","page":"Operations ProblemTemplates","title":"Operations ProblemTemplates","text":"using PowerSimulations #hide\ntemplate_economic_dispatch()","category":"page"},{"location":"modeler_guide/problem_templates/","page":"Operations ProblemTemplates","title":"Operations ProblemTemplates","text":"template_unit_commitment","category":"page"},{"location":"modeler_guide/problem_templates/","page":"Operations ProblemTemplates","title":"Operations ProblemTemplates","text":"using PowerSimulations #hide\ntemplate_unit_commitment()","category":"page"},{"location":"modeler_guide/problem_templates/","page":"Operations ProblemTemplates","title":"Operations ProblemTemplates","text":"template_agc_reserve_deployment","category":"page"},{"location":"modeler_guide/problem_templates/","page":"Operations ProblemTemplates","title":"Operations ProblemTemplates","text":"using PowerSimulations #hide\ntemplate_agc_reserve_deployment()","category":"page"},{"location":"code_base_developer_guide/developer/#Guidelines-for-Developers","page":"Developer Guide","title":"Guidelines for Developers","text":"","category":"section"},{"location":"code_base_developer_guide/developer/","page":"Developer Guide","title":"Developer Guide","text":"In order to contribute to PowerSystems.jl repository please read the following sections of InfrastructureSystems.jl documentation in detail:","category":"page"},{"location":"code_base_developer_guide/developer/","page":"Developer Guide","title":"Developer Guide","text":"Style Guide\nContributing Guidelines","category":"page"},{"location":"code_base_developer_guide/developer/","page":"Developer Guide","title":"Developer Guide","text":"Pull requests are always welcome to fix bugs or add additional modeling capabilities.","category":"page"},{"location":"code_base_developer_guide/developer/","page":"Developer Guide","title":"Developer Guide","text":"All the code contributions need to include tests with a minimum coverage of 70%","category":"page"},{"location":"modeler_guide/modeling_faq/#Modeling-FAQ","page":"Modeling FAQ","title":"Modeling FAQ","text":"","category":"section"},{"location":"modeler_guide/modeling_faq/","page":"Modeling FAQ","title":"Modeling FAQ","text":"question: How do I reduce the amount of print on my REPL?\nThe print to the REPL is controlled with the logging. Check the Logging documentation page to see how to reduce the print out","category":"page"},{"location":"modeler_guide/modeling_faq/","page":"Modeling FAQ","title":"Modeling FAQ","text":"question: How do I print the optimizer logs to see the solution process?\nWhen specifying the DecisionModel or EmulationModel pass the keyword print_optimizer_log = true","category":"page"},{"location":"api/PowerSimulations/#PowerSimulations","page":"API Reference","title":"PowerSimulations","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"CurrentModule = PowerSimulations\nDocTestSetup  = quote\n    using PowerSimulations\nend","category":"page"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"API documentation","category":"page"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"Pages = [\"PowerSimulations.md\"]","category":"page"},{"location":"api/PowerSimulations/#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"Pages = [\"PowerSimulations.md\"]","category":"page"},{"location":"api/PowerSimulations/#Exported","page":"API Reference","title":"Exported","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"Modules = [PowerSimulations]\nPrivate = false\nFilter = t -> typeof(t) === DataType ? !(t <: Union{PowerSimulations.AbstractDeviceFormulation, PowerSimulations.AbstractServiceFormulation}) : true","category":"page"},{"location":"api/PowerSimulations/#PowerSimulations.AGCReserveDeployment-Tuple{System}","page":"API Reference","title":"PowerSimulations.AGCReserveDeployment","text":"AGCReserveDeployment(\n    system::System;\n    kwargs...\n) -> DecisionModel{UnitCommitmentProblem}\n\n\nAGCReserveDeployment(system::PSY.System; kwargs...)\n\nCreates a ProblemTemplate with default DeviceModels for an AGC Reserve Deplyoment Problem. Uses the template to create an DecisionProblem.\n\nExample\n\nagc_problem = AGCReserveDeployment(system)\n\n\n# Accepted Key Words\n- Key word arguments supported by `DecisionProblem`\n\nAGCReserveDeployment(system; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/decision_problems.jl:90.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.ActivePowerInVariable","page":"API Reference","title":"PowerSimulations.ActivePowerInVariable","text":"Struct to dispatch the creation of Active Power Input Variables for 2-directional devices. For instance storage or pump-hydro\n\nDocs abbreviation: Pg^in\n\nActivePowerInVariable()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/variables.jl:53.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ActivePowerOutVariable","page":"API Reference","title":"PowerSimulations.ActivePowerOutVariable","text":"Struct to dispatch the creation of Active Power Output Variables for 2-directional devices. For instance storage or pump-hydro\n\nDocs abbreviation: Pg^out\n\nActivePowerOutVariable()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/variables.jl:60.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ActivePowerReserveVariable","page":"API Reference","title":"PowerSimulations.ActivePowerReserveVariable","text":"Struct to dispatch the creation of Active Power Reserve Variables\n\nDocs abbreviation: Pr\n\nActivePowerReserveVariable()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/variables.jl:131.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ActivePowerTimeSeriesParameter","page":"API Reference","title":"PowerSimulations.ActivePowerTimeSeriesParameter","text":"Parameter to define active power time series\n\nActivePowerTimeSeriesParameter()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/parameters.jl:160.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ActivePowerVariable","page":"API Reference","title":"PowerSimulations.ActivePowerVariable","text":"Struct to dispatch the creation of Active Power Variables\n\nDocs abbreviation: Pg\n\nActivePowerVariable()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/variables.jl:39.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.DecisionModel","page":"API Reference","title":"PowerSimulations.DecisionModel","text":"DecisionModel(::Type{M},\ntemplate::ProblemTemplate,\nsys::PSY.System,\njump_model::Union{Nothing, JuMP.Model}=nothing;\nkwargs...) where {M<:DecisionProblem,\n                  T<:PM.AbstractPowerFormulation}\n\nThis builds the optimization problem of type M with the specific system and template.\n\nArguments\n\n::Type{M} where M<:DecisionProblem: The abstract operation model type\ntemplate::ProblemTemplate: The model reference made up of transmission, devices, branches, and services.\nsys::PSY.System: the system created using Power Systems\njump_model::Union{Nothing, JuMP.Model}: Enables passing a custom JuMP model. Use with care\n\nOutput\n\nmodel::DecisionModel: The operation model containing the model type, built JuMP model, Power Systems system.\n\nExample\n\ntemplate = ProblemTemplate(CopperPlatePowerModel, devices, branches, services)\nOpModel = DecisionModel(MockOperationProblem, template, system)\n\nAccepted Key Words\n\noptimizer: The optimizer that will be used in the optimization model.\nhorizon::Int: Manually specify the length of the forecast Horizon\nwarm_start::Bool: True will use the current operation point in the system to initialize variable values. False initializes all variables to zero. Default is true\nsystem_to_file::Bool:: True to create a copy of the system used in the model. Default true.\nexport_pwl_vars::Bool: True to export all the pwl intermediate variables. It can slow down significantly the solve time. Default is false.\nallow_fails::Bool: True to allow the simulation to continue even if the optimization step fails. Use with care, default to false.\noptimizer_solve_log_print::Bool: True to print the optimizer solve log. Default is false.\ndirect_mode_optimizer::Bool True to use the solver in direct mode. Creates a JuMP.direct_model. Default is false.\ninitial_time::Dates.DateTime: Initial Time for the model solve\ntime_series_cache_size::Int: Size in bytes to cache for each time array. Default is 1 MiB. Set to 0 to disable.\n\nDecisionModel(, template, sys)\nDecisionModel(, template, sys, jump_model; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/decision_model.jl:171.\n\nDecisionModel(template, sys)\nDecisionModel(template, sys, jump_model; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/decision_model.jl:181.\n\nDecisionModel(directory, optimizer; jump_model, system)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/decision_model.jl:206.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.DecisionModel-Tuple{AbstractString, MathOptInterface.OptimizerWithAttributes}","page":"API Reference","title":"PowerSimulations.DecisionModel","text":"DecisionModel(\n    directory::AbstractString,\n    optimizer::MathOptInterface.OptimizerWithAttributes;\n    jump_model,\n    system\n) -> Any\n\n\nDecisionModel(directory::AbstractString)\n\nConstruct an DecisionProblem from a serialized file.\n\nArguments\n\ndirectory::AbstractString: Directory containing a serialized model\njump_model::Union{Nothing, JuMP.Model} = nothing: The JuMP model does not get serialized. Callers should pass whatever they passed to the original problem.\noptimizer::Union{Nothing,MOI.OptimizerWithAttributes} = nothing: The optimizer does not get serialized. Callers should pass whatever they passed to the original problem.\nsystem::Union{Nothing, PSY.System}: Optionally, the system used for the model. If nothing and systofile was set to true when the model was created, the system will be deserialized from a file.\n\nDecisionModel(directory, optimizer; jump_model, system)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/decision_model.jl:206.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.DecisionModel-Union{Tuple{M}, Tuple{Type{M}, ProblemTemplate, System}, Tuple{Type{M}, ProblemTemplate, System, Union{Nothing, JuMP.Model}}} where M<:PowerSimulations.DecisionProblem","page":"API Reference","title":"PowerSimulations.DecisionModel","text":"DecisionModel(\n    ::Type{M<:PowerSimulations.DecisionProblem},\n    template::ProblemTemplate,\n    sys::System\n) -> Any\nDecisionModel(\n    ::Type{M<:PowerSimulations.DecisionProblem},\n    template::ProblemTemplate,\n    sys::System,\n    jump_model::Union{Nothing, JuMP.Model};\n    kwargs...\n) -> Any\n\n\nDecisionModel(::Type{M},\ntemplate::ProblemTemplate,\nsys::PSY.System,\noptimizer::MOI.OptimizerWithAttributes,\njump_model::Union{Nothing, JuMP.Model}=nothing;\nkwargs...) where {M <: DecisionProblem}\n\nThis builds the optimization problem of type M with the specific system and template\n\nArguments\n\n::Type{M} where M<:DecisionProblem: The abstract operation model type\ntemplate::ProblemTemplate: The model reference made up of transmission, devices, branches, and services.\nsys::PSY.System: the system created using Power Systems\njump_model::Union{Nothing, JuMP.Model}: Enables passing a custom JuMP model. Use with care\n\nOutput\n\nStage::DecisionProblem: The operation model containing the model type, unbuilt JuMP model, Power Systems system.\n\nExample\n\ntemplate = ProblemTemplate(CopperPlatePowerModel, devices, branches, services) problem = DecisionModel(MyOpProblemType template, system, optimizer)\n\n# Accepted Key Words\n- `initial_time::Dates.DateTime`: Initial Time for the model solve\n- `warm_start::Bool` True will use the current operation point in the system to initialize variable values. False initializes all variables to zero. Default is true\n- `export_pwl_vars::Bool` True will write the results of the piece-wise-linear intermediate variables. Slows down the simulation process significantly\n- `allow_fails::Bool` True will allow the simulation to continue if the optimizer can't find a solution. Use with care, can lead to unwanted behaviour or results\n- `optimizer_solve_log_print::Bool` Uses JuMP.unset_silent() to print the optimizer's log. By default all solvers are set to `MOI.Silent()`\n- `name`: name of model, string or symbol; defaults to the type of template converted to a symbol\n\nDecisionModel(, template, sys)\nDecisionModel(, template, sys, jump_model; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/decision_model.jl:171.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.DeviceModel","page":"API Reference","title":"PowerSimulations.DeviceModel","text":"Establishes the model for a particular device specified by type. Uses the keyword argument feedforward to enable passing values between operation model at simulation time\n\nArguments\n\n-::Type{D}: Power System Device Type -::Type{B}: Abstract Device Formulation\n\nAccepted Key Words\n\nfeedforward::Array{<:AbstractAffectFeedforward} : use to pass parameters between models\n\nExample\n\nthermal_gens = DeviceModel(ThermalStandard, ThermalBasicUnitCommitment),\n\nDeviceModel(\n    ,\n    ;\n    feedforwards,\n    use_slacks,\n    duals,\n    time_series_names,\n    attributes\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/device_model.jl:43.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.EconomicDispatchProblem-Tuple{System}","page":"API Reference","title":"PowerSimulations.EconomicDispatchProblem","text":"EconomicDispatchProblem(\n    system::System;\n    kwargs...\n) -> DecisionModel{EconomicDispatchProblem}\n\n\nEconomicDispatchProblem(system::PSY.System; kwargs...)\n\nCreates a ProblemTemplate with default DeviceModels for an EconomicDispatch problem. Uses the template to create an DecisionProblem.\n\nExample\n\ned_problem = EconomicDispatchProblem(system)\n\n\n# Accepted Key Words\n- `network::Type{<:PM.AbstractPowerModel}` : override default network model settings\n- `devices::Dict{String, DeviceModel}` : override default `DeviceModel` settings\n- `services::Dict{String, ServiceModel}` : override default `ServiceModel` settings\n- Key word arguments supported by `DecisionProblem`\n\nEconomicDispatchProblem(system; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/decision_problems.jl:31.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.EmulationModel","page":"API Reference","title":"PowerSimulations.EmulationModel","text":"EmulationModel(::Type{M},\ntemplate::ProblemTemplate,\nsys::PSY.System,\njump_model::Union{Nothing, JuMP.Model}=nothing;\nkwargs...) where {M<:EmulationProblem,\n                  T<:PM.AbstractPowerFormulation}\n\nThis builds the optimization problem of type M with the specific system and template.\n\nArguments\n\n::Type{M} where M<:EmulationProblem: The abstract Emulation model type\ntemplate::ProblemTemplate: The model reference made up of transmission, devices, branches, and services.\nsys::PSY.System: the system created using Power Systems\njump_model::Union{Nothing, JuMP.Model}: Enables passing a custom JuMP model. Use with care\n\nOutput\n\nmodel::EmulationModel: The Emulation model containing the model type, built JuMP model, Power Systems system.\n\nExample\n\ntemplate = ProblemTemplate(CopperPlatePowerModel, devices, branches, services) OpModel = EmulationModel(MockEmulationProblem, template, system)\n\nAccepted Key Words\n\noptimizer: The optimizer that will be used in the optimization model.\nwarm_start::Bool: True will use the current Emulation point in the system to initialize variable values. False initializes all variables to zero. Default is true\nsystem_to_file::Bool:: True to create a copy of the system used in the model. Default true.\nexport_pwl_vars::Bool: True to export all the pwl intermediate variables. It can slow down significantly the solve time. Default is false.\nallow_fails::Bool: True to allow the simulation to continue even if the optimization step fails. Use with care, default to false.\noptimizer_solve_log_print::Bool: True to print the optimizer solve log. Default is false.\ndirect_mode_optimizer::Bool True to use the solver in direct mode. Creates a JuMP.direct_model. Default is false.\ninitial_time::Dates.DateTime: Initial Time for the model solve\ntime_series_cache_size::Int: Size in bytes to cache for each time array. Default is 1 MiB. Set to 0 to disable.\n\nEmulationModel(, template, sys)\nEmulationModel(, template, sys, jump_model; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/emulation_model.jl:159.\n\nEmulationModel(template, sys)\nEmulationModel(template, sys, jump_model; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/emulation_model.jl:169.\n\nEmulationModel(\n    directory,\n    optimizer;\n    jump_model,\n    system,\n    kwargs...\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/emulation_model.jl:194.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.EmulationModel-Tuple{AbstractString, MathOptInterface.OptimizerWithAttributes}","page":"API Reference","title":"PowerSimulations.EmulationModel","text":"EmulationModel(\n    directory::AbstractString,\n    optimizer::MathOptInterface.OptimizerWithAttributes;\n    jump_model,\n    system,\n    kwargs...\n) -> Any\n\n\nEmulationModel(directory::AbstractString)\n\nConstruct an EmulationProblem from a serialized file.\n\nArguments\n\ndirectory::AbstractString: Directory containing a serialized model.\noptimizer::MOI.OptimizerWithAttributes: The optimizer does not get serialized. Callers should pass whatever they passed to the original problem.\njump_model::Union{Nothing, JuMP.Model} = nothing: The JuMP model does not get serialized. Callers should pass whatever they passed to the original problem.\nsystem::Union{Nothing, PSY.System}: Optionally, the system used for the model. If nothing and systofile was set to true when the model was created, the system will be deserialized from a file.\n\nEmulationModel(\n    directory,\n    optimizer;\n    jump_model,\n    system,\n    kwargs...\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/emulation_model.jl:194.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.EmulationModel-Union{Tuple{M}, Tuple{Type{M}, ProblemTemplate, System}, Tuple{Type{M}, ProblemTemplate, System, Union{Nothing, JuMP.Model}}} where M<:PowerSimulations.EmulationProblem","page":"API Reference","title":"PowerSimulations.EmulationModel","text":"EmulationModel(\n    ::Type{M<:PowerSimulations.EmulationProblem},\n    template::ProblemTemplate,\n    sys::System\n) -> Any\nEmulationModel(\n    ::Type{M<:PowerSimulations.EmulationProblem},\n    template::ProblemTemplate,\n    sys::System,\n    jump_model::Union{Nothing, JuMP.Model};\n    kwargs...\n) -> Any\n\n\nEmulationModel(::Type{M},\ntemplate::ProblemTemplate,\nsys::PSY.System,\noptimizer::MOI.OptimizerWithAttributes,\njump_model::Union{Nothing, JuMP.Model}=nothing;\nkwargs...) where {M <: EmulationProblem}\n\nThis builds the optimization problem of type M with the specific system and template\n\nArguments\n\n::Type{M} where M<:EmulationProblem: The abstract Emulation model type\ntemplate::ProblemTemplate: The model reference made up of transmission, devices, branches, and services.\nsys::PSY.System: the system created using Power Systems\njump_model::Union{Nothing, JuMP.Model}: Enables passing a custom JuMP model. Use with care\n\nOutput\n\nStage::EmulationProblem: The Emulation model containing the model type, unbuilt JuMP model, Power Systems system.\n\nExample\n\ntemplate = ProblemTemplate(CopperPlatePowerModel, devices, branches, services) problem = EmulationModel(MyOpProblemType template, system, optimizer)\n\nAccepted Key Words\n\ninitial_time::Dates.DateTime: Initial Time for the model solve\nwarm_start::Bool True will use the current Emulation point in the system to initialize variable values. False initializes all variables to zero. Default is true\nexport_pwl_vars::Bool True will write the results of the piece-wise-linear intermediate variables. Slows down the simulation process significantly\nallow_fails::Bool True will allow the simulation to continue if the optimizer can't find a solution. Use with care, can lead to unwanted behaviour or results\noptimizer_solve_log_print::Bool Uses JuMP.unset_silent() to print the optimizer's log. By default all solvers are set to MOI.Silent()\nname: name of model, string or symbol; defaults to the type of template converted to a symbol\n\nEmulationModel(, template, sys)\nEmulationModel(, template, sys, jump_model; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/emulation_model.jl:159.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.EnergyBudgetTimeSeriesParameter","page":"API Reference","title":"PowerSimulations.EnergyBudgetTimeSeriesParameter","text":"Parameter to define energy budget time series\n\nEnergyBudgetTimeSeriesParameter()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/parameters.jl:180.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.EnergyLimitFeedforward","page":"API Reference","title":"PowerSimulations.EnergyLimitFeedforward","text":"Adds a constraint to limit the sum of a variable over the number of periods to the source value\n\nEnergyLimitFeedforward(\n;\n    component_type,\n    source,\n    affected_values,\n    number_of_periods,\n    meta\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/feedforward/feedforwards.jl:141.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.EnergyOutput","page":"API Reference","title":"PowerSimulations.EnergyOutput","text":"Auxiliary Variable for Hydro and Storage Models that solve for total energy output\n\nEnergyOutput()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/auxiliary_variables.jl:29.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.EnergyShortageVariable","page":"API Reference","title":"PowerSimulations.EnergyShortageVariable","text":"Struct to dispatch the creation of a slack variable for energy storage levels < target storage levels\n\nDocs abbreviation: E^shortage\n\nEnergyShortageVariable()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/variables.jl:94.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.EnergySurplusVariable","page":"API Reference","title":"PowerSimulations.EnergySurplusVariable","text":"Struct to dispatch the creation of a slack variable for energy storage levels > target storage levels\n\nDocs abbreviation: E^surplus\n\nEnergySurplusVariable()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/variables.jl:101.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.EnergyTargetFeedforward","page":"API Reference","title":"PowerSimulations.EnergyTargetFeedforward","text":"Adds a constraint to enforce a minimum energy level target with a slack variable associated witha penalty term.\n\nEnergyTargetFeedforward(\n;\n    component_type,\n    source,\n    affected_values,\n    target_period,\n    penalty_cost,\n    meta\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/feedforward/feedforwards.jl:210.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.EnergyTargetTimeSeriesParameter","page":"API Reference","title":"PowerSimulations.EnergyTargetTimeSeriesParameter","text":"Parameter to define energy storage target level time series\n\nEnergyTargetTimeSeriesParameter()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/parameters.jl:175.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.EnergyVariable","page":"API Reference","title":"PowerSimulations.EnergyVariable","text":"Struct to dispatch the creation of a variable for energy storage level (state of charge)\n\nDocs abbreviation: E\n\nEnergyVariable()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/variables.jl:73.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.EnergyVariableDown","page":"API Reference","title":"PowerSimulations.EnergyVariableDown","text":"Struct to dispatch the creation of a variable for energy storage level (state of charge) of lower reservoir\n\nDocs abbreviation: E^down\n\nEnergyVariableDown()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/variables.jl:87.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.EnergyVariableUp","page":"API Reference","title":"PowerSimulations.EnergyVariableUp","text":"Struct to dispatch the creation of a variable for energy storage level (state of charge) of upper reservoir\n\nDocs abbreviation: E^up\n\nEnergyVariableUp()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/variables.jl:80.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.FixValueFeedforward","page":"API Reference","title":"PowerSimulations.FixValueFeedforward","text":"Fixes a Variable or Parameter Value in the model. Is the only Feed Forward that can be used with a Parameter or a Variable as the affected value.\n\nFixValueFeedforward(\n;\n    component_type,\n    source,\n    affected_values,\n    meta\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/feedforward/feedforwards.jl:178.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.FlowActivePowerFromToVariable","page":"API Reference","title":"PowerSimulations.FlowActivePowerFromToVariable","text":"Struct to dispatch the creation of unidirectional Active Power Flow Variables\n\nDocs abbreviation: overrightarrowP\n\nFlowActivePowerFromToVariable()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/variables.jl:185.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.FlowActivePowerToFromVariable","page":"API Reference","title":"PowerSimulations.FlowActivePowerToFromVariable","text":"Struct to dispatch the creation of unidirectional Active Power Flow Variables\n\nDocs abbreviation: overleftarrowP\n\nFlowActivePowerToFromVariable()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/variables.jl:192.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.FlowActivePowerVariable","page":"API Reference","title":"PowerSimulations.FlowActivePowerVariable","text":"Struct to dispatch the creation of bidirectional Active Power Flow Variables\n\nDocs abbreviation: P\n\nFlowActivePowerVariable()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/variables.jl:175.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.FlowReactivePowerFromToVariable","page":"API Reference","title":"PowerSimulations.FlowReactivePowerFromToVariable","text":"Struct to dispatch the creation of unidirectional Reactive Power Flow Variables\n\nDocs abbreviation: overrightarrowQ\n\nFlowReactivePowerFromToVariable()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/variables.jl:199.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.FlowReactivePowerToFromVariable","page":"API Reference","title":"PowerSimulations.FlowReactivePowerToFromVariable","text":"Struct to dispatch the creation of unidirectional Reactive Power Flow Variables\n\nDocs abbreviation: overleftarrowQ\n\nFlowReactivePowerToFromVariable()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/variables.jl:206.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.GenericOpProblem","page":"API Reference","title":"PowerSimulations.GenericOpProblem","text":"Default PowerSimulations Operation Problem Type\n\nGenericOpProblem()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/decision_model.jl:4.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.InitialCondition","page":"API Reference","title":"PowerSimulations.InitialCondition","text":"Container for the initial condition data\n\nInitialCondition(_, component, value)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/initial_conditions.jl:27.\n\nInitialCondition(_, component, value)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/initial_conditions.jl:35.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.IntraProblemChronology","page":"API Reference","title":"PowerSimulations.IntraProblemChronology","text":"InterProblemChronology()\n\nType struct to select an information sharing model between stages that uses results from the same recent stage to calculate the initial conditions. This model ignores solutions from stages defined finer resolutions.\n\nIntraProblemChronology()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/initial_conditions/initial_condition_chronologies.jl:16.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.LowerBoundFeedforward","page":"API Reference","title":"PowerSimulations.LowerBoundFeedforward","text":"Adds a lower bound constraint to a variable.\n\nLowerBoundFeedforward(\n;\n    component_type,\n    source,\n    affected_values,\n    meta\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/feedforward/feedforwards.jl:56.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.NetworkModel","page":"API Reference","title":"PowerSimulations.NetworkModel","text":"Establishes the model for a particular device specified by type.\n\nArguments\n\n-::Type{T}: PowerModels AbstractPowerModel\n\nAccepted Key Words\n\nuse_slacks::Bool: Adds slacks to the network modelings\nPTDF::PSY.PTDF: PTDF Array calculated using PowerSystems\nduals::Vector{DataType}: Constraint types to calculate the duals\n\nExample\n\nptdfarray = PSY.PTDF(system) thermalgens = NetworkModel(StandardPTDFModel, ptdf = ptdf_array),\n\nNetworkModel(; use_slacks, PTDF, duals)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/network_model.jl:34.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.OnVariable","page":"API Reference","title":"PowerSimulations.OnVariable","text":"Struct to dispatch the creation of a binary commitment status variable\n\nDocs abbreviation: u\n\nOnVariable()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/variables.jl:110.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.PowerAboveMinimumVariable","page":"API Reference","title":"PowerSimulations.PowerAboveMinimumVariable","text":"Struct to dispatch the creation of Active Power Variables above minimum power for Thermal Compact formulations\n\nDocs abbreviation: hatPg\n\nPowerAboveMinimumVariable()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/variables.jl:46.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.PowerOutput","page":"API Reference","title":"PowerSimulations.PowerOutput","text":"Auxiliary Variable for Thermal Generation Models that solve for power above min\n\nPowerOutput()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/auxiliary_variables.jl:25.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ProblemResults-Tuple{AbstractString}","page":"API Reference","title":"PowerSimulations.ProblemResults","text":"ProblemResults(directory::AbstractString) -> Any\n\n\nConstruct a ProblemResults instance from a serialized directory.\n\nIf the directory contains a serialized PowerSystems.System then it will deserialize that system and add it to the results. Otherwise, it is up to the caller to call set_system! on the returned instance to restore it.\n\nProblemResults(directory)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:260.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.ProblemResults-Tuple{DecisionModel}","page":"API Reference","title":"PowerSimulations.ProblemResults","text":"ProblemResults(model::DecisionModel) -> ProblemResults\n\n\nConstruct ProblemResults from a solved DecisionModel.\n\nProblemResults(model)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:51.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.ProblemResults-Tuple{EmulationModel}","page":"API Reference","title":"PowerSimulations.ProblemResults","text":"ProblemResults(model::EmulationModel) -> ProblemResults\n\n\nConstruct ProblemResults from a solved EmulationModel.\n\nProblemResults(model)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:95.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.ProblemTemplate","page":"API Reference","title":"PowerSimulations.ProblemTemplate","text":"ProblemTemplate(::Type{T}) where {T<:PM.AbstractPowerFormulation}\n\nCreates a model reference of the PowerSimulations Optimization Problem.\n\nArguments\n\nmodel::Type{T<:PM.AbstractPowerFormulation}:\n\nExample\n\ntemplate = ProblemTemplate(CopperPlatePowerModel)\n\nProblemTemplate(network)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_template.jl:23.\n\nProblemTemplate(_)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_template.jl:33.\n\nProblemTemplate()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_template.jl:35.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ReactivePowerTimeSeriesParameter","page":"API Reference","title":"PowerSimulations.ReactivePowerTimeSeriesParameter","text":"Parameter to define reactive power time series\n\nReactivePowerTimeSeriesParameter()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/parameters.jl:165.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ReactivePowerVariable","page":"API Reference","title":"PowerSimulations.ReactivePowerVariable","text":"Struct to dispatch the creation of Reactive Power Variables\n\nDocs abbreviation: Qg\n\nReactivePowerVariable()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/variables.jl:117.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.RequirementTimeSeriesParameter","page":"API Reference","title":"PowerSimulations.RequirementTimeSeriesParameter","text":"Paramter to define requirement time series\n\nRequirementTimeSeriesParameter()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/parameters.jl:170.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ReservationVariable","page":"API Reference","title":"PowerSimulations.ReservationVariable","text":"Struct to dispatch the creation of binary storage charge reservation variable\n\nDocs abbreviation: r\n\nReservationVariable()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/variables.jl:124.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.SemiContinuousFeedforward","page":"API Reference","title":"PowerSimulations.SemiContinuousFeedforward","text":"Adds a constraint to make the bounds of a variable 0.0. Effectively allows to \"turn off\" a value.\n\nSemiContinuousFeedforward(\n;\n    component_type,\n    source,\n    affected_values,\n    meta\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/feedforward/feedforwards.jl:86.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ServiceModel","page":"API Reference","title":"PowerSimulations.ServiceModel","text":"Establishes the model for a particular services specified by type. Uses the keyword argument use_service_name to assign the model to a service with the same name as the name in the template. Uses the keyword argument feedforward to enable passing values between operation model at simulation time\n\nArguments\n\n-::Type{D}: Power System Service Type -::Type{B}: Abstract Service Formulation\n\nAccepted Key Words\n\nfeedforward::Array{<:AbstractAffectFeedforward} : use to pass parameters between models\nuse_service_name::Bool : use the name as the name for the service\n\nExample\n\nreserves = ServiceModel(PSY.VariableReserve{PSY.ReserveUp}, RangeReserve)\n\nServiceModel(\n    ,\n    ,\n    service_name;\n    use_slacks,\n    feedforwards,\n    duals,\n    time_series_names,\n    attributes,\n    contributing_devices_map\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/service_model.jl:53.\n\nServiceModel(\n    service_type,\n    formulation_type;\n    use_slacks,\n    feedforwards,\n    duals,\n    time_series_names,\n    attributes\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/service_model.jl:99.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.Simulation","page":"API Reference","title":"PowerSimulations.Simulation","text":"Simulation(\n    steps::Int\n    models::SimulationModels,\n    sequence::Union{Nothing, SimulationSequence},\n    simulation_folder::String,\n    name::String,\n    internal::Union{Nothing, SimulationInternal},\n)\n\nSimulation(\n;\n    sequence,\n    name,\n    steps,\n    models,\n    simulation_folder,\n    initial_time\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation.jl:20.\n\nSimulation(directory, model_info)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation.jl:67.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.Simulation-Tuple{AbstractString, Dict}","page":"API Reference","title":"PowerSimulations.Simulation","text":"Simulation(directory::AbstractString, model_info::Dict)\n\n\nSimulation(directory::AbstractString)\n\nConstructs Simulation from a serialized directory. Callers should pass any kwargs here that they passed to the original Simulation.\n\nArguments\n\ndirectory::AbstractString: the directory returned from the call to serialize\nmodel_info::Dict: Two-level dictionary containing model parameters that cannot be serialized. The outer dict should be keyed by the problem name. The inner dict must contain 'optimizer' and may contain 'jump_model'. These should be the same values used for the original simulation.\n\nSimulation(directory, model_info)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation.jl:67.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.SimulationModels","page":"API Reference","title":"PowerSimulations.SimulationModels","text":"Stores the OperationProblem definitions to be used in the simulation. When creating the SimulationModels, the order in which the models are created determines the order on which the simulation is executed.\n\nSimulationModels(decision_models)\nSimulationModels(decision_models, emulation_model)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_models.jl:10.\n\nSimulationModels(decision_models)\nSimulationModels(decision_models, emulation_model)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_models.jl:27.\n\nSimulationModels(; decision_models, emulation_model)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_models.jl:34.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.SimulationPartitionResults","page":"API Reference","title":"PowerSimulations.SimulationPartitionResults","text":"Handles merging of simulation partitions\n\nSimulationPartitionResults(\n    path,\n    simulation_name,\n    partitions,\n    datasets\n)\nSimulationPartitionResults(\n    path,\n    simulation_name,\n    partitions,\n    datasets\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_partition_results.jl:7.\n\nSimulationPartitionResults(path)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_partition_results.jl:17.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.SimulationPartitions","page":"API Reference","title":"PowerSimulations.SimulationPartitions","text":"Defines how a simulation can be partition into partitions and run in parallel.\n\nSimulationPartitions(num_steps, period)\nSimulationPartitions(num_steps, period, num_overlap_steps)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_partitions.jl:12.\n\nSimulationPartitions(; num_steps, period, num_overlap_steps)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_partitions.jl:25.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.SimulationResults","page":"API Reference","title":"PowerSimulations.SimulationResults","text":"SimulationResults(\n    path::AbstractString,\n    name::AbstractString\n) -> SimulationResults\nSimulationResults(\n    path::AbstractString,\n    name::AbstractString,\n    execution;\n    ignore_status\n) -> SimulationResults\n\n\nConstruct SimulationResults from a simulation output directory.\n\nArguments\n\npath::AbstractString: Simulation output directory\nname::AbstractString: Simulation name\nexecution::AbstractString: Execution number. Default is the most recent.\nignore_status::Bool: If true, return results even if the simulation failed.\n\nSimulationResults(path, name)\nSimulationResults(path, name, execution; ignore_status)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_results.jl:72.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.SimulationResults-Tuple{Simulation}","page":"API Reference","title":"PowerSimulations.SimulationResults","text":"SimulationResults(\n    sim::Simulation;\n    ignore_status,\n    kwargs...\n) -> SimulationResults\n\n\nConstruct SimulationResults from a simulation.\n\nSimulationResults(sim; ignore_status, kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_results.jl:144.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.SimulationSequence","page":"API Reference","title":"PowerSimulations.SimulationSequence","text":"SimulationSequence(\n                    models::SimulationModels,\n                    feedforward::Dict{Symbol, <:AbstractAffectFeedforward}\n                    ini_cond_chronology::Dict{Symbol, <:FeedforwardChronology}\n                    )\n\nSimulationSequence(\n;\n    models,\n    feedforwards,\n    ini_cond_chronology\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_sequence.jl:169.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.UnitCommitmentProblem-Tuple{System}","page":"API Reference","title":"PowerSimulations.UnitCommitmentProblem","text":"UnitCommitmentProblem(\n    system::System;\n    kwargs...\n) -> DecisionModel{UnitCommitmentProblem}\n\n\nUnitCommitmentProblem(system::PSY.System; kwargs...)\n\nCreates a ProblemTemplate with default DeviceModels for a Unit Commitment problem. Uses the template to create an DecisionProblem.\n\nExample\n\nuc_problem = UnitCommitmentProblem(system)\n\n\n# Accepted Key Words\n- `network::Type{<:PM.AbstractPowerModel}` : override default network model settings\n- `devices::Dict{String, DeviceModel}` : override default `DeviceModel` settings\n- `services::Dict{String, ServiceModel}` : override default `ServiceModel` settings\n- Key word arguments supported by `DecisionProblem`\n\nUnitCommitmentProblem(system; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/decision_problems.jl:62.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.UpperBoundFeedforward","page":"API Reference","title":"PowerSimulations.UpperBoundFeedforward","text":"Adds an upper bound constraint to a variable.\n\nUpperBoundFeedforward(\n;\n    component_type,\n    source,\n    affected_values,\n    meta\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/feedforward/feedforwards.jl:26.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.WaterSpillageVariable","page":"API Reference","title":"PowerSimulations.WaterSpillageVariable","text":"Struct to dispatch the creation of energy (water) spillage variable representing energy released from a storage/reservoir not injected into the network\n\nDocs abbreviation: S\n\nWaterSpillageVariable()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/variables.jl:140.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.build!-Tuple{DecisionModel}","page":"API Reference","title":"PowerSimulations.build!","text":"build!(\n    model::DecisionModel;\n    output_dir,\n    recorders,\n    console_level,\n    file_level,\n    disable_timer_outputs\n)\n\n\nImplementation of build for any DecisionProblem\n\nbuild!(\n    model;\n    output_dir,\n    recorders,\n    console_level,\n    file_level,\n    disable_timer_outputs\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/decision_model.jl:283.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.build!-Tuple{EmulationModel}","page":"API Reference","title":"PowerSimulations.build!","text":"build!(\n    model::EmulationModel;\n    executions,\n    output_dir,\n    recorders,\n    console_level,\n    file_level,\n    disable_timer_outputs\n)\n\n\nImplementation of build for any EmulationProblem\n\nbuild!(\n    model;\n    executions,\n    output_dir,\n    recorders,\n    console_level,\n    file_level,\n    disable_timer_outputs\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/emulation_model.jl:268.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.build!-Tuple{Simulation}","page":"API Reference","title":"PowerSimulations.build!","text":"build!(\n    sim::Simulation;\n    recorders,\n    console_level,\n    file_level,\n    serialize,\n    partitions,\n    index\n) -> BuildStatus\n\n\nbuild!(sim::Simulation)\n\nBuild the Simulation, problems and the related folder structure\n\nArguments\n\nsim::Simulation: simulation object\nserialize::Bool = true: serializes the simulation objects in the simulation\nrecorders::Vector{Symbol} = []: recorder names to register\nconsole_level = Logging.Error:\nfile_level = Logging.Info:\n\nThrows an exception if name is passed and the directory already exists.\n\nbuild!(\n    sim;\n    recorders,\n    console_level,\n    file_level,\n    serialize,\n    partitions,\n    index\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation.jl:569.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.execute!-Tuple{Simulation}","page":"API Reference","title":"PowerSimulations.execute!","text":"execute!(sim::Simulation; kwargs...) -> RunStatus\n\n\nexecute!(sim::Simulation; kwargs...)\n\nSolves the simulation model for sequential Simulations.\n\nArguments\n\nsim::Simulation=sim: simulation object created by Simulation()\n\nThe optional keyword argument exports controls exporting of results to CSV files as the simulation runs. Refer to export_results for a description of this argument.\n\nExample\n\nsim = Simulation(\"Test\", 7, problems, \"/Users/folder\") execute!(sim::Simulation; kwargs...)\n\nexecute!(sim; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation.jl:911.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.export_optimizer_stats-Tuple{Union{ProblemResults, PowerSimulations.SimulationProblemResults}, AbstractString}","page":"API Reference","title":"PowerSimulations.export_optimizer_stats","text":"export_optimizer_stats(\n    res::Union{ProblemResults, PowerSimulations.SimulationProblemResults},\n    directory::AbstractString;\n    format\n) -> Any\n\n\nSave the optimizer statistics to CSV or JSON\n\nArguments\n\nres::Union{ProblemResults, SimulationProblmeResults: Results\ndirectory::AbstractString : target directory\nformat = \"CSV\" : can be \"csv\" or \"json\n\nexport_optimizer_stats(res, directory; format)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:704.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.export_realized_results-Tuple{PowerSimulations.SimulationProblemResults}","page":"API Reference","title":"PowerSimulations.export_realized_results","text":"export_realized_results(\n    res::PowerSimulations.SimulationProblemResults\n) -> String\n\n\nSave the realized results to CSV files for all variables, paramaters, duals, auxiliary variables, expressions, and optimizer statistics.\n\nArguments\n\nres::Union{ProblemResults, SimulationProblmeResults: Results\nsave_path::AbstractString : path to save results (defaults to simulation path)\n\nexport_realized_results(res)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:658.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.export_results-Tuple{ProblemResults}","page":"API Reference","title":"PowerSimulations.export_results","text":"export_results(results::ProblemResults; kwargs...)\n\n\nExports all results from the operations problem.\n\nexport_results(results; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:136.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.export_results-Tuple{SimulationResults, Any}","page":"API Reference","title":"PowerSimulations.export_results","text":"export_results(results::SimulationResults, exports)\n\n\nExport results to files in the results directory.\n\nArguments\n\nresults::SimulationResults: simulation results\nexports: SimulationResultsExport or anything that can be passed to its constructor. (such as Dict or path to JSON file)\n\nAn example JSON file demonstrating possible options is below. Note that start_time, end_time, path, and format are optional.\n\n{\n  \"decision_models\": [\n    {\n      \"name\": \"ED\",\n      \"variables\": [\n        \"P__ThermalStandard\",\n        \"E__HydroEnergyReservoir\"\n      ],\n      \"parameters\": [\n        \"all\"\n      ]\n    },\n    {\n      \"name\": \"UC\",\n      \"variables\": [\n        \"On__ThermalStandard\"\n      ],\n      \"parameters\": [\n        \"all\"\n      ],\n      \"duals\": [\n        \"all\"\n      ]\n    }\n  ],\n  \"start_time\": \"2020-01-01T04:00:00\",\n  \"end_time\": null,\n  \"path\": null,\n  \"format\": \"csv\"\n}\n\n\nexport_results(results, exports)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_results.jl:264.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_all_constraint_index-Tuple{PowerSimulations.OperationModel}","page":"API Reference","title":"PowerSimulations.get_all_constraint_index","text":"get_all_constraint_index(\n    model::PowerSimulations.OperationModel\n) -> Vector{Tuple{PowerSimulations.ConstraintKey, Int64, Int64}}\n\n\nEach Tuple corresponds to (conname, internalindex, moi_index)\n\nget_all_constraint_index(model)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/optimization_debugging.jl:4.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_all_variable_index-Tuple{PowerSimulations.OperationModel}","page":"API Reference","title":"PowerSimulations.get_all_variable_index","text":"get_all_variable_index(\n    model::PowerSimulations.OperationModel\n) -> Vector{Tuple{Symbol, Int64, Int64}}\n\n\nEach Tuple corresponds to (conname, internalindex, moi_index)\n\nget_all_variable_index(model)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/optimization_debugging.jl:19.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_num_partitions-Tuple{SimulationPartitions}","page":"API Reference","title":"PowerSimulations.get_num_partitions","text":"get_num_partitions(x::SimulationPartitions) -> Int64\n\n\nReturn the number of partitions in the simulation.\n\nget_num_partitions(x)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_partitions.jl:32.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_system!-Tuple{PowerSimulations.SimulationProblemResults}","page":"API Reference","title":"PowerSimulations.get_system!","text":"get_system!(\n    results::PowerSimulations.SimulationProblemResults\n) -> Union{Nothing, System}\n\n\nReturn the system used for the problem. If the system hasn't already been deserialized or set with set_system! then deserialize and store it.\n\nget_system!(results)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:146.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_timestamps-Tuple{PowerSimulations.SimulationProblemResults}","page":"API Reference","title":"PowerSimulations.get_timestamps","text":"get_timestamps(\n    result::PowerSimulations.SimulationProblemResults\n) -> StepRange{Dates.DateTime, Dates.Millisecond}\n\n\nReturn a reference to a StepRange of available timestamps.\n\nget_timestamps(result)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:140.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.list_aux_variable_keys-Tuple{PowerSimulations.SimulationProblemResults}","page":"API Reference","title":"PowerSimulations.list_aux_variable_keys","text":"list_aux_variable_keys(\n    res::PowerSimulations.SimulationProblemResults\n) -> Any\n\n\nReturn an array of AuxVarKeys that are available for reads.\n\nlist_aux_variable_keys(res)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:129.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.list_aux_variable_names-Tuple{PowerSimulations.SimulationProblemResults}","page":"API Reference","title":"PowerSimulations.list_aux_variable_names","text":"list_aux_variable_names(\n    res::PowerSimulations.SimulationProblemResults\n) -> Any\n\n\nReturn an array of auxillary variable names (strings) that are available for reads.\n\nlist_aux_variable_names(res)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:102.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.list_decision_problems-Tuple{SimulationResults}","page":"API Reference","title":"PowerSimulations.list_decision_problems","text":"list_decision_problems(\n    results::SimulationResults\n) -> Vector{String}\n\n\nReturn the problem names in the simulation.\n\nlist_decision_problems(results)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_results.jl:215.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.list_dual_keys-Tuple{PowerSimulations.SimulationProblemResults}","page":"API Reference","title":"PowerSimulations.list_dual_keys","text":"list_dual_keys(\n    res::PowerSimulations.SimulationProblemResults\n) -> Any\n\n\nReturn an array of ConstraintKeys that are available for reading duals.\n\nlist_dual_keys(res)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:119.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.list_dual_names-Tuple{PowerSimulations.SimulationProblemResults}","page":"API Reference","title":"PowerSimulations.list_dual_names","text":"list_dual_names(\n    res::PowerSimulations.SimulationProblemResults\n) -> Any\n\n\nReturn an array of dual names (strings) that are available for reads.\n\nlist_dual_names(res)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:90.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.list_expression_keys-Tuple{PowerSimulations.SimulationProblemResults}","page":"API Reference","title":"PowerSimulations.list_expression_keys","text":"list_expression_keys(\n    res::PowerSimulations.SimulationProblemResults\n) -> Any\n\n\nReturn an array of ExpressionKeys that are available for reads.\n\nlist_expression_keys(res)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:135.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.list_expression_names-Tuple{PowerSimulations.SimulationProblemResults}","page":"API Reference","title":"PowerSimulations.list_expression_names","text":"list_expression_names(\n    res::PowerSimulations.SimulationProblemResults\n) -> Any\n\n\nReturn an array of expression names (strings) that are available for reads.\n\nlist_expression_names(res)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:108.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.list_parameter_keys-Tuple{PowerSimulations.SimulationProblemResults}","page":"API Reference","title":"PowerSimulations.list_parameter_keys","text":"list_parameter_keys(\n    res::PowerSimulations.SimulationProblemResults\n) -> Any\n\n\nReturn an array of ParameterKeys that are available for reads.\n\nlist_parameter_keys(res)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:124.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.list_parameter_names-Tuple{PowerSimulations.SimulationProblemResults}","page":"API Reference","title":"PowerSimulations.list_parameter_names","text":"list_parameter_names(\n    res::PowerSimulations.SimulationProblemResults\n) -> Any\n\n\nReturn an array of parmater names (strings) that are available for reads.\n\nlist_parameter_names(res)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:96.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.list_simulation_events-Union{Tuple{T}, Tuple{Type{T}, AbstractString}, Tuple{Type{T}, AbstractString, Union{Nothing, Function}}} where T<:InfrastructureSystems.AbstractRecorderEvent","page":"API Reference","title":"PowerSimulations.list_simulation_events","text":"list_simulation_events(\n    ::Type{T<:InfrastructureSystems.AbstractRecorderEvent},\n    output_dir::AbstractString\n) -> Vector\nlist_simulation_events(\n    ::Type{T<:InfrastructureSystems.AbstractRecorderEvent},\n    output_dir::AbstractString,\n    filter_func::Union{Nothing, Function};\n    step,\n    model_name\n) -> Vector\n\n\nlist_simulation_events(\n    ::Type{T},\n    output_dir::AbstractString,\n    filter_func::Union{Nothing, Function} = nothing;\n    step = nothing,\n    model = nothing,\n) where {T <: IS.AbstractRecorderEvent}\n\nList simulation events of type T in a simulation output directory.\n\nArguments\n\noutput_dir::AbstractString: Simulation output directory\nfilter_func::Union{Nothing, Function} = nothing: Refer to show_simulation_events.\nstep::Int = nothing: Filter events by step. Required if model is passed.\nmodel::Int = nothing: Filter events by model.\n\nlist_simulation_events(, output_dir)\nlist_simulation_events(\n    ,\n    output_dir,\n    filter_func;\n    step,\n    model_name\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/recorder_events.jl:253.\n\nlist_simulation_events(, output_dir)\nlist_simulation_events(, output_dir, filter_func; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/recorder_events.jl:282.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.list_variable_keys-Tuple{PowerSimulations.SimulationProblemResults}","page":"API Reference","title":"PowerSimulations.list_variable_keys","text":"list_variable_keys(\n    res::PowerSimulations.SimulationProblemResults\n) -> Any\n\n\nReturn an array of VariableKeys that are available for reads.\n\nlist_variable_keys(res)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:114.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.list_variable_names-Tuple{PowerSimulations.SimulationProblemResults}","page":"API Reference","title":"PowerSimulations.list_variable_names","text":"list_variable_names(\n    res::PowerSimulations.SimulationProblemResults\n) -> Any\n\n\nReturn an array of variable names (strings) that are available for reads.\n\nlist_variable_names(res)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:84.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.load_results!-Tuple{PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults}, Int64}","page":"API Reference","title":"PowerSimulations.load_results!","text":"load_results!(\n    res::PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults},\n    count::Int64;\n    initial_time,\n    variables,\n    duals,\n    parameters,\n    aux_variables,\n    expressions\n)\n\n\nLoad the simulation results into memory for repeated reads. Running this function twice overwrites the previously loaded results. This is useful when loading results from remote locations over network connections.\n\nFor each variable/parameter/dual, etc., each element must be the name encoded as a string, like \"ActivePowerVariable__ThermalStandard\" or a Tuple with its constituent types, like (ActivePowerVariable, ThermalStandard).\n\nArguments\n\ncount::Int: Number of windows to load.\ninitial_time::Dates.DateTime : Initial time of first window to load. Defaults to first.\naux_variables::Vector{Union{String, Tuple}}: Optional list of aux variables to load.\nduals::Vector{Union{String, Tuple}}: Optional list of duals to load.\nexpressions::Vector{Union{String, Tuple}}: Optional list of expressions to load.\nparameters::Vector{Union{String, Tuple}}: Optional list of parameters to load.\nvariables::Vector{Union{String, Tuple}}: Optional list of variables to load.\n\nload_results!(\n    res,\n    count;\n    initial_time,\n    variables,\n    duals,\n    parameters,\n    aux_variables,\n    expressions\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/decision_model_simulation_results.jl:480.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.load_results!-Tuple{PowerSimulations.SimulationProblemResults{PowerSimulations.EmulationModelSimulationResults}}","page":"API Reference","title":"PowerSimulations.load_results!","text":"load_results!(\n    res::PowerSimulations.SimulationProblemResults{PowerSimulations.EmulationModelSimulationResults};\n    aux_variables,\n    duals,\n    expressions,\n    parameters,\n    variables\n)\n\n\nLoad the simulation results into memory for repeated reads. Running this function twice overwrites the previously loaded results. This is useful when loading results from remote locations over network connections.\n\nFor each variable/parameter/dual, etc., each element must be the name encoded as a string, like \"ActivePowerVariable__ThermalStandard\"or a Tuple with its constituent types, like(ActivePowerVariable, ThermalStandard)`.\n\nArguments\n\naux_variables::Vector{Union{String, Tuple}}: Optional list of aux variables to load.\nduals::Vector{Union{String, Tuple}}: Optional list of duals to load.\nexpressions::Vector{Union{String, Tuple}}: Optional list of expressions to load.\nparameters::Vector{Union{String, Tuple}}: Optional list of parameters to load.\nvariables::Vector{Union{String, Tuple}}: Optional list of variables to load.\n\nload_results!(\n    res;\n    aux_variables,\n    duals,\n    expressions,\n    parameters,\n    variables\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/emulation_model_simulation_results.jl:343.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_aux_variable-Tuple{PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults}, Vararg{Any}}","page":"API Reference","title":"PowerSimulations.read_aux_variable","text":"read_aux_variable(\n    res::PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults},\n    args...;\n    time_series_name,\n    initial_time,\n    count,\n    store\n) -> SortedDict{Dates.DateTime, DataFrames.DataFrame}\n\n\nReturn the values for the requested auxillary variables. It keeps requests when performing multiple retrievals.\n\nArguments\n\nargs: Can be a string returned from list_aux_variable_names or args that can be splatted into a AuxVarKey.\ninitial_time::Dates.DateTime : initial of the requested results\ncount::Int: Number of results\n\nread_aux_variable(\n    res,\n    args;\n    time_series_name,\n    initial_time,\n    count,\n    store\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/decision_model_simulation_results.jl:312.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_aux_variable-Tuple{ProblemResults, Vararg{Any}}","page":"API Reference","title":"PowerSimulations.read_aux_variable","text":"read_aux_variable(\n    res::ProblemResults,\n    args...;\n    kwargs...\n) -> DataFrames.DataFrame\n\n\nReturn the values for the requested auxvariable key for a problem. Accepts a vector of keys for the return of the values. If the time stamps and keys are loaded using the [`loadresults!`](@ref) function it will read from memory.\n\nArguments\n\naux_variable::Tuple{Type{<:AuxVariableType}, Type{<:PSY.Component} : Tuple with aux_variable type and device type for the desired results\nstart_time::Dates.DateTime : initial time of the requested results\nlen::Int: length of results\n\nread_aux_variable(res, args; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:617.\n\nread_aux_variable(res, key; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:622.\n\nread_aux_variable(res, key; start_time, len)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:626.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_aux_variables-Tuple{InfrastructureSystems.Results}","page":"API Reference","title":"PowerSimulations.read_aux_variables","text":"read_aux_variables(\n    res::InfrastructureSystems.Results\n) -> Dict\n\n\nReturn the values for all auxiliary variables.\n\nread_aux_variables(res)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:676.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_aux_variables-Tuple{ProblemResults, Any}","page":"API Reference","title":"PowerSimulations.read_aux_variables","text":"read_aux_variables(\n    res::ProblemResults,\n    aux_variables;\n    kwargs...\n) -> Dict{String, DataFrames.DataFrame}\n\n\nReturn the values for the requested auxvariable keys for a problem. Accepts a vector of keys for the return of the values. If the time stamps and keys are loaded using the [`loadresults!`](@ref) function it will read from memory.\n\nArguments\n\naux_variables::Vector{Tuple{Type{<:AuxVariableType}, Type{<:PSY.Component}} : Tuple with aux_variable type and device type for the desired results\nstart_time::Dates.DateTime : initial time of the requested results\nlen::Int: length of results\n\nread_aux_variables(res, aux_variables; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:646.\n\nread_aux_variables(res, aux_variables; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:650.\n\nread_aux_variables(res, aux_variables; start_time, len)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:662.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_dual-Tuple{PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults}, Vararg{Any}}","page":"API Reference","title":"PowerSimulations.read_dual","text":"read_dual(\n    res::PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults},\n    args...;\n    initial_time,\n    count,\n    store\n) -> SortedDict{Dates.DateTime, DataFrames.DataFrame}\n\n\nReturn the values for the requested dual. It keeps requests when performing multiple retrievals.\n\nArguments\n\nargs: Can be a string returned from list_dual_names or args that can be splatted into a ConstraintKey.\ninitial_time::Dates.DateTime : initial of the requested results\ncount::Int: Number of results\nstore::SimulationStore: a store that has been opened for reading\n\nread_dual(res, args; initial_time, count, store)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/decision_model_simulation_results.jl:222.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_dual-Tuple{ProblemResults, Vararg{Any}}","page":"API Reference","title":"PowerSimulations.read_dual","text":"read_dual(\n    res::ProblemResults,\n    args...;\n    kwargs...\n) -> DataFrames.DataFrame\n\n\nReturn the values for the requested dual key for a problem. Accepts a vector of keys for the return of the values. If the time stamps and keys are loaded using the load_results! function it will read from memory.\n\nArguments\n\ndual::Tuple{Type{<:ConstraintType}, Type{<:PSY.Component} : Tuple with dual type and device type for the desired results\nstart_time::Dates.DateTime : initial time of the requested results\nlen::Int: length of results\n\nread_dual(res, args; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:442.\n\nread_dual(res, key; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:447.\n\nread_dual(res, key; start_time, len)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:451.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_duals-Tuple{InfrastructureSystems.Results}","page":"API Reference","title":"PowerSimulations.read_duals","text":"read_duals(res::InfrastructureSystems.Results) -> Dict\n\n\nReturn the values for all duals.\n\nread_duals(res)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:496.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_duals-Tuple{ProblemResults, Any}","page":"API Reference","title":"PowerSimulations.read_duals","text":"read_duals(\n    res::ProblemResults,\n    duals;\n    kwargs...\n) -> Dict{String, DataFrames.DataFrame}\n\n\nReturn the values for the requested dual keys for a problem. Accepts a vector of keys for the return of the values. If the time stamps and keys are loaded using the load_results! function it will read from memory.\n\nArguments\n\nduals::Vector{Tuple{Type{<:ConstraintType}, Type{<:PSY.Component}} : Tuple with dual type and device type for the desired results\nstart_time::Dates.DateTime : initial time of the requested results\nlen::Int: length of results\n\nread_duals(res, duals; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:471.\n\nread_duals(res, duals; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:475.\n\nread_duals(res, duals; start_time, len)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:483.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_expression-Tuple{PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults}, Vararg{Any}}","page":"API Reference","title":"PowerSimulations.read_expression","text":"read_expression(\n    res::PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults},\n    args...;\n    time_series_name,\n    initial_time,\n    count,\n    store\n) -> SortedDict{Dates.DateTime, DataFrames.DataFrame}\n\n\nReturn the values for the requested auxillary variables. It keeps requests when performing multiple retrievals.\n\nArguments\n\nargs: Can be a string returned from list_expression_names or args that can be splatted into a ExpressionKey.\ninitial_time::Dates.DateTime : initial of the requested results\ncount::Int: Number of results\n\nread_expression(\n    res,\n    args;\n    time_series_name,\n    initial_time,\n    count,\n    store\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/decision_model_simulation_results.jl:360.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_expression-Tuple{ProblemResults, Vararg{Any}}","page":"API Reference","title":"PowerSimulations.read_expression","text":"read_expression(\n    res::ProblemResults,\n    args...;\n    kwargs...\n) -> DataFrames.DataFrame\n\n\nReturn the values for the requested expression key for a problem. Accepts a vector of keys for the return of the values. If the time stamps and keys are loaded using the load_results! function it will read from memory.\n\nArguments\n\nexpression::Tuple{Type{<:ExpressionType}, Type{<:PSY.Component} : Tuple with expression type and device type for the desired results\nstart_time::Dates.DateTime : initial time of the requested results\nlen::Int: length of results\n\nread_expression(res, args; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:707.\n\nread_expression(res, key; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:712.\n\nread_expression(res, key; start_time, len)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:716.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_expressions-Tuple{InfrastructureSystems.Results}","page":"API Reference","title":"PowerSimulations.read_expressions","text":"read_expressions(\n    res::InfrastructureSystems.Results\n) -> Dict{String, DataFrames.DataFrame}\n\n\nReturn the values for all expressions.\n\nread_expressions(res; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:736.\n\nread_expressions(res)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:770.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_expressions-Tuple{ProblemResults}","page":"API Reference","title":"PowerSimulations.read_expressions","text":"read_expressions(\n    res::ProblemResults;\n    kwargs...\n) -> Dict{String, DataFrames.DataFrame}\n\n\nReturn the values for the requested expression keys for a problem. Accepts a vector of keys for the return of the values. If the time stamps and keys are loaded using the load_results! function it will read from memory.\n\nArguments\n\nexpressions::Vector{Tuple{Type{<:ExpressionType}, Type{<:PSY.Component}} : Tuple with expression type and device type for the desired results\nstart_time::Dates.DateTime : initial time of the requested results\nlen::Int: length of results\n\nread_expressions(res; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:736.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_optimizer_stats-Tuple{PowerSimulations.HdfSimulationStore, Any}","page":"API Reference","title":"PowerSimulations.read_optimizer_stats","text":"read_optimizer_stats(\n    store::PowerSimulations.HdfSimulationStore,\n    model_name\n) -> Any\n\n\nReturn the optimizer stats for a problem as a DataFrame.\n\nread_optimizer_stats(store, model_name)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/hdf_simulation_store.jl:231.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_optimizer_stats-Tuple{PowerSimulations.HdfSimulationStore, Int64, Symbol, Int64}","page":"API Reference","title":"PowerSimulations.read_optimizer_stats","text":"read_optimizer_stats(\n    store::PowerSimulations.HdfSimulationStore,\n    simulation_step::Int64,\n    model_name::Symbol,\n    execution_index::Int64\n) -> Any\n\n\nRead the optimizer stats for a problem execution.\n\nread_optimizer_stats(\n    store,\n    simulation_step,\n    model_name,\n    execution_index\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/hdf_simulation_store.jl:215.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_optimizer_stats-Tuple{PowerSimulations.SimulationProblemResults}","page":"API Reference","title":"PowerSimulations.read_optimizer_stats","text":"read_optimizer_stats(\n    res::PowerSimulations.SimulationProblemResults;\n    store\n) -> Any\n\n\nReturn the optimizer stats for the problem as a DataFrame.\n\nAccepted keywords\n\nstore::SimulationStore: a store that has been opened for reading\n\nread_optimizer_stats(res; store)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:631.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_parameter-Tuple{PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults}, Vararg{Any}}","page":"API Reference","title":"PowerSimulations.read_parameter","text":"read_parameter(\n    res::PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults},\n    args...;\n    time_series_name,\n    initial_time,\n    count,\n    store\n) -> SortedDict{Dates.DateTime, DataFrames.DataFrame}\n\n\nReturn the values for the requested parameter. It keeps requests when performing multiple retrievals.\n\nArguments\n\nargs: Can be a string returned from list_parameter_names or args that can be splatted into a ParameterKey.\ninitial_time::Dates.DateTime : initial of the requested results\ncount::Int: Number of results\n\nread_parameter(\n    res,\n    args;\n    time_series_name,\n    initial_time,\n    count,\n    store\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/decision_model_simulation_results.jl:264.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_parameter-Tuple{ProblemResults, Vararg{Any}}","page":"API Reference","title":"PowerSimulations.read_parameter","text":"read_parameter(\n    res::ProblemResults,\n    args...;\n    kwargs...\n) -> DataFrames.DataFrame\n\n\nReturn the values for the requested parameter key for a problem. Accepts a vector of keys for the return of the values. If the time stamps and keys are loaded using the load_results! function it will read from memory.\n\nArguments\n\nparameter::Tuple{Type{<:ParameterType}, Type{<:PSY.Component} : Tuple with parameter type and device type for the desired results\nstart_time::Dates.DateTime : initial time of the requested results\nlen::Int: length of results\n\nread_parameter(res, args; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:527.\n\nread_parameter(res, key; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:532.\n\nread_parameter(res, key; start_time, len)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:536.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_parameters-Tuple{InfrastructureSystems.Results}","page":"API Reference","title":"PowerSimulations.read_parameters","text":"read_parameters(res::InfrastructureSystems.Results) -> Dict\n\n\nReturn the values for all parameters.\n\nread_parameters(res)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:586.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_parameters-Tuple{ProblemResults, Any}","page":"API Reference","title":"PowerSimulations.read_parameters","text":"read_parameters(\n    res::ProblemResults,\n    parameters;\n    kwargs...\n) -> Dict{String, DataFrames.DataFrame}\n\n\nReturn the values for the requested parameter keys for a problem. Accepts a vector of keys for the return of the values. If the time stamps and keys are loaded using the load_results! function it will read from memory.\n\nArguments\n\nparameters::Vector{Tuple{Type{<:ParameterType}, Type{<:PSY.Component}} : Tuple with parameter type and device type for the desired results\nstart_time::Dates.DateTime : initial time of the requested results\nlen::Int: length of results\n\nread_parameters(res, parameters; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:556.\n\nread_parameters(res, parameters; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:560.\n\nread_parameters(res, parameters; start_time, len)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:572.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_realized_aux_variable-Tuple{PowerSimulations.SimulationProblemResults, AbstractString}","page":"API Reference","title":"PowerSimulations.read_realized_aux_variable","text":"read_realized_aux_variable(\n    res::PowerSimulations.SimulationProblemResults,\n    aux_variable::AbstractString;\n    kwargs...\n) -> DataFrames.DataFrame\n\n\nReturn the final values for the requested auxiliary variable for each time step for a problem.\n\nRefer to read_realized_variable for help and examples.\n\nread_realized_aux_variable(res, aux_variable; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:399.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_realized_aux_variables-Tuple{PowerSimulations.SimulationProblemResults}","page":"API Reference","title":"PowerSimulations.read_realized_aux_variables","text":"read_realized_aux_variables(\n    res::PowerSimulations.SimulationProblemResults;\n    kwargs...\n) -> Dict{String, DataFrames.DataFrame}\n\n\nReturn the final values for the requested auxiliary variables for each time step for a problem.\n\nRefer to read_realized_variables for help and examples.\n\nread_realized_aux_variables(res; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:353.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_realized_dual-Tuple{PowerSimulations.SimulationProblemResults, AbstractString}","page":"API Reference","title":"PowerSimulations.read_realized_dual","text":"read_realized_dual(\n    res::PowerSimulations.SimulationProblemResults,\n    dual::AbstractString;\n    kwargs...\n) -> DataFrames.DataFrame\n\n\nReturn the final values for the requested dual for each time step for a problem.\n\nRefer to read_realized_variable for help and examples.\n\nread_realized_dual(res, dual; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:539.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_realized_duals-Tuple{PowerSimulations.SimulationProblemResults}","page":"API Reference","title":"PowerSimulations.read_realized_duals","text":"read_realized_duals(\n    res::PowerSimulations.SimulationProblemResults;\n    kwargs...\n) -> Dict{String, DataFrames.DataFrame}\n\n\nReturn the final values for the requested duals for each time step for a problem.\n\nRefer to read_realized_variables for help and examples.\n\nread_realized_duals(res; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:501.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_realized_expression-Tuple{PowerSimulations.SimulationProblemResults, AbstractString}","page":"API Reference","title":"PowerSimulations.read_realized_expression","text":"read_realized_expression(\n    res::PowerSimulations.SimulationProblemResults,\n    expression::AbstractString;\n    kwargs...\n) -> DataFrames.DataFrame\n\n\nReturn the final values for the requested expression for each time step for a problem.\n\nRefer to read_realized_variable for help and examples.\n\nread_realized_expression(res, expression; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:602.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_realized_expressions-Tuple{PowerSimulations.SimulationProblemResults}","page":"API Reference","title":"PowerSimulations.read_realized_expressions","text":"read_realized_expressions(\n    res::PowerSimulations.SimulationProblemResults;\n    kwargs...\n) -> Dict{String, DataFrames.DataFrame}\n\n\nReturn the final values for the requested expressions for each time step for a problem.\n\nRefer to read_realized_variables for help and examples.\n\nread_realized_expressions(res; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:560.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_realized_parameter-Tuple{PowerSimulations.SimulationProblemResults, AbstractString}","page":"API Reference","title":"PowerSimulations.read_realized_parameter","text":"read_realized_parameter(\n    res::PowerSimulations.SimulationProblemResults,\n    parameter::AbstractString;\n    kwargs...\n) -> DataFrames.DataFrame\n\n\nReturn the final values for the requested parameter for each time step for a problem.\n\nRefer to read_realized_variable for help and examples.\n\nread_realized_parameter(res, parameter; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:474.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_realized_parameters-Tuple{PowerSimulations.SimulationProblemResults}","page":"API Reference","title":"PowerSimulations.read_realized_parameters","text":"read_realized_parameters(\n    res::PowerSimulations.SimulationProblemResults;\n    kwargs...\n) -> Dict{String, DataFrames.DataFrame}\n\n\nReturn the final values for the requested parameters for each time step for a problem.\n\nRefer to read_realized_variables for help and examples.\n\nread_realized_parameters(res; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:432.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_realized_variable-Tuple{PowerSimulations.SimulationProblemResults, AbstractString}","page":"API Reference","title":"PowerSimulations.read_realized_variable","text":"read_realized_variable(\n    res::PowerSimulations.SimulationProblemResults,\n    variable::AbstractString;\n    kwargs...\n) -> DataFrames.DataFrame\n\n\nReturn the final values for the requested variable for each time step for a problem.\n\nDecision problem results are returned in a Dict{DateTime, DataFrame}.\n\nEmulation problem results are returned in a DataFrame.\n\nLimit the data sizes returned by specifying initial_time and count for decision problems or start_time and len for emulation problems.\n\nSee also load_results! to preload data into memory.\n\nArguments\n\nvariable::Union{String, Tuple}: Variable name as a string or a Tuple with variable type and device type.\ninitial_time::Dates.DateTime: Initial time of the requested results. Decision problems only.\ncount::Int: Number of results. Decision problems only.\nstart_time::Dates.DateTime: Start time of the requested results. Emulation problems only.\nlen::Int: Number of rows in each DataFrame. Emulation problems only.\n\nExamples\n\njulia > read_realized_variable(results, \"ActivePowerVariable__ThermalStandard\")\njulia > read_realized_variable(results, (ActivePowerVariable, ThermalStandard))\n\nread_realized_variable(res, variable; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:326.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_realized_variables-Tuple{PowerSimulations.SimulationProblemResults}","page":"API Reference","title":"PowerSimulations.read_realized_variables","text":"read_realized_variables(\n    res::PowerSimulations.SimulationProblemResults;\n    kwargs...\n) -> Dict{String, DataFrames.DataFrame}\n\n\nReturn the final values for the requested variables for each time step for a problem.\n\nDecision problem results are returned in a Dict{String, Dict{DateTime, DataFrame}}.\n\nEmulation problem results are returned in a Dict{String, DataFrame}.\n\nLimit the data sizes returned by specifying initial_time and count for decision problems or start_time and len for emulation problems.\n\nSee also load_results! to preload data into memory.\n\nArguments\n\nvariables::Vector{Union{String, Tuple}}: Variable name as a string or a Tuple with variable type and device type. If not provided then return all variables.\ninitial_time::Dates.DateTime: Initial time of the requested results. Decision problems only.\ncount::Int: Number of results. Decision problems only.\nstart_time::Dates.DateTime: Start time of the requested results. Emulation problems only.\nlen::Int: Number of rows in each DataFrame. Emulation problems only.\n\nExamples\n\njulia > variables_as_strings =\n    [\"ActivePowerVariable__ThermalStandard\", \"ActivePowerVariable__RenewableDispatch\"]\njulia > variables_as_types =\n    [(ActivePowerVariable, ThermalStandard), (ActivePowerVariable, RenewableDispatch)]\njulia > read_realized_variables(results, variables_as_strings)\njulia > read_realized_variables(results, variables_as_types)\n\nread_realized_variables(res; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:263.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_variable-Tuple{PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults}, Vararg{Any}}","page":"API Reference","title":"PowerSimulations.read_variable","text":"read_variable(\n    res::PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults},\n    args...;\n    initial_time,\n    count,\n    store\n) -> SortedDict{Dates.DateTime, DataFrames.DataFrame}\n\n\nReturn the values for the requested variable. It keeps requests when performing multiple retrievals.\n\nArguments\n\nargs: Can be a string returned from list_variable_names or args that can be splatted into a VariableKey.\ninitial_time::Dates.DateTime : initial of the requested results\ncount::Int: Number of results\nstore::SimulationStore: a store that has been opened for reading\n\nExamples\n\nread_variable(results, ActivePowerVariable, ThermalStandard)\nread_variable(results, \"ActivePowerVariable__ThermalStandard\")\n\nread_variable(res, args; initial_time, count, store)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/decision_model_simulation_results.jl:179.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_variable-Tuple{ProblemResults, Vararg{Any}}","page":"API Reference","title":"PowerSimulations.read_variable","text":"read_variable(\n    res::ProblemResults,\n    args...;\n    kwargs...\n) -> DataFrames.DataFrame\n\n\nReturn the values for the requested variable key for a problem. Accepts a vector of keys for the return of the values. If the time stamps and keys are loaded using the load_results! function it will read from memory.\n\nArguments\n\nvariable::Tuple{Type{<:VariableType}, Type{<:PSY.Component} : Tuple with variable type and device type for the desired results\nstart_time::Dates.DateTime : start time of the requested results\nlen::Int: length of results\n\nread_variable(res, args; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:357.\n\nread_variable(res, key; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:362.\n\nread_variable(res, key; start_time, len)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:366.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_variables-Tuple{InfrastructureSystems.Results}","page":"API Reference","title":"PowerSimulations.read_variables","text":"read_variables(res::InfrastructureSystems.Results) -> Dict\n\n\nReturn the values for all variables.\n\nread_variables(res)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:411.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_variables-Tuple{ProblemResults, Any}","page":"API Reference","title":"PowerSimulations.read_variables","text":"read_variables(\n    res::ProblemResults,\n    variables;\n    kwargs...\n) -> Dict{String, DataFrames.DataFrame}\n\n\nReturn the values for the requested variable keys for a problem. Accepts a vector of keys for the return of the values. If the time stamps and keys are loaded using the load_results! function it will read from memory.\n\nArguments\n\nvariables::Vector{Tuple{Type{<:VariableType}, Type{<:PSY.Component}} : Tuple with variable type and device type for the desired results\nstart_time::Dates.DateTime : initial time of the requested results\nlen::Int: length of results\n\nread_variables(res, variables; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:386.\n\nread_variables(res, variables; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:390.\n\nread_variables(res, variables; start_time, len)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:398.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.run!-Tuple{EmulationModel}","page":"API Reference","title":"PowerSimulations.run!","text":"run!(\n    model::EmulationModel;\n    export_problem_results,\n    console_level,\n    file_level,\n    disable_timer_outputs,\n    serialize,\n    kwargs...\n) -> RunStatus\n\n\nDefault run method for problems that conform to the requirements of EmulationModel{<: EmulationProblem}\n\nThis will call build! on the model if it is not already built. It will forward all keyword arguments to that function.\n\nArguments\n\nmodel::EmulationModel = model: Emulation model\noptimizer::MOI.OptimizerWithAttributes: The optimizer that is used to solve the model\nexecutions::Int: Number of executions for the emulator run\nexport_problem_results::Bool: If true, export ProblemResults DataFrames to CSV files.\noutput_dir::String: Required if the model is not already built, otherwise ignored\nenable_progress_bar::Bool: Enables/Disable progress bar printing\nserialize::Bool: If true, serialize the model to a file to allow re-execution later.\n\nExamples\n\nstatus = run!(model; optimizer = GLPK.Optimizer, executions = 10) status = run!(model; outputdir = ./modeloutput, optimizer = GLPK.Optimizer, executions = 10)\n\nrun!(\n    model;\n    export_problem_results,\n    console_level,\n    file_level,\n    disable_timer_outputs,\n    serialize,\n    kwargs...\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/emulation_model.jl:437.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.run_economic_dispatch-Tuple{System}","page":"API Reference","title":"PowerSimulations.run_economic_dispatch","text":"run_economic_dispatch(sys::System; kwargs...) -> RunStatus\n\n\nrun_economic_dispatch(system::PSY.System; kwargs...)\n\nCreates a ProblemTemplate with default DeviceModels for an EconomicDispatch problem. Uses the template to create an DecisionProblem.\n\nExample\n\nresults = runeconomicdispatch(system; optimizer = optimizer)\n\n\n# Accepted Key Words\n- `network::Type{<:PM.AbstractPowerModel}` : override default network model settings\n- `devices::Dict{String, DeviceModel}` : override default `DeviceModel` settings\n- `services::Dict{String, ServiceModel}` : override default `ServiceModel` settings\n- `optimizer::JuMP optimizer` : a JuMP optimizer is a required key word\n- `output_dir::AbstractString`  : Path to save outputs\n- Key word arguments supported by `DecisionProblem`\n\nrun_economic_dispatch(sys; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/decision_problems.jl:148.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.run_parallel_simulation-Tuple{Any, Any}","page":"API Reference","title":"PowerSimulations.run_parallel_simulation","text":"run_parallel_simulation(\n    build_function,\n    execute_function;\n    script,\n    output_dir,\n    name,\n    num_steps,\n    period,\n    num_overlap_steps,\n    num_parallel_processes,\n    exeflags,\n    force\n)\n\n\nRun a partitioned simulation in parallel on a local computer.\n\nArguments\n\nbuild_function: Function reference that returns a built Simulation.\nexecute_function: Function reference that executes a Simulation.\nscript::AbstractString: Path to script that includes build_function and execute_function.\noutput_dir::AbstractString: Path for simulation outputs\nname::AbstractString: Simulation name\nnum_steps::Integer: Total number of steps in the simulation\nperiod::Integer: Number of steps in each simulation partition\nnum_overlap_steps::Integer: Number of steps that each partition overlaps with the previous partition\nnum_parallel_processes: Number of partitions to run in parallel. If nothing, use the number of cores.\nexeflags: Path to Julia project. Forwarded to Distributed.addprocs.\nforce: Overwrite the output directory if it already exists.\n\nrun_parallel_simulation(\n    build_function,\n    execute_function;\n    script,\n    output_dir,\n    name,\n    num_steps,\n    period,\n    num_overlap_steps,\n    num_parallel_processes,\n    exeflags,\n    force\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_partitions.jl:190.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.serialize_optimization_model-Tuple{JuMP.Model, String}","page":"API Reference","title":"PowerSimulations.serialize_optimization_model","text":"serialize_optimization_model(\n    jump_model::JuMP.Model,\n    save_path::String\n)\n\n\nExports the JuMP object in MathOptFormat\n\nserialize_optimization_model(jump_model, save_path)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/jump_utils.jl:305.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.serialize_optimization_model-Tuple{PowerSimulations.OptimizationContainer, String}","page":"API Reference","title":"PowerSimulations.serialize_optimization_model","text":"serialize_optimization_model(\n    container::PowerSimulations.OptimizationContainer,\n    save_path::String\n)\n\n\nExports the OpModel JuMP object in MathOptFormat\n\nserialize_optimization_model(container, save_path)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/optimization_container.jl:656.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.serialize_results-Tuple{ProblemResults, AbstractString}","page":"API Reference","title":"PowerSimulations.serialize_results","text":"serialize_results(\n    res::ProblemResults,\n    directory::AbstractString\n)\n\n\nSerialize the results to a binary file.\n\nIt is recommended that directory be the directory that contains a serialized OperationModel. That will allow automatic deserialization of the PowerSystems.System. The ProblemResults instance can be deserialized with ProblemResults(directory).\n\nserialize_results(res, directory)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:245.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.set_device_model!-Tuple{ProblemTemplate, DeviceModel}","page":"API Reference","title":"PowerSimulations.set_device_model!","text":"set_device_model!(\n    template::ProblemTemplate,\n    model::DeviceModel\n)\n\n\nSets the device model in a template using a DeviceModel instance\n\nset_device_model!(template, model)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_template.jl:93.\n\nset_device_model!(template, model)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_template.jl:101.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.set_device_model!-Tuple{ProblemTemplate, Type{<:Device}, Type{<:PowerSimulations.AbstractDeviceFormulation}}","page":"API Reference","title":"PowerSimulations.set_device_model!","text":"set_device_model!(\n    template::ProblemTemplate,\n    component_type::Type{<:Device},\n    formulation::Type{<:PowerSimulations.AbstractDeviceFormulation}\n)\n\n\nSets the device model in a template using the component type and formulation. Builds a default DeviceModel\n\nset_device_model!(template, component_type, formulation)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_template.jl:81.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.set_network_model!-Tuple{ProblemTemplate, NetworkModel}","page":"API Reference","title":"PowerSimulations.set_network_model!","text":"set_network_model!(\n    template::ProblemTemplate,\n    model::NetworkModel\n)\n\n\nSets the network model in a template.\n\nset_network_model!(template, model)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_template.jl:69.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.set_service_model!-Tuple{ProblemTemplate, String, Type{<:Service}, Type{<:PowerSimulations.AbstractServiceFormulation}}","page":"API Reference","title":"PowerSimulations.set_service_model!","text":"set_service_model!(\n    template::ProblemTemplate,\n    service_name::String,\n    service_type::Type{<:Service},\n    formulation::Type{<:PowerSimulations.AbstractServiceFormulation}\n)\n\n\nSets the service model in a template using a name and the service type and formulation. Builds a default ServiceModel with useservicename set to true.\n\nset_service_model!(\n    template,\n    service_name,\n    service_type,\n    formulation\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_template.jl:113.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.set_service_model!-Tuple{ProblemTemplate, Type{<:Service}, Type{<:PowerSimulations.AbstractServiceFormulation}}","page":"API Reference","title":"PowerSimulations.set_service_model!","text":"set_service_model!(\n    template::ProblemTemplate,\n    service_type::Type{<:Service},\n    formulation::Type{<:PowerSimulations.AbstractServiceFormulation}\n)\n\n\nSets the service model in a template using a ServiceModel instance.\n\nset_service_model!(template, service_type, formulation)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_template.jl:130.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.set_system!-Tuple{PowerSimulations.SimulationProblemResults, AbstractString}","page":"API Reference","title":"PowerSimulations.set_system!","text":"set_system!(\n    results::PowerSimulations.SimulationProblemResults,\n    system::AbstractString\n)\n\n\nSet the system in the results instance.\n\nThrows InvalidValue if the system UUID is incorrect.\n\nArguments\n\nresults::SimulationProblemResults: Results object\nsystem::AbstractString: Path to the system json file\n\nExamples\n\njulia > set_system!(res, \"my_path/system_data.json\")\n\nset_system!(results, system)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:173.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.set_system!-Tuple{ProblemResults, System}","page":"API Reference","title":"PowerSimulations.set_system!","text":"set_system!(res::ProblemResults, system::System)\n\n\nSet the system in the results instance.\n\nThrows InvalidValue if the system UUID is incorrect.\n\nset_system!(res, system)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:222.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.show_recorder_events-Union{Tuple{T}, Tuple{Type{T}, AbstractString}, Tuple{Type{T}, AbstractString, Union{Nothing, Function}}} where T<:InfrastructureSystems.AbstractRecorderEvent","page":"API Reference","title":"PowerSimulations.show_recorder_events","text":"show_recorder_events(\n    ::Type{T},\n    filename::AbstractString,\n    filter_func::Union{Nothing, Function} = nothing;\n    wall_time = false,\n    kwargs...,\n) where {T <: IS.AbstractRecorderEvent}\n\nShow the events of type T in a recorder file.\n\nArguments\n\n::Type{T}: Recorder event type\nfilename::AbstractString: recorder filename\nfilter_func::Union{Nothing, Function} = nothing: Optional function that accepts an event of type T and returns a Bool. Apply this function to each event and only return events where the result is true.\nwall_time = false: If true, show the wall_time timestamp.\n\nshow_recorder_events(, filename)\nshow_recorder_events(\n    ,\n    filename,\n    filter_func;\n    wall_time,\n    kwargs...\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/recorder_events.jl:399.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.show_simulation_events-Union{Tuple{T}, Tuple{Type{T}, AbstractString}, Tuple{Type{T}, AbstractString, Union{Nothing, Function}}} where T<:InfrastructureSystems.AbstractRecorderEvent","page":"API Reference","title":"PowerSimulations.show_simulation_events","text":"show_simulation_events(\n    ::Type{T},\n    output_dir::AbstractString,\n    filter_func::Union{Nothing,Function} = nothing;\n    step = nothing,\n    model = nothing,\n    wall_time = false,\n    kwargs...,\n) where { T <: IS.AbstractRecorderEvent}\n\nShow all simulation events of type T in a simulation output directory.\n\nArguments\n\n::Type{T}: Recorder event type\noutput_dir::AbstractString: Simulation output directory\nfilter_func::Union{Nothing, Function} = nothing: Refer to show_recorder_events.\nstep::Int = nothing: Filter events by step. Required if model is passed.\nmodel::Int = nothing: Filter events by model.\nwall_time = false: If true, show the wall_time timestamp.\n\nshow_simulation_events(, output_dir)\nshow_simulation_events(\n    ,\n    output_dir,\n    filter_func;\n    step,\n    model,\n    wall_time,\n    kwargs...\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/recorder_events.jl:314.\n\nshow_simulation_events(, output_dir)\nshow_simulation_events(\n    ,\n    output_dir,\n    filter_func;\n    wall_time,\n    kwargs...\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/recorder_events.jl:335.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.solve!-Tuple{DecisionModel}","page":"API Reference","title":"PowerSimulations.solve!","text":"solve!(\n    model::DecisionModel;\n    export_problem_results,\n    console_level,\n    file_level,\n    disable_timer_outputs,\n    serialize,\n    kwargs...\n) -> RunStatus\n\n\nDefault solve method for models that conform to the requirements of DecisionModel{<: DecisionProblem}.\n\nThis will call build! on the model if it is not already built. It will forward all keyword arguments to that function.\n\nArguments\n\nmodel::OperationModel = model: operation model\noptimizer::MOI.OptimizerWithAttributes: The optimizer that is used to solve the model\nexport_problem_results::Bool: If true, export ProblemResults DataFrames to CSV files.\nserialize::Bool: If true, serialize the model to a file to allow re-execution later.\n\nExamples\n\nresults = solve!(OpModel)\nresults = solve!(OpModel, output_dir=\"output\")\n\nsolve!(\n    model;\n    export_problem_results,\n    console_level,\n    file_level,\n    disable_timer_outputs,\n    serialize,\n    kwargs...\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/decision_model.jl:372.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.solve!-Tuple{Int64, DecisionModel, Dates.DateTime, PowerSimulations.SimulationStore}","page":"API Reference","title":"PowerSimulations.solve!","text":"solve!(\n    step::Int64,\n    model::DecisionModel,\n    start_time::Dates.DateTime,\n    store::PowerSimulations.SimulationStore;\n    exports\n) -> RunStatus\n\n\nDefault solve method for a DecisionModel used inside of a Simulation. Solves problems that conform to the requirements of DecisionModel{<: DecisionProblem}\n\nArguments\n\nstep::Int: Simulation Step\nmodel::OperationModel: operation model\nstart_time::Dates.DateTime: Initial Time of the simulation step in Simulation time.\nstore::SimulationStore: Simulation output store\n\nAccepted Key Words\n\nexports: realtime export of output. Use wisely, it can have negative impacts in the simulation times\n\nsolve!(step, model, start_time, store; exports)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/decision_model.jl:456.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.solve!-Tuple{Int64, EmulationModel, Dates.DateTime, PowerSimulations.SimulationStore}","page":"API Reference","title":"PowerSimulations.solve!","text":"solve!(\n    step::Int64,\n    model::EmulationModel,\n    start_time::Dates.DateTime,\n    store::PowerSimulations.SimulationStore;\n    exports\n) -> RunStatus\n\n\nDefault solve method for an EmulationModel used inside of a Simulation. Solves problems that conform to the requirements of DecisionModel{<: DecisionProblem}\n\nArguments\n\nstep::Int: Simulation Step\nmodel::OperationModel: operation model\nstart_time::Dates.DateTime: Initial Time of the simulation step in Simulation time.\nstore::SimulationStore: Simulation output store\n\nAccepted Key Words\n\nexports: realtime export of output. Use wisely, it can have negative impacts in the simulation times\n\nsolve!(step, model, start_time, store; exports)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/emulation_model.jl:511.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.template_agc_reserve_deployment-Tuple{}","page":"API Reference","title":"PowerSimulations.template_agc_reserve_deployment","text":"template_agc_reserve_deployment(\n;\n    kwargs...\n) -> ProblemTemplate\n\n\ntemplate_agc_reserve_deployment(; kwargs...)\n\nCreates a ProblemTemplate with default DeviceModels for an AGC Reserve Deplyment Problem. This model doesn't support customization\n\nExample\n\ntemplate = agcreservedeployment()\n\ntemplate_agc_reserve_deployment(; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/operation_problem_templates.jl:107.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.template_economic_dispatch-Tuple{}","page":"API Reference","title":"PowerSimulations.template_economic_dispatch","text":"template_economic_dispatch(; kwargs...) -> ProblemTemplate\n\n\ntemplate_economic_dispatch(; kwargs...)\n\nCreates a ProblemTemplate with default DeviceModels for an Economic Dispatch problem.\n\nExample\n\ntemplate = templateeconomicdispatch()\n\n\n# Accepted Key Words\n- `network::Type{<:PM.AbstractPowerModel}` : override default network model settings\n- `devices::Vector{DeviceModel}` : override default `DeviceModel` settings\n- `services::Vector{ServiceModel}` : override default `ServiceModel` settings\n\ntemplate_economic_dispatch(; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/operation_problem_templates.jl:84.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.template_unit_commitment-Tuple{}","page":"API Reference","title":"PowerSimulations.template_unit_commitment","text":"template_unit_commitment(; kwargs...) -> ProblemTemplate\n\n\ntemplate_unit_commitment(; kwargs...)\n\nCreates a ProblemTemplate with default DeviceModels for a Unit Commitment problem.\n\nExample\n\ntemplate = templateunitcommitment()\n\n\n# Accepted Key Words\n- `network::Type{<:PM.AbstractPowerModel}` : override default network model settings\n- `devices::Vector{DeviceModel}` : override default `DeviceModel` settings\n- `services::Vector{ServiceModel}` : override default `ServiceModel` settings\n\ntemplate_unit_commitment(; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/operation_problem_templates.jl:53.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#Internal","page":"API Reference","title":"Internal","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"Modules = [PowerSimulations]\nPublic = false","category":"page"},{"location":"api/PowerSimulations/#PowerSimulations.AbstractDeviceFormulation","page":"API Reference","title":"PowerSimulations.AbstractDeviceFormulation","text":"Abstract type for Device Formulations (a.k.a Models)\n\nExample\n\nimport PowerSimulations const PSI = PowerSimulations struct MyCustomDeviceFormulation <: PSI.AbstractDeviceFormulation\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.AbstractServiceFormulation","page":"API Reference","title":"PowerSimulations.AbstractServiceFormulation","text":"Abstract type for Service Formulations (a.k.a Models)\n\nExample\n\nimport PowerSimulations const PSI = PowerSimulations struct MyServiceFormulation <: PSI.AbstractServiceFormulation\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.AbstractSimulationStatusEvent","page":"API Reference","title":"PowerSimulations.AbstractSimulationStatusEvent","text":"All events subtyped from this need to be recorded under :simulation_status.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.CacheFlushRules","page":"API Reference","title":"PowerSimulations.CacheFlushRules","text":"Informs the flusher on what data to keep in cache.\n\nCacheFlushRules(data, min_flush_size, max_size)\nCacheFlushRules(data, min_flush_size, max_size)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/cache_utils.jl:22.\n\nCacheFlushRules(; max_size, min_flush_size)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/cache_utils.jl:27.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ConstructStage","page":"API Reference","title":"PowerSimulations.ConstructStage","text":"Optimization Container construction stage\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.DecisionModelStore","page":"API Reference","title":"PowerSimulations.DecisionModelStore","text":"Stores results data for one DecisionModel\n\nDecisionModelStore(\n    duals,\n    parameters,\n    variables,\n    aux_variables,\n    expressions,\n    optimizer_stats\n)\nDecisionModelStore(\n    duals,\n    parameters,\n    variables,\n    aux_variables,\n    expressions,\n    optimizer_stats\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/decision_model_store.jl:5.\n\nDecisionModelStore()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/decision_model_store.jl:13.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.DecisionProblem","page":"API Reference","title":"PowerSimulations.DecisionProblem","text":"Abstract type for Decision Problems\n\nExample\n\nimport PowerSimulations const PSI = PowerSimulations struct MyCustomProblem <: PSI.DecisionProblem\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.EmulationModelStore","page":"API Reference","title":"PowerSimulations.EmulationModelStore","text":"Stores results data for one EmulationModel\n\nEmulationModelStore(data_container, optimizer_stats)\nEmulationModelStore(data_container, optimizer_stats)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/emulation_model_store.jl:5.\n\nEmulationModelStore()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/emulation_model_store.jl:12.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.EmulationProblem","page":"API Reference","title":"PowerSimulations.EmulationProblem","text":"Abstract type for Emulation Problems\n\nExample\n\nimport PowerSimulations const PSI = PowerSimulations struct MyCustomEmulator <: PSI.EmulationProblem\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.GenericEmulationProblem","page":"API Reference","title":"PowerSimulations.GenericEmulationProblem","text":"Default PowerSimulations Emulation Problem Type\n\nGenericEmulationProblem()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/emulation_model.jl:4.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.HdfSimulationStore","page":"API Reference","title":"PowerSimulations.HdfSimulationStore","text":"Stores simulation data in an HDF file.\n\nHdfSimulationStore(\n    file,\n    params,\n    dm_data,\n    em_data,\n    optimizer_stats_datasets,\n    optimizer_stats_write_index,\n    cache\n)\nHdfSimulationStore(\n    file,\n    params,\n    dm_data,\n    em_data,\n    optimizer_stats_datasets,\n    optimizer_stats_write_index,\n    cache\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/hdf_simulation_store.jl:22.\n\nHdfSimulationStore(file_path, mode)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/hdf_simulation_store.jl:35.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.InMemorySimulationStore","page":"API Reference","title":"PowerSimulations.InMemorySimulationStore","text":"Stores simulation data in memory\n\nInMemorySimulationStore(\n    params,\n    dm_data,\n    em_data,\n    container_key_lookup\n)\nInMemorySimulationStore(\n    params,\n    dm_data,\n    em_data,\n    container_key_lookup\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/in_memory_simulation_store.jl:5.\n\nInMemorySimulationStore()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/in_memory_simulation_store.jl:11.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.InflowTimeSeriesParameter","page":"API Reference","title":"PowerSimulations.InflowTimeSeriesParameter","text":"Parameter to define energy inflow to storage or reservoir time series\n\nInflowTimeSeriesParameter()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/parameters.jl:185.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.InitialConditionsData","page":"API Reference","title":"PowerSimulations.InitialConditionsData","text":"Stores data to populate initial conditions before the build call\n\nInitialConditionsData(\n    duals,\n    parameters,\n    variables,\n    aux_variables\n)\nInitialConditionsData(\n    duals,\n    parameters,\n    variables,\n    aux_variables\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/initial_conditions.jl:72.\n\nInitialConditionsData()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/initial_conditions.jl:78.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.OperationModel","page":"API Reference","title":"PowerSimulations.OperationModel","text":"Abstract type for Decision Model and Emulation Model. OperationModel structs are parameterized with DecisionProblem or Emulation Problem structs\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.OptimizationOutputCache","page":"API Reference","title":"PowerSimulations.OptimizationOutputCache","text":"Cache for a single parameter/variable/dual. Stores arrays chronologically by simulation timestamp.\n\nOptimizationOutputCache(\n    key,\n    data,\n    dirty_timestamps,\n    stats,\n    size_per_entry,\n    flush_rule\n)\nOptimizationOutputCache(\n    key,\n    data,\n    dirty_timestamps,\n    stats,\n    size_per_entry,\n    flush_rule\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/optimization_output_cache.jl:6.\n\nOptimizationOutputCache(key, flush_rule)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/optimization_output_cache.jl:17.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.OptimizationOutputCaches","page":"API Reference","title":"PowerSimulations.OptimizationOutputCaches","text":"Cache for all model results\n\nOptimizationOutputCaches(data, max_size, min_flush_size)\nOptimizationOutputCaches(data, max_size, min_flush_size)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/optimization_output_caches.jl:5.\n\nOptimizationOutputCaches()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/optimization_output_caches.jl:10.\n\nOptimizationOutputCaches(rules)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/optimization_output_caches.jl:18.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.OptimizerStats-Tuple{Vector{Float64}}","page":"API Reference","title":"PowerSimulations.OptimizerStats","text":"OptimizerStats(data::Vector{Float64}) -> Any\n\n\nConstruct OptimizerStats from a vector that was serialized to HDF5.\n\nOptimizerStats(data)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/optimizer_stats.jl:55.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.OutflowTimeSeriesParameter","page":"API Reference","title":"PowerSimulations.OutflowTimeSeriesParameter","text":"Parameter to define energy outflow from storage or reservoir time series\n\nOutflowTimeSeriesParameter()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/parameters.jl:190.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.RightHandSideParameter","page":"API Reference","title":"PowerSimulations.RightHandSideParameter","text":"Parameters implemented through ParameterJuMP\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.SimulationProblemResults","page":"API Reference","title":"PowerSimulations.SimulationProblemResults","text":"Holds the results of a simulation problem for plotting or exporting.\n\nSimulationProblemResults(\n    ,\n    store,\n    model_name,\n    problem_params,\n    sim_params,\n    path,\n    container_key_lookup;\n    kwargs...\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/decision_model_simulation_results.jl:12.\n\nSimulationProblemResults(\n    ,\n    store,\n    model_name,\n    problem_params,\n    sim_params,\n    path,\n    container_key_lookup;\n    kwargs...\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/emulation_model_simulation_results.jl:10.\n\nSimulationProblemResults(\n    problem,\n    base_power,\n    execution_path,\n    results_output_folder,\n    timestamps,\n    results_timestamps,\n    values,\n    system,\n    system_uuid,\n    resolution,\n    store\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:18.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.SimulationStore","page":"API Reference","title":"PowerSimulations.SimulationStore","text":"Provides storage of simulation data\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations._add_pwl_term!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Vector{Tuple{Float64, Float64}}, U, V}} where {T<:Component, U<:PowerSimulations.VariableType, V<:PowerSimulations.AbstractDeviceFormulation}","page":"API Reference","title":"PowerSimulations._add_pwl_term!","text":"_add_pwl_term!(\n    container::PowerSimulations.OptimizationContainer,\n    component::Component,\n    data::Vector{Tuple{Float64, Float64}},\n    _::PowerSimulations.VariableType,\n    _::PowerSimulations.AbstractDeviceFormulation\n) -> Vector{JuMP.AffExpr}\n\n\nAdd PWL cost terms for data coming from a constant PWL cost function\n\n_add_pwl_term!(container, component, data, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/objective_functions.jl:705.\n\n_add_pwl_term!(container, component, data, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/objective_functions.jl:753.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._add_pwl_term!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Vector{VariableCost{Vector{Tuple{Float64, Float64}}}}, U, V}} where {T<:Component, U<:PowerSimulations.VariableType, V<:PowerSimulations.AbstractDeviceFormulation}","page":"API Reference","title":"PowerSimulations._add_pwl_term!","text":"_add_pwl_term!(\n    container::PowerSimulations.OptimizationContainer,\n    component::Component,\n    cost_data::Vector{VariableCost{Vector{Tuple{Float64, Float64}}}},\n    _::PowerSimulations.VariableType,\n    _::PowerSimulations.AbstractDeviceFormulation\n) -> Vector{JuMP.AffExpr}\n\n\nAdd PWL cost terms for data coming from the MarketBidCost\n\n_add_pwl_term!(container, component, cost_data, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/objective_functions.jl:623.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, VariableCost{Float64}, U}} where {T<:PowerSimulations.VariableType, U<:PowerSimulations.AbstractDeviceFormulation}","page":"API Reference","title":"PowerSimulations._add_variable_cost_to_objective!","text":"_add_variable_cost_to_objective!(\n    container::PowerSimulations.OptimizationContainer,\n    _::PowerSimulations.VariableType,\n    component::Component,\n    cost_component::VariableCost{Float64},\n    _::PowerSimulations.AbstractDeviceFormulation\n)\n\n\nAdds to the cost function cost terms for sum of variables with common factor to be used for cost expression for optimization_container model.\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nvar_key::VariableKey: The variable name\ncomponentname::String: The componentname of the variable container\ncost_component::PSY.VariableCost{Float64} : container for cost to be associated with variable\n\n_add_variable_cost_to_objective!(\n    container,\n    _,\n    component,\n    cost_component,\n    _\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/objective_functions.jl:409.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, VariableCost{Tuple{Float64, Float64}}, U}} where {T<:PowerSimulations.VariableType, U<:PowerSimulations.AbstractDeviceFormulation}","page":"API Reference","title":"PowerSimulations._add_variable_cost_to_objective!","text":"_add_variable_cost_to_objective!(\n    container::PowerSimulations.OptimizationContainer,\n    _::PowerSimulations.VariableType,\n    component::Component,\n    cost_component::VariableCost{Tuple{Float64, Float64}},\n    _::PowerSimulations.AbstractDeviceFormulation\n)\n\n\nAdds to the cost function cost terms for sum of variables with common factor to be used for cost expression for optimization_container model.\n\nEquation\n\ngen_cost = dt*sign*(sum(variable.^2)*cost_data[1] + sum(variable)*cost_data[2])\n\nLaTeX\n\ncost = dttimes sign (sum_iin I c_1 v_i^2 + sum_iin I c_2 v_i )\n\nfor quadratic factor large enough. If the first term of the quadratic objective is 0.0, adds a linear cost term sum(variable)*cost_data[2]\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nvar_key::VariableKey: The variable name\ncomponentname::String: The componentname of the variable container\ncost_component::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors\n\n_add_variable_cost_to_objective!(\n    container,\n    _,\n    component,\n    cost_component,\n    _\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/objective_functions.jl:461.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, VariableCost{Vector{Tuple{Float64, Float64}}}, U}} where {T<:PowerSimulations.VariableType, U<:PowerSimulations.AbstractDeviceFormulation}","page":"API Reference","title":"PowerSimulations._add_variable_cost_to_objective!","text":"_add_variable_cost_to_objective!(\n    container::PowerSimulations.OptimizationContainer,\n    _::PowerSimulations.VariableType,\n    component::Component,\n    cost_component::VariableCost{Vector{Tuple{Float64, Float64}}},\n    _::PowerSimulations.AbstractDeviceFormulation\n)\n\n\nCreates piecewise linear cost function using a sum of variables and expression with sign and time step included.\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nvar_key::VariableKey: The variable name\ncomponentname::String: The componentname of the variable container\ncost_component::PSY.VariableCost{Vector{NTuple{2, Float64}}}\n\n_add_variable_cost_to_objective!(\n    container,\n    _,\n    component,\n    cost_component,\n    _\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/objective_functions.jl:514.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._allocate_execution_order-Tuple{Vector{Int64}}","page":"API Reference","title":"PowerSimulations._allocate_execution_order","text":"_allocate_execution_order(\n    interval_run_counts::Vector{Int64}\n) -> Vector{Int64}\n\n\nFunction calculates the total number of problem executions in the simulation and allocates the appropiate vector\n\n_allocate_execution_order(interval_run_counts)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_sequence.jl:71.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._calculate_interval_inner_counts-Tuple{OrderedDict{Symbol, Dates.Millisecond}}","page":"API Reference","title":"PowerSimulations._calculate_interval_inner_counts","text":"_calculate_interval_inner_counts(\n    intervals::OrderedDict{Symbol, Dates.Millisecond}\n) -> Vector{Int64}\n\n\ncalculateintervalinnercounts(intervals::OrderedDict{String,<:Dates.TimePeriod})\n\nCalculates how many times a problem is executed for every interval of the previous problem\n\n_calculate_interval_inner_counts(intervals)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_sequence.jl:44.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._get_data_for_tdc-Union{Tuple{U}, Tuple{T}, Tuple{Vector{T}, Vector{U}, Dates.TimePeriod}} where {T<:InitialCondition, U<:InitialCondition}","page":"API Reference","title":"PowerSimulations._get_data_for_tdc","text":"_get_data_for_tdc(\n    initial_conditions_on::Array{T<:InitialCondition, 1},\n    initial_conditions_off::Array{U<:InitialCondition, 1},\n    resolution::Dates.TimePeriod\n) -> Tuple{Matrix{InitialCondition}, Vector{NamedTuple{(:up, :down), Tuple{Float64, Float64}}}}\n\n\nIf the fraction of hours that a generator has a duration constraint is less than the fraction of hours that a single time_step represents then it is not binding.\n\n_get_data_for_tdc(\n    initial_conditions_on,\n    initial_conditions_off,\n    resolution\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:1128.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._get_initial_condition_type-Tuple{Type{RampConstraint}, Type{<:ThermalGen}, Type{<:PowerSimulations.AbstractThermalFormulation}}","page":"API Reference","title":"PowerSimulations._get_initial_condition_type","text":"_get_initial_condition_type(\n    _::Type{RampConstraint},\n    _::Type{<:ThermalGen},\n    _::Type{<:PowerSimulations.AbstractThermalFormulation}\n) -> Type{PowerSimulations.DeviceAboveMinPower}\n\n\nThis function gets the data for the generators for ramping constraints of thermal generators\n\n_get_initial_condition_type(_, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:799.\n\n_get_initial_condition_type(_, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:804.\n\n_get_initial_condition_type(_, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:809.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._slope_convexity_check-Tuple{Vector{Float64}}","page":"API Reference","title":"PowerSimulations._slope_convexity_check","text":"_slope_convexity_check(slopes::Vector{Float64}) -> Bool\n\n\nReturns True/False depending on compatibility of the cost data with the convex implementation method\n\n_slope_convexity_check(slopes)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/objective_functions.jl:547.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._summary_to_dict!-Tuple{PowerSimulations.OptimizerStats, JuMP.Model}","page":"API Reference","title":"PowerSimulations._summary_to_dict!","text":"_summary_to_dict!(\n    optimizer_stats::PowerSimulations.OptimizerStats,\n    jump_model::JuMP.Model\n)\n\n\nRun this function only when getting detailed solver stats\n\n_summary_to_dict!(optimizer_stats, jump_model)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/jump_utils.jl:231.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{SR}, Tuple{PowerSimulations.OptimizationContainer, Type{RequirementConstraint}, SR, Vector{<:Service}, ServiceModel{SR, GroupReserve}}} where SR<:StaticReserveGroup","page":"API Reference","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{RequirementConstraint},\n    service::StaticReserveGroup,\n    contributing_services::Vector{<:Service},\n    model::ServiceModel{SR<:StaticReserveGroup, GroupReserve}\n)\n\n\nThis function creates the requirement constraint that will be attained by the apropriate services\n\nadd_constraints!(\n    container,\n    _,\n    service,\n    contributing_services,\n    model\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/services_models/group_reserve.jl:25.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{S}, Tuple{B}, Tuple{PowerSimulations.OptimizationContainer, Type{NetworkFlowConstraint}, InfrastructureSystems.FlattenIteratorWrapper{B}, DeviceModel{B, <:PowerSimulations.AbstractBranchFormulation}, NetworkModel{S}}} where {B<:ACBranch, S<:StandardPTDFModel}","page":"API Reference","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    cons_type::Type{NetworkFlowConstraint},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{B<:ACBranch},\n    model::DeviceModel{B<:ACBranch, <:PowerSimulations.AbstractBranchFormulation},\n    network_model::NetworkModel{S<:StandardPTDFModel}\n)\n\n\nAdd network flow constraints for ACBranch and NetworkModel with StandardPTDFModel\n\nadd_constraints!(\n    container,\n    cons_type,\n    devices,\n    model,\n    network_model\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:196.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{MustRunConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, S}, Type{<:PowerModels.AbstractPowerModel}}} where {T<:ThermalGen, S<:PowerSimulations.AbstractThermalUnitCommitment}","page":"API Reference","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{MustRunConstraint},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{T<:ThermalGen},\n    model::DeviceModel{T<:ThermalGen, S<:PowerSimulations.AbstractThermalUnitCommitment},\n    W::Type{<:PowerModels.AbstractPowerModel}\n)\n\n\nThis function creates constraints that keep must run devices online\n\nadd_constraints!(container, _, devices, model, W)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:1104.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{B}, Tuple{PowerSimulations.OptimizationContainer, Type{RateLimitConstraintFromTo}, InfrastructureSystems.FlattenIteratorWrapper{B}, DeviceModel{B, <:PowerSimulations.AbstractBranchFormulation}, Type{T}}} where {B<:ACBranch, T<:PowerModels.AbstractPowerModel}","page":"API Reference","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    cons_type::Type{RateLimitConstraintFromTo},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{B<:ACBranch},\n    model::DeviceModel{B<:ACBranch, <:PowerSimulations.AbstractBranchFormulation},\n    _::Type{T<:PowerModels.AbstractPowerModel}\n)\n\n\nAdd rate limit from to constraints for ACBranch with AbstractPowerModel\n\nadd_constraints!(container, cons_type, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:128.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{B}, Tuple{PowerSimulations.OptimizationContainer, Type{RateLimitConstraintToFrom}, InfrastructureSystems.FlattenIteratorWrapper{B}, DeviceModel{B, <:PowerSimulations.AbstractBranchFormulation}, Type{T}}} where {B<:ACBranch, T<:PowerModels.AbstractPowerModel}","page":"API Reference","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    cons_type::Type{RateLimitConstraintToFrom},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{B<:ACBranch},\n    model::DeviceModel{B<:ACBranch, <:PowerSimulations.AbstractBranchFormulation},\n    _::Type{T<:PowerModels.AbstractPowerModel}\n)\n\n\nAdd rate limit to from constraints for ACBranch with AbstractPowerModel\n\nadd_constraints!(container, cons_type, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:162.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{StartTypeConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, ThermalMultiStartUnitCommitment}, Type{<:PowerModels.AbstractPowerModel}}} where T<:ThermalMultiStart","page":"API Reference","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{StartTypeConstraint},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{T<:ThermalMultiStart},\n    model::DeviceModel{T<:ThermalMultiStart, ThermalMultiStartUnitCommitment},\n    _::Type{<:PowerModels.AbstractPowerModel}\n)\n\n\nConstructs contraints that restricts devices to one type of start at a time\n\nEquations\n\nsum(var_starts[name, s, t] for s in starts) = var_start[name, t]\n\nLaTeX\n\nsum^S_g_s=1 δ^s(t)  eq  x^start(t)\n\nadd_constraints!(container, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:981.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{StartupInitialConditionConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, ThermalMultiStartUnitCommitment}, Type{<:PowerModels.AbstractPowerModel}}} where T<:ThermalMultiStart","page":"API Reference","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{StartupInitialConditionConstraint},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{T<:ThermalMultiStart},\n    model::DeviceModel{T<:ThermalMultiStart, ThermalMultiStartUnitCommitment},\n    _::Type{<:PowerModels.AbstractPowerModel}\n)\n\n\nConstructs contraints that restricts devices to one type of start at a time\n\nEquations\n\nub: (time_limits[st+1]-1)*δ^{s}(t) + (1 - δ^{s}(t)) * M_VALUE >= sum(1-varbin[name, i]) for i in 1:t) + initial_condition_offtime lb: (time_limits[st]-1)*δ^{s}(t) =< sum(1-varbin[name, i]) for i in 1:t) + initial_condition_offtime\n\nLaTeX\n\nTS^s+1_g δ^s(t) + (1-δ^s(t)) M_VALUE   geq  sum^t_i=1 x^status(i)  +  DT_g^0  forall t in 1 ldots  TS^s+1_g\n\nTS^s_g δ^s(t) leq  sum^t_i=1 x^status(i)  +  DT_g^0  forall t in 1 ldots  TS^s+1_g\n\nadd_constraints!(container, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:1032.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{StartupTimeLimitTemperatureConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, ThermalMultiStartUnitCommitment}, Type{<:PowerModels.AbstractPowerModel}}} where T<:ThermalMultiStart","page":"API Reference","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{StartupTimeLimitTemperatureConstraint},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{T<:ThermalMultiStart},\n    model::DeviceModel{T<:ThermalMultiStart, ThermalMultiStartUnitCommitment},\n    _::Type{<:PowerModels.AbstractPowerModel}\n)\n\n\nConstructs contraints for different types of starts based on generator down-time\n\nEquations\n\nfor t in time_limits[s+1]:T\n\nvar_starts[name, s, t] <= sum( var_stop[name, t-i] for i in time_limits[s]:(time_limits[s+1]-1)\n\nLaTeX\n\nδ^s(t)  leq sum_i=TS^s_g^TS^s+1_g x^stop(t-i)\n\nadd_constraints!(container, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:909.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{RateLimitConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, U}, Type{<:PowerModels.AbstractActivePowerModel}}} where {T<:ACBranch, U<:PowerSimulations.AbstractBranchFormulation}","page":"API Reference","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    cons_type::Type{RateLimitConstraint},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{T<:ACBranch},\n    model::DeviceModel{T<:ACBranch, U<:PowerSimulations.AbstractBranchFormulation},\n    X::Type{<:PowerModels.AbstractActivePowerModel}\n)\n\n\nAdd branch rate limit constraints for ACBranch with AbstractActivePowerModel\n\nadd_constraints!(container, cons_type, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:114.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{V}, Tuple{U}, Tuple{PowerSimulations.OptimizationContainer, Type{RampConstraint}, InfrastructureSystems.FlattenIteratorWrapper{U}, DeviceModel{U, V}, Type{<:PowerModels.AbstractPowerModel}}} where {U<:ThermalGen, V<:PowerSimulations.AbstractThermalUnitCommitment}","page":"API Reference","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    T::Type{RampConstraint},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{U<:ThermalGen},\n    model::DeviceModel{U<:ThermalGen, V<:PowerSimulations.AbstractThermalUnitCommitment},\n    W::Type{<:PowerModels.AbstractPowerModel}\n)\n\n\nThis function adds the ramping limits of generators when there are CommitmentVariables\n\nadd_constraints!(container, T, devices, model, W)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:814.\n\nadd_constraints!(container, T, devices, model, W)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:832.\n\nadd_constraints!(container, T, devices, model, W)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:872.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{SteadyStateFrequencyDeviation}, InfrastructureSystems.FlattenIteratorWrapper{U}, ServiceModel{AGC, V}, System}} where {T<:FrequencyResponseConstraint, U<:Area, V<:PIDSmoothACE}","page":"API Reference","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:FrequencyResponseConstraint},\n    _::Type{SteadyStateFrequencyDeviation},\n    areas::InfrastructureSystems.FlattenIteratorWrapper{U<:Area},\n    _::ServiceModel{AGC, V<:PIDSmoothACE},\n    sys::System\n)\n\n\nExpression for the power deviation given deviation in the frequency. This expression allows updating the response of the frequency depending on commitment decisions\n\nadd_constraints!(container, _, _, areas, _, sys)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/services_models/agc.jl:101.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{<:ActivePowerVariableLimitsConstraint}, Type{<:PowerSimulations.VariableType}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{<:PowerModels.AbstractPowerModel}}} where {V<:ThermalMultiStart, W<:ThermalMultiStartUnitCommitment}","page":"API Reference","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    T::Type{<:ActivePowerVariableLimitsConstraint},\n    U::Type{<:PowerSimulations.VariableType},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:ThermalMultiStart},\n    model::DeviceModel{V<:ThermalMultiStart, W<:ThermalMultiStartUnitCommitment},\n    X::Type{<:PowerModels.AbstractPowerModel}\n)\n\n\nThis function adds range constraint for the first time period. Constraint (10) from PGLIB formulation\n\nadd_constraints!(container, T, U, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:65.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:91.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:111.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:293.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:206.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:246.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:258.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:312.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:327.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:365.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:64.\n\nadd_constraints!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:79.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:102.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:122.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:196.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:345.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{<:PowerSimulations.PowerVariableLimitsConstraint}, Type{<:Union{PowerAboveMinimumVariable, PowerSimulations.ExpressionType}}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{<:PowerModels.AbstractPowerModel}}} where {V<:ThermalGen, W<:ThermalCompactDispatch}","page":"API Reference","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    T::Type{<:PowerSimulations.PowerVariableLimitsConstraint},\n    U::Type{<:Union{PowerAboveMinimumVariable, PowerSimulations.ExpressionType}},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:ThermalGen},\n    model::DeviceModel{V<:ThermalGen, W<:ThermalCompactDispatch},\n    X::Type{<:PowerModels.AbstractPowerModel}\n)\n\n\nRange constraints for thermal compact dispatch\n\nadd_constraints!(container, T, U, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:65.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:91.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:111.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:293.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:305.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:327.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:340.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:206.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:229.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:246.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:258.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:312.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:327.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:365.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:64.\n\nadd_constraints!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:79.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:102.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:122.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:196.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:271.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:345.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:420.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:456.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{<:PowerSimulations.PowerVariableLimitsConstraint}, Type{<:Union{PowerSimulations.ExpressionType, PowerSimulations.VariableType}}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{<:PowerModels.AbstractPowerModel}}} where {V<:HydroGen, W<:PowerSimulations.AbstractHydroDispatchFormulation}","page":"API Reference","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    T::Type{<:PowerSimulations.PowerVariableLimitsConstraint},\n    U::Type{<:Union{PowerSimulations.ExpressionType, PowerSimulations.VariableType}},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:HydroGen},\n    model::DeviceModel{V<:HydroGen, W<:PowerSimulations.AbstractHydroDispatchFormulation},\n    X::Type{<:PowerModels.AbstractPowerModel}\n)\n\n\nAdd power variable limits constraints for hydro dispatch formulation\n\nadd_constraints!(container, T, U, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:65.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:91.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:111.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:293.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:305.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:327.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:340.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:361.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:377.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:393.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:206.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:229.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:246.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:258.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:312.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:327.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:344.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:365.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:64.\n\nadd_constraints!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:79.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:102.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:122.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:196.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:239.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:271.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:345.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:420.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:456.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{<:PowerSimulations.PowerVariableLimitsConstraint}, Type{<:Union{PowerSimulations.ExpressionType, PowerSimulations.VariableType}}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{<:PowerModels.AbstractPowerModel}}} where {V<:HydroGen, W<:PowerSimulations.AbstractHydroUnitCommitment}","page":"API Reference","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    T::Type{<:PowerSimulations.PowerVariableLimitsConstraint},\n    U::Type{<:Union{PowerSimulations.ExpressionType, PowerSimulations.VariableType}},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:HydroGen},\n    model::DeviceModel{V<:HydroGen, W<:PowerSimulations.AbstractHydroUnitCommitment},\n    X::Type{<:PowerModels.AbstractPowerModel}\n)\n\n\nAdd power variable limits constraints for hydro unit commitment formulation\n\nadd_constraints!(container, T, U, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:65.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:91.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:111.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:293.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:305.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:327.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:340.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:361.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:377.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:393.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:206.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:229.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:246.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:258.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:312.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:327.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:344.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:365.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:64.\n\nadd_constraints!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:79.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:102.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:122.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:196.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:239.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:271.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:345.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:420.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:456.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{<:PowerSimulations.PowerVariableLimitsConstraint}, Type{<:Union{PowerSimulations.ExpressionType, PowerSimulations.VariableType}}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{<:PowerModels.AbstractPowerModel}}} where {V<:HydroPumpedStorage, W<:PowerSimulations.AbstractHydroReservoirFormulation}","page":"API Reference","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    T::Type{<:PowerSimulations.PowerVariableLimitsConstraint},\n    U::Type{<:Union{PowerSimulations.ExpressionType, PowerSimulations.VariableType}},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:HydroPumpedStorage},\n    model::DeviceModel{V<:HydroPumpedStorage, W<:PowerSimulations.AbstractHydroReservoirFormulation},\n    X::Type{<:PowerModels.AbstractPowerModel}\n)\n\n\nAdd output power variable limits constraints for hydro dispatch formulation\n\nadd_constraints!(container, T, U, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:65.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:91.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:111.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:293.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:305.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:327.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:340.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:361.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:377.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:393.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:206.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:229.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:246.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:258.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:344.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:365.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:64.\n\nadd_constraints!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:79.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:102.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:122.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:196.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:239.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:271.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:345.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:420.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:456.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{<:PowerSimulations.PowerVariableLimitsConstraint}, Type{<:Union{PowerSimulations.ExpressionType, PowerSimulations.VariableType}}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{<:PowerModels.AbstractPowerModel}}} where {V<:ThermalGen, W<:PowerSimulations.AbstractThermalDispatchFormulation}","page":"API Reference","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    T::Type{<:PowerSimulations.PowerVariableLimitsConstraint},\n    U::Type{<:Union{PowerSimulations.ExpressionType, PowerSimulations.VariableType}},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:ThermalGen},\n    model::DeviceModel{V<:ThermalGen, W<:PowerSimulations.AbstractThermalDispatchFormulation},\n    X::Type{<:PowerModels.AbstractPowerModel}\n)\n\n\nSemicontinuous range constraints for thermal dispatch formulations\n\nadd_constraints!(container, T, U, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:65.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:91.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:111.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:293.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:305.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:327.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:340.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:361.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:377.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:393.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:206.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:229.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:246.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:258.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:312.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:327.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:344.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:365.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:64.\n\nadd_constraints!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:79.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:102.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:122.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:196.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:239.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:271.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:345.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:420.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:456.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{<:PowerSimulations.PowerVariableLimitsConstraint}, Type{<:Union{PowerSimulations.ExpressionType, PowerSimulations.VariableType}}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{<:PowerModels.AbstractPowerModel}}} where {V<:ThermalGen, W<:PowerSimulations.AbstractThermalUnitCommitment}","page":"API Reference","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    T::Type{<:PowerSimulations.PowerVariableLimitsConstraint},\n    U::Type{<:Union{PowerSimulations.ExpressionType, PowerSimulations.VariableType}},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:ThermalGen},\n    model::DeviceModel{V<:ThermalGen, W<:PowerSimulations.AbstractThermalUnitCommitment},\n    X::Type{<:PowerModels.AbstractPowerModel}\n)\n\n\nSemicontinuous range constraints for unit commitment formulations\n\nadd_constraints!(container, T, U, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:65.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:91.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:111.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:293.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:305.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:327.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:340.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:361.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:377.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:393.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:206.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:229.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:246.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:258.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:312.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:327.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:344.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:365.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:64.\n\nadd_constraints!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:79.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:102.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:122.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:196.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:239.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:271.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:345.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:420.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:456.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{<:ReactivePowerVariableLimitsConstraint}, Type{<:ReactivePowerVariable}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{<:PowerModels.AbstractPowerModel}}} where {V<:ElectricLoad, W<:PowerSimulations.AbstractControllablePowerLoadFormulation}","page":"API Reference","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    T::Type{<:ReactivePowerVariableLimitsConstraint},\n    U::Type{<:ReactivePowerVariable},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:ElectricLoad},\n    _::DeviceModel{V<:ElectricLoad, W<:PowerSimulations.AbstractControllablePowerLoadFormulation},\n    _::Type{<:PowerModels.AbstractPowerModel}\n)\n\n\nReactive Power Constraints on Controllable Loads Assume Constant power_factor\n\nadd_constraints!(container, T, U, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:65.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:293.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:312.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:327.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:365.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:64.\n\nadd_constraints!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:79.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:122.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:196.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:239.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:271.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:345.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{<:ReactivePowerVariableLimitsConstraint}, Type{<:ReactivePowerVariable}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{<:PowerModels.AbstractPowerModel}}} where {V<:RenewableGen, W<:RenewableConstantPowerFactor}","page":"API Reference","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{<:ReactivePowerVariableLimitsConstraint},\n    _::Type{<:ReactivePowerVariable},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:RenewableGen},\n    _::DeviceModel{V<:RenewableGen, W<:RenewableConstantPowerFactor},\n    _::Type{<:PowerModels.AbstractPowerModel}\n)\n\n\nReactive Power Constraints on Renewable Gen Constant power_factor\n\nadd_constraints!(container, T, U, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:65.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:293.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:312.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:327.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:365.\n\nadd_constraints!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:79.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:122.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:196.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:239.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:271.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:345.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{ActivePowerVariableLimitsConstraint}, Type{<:Union{PowerSimulations.ExpressionType, PowerSimulations.VariableType}}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{<:PowerModels.AbstractPowerModel}}} where {V<:HydroGen, W<:HydroDispatchRunOfRiver}","page":"API Reference","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    T::Type{ActivePowerVariableLimitsConstraint},\n    U::Type{<:Union{PowerSimulations.ExpressionType, PowerSimulations.VariableType}},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:HydroGen},\n    model::DeviceModel{V<:HydroGen, W<:HydroDispatchRunOfRiver},\n    X::Type{<:PowerModels.AbstractPowerModel}\n)\n\n\nTime series constraints\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:91.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:111.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:293.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:206.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:229.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:246.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:258.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:312.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:365.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:102.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:122.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:196.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:239.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:271.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:345.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{ActivePowerVariableLimitsConstraint}, Type{<:Union{PowerSimulations.VariableType, var\"#s900\"} where var\"#s900\"<:RangeConstraintLBExpressions}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{<:PowerModels.AbstractPowerModel}}} where {V<:HydroGen, W<:HydroCommitmentRunOfRiver}","page":"API Reference","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    T::Type{ActivePowerVariableLimitsConstraint},\n    U::Type{<:Union{PowerSimulations.VariableType, var\"#s900\"} where var\"#s900\"<:RangeConstraintLBExpressions},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:HydroGen},\n    model::DeviceModel{V<:HydroGen, W<:HydroCommitmentRunOfRiver},\n    X::Type{<:PowerModels.AbstractPowerModel}\n)\n\n\nAdd semicontinuous range constraints for Hydro Unit Commitment formulation\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:91.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:111.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:293.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:206.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:229.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:246.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:327.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:365.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:102.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:122.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:196.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:239.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:271.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:345.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{InputActivePowerVariableLimitsConstraint}, Type{<:Union{PowerSimulations.ExpressionType, PowerSimulations.VariableType}}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{<:PowerModels.AbstractPowerModel}}} where {V<:HydroPumpedStorage, W<:PowerSimulations.AbstractHydroReservoirFormulation}","page":"API Reference","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    T::Type{InputActivePowerVariableLimitsConstraint},\n    U::Type{<:Union{PowerSimulations.ExpressionType, PowerSimulations.VariableType}},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:HydroPumpedStorage},\n    model::DeviceModel{V<:HydroPumpedStorage, W<:PowerSimulations.AbstractHydroReservoirFormulation},\n    X::Type{<:PowerModels.AbstractPowerModel}\n)\n\n\nAdd input power variable limits constraints for hydro dispatch formulation\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:293.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:361.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:344.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:122.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:239.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:271.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{EnergyBalanceConstraint}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {V<:HydroEnergyReservoir, W<:PowerSimulations.AbstractHydroFormulation, X<:PowerModels.AbstractPowerModel}","page":"API Reference","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{EnergyBalanceConstraint},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:HydroEnergyReservoir},\n    model::DeviceModel{V<:HydroEnergyReservoir, W<:PowerSimulations.AbstractHydroFormulation},\n    _::Type{X<:PowerModels.AbstractPowerModel}\n)\n\n\nThis function defines the constraints for the water level (or state of charge) for the Hydro Reservoir.\n\nadd_constraints!(container, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:411.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{EnergyBalanceConstraint}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {V<:Storage, W<:PowerSimulations.AbstractStorageFormulation, X<:PowerModels.AbstractPowerModel}","page":"API Reference","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{EnergyBalanceConstraint},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:Storage},\n    model::DeviceModel{V<:Storage, W<:PowerSimulations.AbstractStorageFormulation},\n    _::Type{X<:PowerModels.AbstractPowerModel}\n)\n\n\nAdd Energy Balance Constraints for AbstractStorageFormulation\n\nadd_constraints!(container, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:186.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{EnergyCapacityConstraint}, Type{<:PowerSimulations.VariableType}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {V<:Storage, W<:PowerSimulations.AbstractStorageFormulation, X<:PowerModels.AbstractPowerModel}","page":"API Reference","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    T::Type{EnergyCapacityConstraint},\n    U::Type{<:PowerSimulations.VariableType},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:Storage},\n    model::DeviceModel{V<:Storage, W<:PowerSimulations.AbstractStorageFormulation},\n    _::Type{X<:PowerModels.AbstractPowerModel}\n)\n\n\nAdd Energy Capacity Constraints for AbstractStorageFormulation\n\nadd_constraints!(container, T, U, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:162.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{EnergyCapacityDownConstraint}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {V<:HydroPumpedStorage, W<:PowerSimulations.AbstractHydroFormulation, X<:PowerModels.AbstractPowerModel}","page":"API Reference","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{EnergyCapacityDownConstraint},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:HydroPumpedStorage},\n    model::DeviceModel{V<:HydroPumpedStorage, W<:PowerSimulations.AbstractHydroFormulation},\n    _::Type{X<:PowerModels.AbstractPowerModel}\n)\n\n\nAdd energy capacity down constraints for hydro pumped storage\n\nadd_constraints!(container, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:533.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{EnergyCapacityUpConstraint}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {V<:HydroPumpedStorage, W<:PowerSimulations.AbstractHydroFormulation, X<:PowerModels.AbstractPowerModel}","page":"API Reference","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{EnergyCapacityUpConstraint},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:HydroPumpedStorage},\n    model::DeviceModel{V<:HydroPumpedStorage, W<:PowerSimulations.AbstractHydroFormulation},\n    _::Type{X<:PowerModels.AbstractPowerModel}\n)\n\n\nThis function defines the constraints for the water level (or state of charge) for the HydroPumpedStorage.\n\nadd_constraints!(container, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:469.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{EnergyTargetConstraint}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {V<:HydroGen, W<:PowerSimulations.AbstractHydroFormulation, X<:PowerModels.AbstractPowerModel}","page":"API Reference","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{EnergyTargetConstraint},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:HydroGen},\n    model::DeviceModel{V<:HydroGen, W<:PowerSimulations.AbstractHydroFormulation},\n    _::Type{X<:PowerModels.AbstractPowerModel}\n)\n\n\nAdd energy target constraints for hydro gen\n\nadd_constraints!(container, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:598.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{EnergyTargetConstraint}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {V<:Storage, W<:EnergyTarget, X<:PowerModels.AbstractPowerModel}","page":"API Reference","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{EnergyTargetConstraint},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:Storage},\n    model::DeviceModel{V<:Storage, W<:EnergyTarget},\n    _::Type{X<:PowerModels.AbstractPowerModel}\n)\n\n\nAdd Energy Target Constraints for EnergyTarget formulation\n\nadd_constraints!(container, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:335.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_feedforward_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, DeviceModel, InfrastructureSystems.FlattenIteratorWrapper{T}, EnergyLimitFeedforward}} where T<:Component","page":"API Reference","title":"PowerSimulations.add_feedforward_constraints!","text":"add_feedforward_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::DeviceModel,\n    devices::InfrastructureSystems.FlattenIteratorWrapper{T<:Component},\n    ff::EnergyLimitFeedforward\n)\n\n\n    add_feedforward_constraints(container::OptimizationContainer,\n                    cons_name::Symbol,\n                    param_reference,\n                    var_key::VariableKey)\n\nConstructs a parameterized integral limit constraint to implement feedforward from other models. The Parameters are initialized using the upper boundary values of the provided variables.\n\nsum(variable[var_name, t] for t in 1:affected_periods)/affected_periods <= param_reference[var_name]\n\nLaTeX\n\nsum_t x leq param^max\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nmodel::DeviceModel : the device model\ndevices::IS.FlattenIteratorWrapper{T} : list of devices\nff::FixValueFeedforward : a instance of the FixValue Feedforward\n\nadd_feedforward_constraints!(container, _, devices, ff)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/feedforward/feedforward_constraints.jl:366.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_feedforward_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, DeviceModel, InfrastructureSystems.FlattenIteratorWrapper{T}, EnergyTargetFeedforward}} where T<:Component","page":"API Reference","title":"PowerSimulations.add_feedforward_constraints!","text":"add_feedforward_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::DeviceModel,\n    devices::InfrastructureSystems.FlattenIteratorWrapper{T<:Component},\n    ff::EnergyTargetFeedforward\n)\n\n\n    add_feedforward_constraints(\n        container::OptimizationContainer,\n        ::DeviceModel,\n        devices::IS.FlattenIteratorWrapper{T},\n        ff::EnergyTargetFeedforward,\n    ) where {T <: PSY.Component}\n\nConstructs a equality constraint to a fix a variable in one model using the variable value from other model results.\n\nvariable[var_name, t] + slack[var_name, t] >= param[var_name, t]\n\nLaTeX\n\nx + slack = param\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nmodel::DeviceModel : the device model\ndevices::IS.FlattenIteratorWrapper{T} : list of devices\nff::EnergyTargetFeedforward : a instance of the FixValue Feedforward\n\nadd_feedforward_constraints!(container, _, devices, ff)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/feedforward/feedforward_constraints.jl:484.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_feedforward_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, DeviceModel, InfrastructureSystems.FlattenIteratorWrapper{T}, FixValueFeedforward}} where T<:Component","page":"API Reference","title":"PowerSimulations.add_feedforward_constraints!","text":"add_feedforward_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::DeviceModel,\n    devices::InfrastructureSystems.FlattenIteratorWrapper{T<:Component},\n    ff::FixValueFeedforward\n)\n\n\n    add_feedforward_constraints(\n        container::OptimizationContainer,\n        ::DeviceModel,\n        devices::IS.FlattenIteratorWrapper{T},\n        ff::FixValueFeedforward,\n    ) where {T <: PSY.Component}\n\nConstructs a equality constraint to a fix a variable in one model using the variable value from other model results.\n\nvariable[var_name, t] == param[var_name, t]\n\nLaTeX\n\nx == param\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nmodel::DeviceModel : the device model\ndevices::IS.FlattenIteratorWrapper{T} : list of devices\nff::FixValueFeedforward : a instance of the FixValue Feedforward\n\nadd_feedforward_constraints!(container, _, devices, ff)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/feedforward/feedforward_constraints.jl:438.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_feedforward_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, DeviceModel, InfrastructureSystems.FlattenIteratorWrapper{T}, LowerBoundFeedforward}} where T<:Component","page":"API Reference","title":"PowerSimulations.add_feedforward_constraints!","text":"add_feedforward_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::DeviceModel,\n    devices::InfrastructureSystems.FlattenIteratorWrapper{T<:Component},\n    ff::LowerBoundFeedforward\n)\n\n\n    lb_ff(container::OptimizationContainer,\n          cons_name::Symbol,\n          constraint_infos,\n          param_reference,\n          var_key::VariableKey)\n\nConstructs a parameterized upper bound constraint to implement feedforward from other models. The Parameters are initialized using the uppper boundary values of the provided variables.\n\nvariable[var_name, t] <= param_reference[var_name]\n\nLaTeX\n\nx leq param^max\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\ncons_name::Symbol : name of the constraint\nparam_reference : Reference to the PJ.ParameterRef used to determine the upperbound\nvar_key::VariableKey : the name of the continuous variable\n\nadd_feedforward_constraints!(container, _, devices, ff)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/feedforward/feedforward_constraints.jl:272.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_feedforward_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, DeviceModel, InfrastructureSystems.FlattenIteratorWrapper{T}, UpperBoundFeedforward}} where T<:Component","page":"API Reference","title":"PowerSimulations.add_feedforward_constraints!","text":"add_feedforward_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::DeviceModel,\n    devices::InfrastructureSystems.FlattenIteratorWrapper{T<:Component},\n    ff::UpperBoundFeedforward\n)\n\n\n    ub_ff(container::OptimizationContainer,\n          cons_name::Symbol,\n          constraint_infos,\n          param_reference,\n          var_key::VariableKey)\n\nConstructs a parameterized upper bound constraint to implement feedforward from other models. The Parameters are initialized using the uppper boundary values of the provided variables.\n\nvariable[var_name, t] <= param_reference[var_name]\n\nLaTeX\n\nx leq param^max\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\ncons_name::Symbol : name of the constraint\nparam_reference : Reference to the PJ.ParameterRef used to determine the upperbound\nvar_key::VariableKey : the name of the continuous variable\n\nadd_feedforward_constraints!(container, _, devices, ff)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/feedforward/feedforward_constraints.jl:213.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_linear_ramp_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, Type{<:PowerSimulations.ConstraintType}, Type{S}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{<:PowerModels.AbstractPowerModel}}} where {S<:Union{ActivePowerVariable, PowerAboveMinimumVariable}, V<:Component, W<:PowerSimulations.AbstractDeviceFormulation}","page":"API Reference","title":"PowerSimulations.add_linear_ramp_constraints!","text":"Constructs allowed rate-of-change constraints from variables, initial condtions, and rate data.\n\nIf t = 1:\n\nvariable[name, 1] - initial_conditions[ix].value <= rate_data[1][ix].up\n\ninitial_conditions[ix].value - variable[name, 1] <= rate_data[1][ix].down\n\nIf t > 1:\n\nvariable[name, t] - variable[name, t-1] <= rate_data[1][ix].up\n\nvariable[name, t-1] - variable[name, t] <= rate_data[1][ix].down\n\nLaTeX\n\nr^down leq x_1 - x_init leq r^up text for  t = 1\n\nr^down leq x_t - x_t-1 leq r^up forall t geq 2\n\nadd_linear_ramp_constraints!(\n    container,\n    T,\n    U,\n    devices,\n    model,\n    X\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/rateofchange_constraints.jl:59.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_range_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {T<:PowerSimulations.ConstraintType, U<:PowerSimulations.VariableType, V<:Component, W<:PowerSimulations.AbstractDeviceFormulation, X<:PowerModels.AbstractPowerModel}","page":"API Reference","title":"PowerSimulations.add_range_constraints!","text":"Constructs min/max range constraint from device variable.\n\nIf min and max within an epsilon width:\n\nvariable[name, t] == limits.max\n\nOtherwise:\n\nlimits.min <= variable[name, t] <= limits.max\n\nwhere limits in constraint_infos.\n\nLaTeX\n\nx = limits^max text for  limits^max - limits^min  varepsilon\n\nlimits^min leq x leq limits^max text otherwise \n\nadd_range_constraints!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:40.\n\nadd_range_constraints!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:60.\n\nadd_range_constraints!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:79.\n\nadd_range_constraints!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:98.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_reserve_range_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {T<:InputActivePowerVariableLimitsConstraint, U<:PowerSimulations.VariableType, V<:Component, W<:PowerSimulations.AbstractDeviceFormulation, X<:PowerModels.AbstractPowerModel}","page":"API Reference","title":"PowerSimulations.add_reserve_range_constraints!","text":"add_reserve_range_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:InputActivePowerVariableLimitsConstraint},\n    _::Type{U<:PowerSimulations.VariableType},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:Component},\n    model::DeviceModel{V<:Component, W<:PowerSimulations.AbstractDeviceFormulation},\n    _::Type{X<:PowerModels.AbstractPowerModel}\n)\n\n\nConstructs min/max range constraint from device variable and reservation decision variable.\n\nvarcts[name, t] <= limits.max * (1 - varbin[name, t])\n\nvarcts[name, t] >= limits.min * (1 - varbin[name, t])\n\nwhere limits in constraint_infos.\n\nLaTeX\n\n0 leq x^cts leq limits^max (1 - x^bin) text for  limits^min = 0\n\nlimits^min (1 - x^bin) leq x^cts leq limits^max (1 - x^bin) text otherwise \n\nadd_reserve_range_constraints!(\n    container,\n    _,\n    _,\n    devices,\n    model,\n    _\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:347.\n\nadd_reserve_range_constraints!(\n    container,\n    _,\n    _,\n    devices,\n    model,\n    _\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:367.\n\nadd_reserve_range_constraints!(\n    container,\n    _,\n    _,\n    devices,\n    model,\n    _\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:470.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_reserve_range_constraints!-Union{Tuple{Y}, Tuple{X}, Tuple{W}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{W}, DeviceModel{W, X}, Type{Y}}} where {T<:Union{OutputActivePowerVariableLimitsConstraint, ReactivePowerVariableLimitsConstraint}, U<:PowerSimulations.ExpressionType, W<:Component, X<:PowerSimulations.AbstractDeviceFormulation, Y<:PowerModels.AbstractPowerModel}","page":"API Reference","title":"PowerSimulations.add_reserve_range_constraints!","text":"add_reserve_range_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:Union{OutputActivePowerVariableLimitsConstraint, ReactivePowerVariableLimitsConstraint}},\n    _::Type{U<:PowerSimulations.ExpressionType},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{W<:Component},\n    model::DeviceModel{W<:Component, X<:PowerSimulations.AbstractDeviceFormulation},\n    _::Type{Y<:PowerModels.AbstractPowerModel}\n)\n\n\nConstructs min/max range constraint from device variable and reservation decision variable.\n\nvarcts[name, t] <= limits.max * varbin[name, t]\n\nvarcts[name, t] >= limits.min * varbin[name, t]\n\nwhere limits in constraint_infos.\n\nLaTeX\n\nlimits^min x^bin leq x^cts leq limits^max x^bin\n\nadd_reserve_range_constraints!(\n    container,\n    _,\n    _,\n    devices,\n    model,\n    _\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:367.\n\nadd_reserve_range_constraints!(\n    container,\n    _,\n    _,\n    devices,\n    model,\n    _\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:470.\n\nadd_reserve_range_constraints!(\n    container,\n    _,\n    _,\n    devices,\n    model,\n    _\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:506.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_reserve_range_constraints!-Union{Tuple{Y}, Tuple{X}, Tuple{W}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{W}, DeviceModel{W, X}, Type{Y}}} where {T<:Union{OutputActivePowerVariableLimitsConstraint, ReactivePowerVariableLimitsConstraint}, U<:PowerSimulations.VariableType, W<:Component, X<:PowerSimulations.AbstractDeviceFormulation, Y<:PowerModels.AbstractPowerModel}","page":"API Reference","title":"PowerSimulations.add_reserve_range_constraints!","text":"add_reserve_range_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:Union{OutputActivePowerVariableLimitsConstraint, ReactivePowerVariableLimitsConstraint}},\n    _::Type{U<:PowerSimulations.VariableType},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{W<:Component},\n    model::DeviceModel{W<:Component, X<:PowerSimulations.AbstractDeviceFormulation},\n    _::Type{Y<:PowerModels.AbstractPowerModel}\n)\n\n\nConstructs min/max range constraint from device variable and reservation decision variable.\n\nvarcts[name, t] <= limits.max * varbin[name, t]\n\nvarcts[name, t] >= limits.min * varbin[name, t]\n\nwhere limits in constraint_infos.\n\nLaTeX\n\nlimits^min x^bin leq x^cts leq limits^max x^bin\n\nadd_reserve_range_constraints!(\n    container,\n    _,\n    _,\n    devices,\n    model,\n    _\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:347.\n\nadd_reserve_range_constraints!(\n    container,\n    _,\n    _,\n    devices,\n    model,\n    _\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:470.\n\nadd_reserve_range_constraints!(\n    container,\n    _,\n    _,\n    devices,\n    model,\n    _\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:506.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_result!-Tuple{PowerSimulations.OptimizationOutputCache, Any, Any, Any}","page":"API Reference","title":"PowerSimulations.add_result!","text":"add_result!(\n    cache::PowerSimulations.OptimizationOutputCache,\n    timestamp,\n    array,\n    system_cache_is_full\n) -> Int64\n\n\nAdd result to the cache.\n\nadd_result!(cache, timestamp, array, system_cache_is_full)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/optimization_output_cache.jl:55.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_semicontinuous_ramp_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, Type{<:PowerSimulations.ConstraintType}, Type{S}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{<:PowerModels.AbstractPowerModel}}} where {S<:Union{ActivePowerVariable, PowerAboveMinimumVariable}, V<:Component, W<:PowerSimulations.AbstractDeviceFormulation}","page":"API Reference","title":"PowerSimulations.add_semicontinuous_ramp_constraints!","text":"add_semicontinuous_ramp_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    T::Type{<:PowerSimulations.ConstraintType},\n    U::Type{S<:Union{ActivePowerVariable, PowerAboveMinimumVariable}},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:Component},\n    model::DeviceModel{V<:Component, W<:PowerSimulations.AbstractDeviceFormulation},\n    X::Type{<:PowerModels.AbstractPowerModel}\n)\n\n\nConstructs allowed rate-of-change constraints from variables, initial condtions, start/stop status, and rate data\n\nEquations\n\nIf t = 1:\n\nvariable[name, 1] - initial_conditions[ix].value <= rate_data[1][ix].up + rate_data[2][ix].max*varstart[name, 1]\n\ninitial_conditions[ix].value - variable[name, 1] <= rate_data[1][ix].down + rate_data[2][ix].min*varstop[name, 1]\n\nIf t > 1:\n\nvariable[name, t] - variable[name, t-1] <= rate_data[1][ix].up + rate_data[2][ix].max*varstart[name, t]\n\nvariable[name, t-1] - variable[name, t] <= rate_data[1][ix].down + rate_data[2][ix].min*varstop[name, t]\n\nLaTeX\n\nr^down + r^min x^stop_1 leq x_1 - x_init leq r^up + r^max x^start_1 text for  t = 1\n\nr^down + r^min x^stop_t leq x_t - x_t-1 leq r^up + r^max x^start_t forall t geq 2\n\nadd_semicontinuous_ramp_constraints!(\n    container,\n    T,\n    U,\n    devices,\n    model,\n    X\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/rateofchange_constraints.jl:193.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_semicontinuous_range_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {T<:PowerSimulations.ConstraintType, U<:PowerSimulations.VariableType, V<:Component, W<:PowerSimulations.AbstractDeviceFormulation, X<:PowerModels.AbstractPowerModel}","page":"API Reference","title":"PowerSimulations.add_semicontinuous_range_constraints!","text":"add_semicontinuous_range_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:PowerSimulations.ConstraintType},\n    _::Type{U<:PowerSimulations.VariableType},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:Component},\n    model::DeviceModel{V<:Component, W<:PowerSimulations.AbstractDeviceFormulation},\n    _::Type{X<:PowerModels.AbstractPowerModel}\n)\n\n\nConstructs min/max range constraint from device variable and on/off decision variable.\n\nIf device min = 0:\n\nvarcts[name, t] <= limits.max*varbin[name, t])\n\nvarcts[name, t] >= 0.0\n\nOtherwise:\n\nvarcts[name, t] <= limits.max*varbin[name, t]\n\nvarcts[name, t] >= limits.min*varbin[name, t]\n\nwhere limits in constraint_infos.\n\nLaTeX\n\n0 leq x^cts leq limits^max x^bin text for  limits^min = 0\n\nlimits^min x^bin leq x^cts leq limits^max x^bin text otherwise \n\nadd_semicontinuous_range_constraints!(\n    container,\n    _,\n    _,\n    devices,\n    model,\n    _\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:194.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {T<:ActivePowerBalance, U<:FlowActivePowerVariable, V<:Branch, W<:PowerSimulations.AbstractBranchFormulation, X<:PowerModels.AbstractActivePowerModel}","page":"API Reference","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:ActivePowerBalance},\n    _::Type{U<:FlowActivePowerVariable},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:Branch},\n    _::DeviceModel{V<:Branch, W<:PowerSimulations.AbstractBranchFormulation},\n    _::Type{X<:PowerModels.AbstractActivePowerModel}\n)\n\n\nImplementation of addtoexpression! for lossless branch/network models\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:111.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:139.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:199.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:230.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:257.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:287.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:314.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:344.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:375.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:405.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:439.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:476.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:509.\n\nadd_to_expression!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:537.\n\nadd_to_expression!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:563.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {T<:ActivePowerBalance, U<:PowerSimulations.VariableType, V<:StaticInjection, W<:PowerSimulations.AbstractDeviceFormulation, X<:CopperPlatePowerModel}","page":"API Reference","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:ActivePowerBalance},\n    _::Type{U<:PowerSimulations.VariableType},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:StaticInjection},\n    _::DeviceModel{V<:StaticInjection, W<:PowerSimulations.AbstractDeviceFormulation},\n    _::Type{X<:CopperPlatePowerModel}\n)\n\n\nDefault implementation to add variables to SystemBalanceExpressions\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:111.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:139.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:199.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:230.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:257.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:287.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:314.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:344.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:375.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:405.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:439.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:476.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:509.\n\nadd_to_expression!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:537.\n\nadd_to_expression!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:563.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {T<:ActivePowerBalance, U<:PowerSimulations.VariableType, V<:StaticInjection, W<:PowerSimulations.AbstractDeviceFormulation, X<:Union{PTDFPowerModel, StandardPTDFModel}}","page":"API Reference","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:ActivePowerBalance},\n    _::Type{U<:PowerSimulations.VariableType},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:StaticInjection},\n    _::DeviceModel{V<:StaticInjection, W<:PowerSimulations.AbstractDeviceFormulation},\n    _::Type{X<:Union{PTDFPowerModel, StandardPTDFModel}}\n)\n\n\nDefault implementation to add variables to SystemBalanceExpressions\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:111.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:139.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:199.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:230.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:257.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:287.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:314.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:344.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:375.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:405.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:439.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:476.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:509.\n\nadd_to_expression!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:537.\n\nadd_to_expression!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:563.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {T<:SystemBalanceExpressions, U<:PowerSimulations.TimeSeriesParameter, V<:Device, W<:PowerSimulations.AbstractDeviceFormulation, X<:PowerModels.AbstractPowerModel}","page":"API Reference","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:SystemBalanceExpressions},\n    _::Type{U<:PowerSimulations.TimeSeriesParameter},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:Device},\n    _::DeviceModel{V<:Device, W<:PowerSimulations.AbstractDeviceFormulation},\n    _::Type{X<:PowerModels.AbstractPowerModel}\n)\n\n\nDefault implementation to add parameters to SystemBalanceExpressions\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:111.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:139.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:171.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:199.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:230.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:257.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:287.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:314.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:344.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:375.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:405.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:439.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:476.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:509.\n\nadd_to_expression!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:537.\n\nadd_to_expression!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:563.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {T<:SystemBalanceExpressions, U<:PowerSimulations.TimeSeriesParameter, V<:StaticInjection, W<:PowerSimulations.AbstractDeviceFormulation, X<:CopperPlatePowerModel}","page":"API Reference","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:SystemBalanceExpressions},\n    _::Type{U<:PowerSimulations.TimeSeriesParameter},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:StaticInjection},\n    _::DeviceModel{V<:StaticInjection, W<:PowerSimulations.AbstractDeviceFormulation},\n    _::Type{X<:CopperPlatePowerModel}\n)\n\n\nDefault implementation to add parameters to SystemBalanceExpressions\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:139.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:171.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:199.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:230.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:257.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:287.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:314.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:344.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:375.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:405.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:439.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:476.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:509.\n\nadd_to_expression!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:537.\n\nadd_to_expression!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:563.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {T<:SystemBalanceExpressions, U<:PowerSimulations.TimeSeriesParameter, V<:StaticInjection, W<:PowerSimulations.AbstractDeviceFormulation, X<:Union{PTDFPowerModel, StandardPTDFModel}}","page":"API Reference","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:SystemBalanceExpressions},\n    _::Type{U<:PowerSimulations.TimeSeriesParameter},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:StaticInjection},\n    _::DeviceModel{V<:StaticInjection, W<:PowerSimulations.AbstractDeviceFormulation},\n    _::Type{X<:Union{PTDFPowerModel, StandardPTDFModel}}\n)\n\n\nDefault implementation to add parameters to SystemBalanceExpressions\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:139.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:171.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:199.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:230.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:257.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:287.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:314.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:344.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:375.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:405.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:439.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:476.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:509.\n\nadd_to_expression!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:537.\n\nadd_to_expression!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:563.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {T<:SystemBalanceExpressions, U<:PowerSimulations.VariableType, V<:Device, W<:PowerSimulations.AbstractDeviceFormulation, X<:PowerModels.AbstractPowerModel}","page":"API Reference","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:SystemBalanceExpressions},\n    _::Type{U<:PowerSimulations.VariableType},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:Device},\n    _::DeviceModel{V<:Device, W<:PowerSimulations.AbstractDeviceFormulation},\n    _::Type{X<:PowerModels.AbstractPowerModel}\n)\n\n\nDefault implementation to add variables to SystemBalanceExpressions\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:111.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:139.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:171.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:199.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:230.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:257.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:287.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:314.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:344.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:375.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:405.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:439.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:476.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:509.\n\nadd_to_expression!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:537.\n\nadd_to_expression!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:563.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_variable!-Union{Tuple{U}, Tuple{D}, Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AuxVariableType, U, Any}} where {D<:Component, U<:Union{InfrastructureSystems.FlattenIteratorWrapper{D}, Vector{D}}}","page":"API Reference","title":"PowerSimulations.add_variable!","text":"add_variable!(\n    container::PowerSimulations.OptimizationContainer,\n    var_type::PowerSimulations.AuxVariableType,\n    devices::Union{Array{D<:Component, 1}, InfrastructureSystems.FlattenIteratorWrapper{D<:Component}},\n    formulation\n)\n\n\nDefault implementation of adding auxiliary variable to the model.\n\nadd_variable!(container, var_type, devices, formulation)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_auxiliary_variable.jl:17.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_variable!-Union{Tuple{U}, Tuple{T}, Tuple{D}, Tuple{PowerSimulations.OptimizationContainer, T, U, Any}} where {D<:Component, T<:PowerSimulations.VariableType, U<:Union{InfrastructureSystems.FlattenIteratorWrapper{D}, Vector{D}}}","page":"API Reference","title":"PowerSimulations.add_variable!","text":"add_variable!(\n    container::PowerSimulations.OptimizationContainer,\n    variable_type::PowerSimulations.VariableType,\n    devices::Union{Array{D<:Component, 1}, InfrastructureSystems.FlattenIteratorWrapper{D<:Component}},\n    formulation\n)\n\n\nAdds a variable to the optimization model and to the affine expressions contained in the optimization_container model according to the specified sign. Based on the inputs, the variable can be specified as binary.\n\nBounds\n\nlb_value_function <= varstart[name, t] <= ub_value_function\n\nIf binary = true:\n\nvarstart[name, t] in {0,1}\n\nLaTeX\n\nlb ge x^device_t le ub forall t\n\nx^device_t in 01 forall t iff textbinary = true\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\ndevices : Vector or Iterator with the devices\nvar_key::VariableKey : Base Name for the variable\nbinary::Bool : Select if the variable is binary\nexpressionname::Symbol : Expressionname name stored in container.expressions to add the variable\nsign::Float64 : sign of the addition of the variable to the expression_name. Default Value is 1.0\n\nAccepted Keyword Arguments\n\nubvalue : Provides the function over device to obtain the value for a upperbound\nlbvalue : Provides the function over device to obtain the value for a lowerbound. If the variable is meant to be positive define lb = x -> 0.0\ninitial_value : Provides the function over device to obtain the warm start value\n\nadd_variable!(\n    container,\n    variable_type,\n    devices,\n    formulation\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_variable.jl:83.\n\nadd_variable!(\n    container,\n    variable_type,\n    devices,\n    formulation\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_variable.jl:173.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_variables!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}}} where T<:SteadyStateFrequencyDeviation","page":"API Reference","title":"PowerSimulations.add_variables!","text":"add_variables!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:SteadyStateFrequencyDeviation}\n)\n\n\nSteady State deviation of the frequency\n\nadd_variables!(container, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/services_models/agc.jl:51.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_variables!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Union{InfrastructureSystems.FlattenIteratorWrapper{U}, Vector{U}}, PowerSimulations.AbstractDeviceFormulation}} where {T<:PowerSimulations.SubComponentVariableType, U<:Component}","page":"API Reference","title":"PowerSimulations.add_variables!","text":"add_variables!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:PowerSimulations.SubComponentVariableType},\n    devices::Union{Array{U<:Component, 1}, InfrastructureSystems.FlattenIteratorWrapper{U<:Component}},\n    formulation::PowerSimulations.AbstractDeviceFormulation\n)\n\n\nAdd variables to the OptimizationContainer for a Sub-Component of a hybrid systems.\n\nadd_variables!(container, _, devices, formulation)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_auxiliary_variable.jl:4.\n\nadd_variables!(container, _, devices, formulation)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_variable.jl:31.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_variables!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Union{InfrastructureSystems.FlattenIteratorWrapper{U}, Vector{U}}, Union{PowerSimulations.AbstractDeviceFormulation, PowerSimulations.AbstractServiceFormulation}}} where {T<:PowerSimulations.AuxVariableType, U<:Component}","page":"API Reference","title":"PowerSimulations.add_variables!","text":"add_variables!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:PowerSimulations.AuxVariableType},\n    devices::Union{Array{U<:Component, 1}, InfrastructureSystems.FlattenIteratorWrapper{U<:Component}},\n    formulation::Union{PowerSimulations.AbstractDeviceFormulation, PowerSimulations.AbstractServiceFormulation}\n)\n\n\nAdd variables to the OptimizationContainer for any component.\n\nadd_variables!(container, _, devices, formulation)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_auxiliary_variable.jl:4.\n\nadd_variables!(container, _, devices, formulation)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_variable.jl:4.\n\nadd_variables!(container, _, devices, formulation)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_variable.jl:31.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_variables!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Union{InfrastructureSystems.FlattenIteratorWrapper{U}, Vector{U}}, Union{PowerSimulations.AbstractDeviceFormulation, PowerSimulations.AbstractServiceFormulation}}} where {T<:PowerSimulations.VariableType, U<:Component}","page":"API Reference","title":"PowerSimulations.add_variables!","text":"add_variables!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:PowerSimulations.VariableType},\n    devices::Union{Array{U<:Component, 1}, InfrastructureSystems.FlattenIteratorWrapper{U<:Component}},\n    formulation::Union{PowerSimulations.AbstractDeviceFormulation, PowerSimulations.AbstractServiceFormulation}\n)\n\n\nAdd variables to the OptimizationContainer for any component.\n\nadd_variables!(container, _, devices, formulation)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_auxiliary_variable.jl:4.\n\nadd_variables!(container, _, devices, formulation)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_variable.jl:4.\n\nadd_variables!(container, _, devices, formulation)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_variable.jl:31.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_variables!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, U, Union{InfrastructureSystems.FlattenIteratorWrapper{V}, Vector{V}}, PowerSimulations.AbstractReservesFormulation}} where {T<:PowerSimulations.VariableType, U<:AbstractReserve, V<:Component}","page":"API Reference","title":"PowerSimulations.add_variables!","text":"add_variables!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:PowerSimulations.VariableType},\n    service::AbstractReserve,\n    contributing_devices::Union{Array{V<:Component, 1}, InfrastructureSystems.FlattenIteratorWrapper{V<:Component}},\n    formulation::PowerSimulations.AbstractReservesFormulation\n)\n\n\nAdd variables to the OptimizationContainer for a service.\n\nadd_variables!(\n    container,\n    _,\n    service,\n    contributing_devices,\n    formulation\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_variable.jl:17.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.axis_array_to_dataframe-Tuple{JuMP.Containers.DenseAxisArray, PowerSimulations.OptimizationContainerKey}","page":"API Reference","title":"PowerSimulations.axis_array_to_dataframe","text":"axis_array_to_dataframe(\n    array::JuMP.Containers.DenseAxisArray,\n    key::PowerSimulations.OptimizationContainerKey\n) -> Any\n\n\nCreates a DataFrame from a JuMP DenseAxisArray or SparseAxisArray.\n\nArguments\n\narray: JuMP DenseAxisArray or SparseAxisArray to convert\nkey::OptimizationContainerKey:\n\naxis_array_to_dataframe(array, key)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/dataframes_utils.jl:10.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.branch_flow_constraints!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, U}, Type{<:PowerModels.AbstractDCPModel}}} where {T<:MonitoredLine, U<:PowerSimulations.AbstractBranchFormulation}","page":"API Reference","title":"PowerSimulations.branch_flow_constraints!","text":"branch_flow_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    devices::InfrastructureSystems.FlattenIteratorWrapper{T<:MonitoredLine},\n    model::DeviceModel{T<:MonitoredLine, U<:PowerSimulations.AbstractBranchFormulation},\n    X::Type{<:PowerModels.AbstractDCPModel}\n)\n\n\nAdd branch flow constraints for monitored lines with DC Power Model\n\nbranch_flow_constraints!(container, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:259.\n\nbranch_flow_constraints!(container, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:279.\n\nbranch_flow_constraints!(container, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:357.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.branch_flow_constraints!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, U}, Type{<:PowerModels.AbstractDCPModel}}} where {T<:MonitoredLine, U<:StaticBranchUnbounded}","page":"API Reference","title":"PowerSimulations.branch_flow_constraints!","text":"branch_flow_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    devices::InfrastructureSystems.FlattenIteratorWrapper{T<:MonitoredLine},\n    model::DeviceModel{T<:MonitoredLine, U<:StaticBranchUnbounded},\n    _::Type{<:PowerModels.AbstractDCPModel}\n)\n\n\nDon't add branch flow constraints for monitored lines if formulation is StaticBranchUnbounded\n\nbranch_flow_constraints!(container, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:279.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.branch_flow_constraints!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, U}, Type{<:PowerModels.AbstractPowerModel}}} where {T<:MonitoredLine, U<:PowerSimulations.AbstractBranchFormulation}","page":"API Reference","title":"PowerSimulations.branch_flow_constraints!","text":"branch_flow_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    devices::InfrastructureSystems.FlattenIteratorWrapper{T<:MonitoredLine},\n    model::DeviceModel{T<:MonitoredLine, U<:PowerSimulations.AbstractBranchFormulation},\n    _::Type{<:PowerModels.AbstractPowerModel}\n)\n\n\nAdd branch flow constraints for monitored lines\n\nbranch_flow_constraints!(container, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:259.\n\nbranch_flow_constraints!(container, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:279.\n\nbranch_flow_constraints!(container, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:329.\n\nbranch_flow_constraints!(container, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:357.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.branch_flow_constraints!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, U}, Type{<:PowerModels.AbstractPowerModel}}} where {T<:MonitoredLine, U<:StaticBranchUnbounded}","page":"API Reference","title":"PowerSimulations.branch_flow_constraints!","text":"branch_flow_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    devices::InfrastructureSystems.FlattenIteratorWrapper{T<:MonitoredLine},\n    model::DeviceModel{T<:MonitoredLine, U<:StaticBranchUnbounded},\n    _::Type{<:PowerModels.AbstractPowerModel}\n)\n\n\nDon't add branch flow constraints for monitored lines if formulation is StaticBranchUnbounded\n\nbranch_flow_constraints!(container, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:259.\n\nbranch_flow_constraints!(container, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:279.\n\nbranch_flow_constraints!(container, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:357.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.build_model!-Tuple{DecisionModel}","page":"API Reference","title":"PowerSimulations.build_model!","text":"build_model!(model::DecisionModel)\n\n\nDefault implementation of build method for Operational Problems for models conforming with DecisionProblem specification. Overload this function to implement a custom build method\n\nbuild_model!(model)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/decision_model.jl:326.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.build_model!-Tuple{EmulationModel}","page":"API Reference","title":"PowerSimulations.build_model!","text":"build_model!(model::EmulationModel)\n\n\nDefault implementation of build method for Emulation Problems for models conforming with  DecisionProblem specification. Overload this function to implement a custom build method\n\nbuild_model!(model)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/emulation_model.jl:312.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.check_activeservice_variables-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Vector{T}}} where T<:Service","page":"API Reference","title":"PowerSimulations.check_activeservice_variables","text":"check_activeservice_variables(\n    container::PowerSimulations.OptimizationContainer,\n    contributing_services::Array{T<:Service, 1}\n)\n\n\nThis function checks if the variables for reserves were created\n\ncheck_activeservice_variables(\n    container,\n    contributing_services\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/services_models/group_reserve.jl:6.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.check_file_integrity-Tuple{String}","page":"API Reference","title":"PowerSimulations.check_file_integrity","text":"check_file_integrity(path::String)\n\n\ncheck_file_integrity(path::String)\n\nChecks the hash value for each file made with the file is written with the new hash_value to verify the file hasn't been tampered with since written\n\nArguments\n\npath::String: this is the folder path that contains the results and the check.sha256 file\n\ncheck_file_integrity(path)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/file_utils.jl:78.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.compute_sha256-Tuple{AbstractString}","page":"API Reference","title":"PowerSimulations.compute_sha256","text":"compute_sha256(filename::AbstractString) -> String\n\n\nReturn the SHA 256 hash of a file.\n\ncompute_sha256(filename)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/file_utils.jl:22.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{H, D}, Type{S}}} where {H<:HydroGen, D<:HydroCommitmentReservoirBudget, S<:PowerModels.AbstractActivePowerModel}","page":"API Reference","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::PowerSimulations.ArgumentConstructStage,\n    model::DeviceModel{H<:HydroGen, D<:HydroCommitmentReservoirBudget},\n    _::Type{S<:PowerModels.AbstractActivePowerModel}\n)\n\n\nConstruct model for HydroGen with ReservoirBudget Commitment Formulation with only Active Power.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:74.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:182.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:707.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:809.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:1002.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{H, D}, Type{S}}} where {H<:HydroGen, D<:HydroCommitmentReservoirBudget, S<:PowerModels.AbstractPowerModel}","page":"API Reference","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::PowerSimulations.ArgumentConstructStage,\n    model::DeviceModel{H<:HydroGen, D<:HydroCommitmentReservoirBudget},\n    _::Type{S<:PowerModels.AbstractPowerModel}\n)\n\n\nConstruct model for HydroGen with ReservoirBudget Commitment Formulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hybridgeneration_constructor.jl:156.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hybridgeneration_constructor.jl:485.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:74.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:182.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:707.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:809.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:899.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:1002.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/load_constructor.jl:1.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/load_constructor.jl:328.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/renewablegeneration_constructor.jl:1.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/storage_constructor.jl:1.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:36.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:636.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{H, D}, Type{S}}} where {H<:HydroGen, D<:HydroCommitmentRunOfRiver, S<:PowerModels.AbstractActivePowerModel}","page":"API Reference","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::PowerSimulations.ArgumentConstructStage,\n    model::DeviceModel{H<:HydroGen, D<:HydroCommitmentRunOfRiver},\n    _::Type{S<:PowerModels.AbstractActivePowerModel}\n)\n\n\nConstruct model for HydroGen with RunOfRiver Commitment Formulation with only Active Power.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:74.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:182.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:809.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:899.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:1002.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{H, D}, Type{S}}} where {H<:HydroGen, D<:HydroCommitmentRunOfRiver, S<:PowerModels.AbstractPowerModel}","page":"API Reference","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::PowerSimulations.ArgumentConstructStage,\n    model::DeviceModel{H<:HydroGen, D<:HydroCommitmentRunOfRiver},\n    _::Type{S<:PowerModels.AbstractPowerModel}\n)\n\n\nConstruct model for HydroGen with RunOfRiver Commitment Formulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hybridgeneration_constructor.jl:156.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hybridgeneration_constructor.jl:485.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:74.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:182.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:707.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:809.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:899.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:1002.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/load_constructor.jl:1.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/load_constructor.jl:328.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/renewablegeneration_constructor.jl:1.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/storage_constructor.jl:1.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:36.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:636.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{H, D}, Type{S}}} where {H<:HydroGen, D<:PowerSimulations.AbstractHydroDispatchFormulation, S<:PowerModels.AbstractActivePowerModel}","page":"API Reference","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::PowerSimulations.ArgumentConstructStage,\n    model::DeviceModel{H<:HydroGen, D<:PowerSimulations.AbstractHydroDispatchFormulation},\n    _::Type{S<:PowerModels.AbstractActivePowerModel}\n)\n\n\nConstruct model for HydroGen with RunOfRiver Dispatch Formulation with only Active Power.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:182.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:378.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:595.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:707.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:809.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:899.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:1002.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:1353.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{H, D}, Type{S}}} where {H<:HydroGen, D<:PowerSimulations.AbstractHydroDispatchFormulation, S<:PowerModels.AbstractPowerModel}","page":"API Reference","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::PowerSimulations.ArgumentConstructStage,\n    model::DeviceModel{H<:HydroGen, D<:PowerSimulations.AbstractHydroDispatchFormulation},\n    _::Type{S<:PowerModels.AbstractPowerModel}\n)\n\n\nConstruct model for HydroGen with RunOfRiver Dispatch Formulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hybridgeneration_constructor.jl:156.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hybridgeneration_constructor.jl:485.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:74.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:182.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:271.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:378.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:462.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:595.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:707.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:809.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:899.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:1002.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:1353.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/load_constructor.jl:1.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/load_constructor.jl:328.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/renewablegeneration_constructor.jl:1.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/storage_constructor.jl:1.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:36.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:636.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{T, D}, Type{S}}} where {T<:ThermalGen, D<:PowerSimulations.AbstractStandardUnitCommitment, S<:PowerModels.AbstractActivePowerModel}","page":"API Reference","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::PowerSimulations.ArgumentConstructStage,\n    model::DeviceModel{T<:ThermalGen, D<:PowerSimulations.AbstractStandardUnitCommitment},\n    _::Type{S<:PowerModels.AbstractActivePowerModel}\n)\n\n\nThis function creates the arguments model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:153.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:361.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:636.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:738.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{T, D}, Type{S}}} where {T<:ThermalGen, D<:PowerSimulations.AbstractStandardUnitCommitment, S<:PowerModels.AbstractPowerModel}","page":"API Reference","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::PowerSimulations.ArgumentConstructStage,\n    model::DeviceModel{T<:ThermalGen, D<:PowerSimulations.AbstractStandardUnitCommitment},\n    _::Type{S<:PowerModels.AbstractPowerModel}\n)\n\n\nThis function creates the arguments for the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hybridgeneration_constructor.jl:156.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hybridgeneration_constructor.jl:485.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:74.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:707.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:899.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/load_constructor.jl:1.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/load_constructor.jl:328.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/renewablegeneration_constructor.jl:1.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/storage_constructor.jl:1.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:36.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:153.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:255.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:361.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:636.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:738.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ModelConstructStage, DeviceModel{T, D}, Type{S}}} where {T<:ThermalGen, D<:PowerSimulations.AbstractStandardUnitCommitment, S<:PowerModels.AbstractActivePowerModel}","page":"API Reference","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::PowerSimulations.ModelConstructStage,\n    model::DeviceModel{T<:ThermalGen, D<:PowerSimulations.AbstractStandardUnitCommitment},\n    _::Type{S<:PowerModels.AbstractActivePowerModel}\n)\n\n\nThis function creates the constraints for the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:211.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:412.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:692.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:785.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ModelConstructStage, DeviceModel{T, D}, Type{S}}} where {T<:ThermalGen, D<:PowerSimulations.AbstractStandardUnitCommitment, S<:PowerModels.AbstractPowerModel}","page":"API Reference","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::PowerSimulations.ModelConstructStage,\n    model::DeviceModel{T<:ThermalGen, D<:PowerSimulations.AbstractStandardUnitCommitment},\n    _::Type{S<:PowerModels.AbstractPowerModel}\n)\n\n\nThis function creates the constraints for the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hybridgeneration_constructor.jl:243.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hybridgeneration_constructor.jl:572.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:132.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:762.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:953.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/load_constructor.jl:42.\n\nconstruct_device!(container, sys, ccs, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/load_constructor.jl:388.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/renewablegeneration_constructor.jl:58.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/storage_constructor.jl:48.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:102.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:211.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:315.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:412.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:692.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:785.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{H, FixedOutput}, Type{S}}} where {H<:HydroGen, S<:PowerModels.AbstractPowerModel}","page":"API Reference","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::PowerSimulations.ArgumentConstructStage,\n    model::DeviceModel{H<:HydroGen, FixedOutput},\n    _::Type{S<:PowerModels.AbstractPowerModel}\n)\n\n\nConstruct model for HydroGen with FixedOutput Formulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:4.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:48.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/renewablegeneration_constructor.jl:196.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{H, HydroCommitmentReservoirStorage}, Type{S}}} where {H<:HydroEnergyReservoir, S<:PowerModels.AbstractActivePowerModel}","page":"API Reference","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::PowerSimulations.ArgumentConstructStage,\n    model::DeviceModel{H<:HydroEnergyReservoir, HydroCommitmentReservoirStorage},\n    _::Type{S<:PowerModels.AbstractActivePowerModel}\n)\n\n\nConstruct model for HydroGen with ReservoirStorage Dispatch Formulation with only Active Power\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:1235.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{H, HydroCommitmentReservoirStorage}, Type{S}}} where {H<:HydroEnergyReservoir, S<:PowerModels.AbstractPowerModel}","page":"API Reference","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::PowerSimulations.ArgumentConstructStage,\n    model::DeviceModel{H<:HydroEnergyReservoir, HydroCommitmentReservoirStorage},\n    _::Type{S<:PowerModels.AbstractPowerModel}\n)\n\n\nConstruct model for HydroGen with ReservoirStorage Commitment Formulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:1095.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:1235.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{H, HydroDispatchPumpedStorage}, Type{S}}} where {H<:HydroPumpedStorage, S<:PowerModels.AbstractActivePowerModel}","page":"API Reference","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::PowerSimulations.ArgumentConstructStage,\n    model::DeviceModel{H<:HydroPumpedStorage, HydroDispatchPumpedStorage},\n    _::Type{S<:PowerModels.AbstractActivePowerModel}\n)\n\n\nConstruct model for HydroPumpedStorage with PumpedStorage Dispatch Formulation with only Active Power\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:1353.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{H, HydroDispatchReservoirBudget}, Type{S}}} where {H<:HydroEnergyReservoir, S<:PowerModels.AbstractActivePowerModel}","page":"API Reference","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::PowerSimulations.ArgumentConstructStage,\n    model::DeviceModel{H<:HydroEnergyReservoir, HydroDispatchReservoirBudget},\n    _::Type{S<:PowerModels.AbstractActivePowerModel}\n)\n\n\nConstruct model for HydroGen with ReservoirBudget Dispatch Formulation with only Active Power.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:378.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{H, HydroDispatchReservoirBudget}, Type{S}}} where {H<:HydroEnergyReservoir, S<:PowerModels.AbstractPowerModel}","page":"API Reference","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::PowerSimulations.ArgumentConstructStage,\n    model::DeviceModel{H<:HydroEnergyReservoir, HydroDispatchReservoirBudget},\n    _::Type{S<:PowerModels.AbstractPowerModel}\n)\n\n\nConstruct model for HydroGen with ReservoirBudget Dispatch Formulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:182.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:271.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:378.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{H, HydroDispatchReservoirStorage}, Type{S}}} where {H<:HydroEnergyReservoir, S<:PowerModels.AbstractActivePowerModel}","page":"API Reference","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::PowerSimulations.ArgumentConstructStage,\n    model::DeviceModel{H<:HydroEnergyReservoir, HydroDispatchReservoirStorage},\n    _::Type{S<:PowerModels.AbstractActivePowerModel}\n)\n\n\nConstruct model for HydroGen with ReservoirStorage Dispatch Formulation with only Active Power\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:595.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{H, HydroDispatchReservoirStorage}, Type{S}}} where {H<:HydroEnergyReservoir, S<:PowerModels.AbstractPowerModel}","page":"API Reference","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::PowerSimulations.ArgumentConstructStage,\n    model::DeviceModel{H<:HydroEnergyReservoir, HydroDispatchReservoirStorage},\n    _::Type{S<:PowerModels.AbstractPowerModel}\n)\n\n\nConstruct model for HydroGen with ReservoirStorage Dispatch Formulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:182.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:462.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:595.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{T, ThermalBasicUnitCommitment}, Type{S}}} where {T<:ThermalGen, S<:PowerModels.AbstractActivePowerModel}","page":"API Reference","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::PowerSimulations.ArgumentConstructStage,\n    model::DeviceModel{T<:ThermalGen, ThermalBasicUnitCommitment},\n    _::Type{S<:PowerModels.AbstractActivePowerModel}\n)\n\n\nThis function creates the arguments for the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:361.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{T, ThermalBasicUnitCommitment}, Type{S}}} where {T<:ThermalGen, S<:PowerModels.AbstractPowerModel}","page":"API Reference","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::PowerSimulations.ArgumentConstructStage,\n    model::DeviceModel{T<:ThermalGen, ThermalBasicUnitCommitment},\n    _::Type{S<:PowerModels.AbstractPowerModel}\n)\n\n\nThis function creates the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:153.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:255.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:361.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{T, ThermalStandardDispatch}, Type{S}}} where {T<:ThermalGen, S<:PowerModels.AbstractActivePowerModel}","page":"API Reference","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::PowerSimulations.ArgumentConstructStage,\n    model::DeviceModel{T<:ThermalGen, ThermalStandardDispatch},\n    _::Type{S<:PowerModels.AbstractActivePowerModel}\n)\n\n\nThis function creates the arguments for the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:553.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{T, ThermalStandardDispatch}, Type{S}}} where {T<:ThermalGen, S<:PowerModels.AbstractPowerModel}","page":"API Reference","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::PowerSimulations.ArgumentConstructStage,\n    model::DeviceModel{T<:ThermalGen, ThermalStandardDispatch},\n    _::Type{S<:PowerModels.AbstractPowerModel}\n)\n\n\nThis function creates the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:450.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:553.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:738.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ModelConstructStage, DeviceModel{T, ThermalBasicUnitCommitment}, Type{S}}} where {T<:ThermalGen, S<:PowerModels.AbstractActivePowerModel}","page":"API Reference","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::PowerSimulations.ModelConstructStage,\n    model::DeviceModel{T<:ThermalGen, ThermalBasicUnitCommitment},\n    _::Type{S<:PowerModels.AbstractActivePowerModel}\n)\n\n\nThis function creates the constraints for the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:412.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ModelConstructStage, DeviceModel{T, ThermalBasicUnitCommitment}, Type{S}}} where {T<:ThermalGen, S<:PowerModels.AbstractPowerModel}","page":"API Reference","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::PowerSimulations.ModelConstructStage,\n    model::DeviceModel{T<:ThermalGen, ThermalBasicUnitCommitment},\n    _::Type{S<:PowerModels.AbstractPowerModel}\n)\n\n\nThis function creates the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:211.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:315.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:412.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ModelConstructStage, DeviceModel{T, ThermalStandardDispatch}, Type{S}}} where {T<:ThermalGen, S<:PowerModels.AbstractActivePowerModel}","page":"API Reference","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::PowerSimulations.ModelConstructStage,\n    model::DeviceModel{T<:ThermalGen, ThermalStandardDispatch},\n    _::Type{S<:PowerModels.AbstractActivePowerModel}\n)\n\n\nThis function creates the constraints for the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:601.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ModelConstructStage, DeviceModel{T, ThermalStandardDispatch}, Type{S}}} where {T<:ThermalGen, S<:PowerModels.AbstractPowerModel}","page":"API Reference","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::PowerSimulations.ModelConstructStage,\n    model::DeviceModel{T<:ThermalGen, ThermalStandardDispatch},\n    _::Type{S<:PowerModels.AbstractPowerModel}\n)\n\n\nThis function creates the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:507.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:601.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:785.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_service!-Union{Tuple{SR}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, ServiceModel{SR, GroupReserve}, Dict{Symbol, DeviceModel}, Set{<:DataType}}} where SR<:StaticReserveGroup","page":"API Reference","title":"PowerSimulations.construct_service!","text":"construct_service!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::PowerSimulations.ArgumentConstructStage,\n    model::ServiceModel{SR<:StaticReserveGroup, GroupReserve},\n    _::Dict{Symbol, DeviceModel},\n    _::Set{<:DataType}\n)\n\n\nConstructs a service for StaticReserveGroup.\n\nconstruct_service!(container, sys, _, model, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/services_models/services_constructor.jl:394.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.container_spec-Tuple{Type{Float64}, Vararg{Any}}","page":"API Reference","title":"PowerSimulations.container_spec","text":"container_spec(\n    _::Type{Float64},\n    axs...\n) -> JuMP.Containers.DenseAxisArray\n\n\nReturns the correct container specification for the selected type of JuMP Model\n\ncontainer_spec(_, axs)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/jump_utils.jl:156.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.container_spec-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any}}} where T","page":"API Reference","title":"PowerSimulations.container_spec","text":"container_spec(\n    _::Type{T},\n    axs...\n) -> JuMP.Containers.DenseAxisArray\n\n\nReturns the correct container specification for the selected type of JuMP Model\n\ncontainer_spec(_, axs)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/jump_utils.jl:149.\n\ncontainer_spec(_, axs)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/jump_utils.jl:156.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.create_time_series_multiplier_index-Union{Tuple{T}, Tuple{Any, Type{T}}} where T<:PowerSimulations.TimeSeriesParameter","page":"API Reference","title":"PowerSimulations.create_time_series_multiplier_index","text":"create_time_series_multiplier_index(\n    model,\n    _::Type{T<:PowerSimulations.TimeSeriesParameter}\n) -> Union{Nothing, Int64}\n\n\nFunction to create a unique index of time series names for each device model. For example, if two parameters each reference the same time series name, this function will return a different value for each parameter entry\n\ncreate_time_series_multiplier_index(model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/parameters/add_parameters.jl:6.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_duration_compact_retrospective!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Vector{NamedTuple{(:up, :down), Tuple{Float64, Float64}}}, Matrix{InitialCondition}, PowerSimulations.ConstraintType, Tuple{PowerSimulations.VariableType, PowerSimulations.VariableType, PowerSimulations.VariableType}, Type{T}}} where T<:Component","page":"API Reference","title":"PowerSimulations.device_duration_compact_retrospective!","text":"This formulation of the duration constraints adds over the start times looking backwards.\n\nLaTeX\n\nMinimum up-time constraint:\n\nsum_i=t-min(d_min^up T)+ 1^t x_i^start - x_t^on leq 0\n\nfor i in the set of time steps.\n\nMinimum down-time constraint:\n\nsum_i=t-min(d_min^down T) + 1^t x_i^stop + x_t^on leq 1\n\nfor i in the set of time steps.\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nduration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down\ninitial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)\ncons_name::Symbol : name of the constraint\nvar_keys::Tuple{VariableKey, VariableKey, VariableKey}) : names of the variables\n: var_keys[1] : varon\n: var_keys[2] : varstart\n: var_keys[3] : varstop\n\ndevice_duration_compact_retrospective!(\n    container,\n    duration_data,\n    initial_duration,\n    cons_type,\n    var_types,\n    _\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/duration_constraints.jl:363.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_duration_look_ahead!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Vector{NamedTuple{(:up, :down), Tuple{Float64, Float64}}}, Matrix{InitialCondition}, PowerSimulations.ConstraintType, PowerSimulations.ConstraintType, Tuple{PowerSimulations.VariableType, PowerSimulations.VariableType, PowerSimulations.VariableType}, Type{T}}} where T<:Component","page":"API Reference","title":"PowerSimulations.device_duration_look_ahead!","text":"device_duration_look_ahead!(\n    container::PowerSimulations.OptimizationContainer,\n    duration_data::Vector{NamedTuple{(:up, :down), Tuple{Float64, Float64}}},\n    initial_duration::Matrix{InitialCondition},\n    cons_type_up::PowerSimulations.ConstraintType,\n    cons_type_down::PowerSimulations.ConstraintType,\n    var_types::Tuple{PowerSimulations.VariableType, PowerSimulations.VariableType, PowerSimulations.VariableType},\n    _::Type{T<:Component}\n)\n\n\nThis formulation of the duration constraints looks ahead in the time frame of the model.\n\nLaTeX\n\nMinimum up-time constraint:\n\nIf t leq d_min^up\n\nd_min^downx_t^stop - sum_i=t-d_min^up + 1^t x_i^on - x_init^up leq 0\n\nfor i in the set of time steps. Otherwise:\n\nd_min^downx_t^stop - sum_i=t-d_min^up + 1^t x_i^on leq 0\n\nfor i in the set of time steps.\n\nMinimum down-time constraint:\n\nIf t leq d_min^down\n\nd_min^upx_t^start - sum_i=t-d_min^down + 1^t (1 - x_i^on) - x_init^down leq 0\n\nfor i in the set of time steps. Otherwise:\n\nd_min^upx_t^start - sum_i=t-d_min^down + 1^t (1 - x_i^on) leq 0\n\nfor i in the set of time steps.\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nduration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down\ninitial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)\ncons_name::Symbol : name of the constraint\nvar_keys::Tuple{VariableKey, VariableKey, VariableKey}) : names of the variables\n: var_keys[1] : varon\n: var_keys[2] : varstart\n: var_keys[3] : varstop\n\ndevice_duration_look_ahead!(\n    container,\n    duration_data,\n    initial_duration,\n    cons_type_up,\n    cons_type_down,\n    var_types,\n    _\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/duration_constraints.jl:148.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_duration_parameters!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Vector{NamedTuple{(:up, :down), Tuple{Float64, Float64}}}, Matrix{InitialCondition}, PowerSimulations.ConstraintType, Tuple{PowerSimulations.VariableType, PowerSimulations.VariableType, PowerSimulations.VariableType}, Type{T}}} where T<:Component","page":"API Reference","title":"PowerSimulations.device_duration_parameters!","text":"device_duration_parameters!(\n    container::PowerSimulations.OptimizationContainer,\n    duration_data::Vector{NamedTuple{(:up, :down), Tuple{Float64, Float64}}},\n    initial_duration::Matrix{InitialCondition},\n    cons_type::PowerSimulations.ConstraintType,\n    var_types::Tuple{PowerSimulations.VariableType, PowerSimulations.VariableType, PowerSimulations.VariableType},\n    _::Type{T<:Component}\n)\n\n\nThis formulation of the duration constraints considers parameters.\n\nLaTeX\n\nMinimum up-time constraint:\n\nIf t leq d_min^up\n\nd_min^downx_t^stop - sum_i=t-d_min^up + 1^t x_i^on - x_init^up leq 0\n\nfor i in the set of time steps. Otherwise:\n\nsum_i=t-d_min^up + 1^t x_i^start - x_t^on leq 0\n\nfor i in the set of time steps.\n\nMinimum down-time constraint:\n\nIf t leq d_min^down\n\nd_min^upx_t^start - sum_i=t-d_min^down + 1^t (1 - x_i^on) - x_init^down leq 0\n\nfor i in the set of time steps. Otherwise:\n\nsum_i=t-d_min^down + 1^t x_i^stop + x_t^on leq 1\n\nfor i in the set of time steps.\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nduration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down\ninitialdurationon::Vector{InitialCondition} : gives initial number of time steps variable is up\ninitialdurationoff::Vector{InitialCondition} : gives initial number of time steps variable is down\ncons_name::Symbol : name of the constraint\nvar_keys::Tuple{VariableKey, VariableKey, VariableKey}) : names of the variables\n: var_keys[1] : varon\n: var_keys[2] : varstart\n: var_keys[3] : varstop\n\ndevice_duration_parameters!(\n    container,\n    duration_data,\n    initial_duration,\n    cons_type,\n    var_types,\n    _\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/duration_constraints.jl:247.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_duration_retrospective!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Vector{NamedTuple{(:up, :down), Tuple{Float64, Float64}}}, Matrix{InitialCondition}, PowerSimulations.ConstraintType, Tuple{PowerSimulations.VariableType, PowerSimulations.VariableType, PowerSimulations.VariableType}, Type{T}}} where T<:Component","page":"API Reference","title":"PowerSimulations.device_duration_retrospective!","text":"This formulation of the duration constraints adds over the start times looking backwards.\n\nLaTeX\n\nMinimum up-time constraint:\n\nIf t leq d_min^up - d_init^up and d_init^up  0\n\n1 + sum_i=t-d_min^up + 1^t x_i^start - x_t^on leq 0\n\nfor i in the set of time steps. Otherwise:\n\nsum_i=t-d_min^up + 1^t x_i^start - x_t^on leq 0\n\nfor i in the set of time steps.\n\nMinimum down-time constraint:\n\nIf t leq d_min^down - d_init^down and d_init^down  0\n\n1 + sum_i=t-d_min^down + 1^t x_i^stop + x_t^on leq 1\n\nfor i in the set of time steps. Otherwise:\n\nsum_i=t-d_min^down + 1^t x_i^stop + x_t^on leq 1\n\nfor i in the set of time steps.\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nduration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down\ninitial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)\ncons_name::Symbol : name of the constraint\nvar_keys::Tuple{VariableKey, VariableKey, VariableKey}) : names of the variables\n: var_keys[1] : varon\n: var_keys[2] : varstart\n: var_keys[3] : varstop\n\ndevice_duration_retrospective!(\n    container,\n    duration_data,\n    initial_duration,\n    cons_type,\n    var_types,\n    _\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/duration_constraints.jl:41.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.find_key_with_value-Tuple{Any, Any}","page":"API Reference","title":"PowerSimulations.find_key_with_value","text":"find_key_with_value(d, value) -> Any\n\n\nReturn the key for the given value\n\nfind_key_with_value(d, value)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/file_utils.jl:31.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.find_timestamp_index-Tuple{Union{StepRange{Dates.DateTime, Dates.Millisecond}, Vector{Dates.DateTime}}, Dates.DateTime}","page":"API Reference","title":"PowerSimulations.find_timestamp_index","text":"find_timestamp_index(\n    dates::Union{StepRange{Dates.DateTime, Dates.Millisecond}, Vector{Dates.DateTime}},\n    date::Dates.DateTime\n) -> Int64\n\n\ncalculates the index in the time series corresponding to the data. Assumes that the dates vector is sorted.\n\nfind_timestamp_index(dates, date)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/datetime_utils.jl:4.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.generate_formulation_combinations","page":"API Reference","title":"PowerSimulations.generate_formulation_combinations","text":"generate_formulation_combinations(\n\n) -> Dict{String, Vector{Any}}\ngenerate_formulation_combinations(\n    sys\n) -> Dict{String, Vector{Any}}\n\n\nGenerate valid combinations of devicetype/formulation and servicetype/formulation. Return vectors of dictionaries with Julia types.\n\nArguments\n\nsys::Union{Nothing, System}: If set, only include component types present in the system.\n\ngenerate_formulation_combinations()\ngenerate_formulation_combinations(sys)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/generate_valid_formulations.jl:9.\n\n\n\n\n\n","category":"function"},{"location":"api/PowerSimulations/#PowerSimulations.get_absolute_step_range-Tuple{SimulationPartitions, Int64}","page":"API Reference","title":"PowerSimulations.get_absolute_step_range","text":"get_absolute_step_range(\n    partitions::SimulationPartitions,\n    index::Int64\n) -> UnitRange{Int64}\n\n\nReturn a UnitRange for the steps in the partition with the given index. Includes overlap.\n\nget_absolute_step_range(partitions, index)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_partitions.jl:37.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_dirty_data_to_flush!-Tuple{PowerSimulations.OptimizationOutputCache}","page":"API Reference","title":"PowerSimulations.get_dirty_data_to_flush!","text":"get_dirty_data_to_flush!(\n    cache::PowerSimulations.OptimizationOutputCache\n) -> Tuple{Vector{Dates.DateTime}, Any}\n\n\nReturn all dirty data from the cache. Mark the timestamps as clean.\n\nget_dirty_data_to_flush!(cache)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/optimization_output_cache.jl:98.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_enum_value-Tuple{Any, String}","page":"API Reference","title":"PowerSimulations.get_enum_value","text":"get_enum_value(enum, value::String) -> Any\n\n\nGet the enum value for the string. Case insensitive.\n\nget_enum_value(enum, value)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/definitions.jl:104.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_last_updated_timestamp-Tuple{PowerSimulations.DataFrameDataset}","page":"API Reference","title":"PowerSimulations.get_last_updated_timestamp","text":"get_last_updated_timestamp(\n    s::PowerSimulations.DataFrameDataset\n) -> Dates.DateTime\n\n\nReturn the timestamp from most recent data row updated in the dataset. This value may not be the same as the result from get_update_timestamp\n\nget_last_updated_timestamp(s)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/dataset.jl:96.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_last_updated_timestamp-Tuple{PowerSimulations.DatasetContainer, PowerSimulations.OptimizationContainerKey}","page":"API Reference","title":"PowerSimulations.get_last_updated_timestamp","text":"get_last_updated_timestamp(\n    container::PowerSimulations.DatasetContainer,\n    key::PowerSimulations.OptimizationContainerKey\n) -> Dates.DateTime\n\n\nReturn the timestamp from most recent data row updated in the dataset. This value may not be the same as the result from get_update_timestamp\n\nget_last_updated_timestamp(container, key)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/dataset_container.jl:195.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_last_updated_timestamp-Tuple{PowerSimulations.HDF5Dataset}","page":"API Reference","title":"PowerSimulations.get_last_updated_timestamp","text":"get_last_updated_timestamp(\n    s::PowerSimulations.HDF5Dataset\n) -> Dates.DateTime\n\n\nReturn the timestamp from most recent data row updated in the dataset. This value may not be the same as the result from get_update_timestamp\n\nget_last_updated_timestamp(s)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/dataset.jl:144.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{Any, Type{<:PowerSimulations.ConstraintType}, Type{<:PowerSimulations.AbstractBranchFormulation}}","page":"API Reference","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    device,\n    _::Type{<:PowerSimulations.ConstraintType},\n    _::Type{<:PowerSimulations.AbstractBranchFormulation}\n) -> NamedTuple{(:min, :max), Tuple{Float64, Float64}}\n\n\nMin and max limits for Abstract Branch Formulation\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:103.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:235.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:291.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:310.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:12.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:124.\n\nget_min_max_limits(x, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:282.\n\nget_min_max_limits(x, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:293.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:37.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:105.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:110.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:115.\n\nget_min_max_limits(d, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:151.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:173.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:185.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:256.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:297.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:556.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:567.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{<:PowerSimulations.AbstractCompactUnitCommitment}}","page":"API Reference","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    device,\n    _::Type{ActivePowerVariableLimitsConstraint},\n    _::Type{<:PowerSimulations.AbstractCompactUnitCommitment}\n) -> Any\n\n\nMin and Max active power limits for Compact Unit Commitment\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:103.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:173.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:256.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:297.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{<:PowerSimulations.AbstractThermalDispatchFormulation}}","page":"API Reference","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    device,\n    _::Type{ActivePowerVariableLimitsConstraint},\n    _::Type{<:PowerSimulations.AbstractThermalDispatchFormulation}\n) -> NamedTuple{(:min, :max), _A} where _A<:Tuple{Float64, Any}\n\n\nMin and max active power limits of generators for thermal dispatch formulations\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:103.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:173.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:185.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:213.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:228.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:256.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:297.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{<:PowerSimulations.AbstractThermalUnitCommitment}}","page":"API Reference","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    device,\n    _::Type{ActivePowerVariableLimitsConstraint},\n    _::Type{<:PowerSimulations.AbstractThermalUnitCommitment}\n) -> Any\n\n\nMin and max active power limits of generators for thermal unit commitment formulations\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:103.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:173.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:185.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:256.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:297.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{<:ThermalMultiStartUnitCommitment}}","page":"API Reference","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    device,\n    _::Type{ActivePowerVariableLimitsConstraint},\n    _::Type{<:ThermalMultiStartUnitCommitment}\n) -> Any\n\n\nMin and max active power limits for multi-start unit commitment formulations\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:103.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:173.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:256.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{ThermalCompactDispatch}}","page":"API Reference","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    device,\n    _::Type{ActivePowerVariableLimitsConstraint},\n    _::Type{ThermalCompactDispatch}\n) -> NamedTuple{(:min, :max), _A} where _A<:Tuple{Float64, Any}\n\n\nMin and max active power limits of generators for thermal dispatch compact formulations\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:213.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{ThermalDispatchNoMin}}","page":"API Reference","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    device,\n    _::Type{ActivePowerVariableLimitsConstraint},\n    _::Type{ThermalDispatchNoMin}\n) -> NamedTuple{(:min, :max), _A} where _A<:Tuple{Float64, Any}\n\n\nMin and max active power limits of generators for thermal dispatch no minimum formulations\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:228.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{Any, Type{EnergyCapacityConstraint}, Type{<:PowerSimulations.AbstractStorageFormulation}}","page":"API Reference","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    d,\n    _::Type{EnergyCapacityConstraint},\n    _::Type{<:PowerSimulations.AbstractStorageFormulation}\n) -> NamedTuple{(:min, :max), _A} where _A<:Tuple{Any, Any}\n\n\nMin and max limits for Energy Capacity Constraint and AbstractStorageFormulation\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:103.\n\nget_min_max_limits(d, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:151.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{Any, Type{ReactivePowerVariableLimitsConstraint}, Type{<:PowerSimulations.AbstractThermalDispatchFormulation}}","page":"API Reference","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    device,\n    _::Type{ReactivePowerVariableLimitsConstraint},\n    _::Type{<:PowerSimulations.AbstractThermalDispatchFormulation}\n) -> Any\n\n\nReactive power limits of generators for all dispatch formulations\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:103.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:37.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:556.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:567.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{Any, Type{ReactivePowerVariableLimitsConstraint}, Type{<:PowerSimulations.AbstractThermalUnitCommitment}}","page":"API Reference","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    device,\n    _::Type{ReactivePowerVariableLimitsConstraint},\n    _::Type{<:PowerSimulations.AbstractThermalUnitCommitment}\n) -> Any\n\n\nReactive power limits of generators when there CommitmentVariables\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:103.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:37.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:556.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:567.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{HydroGen, Type{<:ActivePowerVariableLimitsConstraint}, Type{<:PowerSimulations.AbstractHydroFormulation}}","page":"API Reference","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    x::HydroGen,\n    _::Type{<:ActivePowerVariableLimitsConstraint},\n    _::Type{<:PowerSimulations.AbstractHydroFormulation}\n) -> NamedTuple{(:min, :max), Tuple{Float64, Float64}}\n\n\nMin and max active Power Variable limits\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:103.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:12.\n\nget_min_max_limits(x, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:282.\n\nget_min_max_limits(x, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:293.\n\nget_min_max_limits(x, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:301.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{HydroGen, Type{<:InputActivePowerVariableLimitsConstraint}, Type{HydroDispatchPumpedStorage}}","page":"API Reference","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    x::HydroGen,\n    _::Type{<:InputActivePowerVariableLimitsConstraint},\n    _::Type{HydroDispatchPumpedStorage}\n) -> NamedTuple{(:min, :max), _A} where _A<:Tuple{Any, Any}\n\n\nMin and max input active power variable limits for hydro dispatch pumped storage\n\nget_min_max_limits(x, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:397.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{HydroGen, Type{<:OutputActivePowerVariableLimitsConstraint}, Type{HydroDispatchPumpedStorage}}","page":"API Reference","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    x::HydroGen,\n    _::Type{<:OutputActivePowerVariableLimitsConstraint},\n    _::Type{HydroDispatchPumpedStorage}\n) -> Any\n\n\nMin and max output active power variable limits for hydro dispatch pumped storage\n\nget_min_max_limits(x, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:386.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{HydroGen, Type{<:ReactivePowerVariableLimitsConstraint}, Type{<:PowerSimulations.AbstractHydroFormulation}}","page":"API Reference","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    x::HydroGen,\n    _::Type{<:ReactivePowerVariableLimitsConstraint},\n    _::Type{<:PowerSimulations.AbstractHydroFormulation}\n) -> NamedTuple{(:min, :max), Tuple{Float64, Float64}}\n\n\nMin and max reactive Power Variable limits\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:103.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:12.\n\nget_min_max_limits(x, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:282.\n\nget_min_max_limits(x, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:293.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{MonitoredLine, Type{<:PowerSimulations.ConstraintType}, Type{<:PowerSimulations.AbstractBranchFormulation}}","page":"API Reference","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    device::MonitoredLine,\n    _::Type{<:PowerSimulations.ConstraintType},\n    _::Type{<:PowerSimulations.AbstractBranchFormulation}\n) -> NamedTuple{(:min, :max), _A} where _A<:Tuple{Any, Any}\n\n\nMin and max limits for monitored line\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:235.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:291.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:310.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{MonitoredLine, Type{FlowLimitFromToConstraint}, Type{<:PowerSimulations.AbstractBranchFormulation}}","page":"API Reference","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    device::MonitoredLine,\n    _::Type{FlowLimitFromToConstraint},\n    _::Type{<:PowerSimulations.AbstractBranchFormulation}\n) -> NamedTuple{(:min, :max), _A} where _A<:Tuple{Any, Any}\n\n\nMin and max limits for flow limit from-to constraint\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:291.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{MonitoredLine, Type{FlowLimitToFromConstraint}, Type{<:PowerSimulations.AbstractBranchFormulation}}","page":"API Reference","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    device::MonitoredLine,\n    _::Type{FlowLimitToFromConstraint},\n    _::Type{<:PowerSimulations.AbstractBranchFormulation}\n) -> NamedTuple{(:min, :max), _A} where _A<:Tuple{Any, Any}\n\n\nMin and max limits for flow limit to-from constraint\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:310.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_startup_shutdown_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{<:PowerSimulations.AbstractCompactUnitCommitment}}","page":"API Reference","title":"PowerSimulations.get_startup_shutdown_limits","text":"get_startup_shutdown_limits(\n    device,\n    _::Type{ActivePowerVariableLimitsConstraint},\n    _::Type{<:PowerSimulations.AbstractCompactUnitCommitment}\n) -> Union{Nothing, NamedTuple{(:startup, :shutdown), _A} where _A<:Tuple{Any, Any}}\n\n\nStartup shutdown limits for Compact Unit Commitment\n\nget_startup_shutdown_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:286.\n\nget_startup_shutdown_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:312.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_startup_shutdown_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{<:ThermalMultiStartUnitCommitment}}","page":"API Reference","title":"PowerSimulations.get_startup_shutdown_limits","text":"get_startup_shutdown_limits(\n    device,\n    _::Type{ActivePowerVariableLimitsConstraint},\n    _::Type{<:ThermalMultiStartUnitCommitment}\n) -> Union{Nothing, NamedTuple{(:startup, :shutdown), _A} where _A<:Tuple{Any, Any}}\n\n\nStartup and shutdown active power limits for Compact Unit Commitment\n\nget_startup_shutdown_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:286.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_update_timestamp-Tuple{PowerSimulations.AbstractDataset}","page":"API Reference","title":"PowerSimulations.get_update_timestamp","text":"get_update_timestamp(\n    s::PowerSimulations.AbstractDataset\n) -> Any\n\n\nReturn the timestamp from the data used in the last update\n\nget_update_timestamp(s)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/dataset.jl:10.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_update_timestamp-Tuple{PowerSimulations.DatasetContainer, PowerSimulations.OptimizationContainerKey}","page":"API Reference","title":"PowerSimulations.get_update_timestamp","text":"get_update_timestamp(\n    container::PowerSimulations.DatasetContainer,\n    key::PowerSimulations.OptimizationContainerKey\n) -> Any\n\n\nReturn the timestamp from the data used in the last update\n\nget_update_timestamp(container, key)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/dataset_container.jl:188.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_valid_step_length-Tuple{SimulationPartitions, Int64}","page":"API Reference","title":"PowerSimulations.get_valid_step_length","text":"get_valid_step_length(\n    partitions::SimulationPartitions,\n    index::Int64\n) -> Int64\n\n\nReturn the length of valid data at the given index.\n\nget_valid_step_length(partitions, index)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_partitions.jl:64.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_valid_step_offset-Tuple{SimulationPartitions, Int64}","page":"API Reference","title":"PowerSimulations.get_valid_step_offset","text":"get_valid_step_offset(\n    partitions::SimulationPartitions,\n    index::Int64\n) -> Int64\n\n\nReturn the step offset for valid data at the given index.\n\nget_valid_step_offset(partitions, index)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_partitions.jl:56.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.has_dirty-Tuple{PowerSimulations.OptimizationOutputCaches}","page":"API Reference","title":"PowerSimulations.has_dirty","text":"has_dirty(\n    cache::PowerSimulations.OptimizationOutputCaches\n) -> Bool\n\n\nReturn true if the cache has data that has not been flushed to storage.\n\nhas_dirty(cache)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/optimization_output_caches.jl:57.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.is_cached-Tuple{PowerSimulations.OptimizationOutputCaches, Any, Any, Any}","page":"API Reference","title":"PowerSimulations.is_cached","text":"is_cached(\n    cache::PowerSimulations.OptimizationOutputCaches,\n    model_name,\n    key,\n    index\n) -> Bool\n\n\nReturn true if the data for timestamp is stored in cache.\n\nis_cached(cache, model_name, key, index)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/optimization_output_caches.jl:82.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.join_simulation-Tuple{AbstractString}","page":"API Reference","title":"PowerSimulations.join_simulation","text":"join_simulation(path::AbstractString)\n\n\nCombine all partition simulation files.\n\njoin_simulation(path)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_partition_results.jl:34.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.list_decision_model_keys-Tuple{PowerSimulations.HdfSimulationStore, Symbol, Symbol}","page":"API Reference","title":"PowerSimulations.list_decision_model_keys","text":"list_decision_model_keys(\n    store::PowerSimulations.HdfSimulationStore,\n    model::Symbol,\n    container_type::Symbol\n) -> Base.KeySet\n\n\nReturn the fields stored for the problem and container_type (duals/parameters/variables).\n\nlist_decision_model_keys(store, model, container_type)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/hdf_simulation_store.jl:172.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.list_decision_models-Tuple{PowerSimulations.HdfSimulationStore}","page":"API Reference","title":"PowerSimulations.list_decision_models","text":"list_decision_models(\n    store::PowerSimulations.HdfSimulationStore\n) -> Base.KeySet{Symbol, OrderedDict{Symbol, PowerSimulations.DatasetContainer{PowerSimulations.HDF5Dataset}}}\n\n\nReturn the problem names in order of execution.\n\nlist_decision_models(store)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/hdf_simulation_store.jl:167.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.log_cache_hit_percentages-Tuple{PowerSimulations.OptimizationOutputCaches}","page":"API Reference","title":"PowerSimulations.log_cache_hit_percentages","text":"log_cache_hit_percentages(\n    cache::PowerSimulations.OptimizationOutputCaches\n)\n\n\nLog the cache hit percentages for all caches.\n\nlog_cache_hit_percentages(cache)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/optimization_output_caches.jl:95.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.open_store","page":"API Reference","title":"PowerSimulations.open_store","text":"open_store(\n    ::Type{PowerSimulations.HdfSimulationStore},\n    directory::AbstractString\n) -> PowerSimulations.HdfSimulationStore\nopen_store(\n    ::Type{PowerSimulations.HdfSimulationStore},\n    directory::AbstractString,\n    mode;\n    filename\n) -> PowerSimulations.HdfSimulationStore\n\n\nConstruct and open an HdfSimulationStore.\n\nWhen reading or writing results in a program you should use the method that accepts a function in order to guarantee that the file handle gets closed.\n\nArguments\n\ndirectory::AbstractString: Directory containing the store file\nmode::AbstractString: Mode to use to open the store file\nfilename::AbstractString: Base name of the store file\n\nExamples\n\n# Assumes a simulation has been executed in the './rts' directory with these parameters.\npath = \"./rts\"\nproblem = :ED\nvar_name = :P__ThermalStandard\ntimestamp = DateTime(\"2020-01-01T05:00:00\")\nstore = open_store(HdfSimulationStore, path)\ndf = PowerSimulations.read_result(DataFrame, store, model, :variables, var_name, timestamp)\n\nopen_store(, directory)\nopen_store(, directory, mode; filename)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/hdf_simulation_store.jl:89.\n\n\n\n\n\n","category":"function"},{"location":"api/PowerSimulations/#PowerSimulations.read_dataframe-Tuple{AbstractString}","page":"API Reference","title":"PowerSimulations.read_dataframe","text":"read_dataframe(\n    filename::AbstractString\n) -> DataFrames.DataFrame\n\n\nReturn a DataFrame from a CSV file.\n\nread_dataframe(filename)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/file_utils.jl:13.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_json-Tuple{AbstractString}","page":"API Reference","title":"PowerSimulations.read_json","text":"read_json(filename::AbstractString) -> Any\n\n\nReturn a decoded JSON file.\n\nread_json(filename)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/file_utils.jl:4.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_result-Tuple{PowerSimulations.OptimizationOutputCaches, Any, Any, Any}","page":"API Reference","title":"PowerSimulations.read_result","text":"read_result(\n    cache::PowerSimulations.OptimizationOutputCaches,\n    model_name,\n    key,\n    timestamp\n) -> Array\n\n\nRead the result from cache. Callers must first call is_cached to check if the timestamp is present.\n\nread_result(cache, model_name, key, timestamp)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/optimization_output_caches.jl:108.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_result-Tuple{Type{DataFrames.DataFrame}, PowerSimulations.HdfSimulationStore, Symbol, PowerSimulations.OptimizationContainerKey, Union{Int64, Dates.DateTime}}","page":"API Reference","title":"PowerSimulations.read_result","text":"read_result(\n    _::Type{DataFrames.DataFrame},\n    store::PowerSimulations.HdfSimulationStore,\n    model_name::Symbol,\n    key::PowerSimulations.OptimizationContainerKey,\n    index::Union{Int64, Dates.DateTime}\n) -> Any\n\n\nReturn DataFrame, DenseAxisArray, or Array for a model result at a timestamp.\n\nread_result(_, store, model_name, key, index)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/hdf_simulation_store.jl:336.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.serialize_formulation_combinations","page":"API Reference","title":"PowerSimulations.serialize_formulation_combinations","text":"serialize_formulation_combinations(\n\n) -> Dict{String, Vector{Any}}\nserialize_formulation_combinations(\n    sys\n) -> Dict{String, Vector{Any}}\n\n\nGenerate valid combinations of devicetype/formulation and servicetype/formulation. Return vectors of dictionaries with Julia types encoded as strings.\n\nArguments\n\nsys::Union{Nothing, System}: If set, only include component types present in the system.\n\nserialize_formulation_combinations()\nserialize_formulation_combinations(sys)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/generate_valid_formulations.jl:37.\n\n\n\n\n\n","category":"function"},{"location":"api/PowerSimulations/#PowerSimulations.serialize_simulation-Tuple{Simulation}","page":"API Reference","title":"PowerSimulations.serialize_simulation","text":"serialize_simulation(sim::Simulation; path, force) -> String\n\n\nserialize_simulation(sim::Simulation, path = \".\")\n\nSerialize the simulation to a directory in path.\n\nReturn the serialized simulation directory name that is created.\n\nArguments\n\nsim::Simulation: simulation to serialize\npath = \".\": path in which to create the serialzed directory\nforce = false: If true, delete the directory if it already exists. Otherwise, it will throw an exception.\n\nserialize_simulation(sim; path, force)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation.jl:987.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.set_expression!-Union{Tuple{T}, Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, Type{S}, JuMP.AbstractJuMPScalar, T, Int64}} where {S<:CostExpressions, T<:Component}","page":"API Reference","title":"PowerSimulations.set_expression!","text":"set_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{S<:CostExpressions},\n    cost_expression::JuMP.AbstractJuMPScalar,\n    component::Component,\n    time_period::Int64\n)\n\n\nReplaces an expression value in the expression container if the key exists\n\nset_expression!(\n    container,\n    _,\n    cost_expression,\n    component,\n    time_period\n)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/set_expression.jl:4.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.set_ic_quantity!-Union{Tuple{T}, Tuple{InitialCondition{T, Float64}, Float64}} where T<:PowerSimulations.InitialConditionType","page":"API Reference","title":"PowerSimulations.set_ic_quantity!","text":"set_ic_quantity!(\n    ic::InitialCondition{T<:PowerSimulations.InitialConditionType, Float64},\n    var_value::Float64\n)\n\n\nDefault implementation of setinitialcondition_value\n\nset_ic_quantity!(ic, var_value)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/initial_conditions/calculate_initial_condition.jl:16.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.set_ic_quantity!-Union{Tuple{T}, Tuple{InitialCondition{T, ParameterJuMP.ParameterRef}, Float64}} where T<:PowerSimulations.InitialConditionType","page":"API Reference","title":"PowerSimulations.set_ic_quantity!","text":"set_ic_quantity!(\n    ic::InitialCondition{T<:PowerSimulations.InitialConditionType, ParameterJuMP.ParameterRef},\n    var_value::Float64\n)\n\n\nDefault implementation of setinitialcondition_value\n\nset_ic_quantity!(ic, var_value)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/initial_conditions/calculate_initial_condition.jl:4.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.solve_impl!-Tuple{PowerSimulations.OptimizationContainer, System}","page":"API Reference","title":"PowerSimulations.solve_impl!","text":"solve_impl!(\n    container::PowerSimulations.OptimizationContainer,\n    system::System\n) -> RunStatus\n\n\nDefault solve method for OptimizationContainer\n\nsolve_impl!(container, system)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/optimization_container.jl:586.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.sparse_container_spec-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any}}} where T<:JuMP.AbstractJuMPScalar","page":"API Reference","title":"PowerSimulations.sparse_container_spec","text":"sparse_container_spec(\n    _::Type{T<:JuMP.AbstractJuMPScalar},\n    axs...\n) -> JuMP.Containers.SparseAxisArray{Any, N} where N\n\n\nReturns the correct container specification for the selected type of JuMP Model\n\nsparse_container_spec(_, axs)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/jump_utils.jl:165.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.to_matrix-Tuple{T} where T<:PowerSimulations.OptimizerStats","page":"API Reference","title":"PowerSimulations.to_matrix","text":"to_matrix(\n    stats::PowerSimulations.OptimizerStats\n) -> Matrix{Float64}\n\n\nConvert OptimizerStats to a matrix of floats that can be serialized to HDF5.\n\nto_matrix(stats)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/optimizer_stats.jl:79.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.update_model!-Tuple{PowerSimulations.OperationModel, Simulation}","page":"API Reference","title":"PowerSimulations.update_model!","text":"update_model!(\n    model::PowerSimulations.OperationModel,\n    sim::Simulation\n)\n\n\nDefault problem update function for most problems with no customization\n\nupdate_model!(model, sim)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation.jl:768.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.update_parameter_values!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OperationModel, PowerSimulations.ParameterKey{T, U}, PowerSimulations.DatasetContainer{PowerSimulations.DataFrameDataset}}} where {T<:PowerSimulations.ParameterType, U<:Component}","page":"API Reference","title":"PowerSimulations.update_parameter_values!","text":"update_parameter_values!(\n    model::PowerSimulations.OperationModel,\n    key::PowerSimulations.ParameterKey{T<:PowerSimulations.ParameterType, U<:Component},\n    input::PowerSimulations.DatasetContainer{PowerSimulations.DataFrameDataset}\n)\n\n\nUpdate parameter function an OperationModel\n\nupdate_parameter_values!(model, key, input)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/parameters/update_parameters.jl:285.\n\nupdate_parameter_values!(model, key, input)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/parameters/update_parameters.jl:309.\n\nupdate_parameter_values!(model, key, input)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/parameters/update_parameters.jl:383.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.update_parameter_values!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OperationModel, PowerSimulations.ParameterKey{T, U}, PowerSimulations.DatasetContainer{PowerSimulations.DataFrameDataset}}} where {T<:PowerSimulations.ParameterType, U<:Service}","page":"API Reference","title":"PowerSimulations.update_parameter_values!","text":"update_parameter_values!(\n    model::PowerSimulations.OperationModel,\n    key::PowerSimulations.ParameterKey{T<:PowerSimulations.ParameterType, U<:Service},\n    input::PowerSimulations.DatasetContainer{PowerSimulations.DataFrameDataset}\n)\n\n\nUpdate parameter function an OperationModel\n\nupdate_parameter_values!(model, key, input)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/parameters/update_parameters.jl:309.\n\nupdate_parameter_values!(model, key, input)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/parameters/update_parameters.jl:383.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.variable_reactive_net_injection-Tuple{PowerModels.AbstractActivePowerModel}","page":"API Reference","title":"PowerSimulations.variable_reactive_net_injection","text":"variable_reactive_net_injection(\n    pm::PowerModels.AbstractActivePowerModel;\n    kwargs...\n)\n\n\nactive power only models ignore reactive power variables\n\nvariable_reactive_net_injection(pm; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/network_models/powermodels_interface.jl:257.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.write_formulation_combinations","page":"API Reference","title":"PowerSimulations.write_formulation_combinations","text":"write_formulation_combinations(\n    filename::AbstractString\n) -> Union{Nothing, Int64}\nwrite_formulation_combinations(\n    filename::AbstractString,\n    sys\n) -> Union{Nothing, Int64}\n\n\nGenerate valid combinations of devicetype/formulation and servicetype/formulation and write the result to a JSON file.\n\nArguments\n\nsys::Union{Nothing, System}: If set, only include component types present in the system.\n\nwrite_formulation_combinations(filename)\nwrite_formulation_combinations(filename, sys)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/generate_valid_formulations.jl:63.\n\n\n\n\n\n","category":"function"},{"location":"api/PowerSimulations/#PowerSimulations.write_result!-Tuple{PowerSimulations.HdfSimulationStore, Symbol, PowerSimulations.OptimizationContainerKey, Dates.DateTime, Dates.DateTime, Any}","page":"API Reference","title":"PowerSimulations.write_result!","text":"write_result!(\n    store::PowerSimulations.HdfSimulationStore,\n    model_name::Symbol,\n    key::PowerSimulations.OptimizationContainerKey,\n    index::Dates.DateTime,\n    _::Dates.DateTime,\n    data\n)\n\n\nWrite a decision model result for a timestamp to the store.\n\nwrite_result!(store, model_name, key, index, _, data)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/hdf_simulation_store.jl:489.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.write_result!-Tuple{PowerSimulations.HdfSimulationStore, Symbol, PowerSimulations.OptimizationContainerKey, Int64, Dates.DateTime, Matrix{Float64}}","page":"API Reference","title":"PowerSimulations.write_result!","text":"write_result!(\n    store::PowerSimulations.HdfSimulationStore,\n    _::Symbol,\n    key::PowerSimulations.OptimizationContainerKey,\n    index::Int64,\n    simulation_time::Dates.DateTime,\n    data::Matrix{Float64}\n)\n\n\nWrite an emulation model result for an execution index value and the timestamp of the update\n\nwrite_result!(store, _, key, index, simulation_time, data)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/hdf_simulation_store.jl:524.\n\n\n\n\n\n","category":"method"},{"location":"modeler_guide/definitions/#Definitions","page":"Definitions","title":"Definitions","text":"","category":"section"},{"location":"modeler_guide/definitions/#D","page":"Definitions","title":"D","text":"","category":"section"},{"location":"modeler_guide/definitions/","page":"Definitions","title":"Definitions","text":"Decision Problem: A decision problem calculates the desired system operation based on forecasts of uncertain inputs and information about the state of the system. The output of a decision problem represents the policies used to drive the set-points of the system's devices, like generators or switches, and depends on the purpose of the problem.","category":"page"},{"location":"modeler_guide/definitions/#E","page":"Definitions","title":"E","text":"","category":"section"},{"location":"modeler_guide/definitions/","page":"Definitions","title":"Definitions","text":"Emulation Problem: An emulation problem is used to mimic the system's behavior subject to an incoming decision and the realization of a forecasted inputs. The solution of the emulator produces outputs representative of the system performance when operating subject the policies resulting from the decision models.","category":"page"},{"location":"modeler_guide/definitions/#H","page":"Definitions","title":"H","text":"","category":"section"},{"location":"modeler_guide/definitions/","page":"Definitions","title":"Definitions","text":"Horizon: The number of steps in the look-ahead of a decision problem. For instance, a Day-ahead problem usually has a 48 step horizon.","category":"page"},{"location":"modeler_guide/definitions/#I","page":"Definitions","title":"I","text":"","category":"section"},{"location":"modeler_guide/definitions/","page":"Definitions","title":"Definitions","text":"Interval:","category":"page"},{"location":"modeler_guide/definitions/#R","page":"Definitions","title":"R","text":"","category":"section"},{"location":"modeler_guide/definitions/","page":"Definitions","title":"Definitions","text":"Resolution: The amount of time between timesteps in a simulation. For instance 1-hour or 5-minutes. In Julia these are defined using the syntax Hour(1) and Minute(5)","category":"page"},{"location":"formulation_library/HybridSystem/#[PowerSystems.HybridSystem](https://nrel-siip.github.io/PowerSystems.jl/stable/model_library/hybrid_device/)-Formulations","page":"Hybrid System","title":"PowerSystems.HybridSystem Formulations","text":"","category":"section"},{"location":"formulation_library/HybridSystem/","page":"Hybrid System","title":"Hybrid System","text":"TODO","category":"page"},{"location":"modeler_guide/debugging_infeasible_models/#Debugging-infeasible-models","page":"Debugging infeasible models","title":"Debugging infeasible models","text":"","category":"section"},{"location":"modeler_guide/debugging_infeasible_models/","page":"Debugging infeasible models","title":"Debugging infeasible models","text":"Getting infeasible solutions to models is a common ocurrence in operations simulations, there are multiple reasons why this can happen. PowerSimulations.jl has several tools to help debug this situation.","category":"page"},{"location":"modeler_guide/debugging_infeasible_models/#Adding-slacks-to-the-model","page":"Debugging infeasible models","title":"Adding slacks to the model","text":"","category":"section"},{"location":"modeler_guide/debugging_infeasible_models/#Getting-the-infeasibility-conflict","page":"Debugging infeasible models","title":"Getting the infeasibility conflict","text":"","category":"section"},{"location":"formulation_library/HydroGen/#PowerSystems.HydroGen-Formulations","page":"Hydro Generation","title":"PowerSystems.HydroGen Formulations","text":"","category":"section"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Valid DeviceModels for subtypes of HydroGen include the following:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"using PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.generate_device_formulation_combinations()\nfilter!(x -> x[\"device_type\"] <: HydroGen, combos)\ncombo_table = DataFrame(\n    \"Valid DeviceModel\" => [\"`DeviceModel($(c[\"device_type\"]), $(c[\"formulation\"]))`\" for c in combos],\n    \"Device Type\" => [\"[$(c[\"device_type\"])](https://nrel-siip.github.io/PowerSystems.jl/stable/model_library/generated_$(c[\"device_type\"])/)\" for c in combos],\n    \"Formulation\" => [\"[$(c[\"formulation\"])](@ref)\" for c in combos],\n    )\nmdtable(combo_table, latex = false)","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"","category":"page"},{"location":"formulation_library/HydroGen/#HydroDispatchRunOfRiver","page":"Hydro Generation","title":"HydroDispatchRunOfRiver","text":"","category":"section"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"HydroDispatchRunOfRiver","category":"page"},{"location":"formulation_library/HydroGen/#PowerSimulations.HydroDispatchRunOfRiver","page":"Hydro Generation","title":"PowerSimulations.HydroDispatchRunOfRiver","text":"Formulation type to add injection variables constrained by a maximum injection time series for HydroGen\n\nHydroDispatchRunOfRiver()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:90.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Variables:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"ActivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_active_power(device)\nReactivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_reactive_power(device)","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Static Parameters:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Pg^textmin = PowerSystems.get_active_power_limits(device).min\nQg^textmin = PowerSystems.get_reactive_power_limits(device).min\nQg^textmax = PowerSystems.get_reactive_power_limits(device).max","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Time Series Parameters:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"using PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.get_default_time_series_names(HydroGen, HydroDispatchRunOfRiver)\ncombo_table = DataFrame(\n    \"Parameter\" => map(x -> \"[`$x`](@ref)\", collect(keys(combos))),\n    \"Default Time Series Name\" => map(x -> \"`$x`\", collect(values(combos))),\n    )\nmdtable(combo_table, latex = false)","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Objective:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Creates an objective function term based on the VariableCost Options where the quantity term is defined as Pg.","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Expressions:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Adds Pg and Qg terms to the respective active and reactive power balance expressions created by the selected Network Formulations","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Constraints:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"beginaligned\n  Pg^textmin le Pg_t le ActivePowerTimeSeriesParameter_t \n  Qg^textmin le Qg_t le Qg^textmax\nendaligned","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"","category":"page"},{"location":"formulation_library/HydroGen/#HydroDispatchPumpedStorage","page":"Hydro Generation","title":"HydroDispatchPumpedStorage","text":"","category":"section"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"HydroDispatchPumpedStorage","category":"page"},{"location":"formulation_library/HydroGen/#PowerSimulations.HydroDispatchPumpedStorage","page":"Hydro Generation","title":"PowerSimulations.HydroDispatchPumpedStorage","text":"Formulation type to constrain energy production from pumped storage with a representation of the energy storage capacity of upper and lower reservoirs and water inflow time series of upper reservoir and outflow time series of lower reservoir for HydroPumpedStorage\n\nHydroDispatchPumpedStorage()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:105.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Variables:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"ActivePowerInVariable:\nBounds: [0.0, ]\nDefault initial value: -1 * PowerSystems.get_active_power(device)\nActivePowerOutVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_active_power(device)\nEnergyVariableUp:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_initial_storage(device).up\nEnergyVariableDown:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_initial_storage(device).down\nWaterSpillageVariable:\nBounds: [0.0, ]\nDefault initial value: 0.0\nEnergyOutput:\nBounds: [0.0, ]\nDefault initial value: 0.0\nReservationVariable:\nonly included if DeviceModel(HydroPumpedStorage, HydroDispatchPumpedStorage; attributes = Dict(reservation => true))\nBounds: {0, 1}\nDefault initial value: 1","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Static Parameters:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Pg^textout max = map(x -> x.max - x.min, PowerSystems.get_active_power_limits(device))\nPg^textin max = map(x -> x.max - x.min, PowerSystems.get_active_power_limits_pump(device))\nEg^textup max = PowerSystems.get_storage_capacity(device).up\nEg^textdown max = PowerSystems.get_storage_capacity(device).down","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Time Series Parameters:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"using PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.get_default_time_series_names(HydroPumpedStorage, HydroDispatchPumpedStorage)\ncombo_table = DataFrame(\n    \"Parameter\" => map(x -> \"[`$x`](@ref)\", collect(keys(combos))),\n    \"Default Time Series Name\" => map(x -> \"`$x`\", collect(values(combos))),\n    )\nmdtable(combo_table, latex = false)","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Objective:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Creates an objective function term based on the VariableCost Options where the quantity term is defined as Pg^out.","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Expressions:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Adds Pg term(s) to the active power balance expression(s) created by the selected Network Formulations","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Constraints:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"beginaligned\n  E^up_t+1 = E^up_t + (InflowTimeSeriesParameter_t - S_t - Pg^out_t + Pg^in_t) cdot Delta T \n  E^down_t+1 = E^down_t + (S_t - OutflowTimeSeriesParameter_t + Pg^out_t - Pg^in_t) cdot Delta T \n  Pg^in_t - r * Pg^textin max le Pg^textin max \n  Pg^out_t + r * Pg^textout max le Pg^textout max \n  E^up_t le E^up max\n  E^down_t le E^down max\nendaligned","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"","category":"page"},{"location":"formulation_library/HydroGen/#HydroDispatchReservoirBudget","page":"Hydro Generation","title":"HydroDispatchReservoirBudget","text":"","category":"section"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"HydroDispatchReservoirBudget","category":"page"},{"location":"formulation_library/HydroGen/#PowerSimulations.HydroDispatchReservoirBudget","page":"Hydro Generation","title":"PowerSimulations.HydroDispatchReservoirBudget","text":"Formulation type to add injection variables constrained by total energy production budget defined with a time series for HydroGen\n\nHydroDispatchReservoirBudget()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:95.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Variables:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"ActivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_active_power(device)\nReactivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_reactive_power(device)","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Auxillary Variables:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"EnergyOutput - TODO","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Static Parameters:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Pg^textmin = PowerSystems.get_active_power_limits(device).min\nPg^textmax = PowerSystems.get_active_power_limits(device).max\nQg^textmin = PowerSystems.get_reactive_power_limits(device).min\nQg^textmax = PowerSystems.get_reactive_power_limits(device).max","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Time Series Parameters:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"using PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.get_default_time_series_names(HydroEnergyReservoir, HydroDispatchReservoirBudget)\ncombo_table = DataFrame(\n    \"Parameter\" => map(x -> \"[`$x`](@ref)\", collect(keys(combos))),\n    \"Default Time Series Name\" => map(x -> \"`$x`\", collect(values(combos))),\n    )\nmdtable(combo_table, latex = false)","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Objective:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Creates an objective function term based on the VariableCost Options where the quantity term is defined as Pg.","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Expressions:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Adds Pg and Qg terms to the respective active and reactive power balance expressions created by the selected Network Formulations","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Constraints:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"beginaligned\n  Pg^textmin le Pg_t le Pg^textmax \n  Qg^textmin le Qg_t le Qg^textmax \n  sum_t = 1^N(Pg_t) cdot Delta T le sum_t = 1^N(EnergyBudgetTimeSeriesParameter_t) cdot Delta T\nendaligned","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"","category":"page"},{"location":"formulation_library/HydroGen/#HydroDispatchReservoirStorage","page":"Hydro Generation","title":"HydroDispatchReservoirStorage","text":"","category":"section"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"HydroDispatchReservoirStorage","category":"page"},{"location":"formulation_library/HydroGen/#PowerSimulations.HydroDispatchReservoirStorage","page":"Hydro Generation","title":"PowerSimulations.HydroDispatchReservoirStorage","text":"Formulation type to constrain hydropower production with a representation of the energy storage capacity and water inflow time series of a reservoir for HydroGen\n\nHydroDispatchReservoirStorage()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:100.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Variables:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"ActivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_active_power(device)\nReactivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_reactive_power(device)\nEnergyVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_initial_storage(device)\nWaterSpillageVariable:\nBounds: [0.0, ]\nDefault initial value: 0.0\nEnergyShortageVariable:\nBounds: [ , 0.0]\nDefault initial value: 0.0\nEnergySurplusVariable:\nBounds: [0.0, ]\nDefault initial value: 0.0","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Auxillary Variables:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"EnergyOutput","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Static Parameters:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Pg^textmin = PowerSystems.get_active_power_limits(device).min\nPg^textmax = PowerSystems.get_active_power_limits(device).max\nQg^textmin = PowerSystems.get_reactive_power_limits(device).min\nQg^textmax = PowerSystems.get_reactive_power_limits(device).max\nEg^textmax = PowerSystems.get_storage_capacity(device)","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Time Series Parameters:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"using PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.get_default_time_series_names(HydroEnergyReservoir, HydroDispatchReservoirStorage)\ncombo_table = DataFrame(\n    \"Parameter\" => map(x -> \"[`$x`](@ref)\", collect(keys(combos))),\n    \"Default Time Series Name\" => map(x -> \"`$x`\", collect(values(combos))),\n    )\nmdtable(combo_table, latex = false)","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Objective:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Creates an objective function term based on the VariableCost Options where the quantity term is defined as Pg. TODO: add slack terms","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Expressions:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Adds Pg and Qg terms to the respective active and reactive power balance expressions created by the selected Network Formulations","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Constraints:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"beginaligned\n  E_t+1 = E_t + (InflowTimeSeriesParameter_t - S_t - Pg_t) cdot Delta T \n  E_t - E^surplus_t + E^shortage_t = EnergyTargetTimeSeriesParameter_t \n  Pg^textmin le Pg_t le Pg^textmax \n  Qg^textmin le Qg_t le Qg^textmax\nendaligned","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"","category":"page"},{"location":"formulation_library/HydroGen/#HydroCommitmentReservoirBudget","page":"Hydro Generation","title":"HydroCommitmentReservoirBudget","text":"","category":"section"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"HydroCommitmentReservoirBudget","category":"page"},{"location":"formulation_library/HydroGen/#PowerSimulations.HydroCommitmentReservoirBudget","page":"Hydro Generation","title":"PowerSimulations.HydroCommitmentReservoirBudget","text":"Formulation type to add commitment and injection variables constrained by total energy production budget defined with a time series for HydroGen\n\nHydroCommitmentReservoirBudget()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:115.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Variables:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"ActivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_active_power(device)\nReactivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_reactive_power(device)\nOnVariable:\nBounds: {0, 1}\nDefault initial value: PowerSystems.get_status(device)","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Auxillary Variables:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"EnergyOutput - TODO","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Static Parameters:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Pg^textmin = PowerSystems.get_active_power_limits(device).min\nPg^textmax = PowerSystems.get_active_power_limits(device).max\nQg^textmin = PowerSystems.get_reactive_power_limits(device).min\nQg^textmax = PowerSystems.get_reactive_power_limits(device).max","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Time Series Parameters:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"using PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.get_default_time_series_names(HydroEnergyReservoir, HydroCommitmentReservoirBudget)\ncombo_table = DataFrame(\n    \"Parameter\" => map(x -> \"[`$x`](@ref)\", collect(keys(combos))),\n    \"Default Time Series Name\" => map(x -> \"`$x`\", collect(values(combos))),\n    )\nmdtable(combo_table, latex = false)","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Objective:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Creates an objective function term based on the VariableCost Options where the quantity term is defined as Pg.","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Expressions:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Adds Pg and Qg terms to the respective active and reactive power balance expressions created by the selected Network Formulations","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Constraints:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"beginaligned\n  sum_t = 1^N P_t cdot Delta T le E^textbudget \n  Pg_t - u_t Pg^textmax le 0 \n  Pg_t - u_t Pg^textmin ge 0 \n  Qg_t - u_t Qg^textmax le 0 \n  Qg_t - u_t Qg^textmin ge 0\nendaligned","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"","category":"page"},{"location":"formulation_library/HydroGen/#HydroCommitmentReservoirStorage","page":"Hydro Generation","title":"HydroCommitmentReservoirStorage","text":"","category":"section"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"HydroCommitmentReservoirStorage","category":"page"},{"location":"formulation_library/HydroGen/#PowerSimulations.HydroCommitmentReservoirStorage","page":"Hydro Generation","title":"PowerSimulations.HydroCommitmentReservoirStorage","text":"Formulation type to constrain hydropower production with unit commitment variables and a representation of the energy storage capacity and water inflow time series of a reservoir for HydroGen\n\nHydroCommitmentReservoirStorage()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:120.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Variables:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"ActivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_active_power(device)\nReactivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_reactive_power(device)\nEnergyVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_initial_storage(device)\nWaterSpillageVariable:\nBounds: [0.0, ]\nDefault initial value: 0.0\nEnergyShortageVariable:\nBounds: [ , 0.0]\nDefault initial value: 0.0\nEnergySurplusVariable:\nBounds: [0.0, ]\nDefault initial value: 0.0\nOnVariable:\nBounds: {0, 1}\nDefault initial value: PowerSystems.get_status(device)","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Auxillary Variables:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"EnergyOutput","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Static Parameters:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Pg^textmin = PowerSystems.get_active_power_limits(device).min\nPg^textmax = PowerSystems.get_active_power_limits(device).max\nQg^textmin = PowerSystems.get_reactive_power_limits(device).min\nQg^textmax = PowerSystems.get_reactive_power_limits(device).max\nEg^textmax = PowerSystems.get_storage_capacity(device)","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Time Series Parameters:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"using PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.get_default_time_series_names(HydroEnergyReservoir, HydroCommitmentReservoirStorage)\ncombo_table = DataFrame(\n    \"Parameter\" => map(x -> \"[`$x`](@ref)\", collect(keys(combos))),\n    \"Default Time Series Name\" => map(x -> \"`$x`\", collect(values(combos))),\n    )\nmdtable(combo_table, latex = false)","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Objective:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Creates an objective function term based on the VariableCost Options where the quantity term is defined as Pg, and objective function terms for StorageManagementCost.","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Expressions:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Adds Pg and Qg terms to the respective active and reactive power balance expressions created by the selected Network Formulations","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Constraints:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"beginaligned\n  E_t+1 = E_t + (InflowTimeSeriesParameter_t - S_t - Pg_t) cdot Delta T \n  E_t - E^surplus_t + E^shortage_t = EnergyTargetTimeSeriesParameter_t \n  Pg_t - u_t Pg^textmax le 0 \n  Pg_t - u_t Pg^textmin ge 0 \n  Qg_t - u_t Qg^textmax le 0 \n  Qg_t - u_t Qg^textmin ge 0\nendaligned","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"","category":"page"},{"location":"formulation_library/HydroGen/#HydroCommitmentRunOfRiver","page":"Hydro Generation","title":"HydroCommitmentRunOfRiver","text":"","category":"section"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"HydroCommitmentRunOfRiver","category":"page"},{"location":"formulation_library/HydroGen/#PowerSimulations.HydroCommitmentRunOfRiver","page":"Hydro Generation","title":"PowerSimulations.HydroCommitmentRunOfRiver","text":"Formulation type to add commitment and injection variables constrained by a maximum injection time series for HydroGen\n\nHydroCommitmentRunOfRiver()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:110.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Variables:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"ActivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_active_power(device)\nReactivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_reactive_power(device)\nOnVariable:\nBounds: {0, 1}\nDefault initial value: PowerSystems.get_status(device)","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Static Parameters:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Pg^textmin = PowerSystems.get_active_power_limits(device).min\nQg^textmin = PowerSystems.get_reactive_power_limits(device).min\nQg^textmax = PowerSystems.get_reactive_power_limits(device).max","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Time Series Parameters:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"using PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.get_default_time_series_names(HydroGen, HydroCommitmentRunOfRiver)\ncombo_table = DataFrame(\n    \"Parameter\" => map(x -> \"[`$x`](@ref)\", collect(keys(combos))),\n    \"Default Time Series Name\" => map(x -> \"`$x`\", collect(values(combos))),\n    )\nmdtable(combo_table, latex = false)","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Objective:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Creates an objective function term based on the VariableCost Options where the quantity term is defined as Pg.","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Expressions:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Adds Pg and Qg terms to the respective active and reactive power balance expressions created by the selected Network Formulations","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"Constraints:","category":"page"},{"location":"formulation_library/HydroGen/","page":"Hydro Generation","title":"Hydro Generation","text":"beginaligned\n  Pg_t le Pg^textmax\n  Pg_t - u_t Pg^textmax le 0 \n  Pg_t - u_t Pg^textmin ge 0 \n  Qg_t - u_t Qg^textmax le 0 \n  Qg_t - u_t Qg^textmin ge 0\nendaligned","category":"page"},{"location":"modeler_guide/psi_structure/#psi_structure","page":"PowerSimulations.jl Modeling Structure","title":"PowerSimulations.jl Modeling Structure","text":"","category":"section"},{"location":"modeler_guide/psi_structure/","page":"PowerSimulations.jl Modeling Structure","title":"PowerSimulations.jl Modeling Structure","text":"PowerSimulations enables the simulation of a sequence of power systems optimization problems and provides user control over each aspect of the simulation configuration. Specifically:","category":"page"},{"location":"modeler_guide/psi_structure/","page":"PowerSimulations.jl Modeling Structure","title":"PowerSimulations.jl Modeling Structure","text":"mathematical formulations can be selected for each component with DeviceModel and ServiceModel\na problem can be defined by creating model entries in a Operations ProblemTemplates\nmodels (DecisionModel or EmulationModel) can be built by applying a ProblemTemplate to a System and can be executed/solved in isolation or as part of a Simulation\nSimulations can be defined and executed by sequencing one or more models and defining how and when data flows between models.","category":"page"},{"location":"modeler_guide/psi_structure/","page":"PowerSimulations.jl Modeling Structure","title":"PowerSimulations.jl Modeling Structure","text":"question: What is the difference between a Model and a Problem?\nA \"Problem\" is an abstract mathematical description of how to represent power system behavior, whereas a \"Model\" is a concrete representation of a \"Problem\" applied to a dataset. I.e. once a Problem is populated with data describing all the loads, generators, lines, etc., it becomes a Model.","category":"page"},{"location":"formulation_library/General/#formulation_library","page":"General","title":"Formulations","text":"","category":"section"},{"location":"formulation_library/General/","page":"General","title":"General","text":"Modeling formulations are created by dispatching on abstract subtypes of PowerSimulations.AbstractDeviceFormulation","category":"page"},{"location":"formulation_library/General/#FixedOutput","page":"General","title":"FixedOutput","text":"","category":"section"},{"location":"formulation_library/General/","page":"General","title":"General","text":"FixedOutput","category":"page"},{"location":"formulation_library/General/#PowerSimulations.FixedOutput","page":"General","title":"PowerSimulations.FixedOutput","text":"Formulation type to augment the power balance constraint expression with a time series parameter\n\nFixedOutput()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/device_model.jl:4.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/General/","page":"General","title":"General","text":"Variables:","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"No variables are created for DeviceModel(<:DeviceType, FixedOutput)","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"Static Parameters:","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"ThermalGen:\nPg^textmax = PowerSystems.get_max_active_power(device)\nQg^textmax = PowerSystems.get_max_reactive_power(device)\nStorage:\nPg^textmax = PowerSystems.get_max_active_power(device)\nQg^textmax = PowerSystems.get_max_reactive_power(device)","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"Time Series Parameters:","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"using PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombo_tables = []\nfor t in [RenewableGen, ThermalGen, HydroGen, Storage, ElectricLoad]\n    combos = PowerSimulations.get_default_time_series_names(t, FixedOutput)\n    combo_table = DataFrame(\n        \"Parameter\" => map(x -> \"[`$x`](@ref)\", collect(keys(combos))),\n        \"Default Time Series Name\" => map(x -> \"`$x`\", collect(values(combos))),\n        )\n    insertcols!(combo_table, 1, \"Device Type\" => fill(string(t), length(combos)))\n    push!(combo_tables, combo_table)\nend\nmdtable(vcat(combo_tables...), latex = false)","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"Objective:","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"No objective terms are created for DeviceModel(<:DeviceType, FixedOutput)","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"Expressions:","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"Adds the active and reactive parameters listed for specific device types above to the respective active and reactive power balance expressions created by the selected Network Formulations","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"Constraints:","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"No constraints are created for DeviceModel(<:DeviceType, FixedOutput)","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"","category":"page"},{"location":"formulation_library/General/#VariableCost-Options","page":"General","title":"VariableCost Options","text":"","category":"section"},{"location":"formulation_library/General/","page":"General","title":"General","text":"PowerSimulations can represent variable costs using a variety of different methods depending on the data available in each device. The following describes the objective function terms that are populated for each variable cost option.","category":"page"},{"location":"formulation_library/General/#Scalar-VariableCost","page":"General","title":"Scalar VariableCost","text":"","category":"section"},{"location":"formulation_library/General/","page":"General","title":"General","text":"variable_cost <: Float64: creates a fixed marginal cost term in the objective function","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"beginaligned\n  textmin sum_t C * G_t\nendaligned","category":"page"},{"location":"formulation_library/General/#Polynomial-VariableCost","page":"General","title":"Polynomial VariableCost","text":"","category":"section"},{"location":"formulation_library/General/","page":"General","title":"General","text":"variable_cost <: Tuple{Float64, Float64}: creates a polynomial cost term in the objective function where","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"C_g=variable_cost[1]\nC_g^prime=variable_cost[2]","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"beginaligned\n  textmin sum_t C * G_t + C^prime * G_t^2\nendaligned","category":"page"},{"location":"formulation_library/General/#Piecewise-Linear-VariableCost","page":"General","title":"Piecewise Linear VariableCost","text":"","category":"section"},{"location":"formulation_library/General/","page":"General","title":"General","text":"variable_cost <: Vector{Tuple{Float64, Float64}}: creates a piecewise linear cost term in the objective function ","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"TODO: add formulation ","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"___","category":"page"},{"location":"formulation_library/General/#StorageManagementCost","page":"General","title":"StorageManagementCost","text":"","category":"section"},{"location":"formulation_library/General/","page":"General","title":"General","text":"Adds an objective function cost term according to:","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"beginaligned\n  textmin sum_t quad E^surplus_t * C^penalty - E^shortage_t * C^value \nendaligned","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"Impact of different cost configurations:","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"The following table describes all possible configuration of the StorageManagementCost with the target constraint in hydro or storage device models. Cases 1(a) & 2(a) will have no impact of the models operations and the target constraint will be rendered useless. In most cases that have no energy target and a non-zero value for C^value, if this cost is too high (C^value  0) or too low (C^value 0) can result in either the model holding on to stored energy till the end or the model not storing any energy in the device. This is caused by the fact that when energy target is zero, we have E_t = - E^shortage_t, and - E^shortage_t * C^value in the objective function is replaced by E_t * C^value, thus resulting in C^value to be seen as the cost of stored energy.","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"Case Energy Target Energy Shortage Cost Energy Value / Energy Surplus cost Effect\nCase 1(a) hatE=0 C^penalty=0 C^value=0 no change\nCase 1(b) hatE=0 C^penalty=0 C^value0 penalty for storing energy\nCase 1(c) hatE=0 C^penalty0 C^value=0 no penalties or incentives applied\nCase 1(d) hatE=0 C^penalty=0 C^value0 incentive for storing energy\nCase 1(e) hatE=0 C^penalty0 C^value0 penalty for storing energy\nCase 1(f) hatE=0 C^penalty0 C^value0 incentive for storing energy\nCase 2(a) hatE0 C^penalty=0 C^value=0 no change\nCase 2(b) hatE0 C^penalty=0 C^value0 penalty on energy storage in excess of target\nCase 2(c) hatE0 C^penalty0 C^value=0 penalty on energy storage short of target\nCase 2(d) hatE0 C^penalty=0 C^value0 incentive on excess energy\nCase 2(e) hatE0 C^penalty0 C^value0 penalty on both excess/shortage of energy\nCase 2(f) hatE0 C^penalty0 C^value0 penalty for shortage, incentive for excess energy","category":"page"},{"location":"modeler_guide/logging/#Logging","page":"Logging","title":"Logging","text":"","category":"section"},{"location":"modeler_guide/logging/","page":"Logging","title":"Logging","text":"PowerSimulations.jl will output many log messages when building systems and running simulations. You may want to customize what gets logged to the console and, optionally, a file.","category":"page"},{"location":"modeler_guide/logging/","page":"Logging","title":"Logging","text":"By default all log messages of level Logging.Info or higher will get displayed to the console.  When you run a simulation a simulation-specific logger will take over and log its messages to a file in the logs directory in the simulation output directory. When finished it will relinquish control back to the global logger.","category":"page"},{"location":"modeler_guide/logging/#Configuring-the-global-logger","page":"Logging","title":"Configuring the global logger","text":"","category":"section"},{"location":"modeler_guide/logging/","page":"Logging","title":"Logging","text":"To configure the global logger in a Jupyter Notebook or REPL you may configure your own logger with the Julia Logging standard library or use the convenience function provided by PowerSimulations.  This example will log messages of level Logging.Error to console and Logging.Info and higher to the file power-simulations.log in the current directory.","category":"page"},{"location":"modeler_guide/logging/","page":"Logging","title":"Logging","text":"import Logging\nusing PowerSimulations\nlogger = configure_logging(\n    console_level = Logging.Error,\n    file_level = Logging.Info,\n    filename = \"power-simulations.log\"\n)","category":"page"},{"location":"modeler_guide/logging/#Configuring-the-simulation-logger","page":"Logging","title":"Configuring the simulation logger","text":"","category":"section"},{"location":"modeler_guide/logging/","page":"Logging","title":"Logging","text":"You can configure the logging level used by the simulation logger when you call build!(simulation).  Here is an example that increases logging verbosity:","category":"page"},{"location":"modeler_guide/logging/","page":"Logging","title":"Logging","text":"import Logging\nusing PowerSimulations\nsimulation = Simulation(...)\nbuild!(simulation, console_level = Logging.Info, file_level = Logging.Debug)","category":"page"},{"location":"modeler_guide/logging/","page":"Logging","title":"Logging","text":"The log file will be located at <your-output-path>/<simulation-name>/<run-output-dir>/logs/simulation.log.","category":"page"},{"location":"modeler_guide/logging/#Solver-logs","page":"Logging","title":"Solver logs","text":"","category":"section"},{"location":"modeler_guide/logging/","page":"Logging","title":"Logging","text":"You can configure logging for the solver you use.  Refer to the solver documentation.  PowerSimulations does not redirect or intercept prints to stdout or stderr from other libraries.","category":"page"},{"location":"modeler_guide/logging/#Recorder-events","page":"Logging","title":"Recorder events","text":"","category":"section"},{"location":"modeler_guide/logging/","page":"Logging","title":"Logging","text":"PowerSimulations uses the InfrastructureSystems.Recorder to store simulation events in a log file.  Refer to this link for more information.","category":"page"},{"location":"formulation_library/RenewableGen/#PowerSystems.RenewableGen-Formulations","page":"Renewable Generation","title":"PowerSystems.RenewableGen Formulations","text":"","category":"section"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Valid DeviceModels for subtypes of RenewableGen include the following:","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"using PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.generate_device_formulation_combinations()\nfilter!(x -> x[\"device_type\"] <: RenewableGen, combos)\ncombo_table = DataFrame(\n    \"Valid DeviceModel\" => [\"`DeviceModel($(c[\"device_type\"]), $(c[\"formulation\"]))`\" for c in combos],\n    \"Device Type\" => [\"[$(c[\"device_type\"])](https://nrel-siip.github.io/PowerSystems.jl/stable/model_library/generated_$(c[\"device_type\"])/)\" for c in combos],\n    \"Formulation\" => [\"[$(c[\"formulation\"])](@ref)\" for c in combos],\n    )\nmdtable(combo_table, latex = false)","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"","category":"page"},{"location":"formulation_library/RenewableGen/#RenewableFullDispatch","page":"Renewable Generation","title":"RenewableFullDispatch","text":"","category":"section"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"RenewableFullDispatch","category":"page"},{"location":"formulation_library/RenewableGen/#PowerSimulations.RenewableFullDispatch","page":"Renewable Generation","title":"PowerSimulations.RenewableFullDispatch","text":"Formulation type to add injection variables constrained by a maximum injection time series for RenewableGen\n\nRenewableFullDispatch()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:134.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Variables:","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"ActivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_active_power(device)\nReactivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_reactive_power(device)","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Static Parameters:","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Pg^textmin = PowerSystems.get_active_power_limits(device).min\nQg^textmin = PowerSystems.get_reactive_power_limits(device).min\nQg^textmax = PowerSystems.get_reactive_power_limits(device).max","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Time Series Parameters:","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"using PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.get_default_time_series_names(RenewableGen, RenewableFullDispatch)\ncombo_table = DataFrame(\n    \"Parameter\" => map(x -> \"[`$x`](@ref)\", collect(keys(combos))),\n    \"Default Time Series Name\" => map(x -> \"`$x`\", collect(values(combos))),\n    )\nmdtable(combo_table, latex = false)","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Objective:","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Creates an objective function term based on the VariableCost Options where the quantity term is defined as - Pg_t to incentivize generation from RenewableGen devices.","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Expressions:","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Adds Pg and Qg terms to the respective active and reactive power balance expressions created by the selected Network Formulations","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Constraints:","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"beginaligned\n  Pg^textmin le Pg_t le ActivePowerTimeSeriesParameter_t \n  Qg^textmin le Qg_t le Qg^textmax\nendaligned","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"","category":"page"},{"location":"formulation_library/RenewableGen/#RenewableConstantPowerFactor","page":"Renewable Generation","title":"RenewableConstantPowerFactor","text":"","category":"section"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"RenewableConstantPowerFactor","category":"page"},{"location":"formulation_library/RenewableGen/#PowerSimulations.RenewableConstantPowerFactor","page":"Renewable Generation","title":"PowerSimulations.RenewableConstantPowerFactor","text":"Formulation type to add real and reactive injection variables with constant power factor with maximum real power injections constrained by a time series for RenewableGen\n\nRenewableConstantPowerFactor()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:139.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Variables:","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"ActivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_active_power(device)\nReactivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_reactive_power(device)","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Static Parameters:","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Pg^textmin = PowerSystems.get_active_power_limits(device).min\nQg^textmin = PowerSystems.get_reactive_power_limits(device).min\nQg^textmax = PowerSystems.get_reactive_power_limits(device).max\npf = PowerSystems.get_power_factor(device)","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Time Series Parameters:","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"using PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.get_default_time_series_names(RenewableGen, RenewableConstantPowerFactor)\ncombo_table = DataFrame(\n    \"Parameter\" => map(x -> \"[`$x`](@ref)\", collect(keys(combos))),\n    \"Default Time Series Name\" => map(x -> \"`$x`\", collect(values(combos))),\n    )\nmdtable(combo_table, latex = false)","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Objective:","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Creates an objective function term based on the VariableCost Options where the quantity term is defined as - Pg_t to incentivize generation from RenewableGen devices.","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Expressions:","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Adds Pg and Qg terms to the respective active and reactive power balance expressions created by the selected Network Formulations","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Constraints:","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"beginaligned\n  Pg^textmin le Pg_t le ActivePowerTimeSeriesParameter_t \n  Qg^textmin le Qg_t le Qg^textmax \n  Qg_t = pf * Pg_t\nendaligned","category":"page"},{"location":"formulation_library/Service/#PowerSystems.Service-Formulations","page":"PowerSystems.Service Formulations","title":"PowerSystems.Service Formulations","text":"","category":"section"},{"location":"formulation_library/Service/","page":"PowerSystems.Service Formulations","title":"PowerSystems.Service Formulations","text":"TODO","category":"page"},{"location":"model_developer_guide/adding_new_problem_model/#Adding-an-Operations-Problem-Model","page":"Adding Problems","title":"Adding an Operations Problem Model","text":"","category":"section"},{"location":"model_developer_guide/adding_new_problem_model/#Decision-Problem","page":"Adding Problems","title":"Decision Problem","text":"","category":"section"},{"location":"model_developer_guide/adding_new_problem_model/#Emulation-Problem","page":"Adding Problems","title":"Emulation Problem","text":"","category":"section"},{"location":"formulation_library/README/#Formulation-documentation-guide","page":"Formulation documentation guide","title":"Formulation documentation guide","text":"","category":"section"},{"location":"formulation_library/README/","page":"Formulation documentation guide","title":"Formulation documentation guide","text":"Formulation documentation should roughly follow the template established by RenewableGen.md","category":"page"},{"location":"formulation_library/README/#Auto-generated-items","page":"Formulation documentation guide","title":"Auto generated items","text":"","category":"section"},{"location":"formulation_library/README/","page":"Formulation documentation guide","title":"Formulation documentation guide","text":"Valid DeviceModel table: just change the device category in the filter function\nTime Series Parameters: just change the device category and formulation in the get_defualt_time_series_names method call","category":"page"},{"location":"formulation_library/README/#Linked-items","page":"Formulation documentation guide","title":"Linked items","text":"","category":"section"},{"location":"formulation_library/README/","page":"Formulation documentation guide","title":"Formulation documentation guide","text":"Formulations in the Valid DeviceModel table must have a docstring in src/core/formulations.jl\nThe Formulation in the @docs block must have a docstring in src/core/formulations.jl\nThe Variables must have docstrings in src/core/variables.jl \nThe Time Series Paraemters must have docstrings in src/core/paramters.jl","category":"page"},{"location":"model_developer_guide/troubleshooting/#Troubleshooting-model-development","page":"Troubleshooting","title":"Troubleshooting model development","text":"","category":"section"},{"location":"model_developer_guide/adding_new_device_formulation/#Adding-Device-Formulations","page":"Adding Formulations","title":"Adding Device Formulations","text":"","category":"section"},{"location":"modeler_guide/running_a_simulation/#Simulation","page":"Simulation","title":"Simulation","text":"","category":"section"},{"location":"modeler_guide/running_a_simulation/","page":"Simulation","title":"Simulation","text":"tip: Always try to solve the operations problem first before putting together the simulation\nIt is not uncommon that when trying to solve a complex simulation the resulting models are infeasible. This situation can be the result of many factors like the input data, the incorrect specification of the initial conditions for models with time dependencies or a poorly specified model. Therefore, it's highly recommended to run and analyze an Operations Problems that reflect the problems that will be included in a simulation prior to executing a simulation.","category":"page"},{"location":"modeler_guide/running_a_simulation/","page":"Simulation","title":"Simulation","text":"Check out the tutorial","category":"page"},{"location":"modeler_guide/running_a_simulation/#Feedforward","page":"Simulation","title":"Feedforward","text":"","category":"section"},{"location":"modeler_guide/running_a_simulation/","page":"Simulation","title":"Simulation","text":"TODO","category":"page"},{"location":"modeler_guide/running_a_simulation/#Sequencing","page":"Simulation","title":"Sequencing","text":"","category":"section"},{"location":"modeler_guide/running_a_simulation/","page":"Simulation","title":"Simulation","text":"TODO","category":"page"},{"location":"#PowerSimulations.jl","page":"Welcome Page","title":"PowerSimulations.jl","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"CurrentModule = PowerSimulations","category":"page"},{"location":"#Overview","page":"Welcome Page","title":"Overview","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"PowerSimulations.jl is a power system operations simulation tool developed as a flexible and open source software for quasi-static power systems simulations including Production Cost Models. PowerSimulations.jl tackles the issues of developing a simulation model in a modular way providing tools for the formulation of decision models and emulation models that can be solved independently or in an interconnected fashion.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"PowerSimulations.jl supports the workflows to develop simulations by separating the development of operations models and simulation models.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"Operation Models: Optimization model used to find the solution of an operation problem.\nSimulations Models: Defined the requirements to find solutions to a sequence of operation problems in a way that resembles the procedures followed by operators.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"The most common Simulation Model is the solution of a Unit Commitment and Economic Dispatch sequence of problems. This model is used in commercial Production Cost Modeling tools, but it has a limited scope of analysis.","category":"page"},{"location":"#How-the-documentation-is-structured","page":"Welcome Page","title":"How the documentation is structured","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"PowerSimulations.jl documentation and code are organized according to the needs of different users depending on their skillset and requirements. In broad terms there are three categories:","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"Modeler: Users that want to solve an operations problem or run a simulation using the existing models in PowerSimulations.jl. For instance, answer questions about the change in operation costs in future fuel mixes. Check the formulations library page to choose a modeling strategy that fits your needs.\nModel Developer: Users that want to develop custom models and workflows for the simulation of a power system operation. For instance, study the impacts of an stochastic optimization problem over a deterministic.\nCode Base Developers: Users that want to add new core functionalities or fix bugs in the core capabilities of PowerSimulations.jl.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"PowerSimulations.jl is an active project under development, and we welcome your feedback, suggestions, and bug reports.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"Note: PowerSimulations.jl uses the data model implemented in PowerSystems.jl to construct optimization models. In most cases, you need to add PowerSystems.jl to your scripts.","category":"page"},{"location":"#Installation","page":"Welcome Page","title":"Installation","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"The latest stable release of PowerModels can be installed using the Julia package manager with","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"] add PowerSimulations","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"For the current development version, \"checkout\" this package with","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"] add PowerSimulations#master","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"An appropriate optimization solver is required for running PowerSimulations models. Refer to JuMP.jl solver's page to select the most appropriate for the application of interest.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"PowerSystems has been developed as part of the Scalable Integrated Infrastructure Planning (SIIP) initiative at the U.S. Department of Energy's National Renewable Energy Laboratory (NREL).","category":"page"},{"location":"formulation_library/Load/#PowerSystems.ElectricLoad-Formulations","page":"Load","title":"PowerSystems.ElectricLoad Formulations","text":"","category":"section"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Valid DeviceModels for subtypes of ElectricLoad include the following:","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"using PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.generate_device_formulation_combinations()\nfilter!(x -> x[\"device_type\"] <: ElectricLoad, combos)\ncombo_table = DataFrame(\n    \"Valid DeviceModel\" => [\"`DeviceModel($(c[\"device_type\"]), $(c[\"formulation\"]))`\" for c in combos],\n    \"Device Type\" => [\"[$(c[\"device_type\"])](https://nrel-siip.github.io/PowerSystems.jl/stable/model_library/generated_$(c[\"device_type\"])/)\" for c in combos],\n    \"Formulation\" => [\"[$(c[\"formulation\"])](@ref)\" for c in combos],\n    )\nmdtable(combo_table, latex = false)","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"","category":"page"},{"location":"formulation_library/Load/#StaticPowerLoad","page":"Load","title":"StaticPowerLoad","text":"","category":"section"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"StaticPowerLoad","category":"page"},{"location":"formulation_library/Load/#PowerSimulations.StaticPowerLoad","page":"Load","title":"PowerSimulations.StaticPowerLoad","text":"Formulation type to add a time series paraemter for non-dispatchable ElectricLoad withdrawls to power balance constraints\n\nStaticPowerLoad()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:63.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Variables:","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"No variables are created","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Time Series Parameters:","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"using PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.get_default_time_series_names(ElectricLoad, StaticPowerLoad)\ncombo_table = DataFrame(\n    \"Parameter\" => map(x -> \"[`$x`](@ref)\", collect(keys(combos))),\n    \"Default Time Series Name\" => map(x -> \"`$x`\", collect(values(combos))),\n    )\nmdtable(combo_table, latex = false)","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Expressions:","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Subtracts the parameters listed above from the respective active and reactive power balance expressions created by the selected Network Formulations","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Constraints:","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"No constraints are created","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"","category":"page"},{"location":"formulation_library/Load/#InterruptiblePowerLoad","page":"Load","title":"InterruptiblePowerLoad","text":"","category":"section"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"InterruptiblePowerLoad","category":"page"},{"location":"formulation_library/Load/#PowerSimulations.InterruptiblePowerLoad","page":"Load","title":"PowerSimulations.InterruptiblePowerLoad","text":"Formulation type to enable (binary) load interruptions\n\nInterruptiblePowerLoad()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:68.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Variables:","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"ActivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: 0.0\nReactivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: 0.0\nOnVariable:\nBounds: {0,1}\nDefault initial value: 1","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Time Series Parameters:","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"using PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.get_default_time_series_names(ElectricLoad, InterruptiblePowerLoad)\ncombo_table = DataFrame(\n    \"Parameter\" => map(x -> \"[`$x`](@ref)\", collect(keys(combos))),\n    \"Default Time Series Name\" => map(x -> \"`$x`\", collect(values(combos))),\n    )\nmdtable(combo_table, latex = false)","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Objective:","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Creates an objective function term based on the VariableCost Options where the quantity term is defined as Pg.","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Expressions:","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Adds Pg and Qg terms and to the respective active and reactive power balance expressions created by the selected Network Formulations\nSubtracts the time series parameters listed above terms from the respective active and reactive power balance expressions created by the selected Network Formulations","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Constraints:","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Pg and Qg represent the \"unserved\" active and reactive power loads","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"beginaligned\n  Pg_t le ActivePowerTimeSeriesParameter_t\n  Pg_t - u_t ActivePowerTimeSeriesParameter_t le 0 \n  Qg_t le ReactivePowerTimeSeriesParameter_t\n  Qg_t - u_t ReactivePowerTimeSeriesParameter_tle 0 \nendaligned","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"","category":"page"},{"location":"formulation_library/Load/#DispatchablePowerLoad","page":"Load","title":"DispatchablePowerLoad","text":"","category":"section"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"DispatchablePowerLoad","category":"page"},{"location":"formulation_library/Load/#PowerSimulations.DispatchablePowerLoad","page":"Load","title":"PowerSimulations.DispatchablePowerLoad","text":"Formulation type to enable (continuous) load interruption dispatch\n\nDispatchablePowerLoad()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:73.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Variables:","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"ActivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_active_power(device)\nReactivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_reactive_power(device)","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Time Series Parameters:","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"using PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.get_default_time_series_names(ElectricLoad, DispatchablePowerLoad)\ncombo_table = DataFrame(\n    \"Parameter\" => map(x -> \"[`$x`](@ref)\", collect(keys(combos))),\n    \"Default Time Series Name\" => map(x -> \"`$x`\", collect(values(combos))),\n    )\nmdtable(combo_table, latex = false)","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Objective:","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Creates an objective function term based on the VariableCost Options where the quantity term is defined as Pg.","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Expressions:","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Adds Pg and Qg terms and to the respective active and reactive power balance expressions created by the selected Network Formulations\nSubtracts the time series parameters listed above terms from the respective active and reactive power balance expressions created by the selected Network Formulations","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Constraints:","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Pg and Qg represent the \"unserved\" active and reactive power loads","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"beginaligned\n  Pg_t le ActivePowerTimeSeriesParameter_t\n  Qg_t le ReactivePowerTimeSeriesParameter_t\nendaligned","category":"page"},{"location":"code_base_developer_guide/extending_powersimulations/#Extending-Source-Code-Functionalities","page":"Extending Source Code Functionalities","title":"Extending Source Code Functionalities","text":"","category":"section"},{"location":"code_base_developer_guide/extending_powersimulations/#Enable-other-recorder-events","page":"Extending Source Code Functionalities","title":"Enable other recorder events","text":"","category":"section"},{"location":"code_base_developer_guide/extending_powersimulations/","page":"Extending Source Code Functionalities","title":"Extending Source Code Functionalities","text":"Other types of recorder events can be enabled with a possible performance impact. To do this pass in the specific recorder names to be enabled when you call build.","category":"page"},{"location":"code_base_developer_guide/extending_powersimulations/","page":"Extending Source Code Functionalities","title":"Extending Source Code Functionalities","text":"sim = Simulation(...)\nrecorders = [:execution]\nbuild!(sim; recorders = recorders)\nexecute!(sim)","category":"page"},{"location":"code_base_developer_guide/extending_powersimulations/","page":"Extending Source Code Functionalities","title":"Extending Source Code Functionalities","text":"Now we can examine InitialConditionUpdateEvents for specific steps and stages.","category":"page"},{"location":"code_base_developer_guide/extending_powersimulations/","page":"Extending Source Code Functionalities","title":"Extending Source Code Functionalities","text":"show_simulation_events(\n    PSI.InitialConditionUpdateEvent,\n    \"./output/aggregation/1\",\n    x -> x.initial_condition_type == \"DeviceStatus\";\n    step = 2,\n    stage = 1\n)\n┌─────────────────────────────┬─────────────────────┬────────────────────────┬─────────────────┬─────────────┬─────┬──────────────┐\n│                        name │     simulation_time │ initial_condition_type │     device_type │ device_name │ val │ stage_number │\n├─────────────────────────────┼─────────────────────┼────────────────────────┼─────────────────┼─────────────┼─────┼──────────────┤\n│ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Solitude │ 0.0 │            1 │\n│ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │   Park City │ 1.0 │            1 │\n│ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │        Alta │ 1.0 │            1 │\n│ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Brighton │ 1.0 │            1 │\n│ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Sundance │ 0.0 │            1 │\n└─────────────────────────────┴─────────────────────┴────────────────────────┴─────────────────┴─────────────┴─────┴──────────────┘","category":"page"},{"location":"code_base_developer_guide/extending_powersimulations/#Show-the-wall-time-with-your-events","page":"Extending Source Code Functionalities","title":"Show the wall time with your events","text":"","category":"section"},{"location":"code_base_developer_guide/extending_powersimulations/","page":"Extending Source Code Functionalities","title":"Extending Source Code Functionalities","text":"Sometimes you might want to see how the events line up with the wall time.","category":"page"},{"location":"code_base_developer_guide/extending_powersimulations/","page":"Extending Source Code Functionalities","title":"Extending Source Code Functionalities","text":"show_simulation_events(\n    PSI.InitialConditionUpdateEvent,\n    \"./output/aggregation/1\",\n    x -> x.initial_condition_type == \"DeviceStatus\";\n    step = 2,\n    stage = 1,\n    wall_time = true\n)\n┌─────────────────────────┬─────────────────────────────┬─────────────────────┬────────────────────────┬─────────────────┬─────────────┬─────┬──────────────┐\n│               timestamp │                        name │     simulation_time │ initial_condition_type │     device_type │ device_name │ val │ stage_number │\n├─────────────────────────┼─────────────────────────────┼─────────────────────┼────────────────────────┼─────────────────┼─────────────┼─────┼──────────────┤\n│ 2020-04-07T15:08:32.711 │ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Solitude │ 0.0 │            1 │\n│ 2020-04-07T15:08:32.711 │ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │   Park City │ 1.0 │            1 │\n│ 2020-04-07T15:08:32.711 │ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │        Alta │ 1.0 │            1 │\n│ 2020-04-07T15:08:32.711 │ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Brighton │ 1.0 │            1 │\n│ 2020-04-07T15:08:32.711 │ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Sundance │ 0.0 │            1 │\n└─────────────────────────┴─────────────────────────────┴─────────────────────┴────────────────────────┴─────────────────┴─────────────┴─────┴──────────────┘","category":"page"}]
}
