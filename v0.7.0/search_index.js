var documenterSearchIndex = {"docs":
[{"location":"man/simulation_recorder/#Simulation-Recorder","page":"Simulation Recorder","title":"Simulation Recorder","text":"","category":"section"},{"location":"man/simulation_recorder/","page":"Simulation Recorder","title":"Simulation Recorder","text":"PowerSimulations provides the ability to record structured data as events during a simulation. These events can be post-processed to help debug problems.","category":"page"},{"location":"man/simulation_recorder/","page":"Simulation Recorder","title":"Simulation Recorder","text":"By default only SimulationStepEvent and SimulationStageEvent are recorded.  Here is an example.","category":"page"},{"location":"man/simulation_recorder/","page":"Simulation Recorder","title":"Simulation Recorder","text":"Suppose a simulation is run in the directory ./output.","category":"page"},{"location":"man/simulation_recorder/","page":"Simulation Recorder","title":"Simulation Recorder","text":"Assume that setup commands have been run:","category":"page"},{"location":"man/simulation_recorder/","page":"Simulation Recorder","title":"Simulation Recorder","text":"using PowerSimulations\nconst PSI = PowerSimulations","category":"page"},{"location":"man/simulation_recorder/","page":"Simulation Recorder","title":"Simulation Recorder","text":"Note that for all functions below you can optionally specify a function to filter events. The function must accept the event type and return true or false.","category":"page"},{"location":"man/simulation_recorder/#Show-all-events-of-type-PSI.SimulationStepEvent","page":"Simulation Recorder","title":"Show all events of type PSI.SimulationStepEvent","text":"","category":"section"},{"location":"man/simulation_recorder/","page":"Simulation Recorder","title":"Simulation Recorder","text":"julia> show_simulation_events(PSI.SimulationStepEvent, \"./output/aggregation/1\")\n┌─────────────────────┬─────────────────────┬──────┬────────┐\n│                name │     simulation_time │ step │ status │\n├─────────────────────┼─────────────────────┼──────┼────────┤\n│ SimulationStepEvent │ 2024-01-01T00:00:00 │    1 │  start │\n│ SimulationStepEvent │ 2024-01-01T23:00:00 │    1 │   done │\n│ SimulationStepEvent │ 2024-01-01T23:00:00 │    2 │  start │\n│ SimulationStepEvent │ 2024-01-02T23:00:00 │    2 │   done │\n└─────────────────────┴─────────────────────┴──────┴────────┘","category":"page"},{"location":"man/simulation_recorder/#Show-events-of-type-PSI.SimulationStageEvent-for-a-specific-step-and-stage.","page":"Simulation Recorder","title":"Show events of type PSI.SimulationStageEvent for a specific step and stage.","text":"","category":"section"},{"location":"man/simulation_recorder/","page":"Simulation Recorder","title":"Simulation Recorder","text":"show_simulation_events(\n    PSI.SimulationStageEvent,\n    \"./output/aggregation/1\",\n    x -> x.step == 1 && x.stage == 2 && x.status == \"start\"\n)\n┌──────────────────────┬─────────────────────┬──────┬───────┬────────┐\n│                 name │     simulation_time │ step │ stage │ status │\n├──────────────────────┼─────────────────────┼──────┼───────┼────────┤\n│ SimulationStageEvent │ 2024-01-01T00:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T00:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T01:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T02:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T03:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T04:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T05:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T06:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T07:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T08:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T09:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T10:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T11:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T12:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T13:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T14:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T15:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T16:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T17:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T18:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T19:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T20:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T21:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T22:00:00 │    1 │     2 │  start │\n└──────────────────────┴─────────────────────┴──────┴───────┴────────┘","category":"page"},{"location":"man/simulation_recorder/#Enable-other-recorder-events","page":"Simulation Recorder","title":"Enable other recorder events","text":"","category":"section"},{"location":"man/simulation_recorder/","page":"Simulation Recorder","title":"Simulation Recorder","text":"Other types of recorder events can be enabled with a possible performance impact. To do this pass in the specific recorder names to be enabled when you call build.","category":"page"},{"location":"man/simulation_recorder/","page":"Simulation Recorder","title":"Simulation Recorder","text":"sim = Simulation(...)\nrecorders = [:simulation]\nbuild!(sim; recorders = recorders)\nexecute!(sim)","category":"page"},{"location":"man/simulation_recorder/","page":"Simulation Recorder","title":"Simulation Recorder","text":"Now we can examine InitialConditionUpdateEvents for specific steps and stages.","category":"page"},{"location":"man/simulation_recorder/","page":"Simulation Recorder","title":"Simulation Recorder","text":"show_simulation_events(\n    PSI.InitialConditionUpdateEvent,\n    \"./output/aggregation/1\",\n    x -> x.initial_condition_type == \"DeviceStatus\";\n    step = 2,\n    stage = 1\n)\n┌─────────────────────────────┬─────────────────────┬────────────────────────┬─────────────────┬─────────────┬─────┬──────────────┐\n│                        name │     simulation_time │ initial_condition_type │     device_type │ device_name │ val │ stage_number │\n├─────────────────────────────┼─────────────────────┼────────────────────────┼─────────────────┼─────────────┼─────┼──────────────┤\n│ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Solitude │ 0.0 │            1 │\n│ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │   Park City │ 1.0 │            1 │\n│ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │        Alta │ 1.0 │            1 │\n│ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Brighton │ 1.0 │            1 │\n│ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Sundance │ 0.0 │            1 │\n└─────────────────────────────┴─────────────────────┴────────────────────────┴─────────────────┴─────────────┴─────┴──────────────┘","category":"page"},{"location":"man/simulation_recorder/#Show-the-wall-time-with-your-events","page":"Simulation Recorder","title":"Show the wall time with your events","text":"","category":"section"},{"location":"man/simulation_recorder/","page":"Simulation Recorder","title":"Simulation Recorder","text":"Sometimes you might want to see how the events line up with the wall time.","category":"page"},{"location":"man/simulation_recorder/","page":"Simulation Recorder","title":"Simulation Recorder","text":"show_simulation_events(\n    PSI.InitialConditionUpdateEvent,\n    \"./output/aggregation/1\",\n    x -> x.initial_condition_type == \"DeviceStatus\";\n    step = 2,\n    stage = 1,\n    wall_time = true\n)\n┌─────────────────────────┬─────────────────────────────┬─────────────────────┬────────────────────────┬─────────────────┬─────────────┬─────┬──────────────┐\n│               timestamp │                        name │     simulation_time │ initial_condition_type │     device_type │ device_name │ val │ stage_number │\n├─────────────────────────┼─────────────────────────────┼─────────────────────┼────────────────────────┼─────────────────┼─────────────┼─────┼──────────────┤\n│ 2020-04-07T15:08:32.711 │ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Solitude │ 0.0 │            1 │\n│ 2020-04-07T15:08:32.711 │ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │   Park City │ 1.0 │            1 │\n│ 2020-04-07T15:08:32.711 │ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │        Alta │ 1.0 │            1 │\n│ 2020-04-07T15:08:32.711 │ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Brighton │ 1.0 │            1 │\n│ 2020-04-07T15:08:32.711 │ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Sundance │ 0.0 │            1 │\n└─────────────────────────┴─────────────────────────────┴─────────────────────┴────────────────────────┴─────────────────┴─────────────┴─────┴──────────────┘","category":"page"},{"location":"api/PowerSimulations/#PowerSimulations","page":"PowerSimulations","title":"PowerSimulations","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"PowerSimulations","title":"PowerSimulations","text":"CurrentModule = PowerSimulations\nDocTestSetup  = quote\n    using PowerSimulations\nend","category":"page"},{"location":"api/PowerSimulations/","page":"PowerSimulations","title":"PowerSimulations","text":"API documentation","category":"page"},{"location":"api/PowerSimulations/","page":"PowerSimulations","title":"PowerSimulations","text":"Pages = [\"PowerSimulations.md\"]","category":"page"},{"location":"api/PowerSimulations/#Index","page":"PowerSimulations","title":"Index","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"PowerSimulations","title":"PowerSimulations","text":"Pages = [\"PowerSimulations.md\"]","category":"page"},{"location":"api/PowerSimulations/#Exported","page":"PowerSimulations","title":"Exported","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"PowerSimulations","title":"PowerSimulations","text":"Modules = [PowerSimulations]\nPrivate = false","category":"page"},{"location":"api/PowerSimulations/#PowerSimulations.AGCReserveDeployment-Tuple{System}","page":"PowerSimulations","title":"PowerSimulations.AGCReserveDeployment","text":"AGCReserveDeployment(system::PSY.System; kwargs...)\n\nCreates an OperationsProblemTemplate with default DeviceModels for an AGC Reserve Deplyoment Problem. Uses the template to create an OperationsProblem.\n\nExample\n\nagc_problem = AGCReserveDeployment(system)\n\nAccepted Key Words\n\nKey word arguments supported by OperationsProblem\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.DeviceModel","page":"PowerSimulations","title":"PowerSimulations.DeviceModel","text":"DeviceModel(::Type{D}, ::Type{B}) where {D<:PSY.Device,\n                                   B<:AbstractDeviceFormulation}\n\nThis validates the device formulation for the Power System Device and the abstract device formulation and returns  Power System Device and the abstract device formulation if the power system device is a concrete type.\n\nArguments\n\n-::Type{D}: Power System Device -::Type{B}: Abstract Device Formulation\n\nOutputs\n\nDeviceModel(D, B, nothing): D::PSY.Device, B::AbstractDeviceFormulation\n\nExample\n\nbranches = Dict{Symbol, DeviceModel}\n    (:L => DeviceModel(PSY.Line, StaticLine),\n    :T => DeviceModel(PSY.Transformer2W, StaticTransformer),\n    :TT => DeviceModel(PSY.TapTransformer , StaticTransformer),\n    :dc_line => DeviceModel(PSY.HVDCLine, HVDCDispatch))\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.IntraStageChronology","page":"PowerSimulations","title":"PowerSimulations.IntraStageChronology","text":"InterStageChronology()\n\nType struct to select an information sharing model between stages that uses results from the same recent stage to calculate the initial conditions. This model ignores solutions from stages defined finer resolutions.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.OperationsProblem-Tuple{AbstractString}","page":"PowerSimulations","title":"PowerSimulations.OperationsProblem","text":"OperationsProblem(filename::AbstractString)\n\nConstruct an OperationsProblem from a serialized file.\n\nArguments\n\nfilename::AbstractString: path to serialized file\njump_model::Union{Nothing, JuMP.AbstractModel} = nothing: The JuMP model does not get  serialized. Callers should pass whatever they passed to the original problem.\noptimizer::Union{Nothing,JuMP.MOI.OptimizerWithAttributes} = nothing: The optimizer does  not get serialized. Callers should pass whatever they passed to the original problem.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.OperationsProblem-Union{Tuple{M}, Tuple{Type{M},OperationsProblemTemplate,System}, Tuple{Type{M},OperationsProblemTemplate,System,Union{Nothing, JuMP.AbstractModel}}} where M<:PowerSimulations.AbstractOperationsProblem","page":"PowerSimulations","title":"PowerSimulations.OperationsProblem","text":"OperationsProblem(::Type{M},\ntemplate::OperationsProblemTemplate,\nsys::PSY.System,\njump_model::Union{Nothing, JuMP.AbstractModel}=nothing;\nkwargs...) where {M<:AbstractOperationsProblem,\n                  T<:PM.AbstractPowerFormulation}\n\nThis builds the optimization problem of type M with the specific system and template.\n\nArguments\n\n::Type{M} where M<:AbstractOperationsProblem: The abstract operation model type\ntemplate::OperationsProblemTemplate: The model reference made up of transmission, devices,                                         branches, and services.\nsys::PSY.System: the system created using Power Systems\njump_model::Union{Nothing, JuMP.AbstractModel}: Enables passing a custom JuMP model. Use with care\n\nOutput\n\nop_problem::OperationsProblem: The operation model containing the model type, built JuMP model, Power\n\nSystems system.\n\nExample\n\ntemplate = OperationsProblemTemplate(CopperPlatePowerModel, devices, branches, services)\nOpModel = OperationsProblem(TestOpProblem, template, system)\n\nAccepted Key Words\n\nhorizon::Int: Manually specify the length of the forecast Horizon\ninitial_time::Dates.DateTime: Initial Time for the model solve\nuse_forecast_data::Bool : If true uses the data in the system forecasts. If false uses the data for current operating point in the system.\nPTDF::PTDF: Passes the PTDF matrix into the optimization model for StandardPTDFModel networks.\noptimizer::JuMP.MOI.OptimizerWithAttributes: The optimizer that will be used in the optimization model.\nuse_parameters::Bool: True will substitute will implement formulations using ParameterJuMP parameters. Defatul is false.\nwarm_start::Bool True will use the current operation point in the system to initialize variable values. False initializes all variables to zero. Default is true\nbalance_slack_variables::Bool True will add slacks to the system balance constraints\nservices_slack_variables::Bool True will add slacks to the services requirement constraints\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.OperationsProblem-Union{Tuple{T}, Tuple{M}, Tuple{Type{M},Type{T},System}, Tuple{Type{M},Type{T},System,Union{Nothing, JuMP.AbstractModel}}} where T<:PowerModels.AbstractPowerModel where M<:PowerSimulations.AbstractOperationsProblem","page":"PowerSimulations","title":"PowerSimulations.OperationsProblem","text":"OperationsProblem(op_problem::Type{M},\n                ::Type{T},\n                sys::PSY.System,\n                jump_model::Union{Nothing, JuMP.AbstractModel}=nothing;\n                kwargs...) where {M<:AbstractOperationsProblem,\n                                  T<:PM.AbstractPowerFormulation}\n\nReturn an unbuilt operation problem of type M with the specific system and network model T.     This constructor doesn't build any device model; it is meant to built device models individually using construct_device!\n\nArguments\n\n::Type{M} where M<:AbstractOperationsProblem: The abstract operation model type\n::Type{T} where T<:AbstractPowerModel: The abstract network formulation\nsys::PSY.System: the system created using Power Systems\njump_model::Union{Nothing, JuMP.AbstractModel}: Enables passing a custom JuMP model. Use with care\n\nOutput\n\nop_problem::OperationsProblem: The operation model containing the model type, unbuilt JuMP model, Power\n\nSystems system.\n\nExample\n\nOpModel = OperationsProblem(MyCustomOpProblem, DCPPowerModel, system)\nmodel = DeviceModel(ThermalStandard, ThermalStandardUnitCommitment)\nconstruct_device!(op_problem, :Thermal, model)\n\nAccepted Key Words\n\nhorizon::Int: Manually specify the length of the forecast Horizon\ninitial_time::Dates.DateTime: Initial Time for the model solve\nuse_forecast_data::Bool : If true uses the data in the system forecasts. If false uses the data for current operating point in the system.\nPTDF::PTDF: Passes the PTDF matrix into the optimization model for StandardPTDFModel networks.\noptimizer::JuMP.MOI.OptimizerWithAttributes: The optimizer that will be used in the optimization model.\nuse_parameters::Bool: True will substitute will implement formulations using ParameterJuMP parameters. Defatul is false.\nwarm_start::Bool True will use the current operation point in the system to initialize variable values. False initializes all variables to zero. Default is true\nbalance_slack_variables::Bool True will add slacks to the system balance constraints\nservices_slack_variables::Bool True will add slacks to the services requirement constraints\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.OperationsProblem-Union{Tuple{T}, Tuple{Type{T},System}, Tuple{Type{T},System,Union{Nothing, JuMP.AbstractModel}}} where T<:PowerModels.AbstractPowerModel","page":"PowerSimulations","title":"PowerSimulations.OperationsProblem","text":"OperationsProblem(::Type{T},\n                sys::PSY.System,\n                jump_model::Union{Nothing, JuMP.AbstractModel}=nothing;\n                kwargs...) where {M<:AbstractOperationsProblem,\n                                  T<:PM.AbstractPowerFormulation}\n\nReturn an unbuilt operation problem of type GenericOpProblem with the specific system and network model T.     This constructor doesn't build any device model; it is meant to built device models individually using construct_device!\n\nArguments\n\n::Type{T} where T<:AbstractPowerModel: The abstract network formulation\nsys::PSY.System: the system created using Power Systems\njump_model::Union{Nothing, JuMP.AbstractModel}: Enables passing a custom JuMP model. Use with care\n\nOutput\n\nop_problem::OperationsProblem: The operation model containing the model type, unbuilt JuMP model, Power\n\nSystems system.\n\nExample\n\nOpModel = OperationsProblem(DCPPowerModel, system)\nmodel = DeviceModel(ThermalStandard, ThermalStandardUnitCommitment)\nconstruct_device!(op_problem, :Thermal, model)\n\nAccepted Key Words\n\nhorizon::Int: Manually specify the length of the forecast Horizon\ninitial_time::Dates.DateTime: Initial Time for the model solve\nuse_forecast_data::Bool : If true uses the data in the system forecasts. If false uses the data for current operating point in the system.\nPTDF::PTDF: Passes the PTDF matrix into the optimization model for StandardPTDFModel networks.\noptimizer::JuMP.MOI.OptimizerWithAttributes: The optimizer that will be used in the optimization model.\nuse_parameters::Bool: True will substitute will implement formulations using ParameterJuMP parameters. Defatul is false.\nwarm_start::Bool True will use the current operation point in the system to initialize variable values. False initializes all variables to zero. Default is true\nbalance_slack_variables::Bool True will add slacks to the system balance constraints\nservices_slack_variables::Bool True will add slacks to the services requirement constraints\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.OperationsProblemTemplate-Union{Tuple{Type{T}}, Tuple{T}} where T<:PowerModels.AbstractPowerModel","page":"PowerSimulations","title":"PowerSimulations.OperationsProblemTemplate","text":"OperationsProblemTemplate(::Type{T}) where {T<:PM.AbstractPowerFormulation}\n\nCreates a model reference of the Power Formulation, devices, branches, and services.\n\nArguments\n\nmodel::Type{T<:PM.AbstractPowerFormulation}:\ndevices::Dict{Symbol, DeviceModel}: device dictionary\nbranches::Dict{Symbol, BranchModel}: branch dictionary\nservices::Dict{Symbol, ServiceModel}: service dictionary\n\nExample\n\ntemplate = OperationsProblemTemplate(CopperPlatePowerModel, devices, branches, services)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.RecedingHorizon","page":"PowerSimulations","title":"PowerSimulations.RecedingHorizon","text":"RecedingHorizon(period::Int)\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.Simulation","page":"PowerSimulations","title":"PowerSimulations.Simulation","text":"Simulation(steps::Int\n            stages::Dict{String, Stage{<:AbstractOperationsProblem}}\n            sequence::Union{Nothing, SimulationSequence}\n            simulation_folder::String\n            name::String\n            internal::Union{Nothing, SimulationInternal}\n            )\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.Simulation-Tuple{AbstractString,Dict}","page":"PowerSimulations","title":"PowerSimulations.Simulation","text":"Simulation(directory::AbstractString)\n\nConstructs Simulation from a serialized directory. Callers should pass any kwargs here that they passed to the original Simulation.\n\nArguments\n\ndirectory::AbstractString: the directory returned from the call to serialize\nstage_info::Dict: Two-level dictionary containing stage parameters that cannot be serialized. The outer dict should be keyed by the stage name. The inner dict must contain 'optimizer' and may contain 'jump_model'. These should be the same values used for the original simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.SimulationSequence","page":"PowerSimulations","title":"PowerSimulations.SimulationSequence","text":"SimulationSequence(horizons::Dict{String, Int}\n                    step_resolution::Dates.TimePeriod\n                    intervals::Dict{String, <:Tuple{<:Dates.TimePeriod, <:FeedForwardChronology}}\n                    order::Dict{Int, String}\n                    feedforward_chronologies::Dict{Pair{String, String}, <:FeedForwardChronology}\n                    feedforward::Dict{Tuple{String, Symbol, Symbol}, <:AbstractAffectFeedForward}\n                    ini_cond_chronology::Dict{String, <:FeedForwardChronology}\n                    cache::Dict{String, AbstractCache}\n                    )\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.Stage","page":"PowerSimulations","title":"PowerSimulations.Stage","text":"Stage({M<:AbstractOperationsProblem}\n    template::OperationsProblemTemplate\n    sys::PSY.System\n    optimizer::JuMP.MOI.OptimizerWithAttributes\n    internal::Union{Nothing, StageInternal}\n    )\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.Stage-Union{Tuple{M}, Tuple{Type{M},OperationsProblemTemplate,System,MathOptInterface.OptimizerWithAttributes}, Tuple{Type{M},OperationsProblemTemplate,System,MathOptInterface.OptimizerWithAttributes,Union{Nothing, JuMP.AbstractModel}}} where M<:PowerSimulations.AbstractOperationsProblem","page":"PowerSimulations","title":"PowerSimulations.Stage","text":"Stage(::Type{M},\ntemplate::OperationsProblemTemplate,\nsys::PSY.System,\noptimizer::JuMP.MOI.OptimizerWithAttributes,\njump_model::Union{Nothing, JuMP.AbstractModel}=nothing;\nkwargs...) where {M<:AbstractOperationsProblem}\n\nThis builds the optimization problem of type M with the specific system and template for the simulation stage\n\nArguments\n\n::Type{M} where M<:AbstractOperationsProblem: The abstract operation model type\ntemplate::OperationsProblemTemplate: The model reference made up of transmission, devices,                                         branches, and services.\nsys::PSY.System: the system created using Power Systems\njump_model::Union{Nothing, JuMP.AbstractModel}: Enables passing a custom JuMP model. Use with care\n\nOutput\n\nStage::Stage: The operation model containing the model type, unbuilt JuMP model, Power\n\nSystems system.\n\nExample\n\ntemplate = OperationsProblemTemplate(CopperPlatePowerModel, devices, branches, services)\nstage = Stage(MyOpProblemType template, system, optimizer)\n\nAccepted Key Words\n\ninitial_time::Dates.DateTime: Initial Time for the model solve\nPTDF::PTDF: Passes the PTDF matrix into the optimization model for StandardPTDFModel networks.\nwarm_start::Bool True will use the current operation point in the system to initialize variable values. False initializes all variables to zero. Default is true\nbalance_slack_variables::Bool True will add slacks to the system balance constraints\nservices_slack_variables::Bool True will add slacks to the services requirement constraints\nexport_pwl_vars::Bool True will write the results of the piece-wise-linear intermediate variables. Slows down the simulation process significantly\nallow_fails::Bool  True will allow the simulation to continue if the optimizer can't find a solution. Use with care, can lead to unwanted behaviour or results\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.Synchronize","page":"PowerSimulations","title":"PowerSimulations.Synchronize","text":"Synchronize(periods::Int)\n\nDefines the co-ordination of time between Two stages.\n\nArguments\n\nperiods::Int: Number of time periods to grab data from\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.TimeStatusChange","page":"PowerSimulations","title":"PowerSimulations.TimeStatusChange","text":"Tracks the last time status of a device changed in a simulation\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.UnitCommitmentProblem-Tuple{System}","page":"PowerSimulations","title":"PowerSimulations.UnitCommitmentProblem","text":"UnitCommitmentProblem(system::PSY.System; kwargs...)\n\nCreates an OperationsProblemTemplate with default DeviceModels for a Unit Commitment problem. Uses the template to create an OperationsProblem.\n\nExample\n\nuc_problem = UnitCommitmentProblem(system)\n\nAccepted Key Words\n\nnetwork::Type{<:PM.AbstractPowerModel} : override default network model settings\ndevices::Dict{Symbol, DeviceModel} : override default DeviceModel settings\nbranches::Dict{Symbol, DeviceModel} : override default DeviceModel settings\nservices::Dict{Symbol, ServiceModel} : override default ServiceModel settings\nKey word arguments supported by OperationsProblem\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#InfrastructureSystems.write_results-Tuple{PowerSimulations.PSIResults,String}","page":"PowerSimulations","title":"InfrastructureSystems.write_results","text":"write_results(results::PSIResults, save_path::String)\n\nExports Operational Problem Results to a path\n\nArguments\n\nresults::OperationsProblemResults: results from the simulation\nsave_path::String: folder path where the files will be written\n\nAccepted Key Words\n\nfile_type = CSV: only CSV and featherfile are accepted\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.build!-Tuple{Simulation}","page":"PowerSimulations","title":"PowerSimulations.build!","text":"build!(sim::Simulation)\n\nBuild the Simulation and all stages.\n\nArguments\n\nsim::Simulation: simulation object\noutput_dir = nothing: If nothing then generate a unique name.\nrecorders::Vector{Symbol} = []: recorder names to register\nconsole_level = Logging.Error:\nfile_level = Logging.Info:\n\nThrows an exception if label is passed and the directory already exists.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.check_file_integrity-Tuple{String}","page":"PowerSimulations","title":"PowerSimulations.check_file_integrity","text":"check_file_integrity(path::String)\n\nChecks the hash value for each file made with the file is written with the new hash_value to verify the file hasn't been tampered with since written\n\nArguments\n\npath::String: this is the folder path that contains the results and the check.sha256 file\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.configure_logging-Tuple{}","page":"PowerSimulations","title":"PowerSimulations.configure_logging","text":"configure_logging(;\n    console_level = Logging.Error,\n    file_level = Logging.Info,\n    filename = \"power-simulations.log\",\n)\n\nCreates console and file loggers.\n\nNote: Log messages may not be written to the file until flush() or close() is called on the returned logger.\n\nArguments\n\nconsole_level = Logging.Error: level for console messages\nfile_level = Logging.Info: level for file messages\nfilename::String = power-simulations.log: log file\n\nExample\n\nlogger = configure_logging(console_level = Logging.Info)\n@info \"log message\"\nclose(logger)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,D},Type{S}}} where S<:PowerModels.AbstractActivePowerModel where D<:HydroCommitmentReservoirBudget where H<:HydroGen","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"Construct model for HydroGen with ReservoirBudget Commitment Formulation with only Active Power.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,D},Type{S}}} where S<:PowerModels.AbstractActivePowerModel where D<:HydroCommitmentRunOfRiver where H<:HydroGen","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"Construct model for HydroGen with RunOfRiver Commitment Formulation with only Active Power.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,D},Type{S}}} where S<:PowerModels.AbstractActivePowerModel where D<:PowerSimulations.AbstractHydroDispatchFormulation where H<:HydroGen","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"Construct model for HydroGen with RunOfRiver Dispatch Formulation with only Active Power.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,D},Type{S}}} where S<:PowerModels.AbstractPowerModel where D<:HydroCommitmentReservoirBudget where H<:HydroGen","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"Construct model for HydroGen with ReservoirBudget Commitment Formulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,D},Type{S}}} where S<:PowerModels.AbstractPowerModel where D<:HydroCommitmentRunOfRiver where H<:HydroGen","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"Construct model for HydroGen with RunOfRiver Commitment Formulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,D},Type{S}}} where S<:PowerModels.AbstractPowerModel where D<:PowerSimulations.AbstractHydroDispatchFormulation where H<:HydroGen","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"Construct model for HydroGen with RunOfRiver Dispatch Formulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{T,D},Type{S}}} where S<:PowerModels.AbstractActivePowerModel where D<:PowerSimulations.AbstractThermalFormulation where T<:ThermalGen","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"This function creates the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{T,D},Type{S}}} where S<:PowerModels.AbstractPowerModel where D<:PowerSimulations.AbstractThermalFormulation where T<:ThermalGen","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"This function creates the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,FixedOutput},Type{S}}} where S<:PowerModels.AbstractPowerModel where H<:HydroGen","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"Construct model for HydroGen with FixedOutput Formulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,HydroCommitmentReservoirStorage},Type{S}}} where S<:PowerModels.AbstractActivePowerModel where H<:HydroEnergyReservoir","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"Construct model for HydroGen with ReservoirStorage Dispatch Formulation with only Active Power\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,HydroCommitmentReservoirStorage},Type{S}}} where S<:PowerModels.AbstractPowerModel where H<:HydroEnergyReservoir","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"Construct model for HydroGen with ReservoirStorage Commitment Formulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,HydroDispatchPumpedStoragewReservation},Type{S}}} where S<:PowerModels.AbstractActivePowerModel where H<:HydroPumpedStorage","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"Construct model for HydroPumpedStorage with PumpedStorage Dispatch Formulation with reservation constraint with only Active Power\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,HydroDispatchPumpedStorage},Type{S}}} where S<:PowerModels.AbstractActivePowerModel where H<:HydroPumpedStorage","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"Construct model for HydroPumpedStorage with PumpedStorage Dispatch Formulation with only Active Power\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,HydroDispatchReservoirBudget},Type{S}}} where S<:PowerModels.AbstractActivePowerModel where H<:HydroEnergyReservoir","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"Construct model for HydroGen with ReservoirBudget Dispatch Formulation with only Active Power.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,HydroDispatchReservoirBudget},Type{S}}} where S<:PowerModels.AbstractPowerModel where H<:HydroEnergyReservoir","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"Construct model for HydroGen with ReservoirBudget Dispatch Formulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,HydroDispatchReservoirStorage},Type{S}}} where S<:PowerModels.AbstractActivePowerModel where H<:HydroEnergyReservoir","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"Construct model for HydroGen with ReservoirStorage Dispatch Formulation with only Active Power\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,HydroDispatchReservoirStorage},Type{S}}} where S<:PowerModels.AbstractPowerModel where H<:HydroEnergyReservoir","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"Construct model for HydroGen with ReservoirStorage Dispatch Formulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{RegulationDevice{T},DeviceLimitedRegulation},Type{S}}} where S<:PowerModels.AbstractPowerModel where T<:StaticInjection","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"This function creates the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{RegulationDevice{T},FixedOutput},Type{S}}} where S<:PowerModels.AbstractPowerModel where T<:StaticInjection","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"This function creates the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{RegulationDevice{T},ReserveLimitedRegulation},Type{S}}} where S<:PowerModels.AbstractPowerModel where T<:StaticInjection","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"This function creates the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{T,ThermalBasicUnitCommitment},Type{S}}} where S<:PowerModels.AbstractActivePowerModel where T<:ThermalGen","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"This function creates the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{T,ThermalBasicUnitCommitment},Type{S}}} where S<:PowerModels.AbstractPowerModel where T<:ThermalGen","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"This function creates the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{T,ThermalRampLimited},Type{S}}} where S<:PowerModels.AbstractActivePowerModel where T<:ThermalGen","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"This function creates the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{T,ThermalRampLimited},Type{S}}} where S<:PowerModels.AbstractPowerModel where T<:ThermalGen","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"This function creates the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_all_constraint_index-Tuple{OperationsProblem}","page":"PowerSimulations","title":"PowerSimulations.get_all_constraint_index","text":"\"Each Tuple corresponds to (conname, internalindex, moi_index)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_all_var_index-Tuple{OperationsProblem}","page":"PowerSimulations","title":"PowerSimulations.get_all_var_index","text":"\"Each Tuple corresponds to (conname, internalindex, moi_index)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.list_simulation_events-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Union{Nothing, Function}}} where T<:InfrastructureSystems.AbstractRecorderEvent","page":"PowerSimulations","title":"PowerSimulations.list_simulation_events","text":"list_simulation_events(\n    ::Type{T},\n    output_dir::AbstractString,\n    filter_func::Union{Nothing, Function} = nothing;\n    step = nothing,\n    stage = nothing,\n) where {T <: IS.AbstractRecorderEvent}\n\nList simulation events of type T in a simulation output directory.\n\nArguments\n\noutput_dir::AbstractString: Simulation output directory\nfilter_func::Union{Nothing, Function} = nothing: Refer to show_simulation_events.\nstep::Int = nothing: Filter events by step. Required if stage is passed.\nstage::Int = nothing: Filter events by stage.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.load_operation_results-Tuple{AbstractString}","page":"PowerSimulations","title":"PowerSimulations.load_operation_results","text":"results = load_operation_results(path)\n\nThis function can be used to load results from a folder of results from a single-step problem, or for a single foulder within a simulation.\n\nArguments\n\npath::AbstractString = folder path\ndirectory::AbstractString = \"2019-10-03T09-18-00\": the foulder name that contains\n\nfeather files of the results.\n\nExample\n\nresults = load_operation_results(\"/Users/test/2019-10-03T09-18-00\")\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.load_simulation_results-Tuple{SimulationResultsReference,String}","page":"PowerSimulations","title":"PowerSimulations.load_simulation_results","text":"load_simulation_results(sim_output, stage)\n\nThis function goes through the reference table of file paths and aggregates the results over time into a struct of type OperationsProblemResults\n\nArguments\n\nsim_output::SimulationResultsReference: the container for the reference dictionary created in execute!\nstage_number::String: The stage of the results getting parsed\n\nExample\n\nsim_output = execute!(simulation)\nresults = load_simulation_results(sim_output, \"stage_name\")\n\nAccepted Key Words\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.load_simulation_results-Tuple{String,String,Vararg{Any,N} where N}","page":"PowerSimulations","title":"PowerSimulations.load_simulation_results","text":"load_simulation_results(file_path, stage)\n\nThis function goes through the reference table of file paths and aggregates the results over time into a struct of type OperationsProblemResults\n\nArguments\n\nfile_path::String: the file path to the dated folder with the raw results\nstage_number::String: The stage of the results getting parsed\n\nExample\n\nexecute!(simulation)\nresults = load_simulation_results(\"file_path\", \"stage_name\")\n\nAccepted Key Words\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.make_references-Tuple{Simulation,String}","page":"PowerSimulations","title":"PowerSimulations.make_references","text":"make_references(sim::Simulation, date_run::String; kwargs...)\n\nCreates a dictionary of variables with a dictionary of stages that contains dataframes of date/step/and desired file path so that the results can be parsed sequentially by variable and stage type.\n\nNote: makereferences can only be run after runsim_model or else, the folder structure will not yet be populated with results\n\nArguments\n\nsim::Simulation = sim: simulation object created by Simulation()\ndate_run::String = \"2019-10-03T09-18-00\"`: the name of the file created\n\nthat contains the specific simulation run of the date run and \"-test\"\n\nExample\n\nsim = Simulation(\"Test\", 7, stages, \"/Users/yourusername/Desktop/\"; system_to_file = false)\nexecute!(sim::Simulation; kwargs...)\nreferences = make_references(sim, \"2019-10-03T09-18-00-test\")\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.show_recorder_events-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Union{Nothing, Function}}} where T<:InfrastructureSystems.AbstractRecorderEvent","page":"PowerSimulations","title":"PowerSimulations.show_recorder_events","text":"show_recorder_events(\n    ::Type{T},\n    filename::AbstractString,\n    filter_func::Union{Nothing, Function} = nothing;\n    wall_time = false,\n    kwargs...,\n) where {T <: IS.AbstractRecorderEvent}\n\nShow the events of type T in a recorder file.\n\nArguments\n\n::Type{T}: Recorder event type\nfilename::AbstractString: recorder filename\nfilter_func::Union{Nothing, Function} = nothing: Optional function that accepts an event  of type T and returns a Bool. Apply this function to each event and only return events  where the result is true.\nwall_time = false: If true, show the wall_time timestamp.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.show_simulation_events-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Union{Nothing, Function}}} where T<:InfrastructureSystems.AbstractRecorderEvent","page":"PowerSimulations","title":"PowerSimulations.show_simulation_events","text":"show_simulation_events(\n    ::Type{T},\n    output_dir::AbstractString,\n    filter_func::Union{Nothing,Function} = nothing;\n    step = nothing,\n    stage = nothing,\n    wall_time = false,\n    kwargs...,\n) where { T <: IS.AbstractRecorderEvent}\n\nShow all simulation events of type T in a simulation output directory.\n\nArguments\n\n::Type{T}: Recorder event type\noutput_dir::AbstractString: Simulation output directory\nfilter_func::Union{Nothing, Function} = nothing: Refer to show_recorder_events.\nstep::Int = nothing: Filter events by step. Required if stage is passed.\nstage::Int = nothing: Filter events by stage.\nwall_time = false: If true, show the wall_time timestamp.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.solve!-Union{Tuple{OperationsProblem{T}}, Tuple{T}} where T<:PowerSimulations.AbstractOperationsProblem","page":"PowerSimulations","title":"PowerSimulations.solve!","text":"solve!(op_problem::OperationsProblem; kwargs...)\n\nThis solves the operational model for a single instance and outputs results of type OperationsProblemResult\n\nArguments\n\nop_problem::OperationModel = op_problem: operation model\n\nExamples\n\nresults = solve!(OpModel)\n\nAccepted Key Words\n\nsave_path::String: If a file path is provided the results\n\nautomatically get written to feather files\n\noptimizer::MOI.OptimizerWithAttributes: The optimizer that is used to solve the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.template_agc_reserve_deployment-Tuple{}","page":"PowerSimulations","title":"PowerSimulations.template_agc_reserve_deployment","text":"template_agc_reserve_deployment(; kwargs...)\n\nCreates an OperationsProblemTemplate with default DeviceModels for an AGC Reserve Deplyment Problem. This model doesn't support customization\n\nExample\n\ntemplate = agc_reserve_deployment()\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.template_economic_dispatch-Tuple{}","page":"PowerSimulations","title":"PowerSimulations.template_economic_dispatch","text":"template_economic_dispatch(; kwargs...)\n\nCreates an OperationsProblemTemplate with default DeviceModels for an Economic Dispatch problem.\n\nExample\n\ntemplate = template_economic_dispatch()\n\nAccepted Key Words\n\nnetwork::Type{<:PM.AbstractPowerModel} : override default network model settings\ndevices::Dict{Symbol, DeviceModel} : override default DeviceModel settings\nbranches::Dict{Symbol, DeviceModel} : override default DeviceModel settings\nservices::Dict{Symbol, ServiceModel} : override default ServiceModel settings\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.template_unit_commitment-Tuple{}","page":"PowerSimulations","title":"PowerSimulations.template_unit_commitment","text":"template_unit_commitment(; kwargs...)\n\nCreates an OperationsProblemTemplate with default DeviceModels for a Unit Commitment problem.\n\nExample\n\ntemplate = template_unit_commitment()\n\nAccepted Key Words\n\nnetwork::Type{<:PM.AbstractPowerModel} : override default network model settings\ndevices::Dict{Symbol, DeviceModel} : override default DeviceModel settings\nbranches::Dict{Symbol, DeviceModel} : override default DeviceModel settings\nservices::Dict{Symbol, ServiceModel} : override default ServiceModel settings\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#Internal","page":"PowerSimulations","title":"Internal","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"PowerSimulations","title":"PowerSimulations","text":"Modules = [PowerSimulations]\nPublic = false","category":"page"},{"location":"api/PowerSimulations/#PowerSimulations.AbstractSimulationStatusEvent","page":"PowerSimulations","title":"PowerSimulations.AbstractSimulationStatusEvent","text":"All events subtyped from this need to be recorded under :simulation_status.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ActivePowerInVariable","page":"PowerSimulations","title":"PowerSimulations.ActivePowerInVariable","text":"Struct to dispatch the creation of Active Power Input Variables for 2-directional devices. for instance storage or pump-hydro\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ActivePowerOutVariable","page":"PowerSimulations","title":"PowerSimulations.ActivePowerOutVariable","text":"Struct to dispatch the creation of Active Power Output Variables for 2-directional devices. for instance storage or pump-hydro\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ActivePowerVariable","page":"PowerSimulations","title":"PowerSimulations.ActivePowerVariable","text":"Struct to dispatch the creation of Active Power Variables\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.AddVariableSpec-Tuple{}","page":"PowerSimulations","title":"PowerSimulations.AddVariableSpec","text":"Construct AddVariableSpec.\n\nAccepts a single variablename or a vector variablenames. One must be passed but not both.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.AddVariableSpec-Union{Tuple{T}, Tuple{Type{PowerSimulations.ActiveServiceVariable},PowerSimulations.PSIContainer,T}} where T<:Reserve","page":"PowerSimulations","title":"PowerSimulations.AddVariableSpec","text":"This function add the variables for reserves to the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.AddVariableSpec-Union{Tuple{U}, Tuple{Type{PowerSimulations.ActivePowerVariable},Type{U},PowerSimulations.PSIContainer}} where U<:Area","page":"PowerSimulations","title":"PowerSimulations.AddVariableSpec","text":"This function add the upwards scheduled regulation variables for power generation output to the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.AddVariableSpec-Union{Tuple{U}, Tuple{Type{PowerSimulations.AdditionalDeltaActivePowerDownVariable},Type{U},PowerSimulations.PSIContainer}} where U<:RegulationDevice","page":"PowerSimulations","title":"PowerSimulations.AddVariableSpec","text":"This function add the variables for power generation output to the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.AddVariableSpec-Union{Tuple{U}, Tuple{Type{PowerSimulations.AdditionalDeltaActivePowerUpVariable},Type{U},PowerSimulations.PSIContainer}} where U<:RegulationDevice","page":"PowerSimulations","title":"PowerSimulations.AddVariableSpec","text":"This function add the upwards scheduled regulation variables for power generation output to the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.AddVariableSpec-Union{Tuple{U}, Tuple{Type{PowerSimulations.DeltaActivePowerDownVariable},Type{U},PowerSimulations.PSIContainer}} where U<:Area","page":"PowerSimulations","title":"PowerSimulations.AddVariableSpec","text":"This function add the downwards scheduled regulation variables for power generation output to the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.AddVariableSpec-Union{Tuple{U}, Tuple{Type{PowerSimulations.DeltaActivePowerDownVariable},Type{U},PowerSimulations.PSIContainer}} where U<:RegulationDevice","page":"PowerSimulations","title":"PowerSimulations.AddVariableSpec","text":"This function add the downwards scheduled regulation variables for power generation output to the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.AddVariableSpec-Union{Tuple{U}, Tuple{Type{PowerSimulations.DeltaActivePowerUpVariable},Type{U},PowerSimulations.PSIContainer}} where U<:Area","page":"PowerSimulations","title":"PowerSimulations.AddVariableSpec","text":"This function add the upwards scheduled regulation variables for power generation output to the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.AddVariableSpec-Union{Tuple{U}, Tuple{Type{PowerSimulations.DeltaActivePowerUpVariable},Type{U},PowerSimulations.PSIContainer}} where U<:RegulationDevice","page":"PowerSimulations","title":"PowerSimulations.AddVariableSpec","text":"This function add the upwards scheduled regulation variables for power generation output to the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.AddVariableSpec-Union{Tuple{U}, Tuple{Type{PowerSimulations.SmoothACE},Type{U},PowerSimulations.PSIContainer}} where U<:AggregationTopology","page":"PowerSimulations","title":"PowerSimulations.AddVariableSpec","text":"This function adds the smooth ACE Variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.AddVariableSpec-Union{Tuple{U}, Tuple{T}, Tuple{Type{T},Type{U},PowerSimulations.PSIContainer}} where U<:HydroGen where T<:PowerSimulations.ActivePowerInVariable","page":"PowerSimulations","title":"PowerSimulations.AddVariableSpec","text":"This function add the variables for active power withdrawl to the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.AddVariableSpec-Union{Tuple{U}, Tuple{T}, Tuple{Type{T},Type{U},PowerSimulations.PSIContainer}} where U<:HydroGen where T<:PowerSimulations.ActivePowerOutVariable","page":"PowerSimulations","title":"PowerSimulations.AddVariableSpec","text":"This function add the variables for active power injection to the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.AddVariableSpec-Union{Tuple{U}, Tuple{T}, Tuple{Type{T},Type{U},PowerSimulations.PSIContainer}} where U<:HydroGen where T<:PowerSimulations.ActivePowerVariable","page":"PowerSimulations","title":"PowerSimulations.AddVariableSpec","text":"This function add the variables for active power to the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.AddVariableSpec-Union{Tuple{U}, Tuple{T}, Tuple{Type{T},Type{U},PowerSimulations.PSIContainer}} where U<:HydroGen where T<:PowerSimulations.EnergyVariable","page":"PowerSimulations","title":"PowerSimulations.AddVariableSpec","text":"This function add the variables for energy storage to the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.AddVariableSpec-Union{Tuple{U}, Tuple{T}, Tuple{Type{T},Type{U},PowerSimulations.PSIContainer}} where U<:HydroGen where T<:PowerSimulations.EnergyVariableDown","page":"PowerSimulations","title":"PowerSimulations.AddVariableSpec","text":"This function add the variables for lower energy storage to the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.AddVariableSpec-Union{Tuple{U}, Tuple{T}, Tuple{Type{T},Type{U},PowerSimulations.PSIContainer}} where U<:HydroGen where T<:PowerSimulations.EnergyVariableUp","page":"PowerSimulations","title":"PowerSimulations.AddVariableSpec","text":"This function add the variables for upper energy storage to the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.AddVariableSpec-Union{Tuple{U}, Tuple{T}, Tuple{Type{T},Type{U},PowerSimulations.PSIContainer}} where U<:HydroGen where T<:PowerSimulations.OnVariable","page":"PowerSimulations","title":"PowerSimulations.AddVariableSpec","text":"This function add the variables for power generation commitment to the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.AddVariableSpec-Union{Tuple{U}, Tuple{T}, Tuple{Type{T},Type{U},PowerSimulations.PSIContainer}} where U<:HydroGen where T<:PowerSimulations.ReactivePowerVariable","page":"PowerSimulations","title":"PowerSimulations.AddVariableSpec","text":"This function add the variables for reactive power to the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.AddVariableSpec-Union{Tuple{U}, Tuple{T}, Tuple{Type{T},Type{U},PowerSimulations.PSIContainer}} where U<:HydroGen where T<:PowerSimulations.ReserveVariable","page":"PowerSimulations","title":"PowerSimulations.AddVariableSpec","text":"This function adds the reservation variable for storage models\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.AddVariableSpec-Union{Tuple{U}, Tuple{T}, Tuple{Type{T},Type{U},PowerSimulations.PSIContainer}} where U<:HydroGen where T<:PowerSimulations.SpillageVariable","page":"PowerSimulations","title":"PowerSimulations.AddVariableSpec","text":"This function add the spillage variable for storage models\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.AddVariableSpec-Union{Tuple{U}, Tuple{T}, Tuple{Type{T},Type{U},PowerSimulations.PSIContainer}} where U<:ThermalGen where T<:PowerSimulations.ActivePowerVariable","page":"PowerSimulations","title":"PowerSimulations.AddVariableSpec","text":"This function add the variables for power generation output to the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.AddVariableSpec-Union{Tuple{U}, Tuple{T}, Tuple{Type{T},Type{U},PowerSimulations.PSIContainer}} where U<:ThermalGen where T<:PowerSimulations.OnVariable","page":"PowerSimulations","title":"PowerSimulations.AddVariableSpec","text":"This function add the variables for power generation commitment to the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.AddVariableSpec-Union{Tuple{U}, Tuple{T}, Tuple{Type{T},Type{U},PowerSimulations.PSIContainer}} where U<:ThermalGen where T<:PowerSimulations.ReactivePowerVariable","page":"PowerSimulations","title":"PowerSimulations.AddVariableSpec","text":"This function add the variables for power generation output to the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.DeviceRangeConstraintInfo","page":"PowerSimulations","title":"PowerSimulations.DeviceRangeConstraintInfo","text":"Data Container to construct range constraints\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.DeviceRangeConstraintSpec-Tuple{Type{#s109} where #s109<:PowerSimulations.RangeConstraint,Type{PowerSimulations.ReactivePowerVariable},Type{#s108} where #s108<:ElectricLoad,Type{#s107} where #s107<:PowerSimulations.AbstractControllablePowerLoadFormulation,Type{#s106} where #s106<:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward},Bool,Bool}","page":"PowerSimulations","title":"PowerSimulations.DeviceRangeConstraintSpec","text":"Reactive Power Constraints on Controllable Loads Assume Constant power_factor\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.DeviceRangeConstraintSpec-Tuple{}","page":"PowerSimulations","title":"PowerSimulations.DeviceRangeConstraintSpec","text":"Construct inputs for creating range constraints.\n\nArguments\n\nrange_constraint_spec::Vector{RangeConstraintSpec}: May be emtpy. timeseries_range_constraint_spec::Vector{TimeSeriesConstraintSpec}: May be empty. custom_psi_container_func::Union{Nothing, Function}: Optional function to add custom  constraints to the internals of a PSIContainer. Must accept PSIContainer, devices iterable,  and a subtype of AbstractDeviceFormulation. devices_filter_func::Union{Nothing, Function}: Optional function to filter the devices on\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s110} where #s110<:PowerSimulations.RangeConstraint,Type{PowerSimulations.ActivePowerVariable},Type{T},Type{#s109} where #s109<:PowerSimulations.AbstractHydroDispatchFormulation,Type{#s108} where #s108<:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward},Bool,Bool}} where T<:HydroGen","page":"PowerSimulations","title":"PowerSimulations.DeviceRangeConstraintSpec","text":"This function define the range constraint specs for the active power for dispatch Run of River formulations.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s110} where #s110<:PowerSimulations.RangeConstraint,Type{PowerSimulations.ActivePowerVariable},Type{T},Type{#s109} where #s109<:PowerSimulations.AbstractHydroReservoirFormulation,Type{#s108} where #s108<:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward},Bool,Bool}} where T<:HydroGen","page":"PowerSimulations","title":"PowerSimulations.DeviceRangeConstraintSpec","text":"This function define the range constraint specs for the active power for dispatch Reservoir formulations.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s110} where #s110<:PowerSimulations.RangeConstraint,Type{PowerSimulations.ActivePowerVariable},Type{T},Type{#s109} where #s109<:PowerSimulations.AbstractHydroUnitCommitment,Type{#s108} where #s108<:PowerModels.AbstractPowerModel,Nothing,Bool,Bool}} where T<:HydroGen","page":"PowerSimulations","title":"PowerSimulations.DeviceRangeConstraintSpec","text":"This function define the range constraint specs for the active power for commitment formulations (semi continuous).\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s110} where #s110<:PowerSimulations.RangeConstraint,Type{PowerSimulations.ActivePowerVariable},Type{T},Type{#s109} where #s109<:PowerSimulations.AbstractThermalDispatchFormulation,Type{#s108} where #s108<:PowerModels.AbstractPowerModel,Nothing,Bool,Bool}} where T<:ThermalGen","page":"PowerSimulations","title":"PowerSimulations.DeviceRangeConstraintSpec","text":"This function adds the active power limits of generators when there are no CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s110} where #s110<:PowerSimulations.RangeConstraint,Type{PowerSimulations.ActivePowerVariable},Type{T},Type{#s109} where #s109<:PowerSimulations.AbstractThermalFormulation,Type{#s108} where #s108<:PowerModels.AbstractPowerModel,Nothing,Bool,Bool}} where T<:ThermalGen","page":"PowerSimulations","title":"PowerSimulations.DeviceRangeConstraintSpec","text":"This function adds the active power limits of generators when there are CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s110} where #s110<:PowerSimulations.RangeConstraint,Type{PowerSimulations.ActivePowerVariable},Type{T},Type{#s109} where #s109<:ThermalDispatchNoMin,Type{#s108} where #s108<:PowerModels.AbstractPowerModel,Nothing,Bool,Bool}} where T<:ThermalGen","page":"PowerSimulations","title":"PowerSimulations.DeviceRangeConstraintSpec","text":"This function adds the active power limits of generators when there are     no CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s110} where #s110<:PowerSimulations.RangeConstraint,Type{PowerSimulations.ActivePowerVariable},Type{T},Type{#s109} where #s109<:ThermalMultiStartUnitCommitment,Type{#s108} where #s108<:PowerModels.AbstractPowerModel,Nothing,Bool,Bool}} where T<:ThermalMultiStart","page":"PowerSimulations","title":"PowerSimulations.DeviceRangeConstraintSpec","text":"This function adds the active power limits of generators. Constraint (17) & (18) from PGLIB\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s110} where #s110<:PowerSimulations.RangeConstraint,Type{PowerSimulations.ReactivePowerVariable},Type{T},Type{#s109} where #s109<:PowerSimulations.AbstractHydroDispatchFormulation,Type{#s108} where #s108<:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward},Bool,Bool}} where T<:HydroGen","page":"PowerSimulations","title":"PowerSimulations.DeviceRangeConstraintSpec","text":"This function define the range constraint specs for the reactive power for dispatch formulations.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s110} where #s110<:PowerSimulations.RangeConstraint,Type{PowerSimulations.ReactivePowerVariable},Type{T},Type{#s109} where #s109<:PowerSimulations.AbstractHydroUnitCommitment,Type{#s108} where #s108<:PowerModels.AbstractPowerModel,Nothing,Bool,Bool}} where T<:HydroGen","page":"PowerSimulations","title":"PowerSimulations.DeviceRangeConstraintSpec","text":"This function define the range constraint specs for the reactive power for commitment formulations (semi continuous).\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s110} where #s110<:PowerSimulations.RangeConstraint,Type{PowerSimulations.ReactivePowerVariable},Type{T},Type{#s109} where #s109<:PowerSimulations.AbstractThermalDispatchFormulation,Type{#s108} where #s108<:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward},Bool,Bool}} where T<:ThermalGen","page":"PowerSimulations","title":"PowerSimulations.DeviceRangeConstraintSpec","text":"This function adds the reactive  power limits of generators when there are CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s110} where #s110<:PowerSimulations.RangeConstraint,Type{PowerSimulations.ReactivePowerVariable},Type{T},Type{#s109} where #s109<:PowerSimulations.AbstractThermalFormulation,Type{#s108} where #s108<:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward},Bool,Bool}} where T<:ThermalGen","page":"PowerSimulations","title":"PowerSimulations.DeviceRangeConstraintSpec","text":"This function adds the reactive power limits of generators when there CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.NodalExpressionSpec-Union{Tuple{U}, Tuple{T}, Tuple{Type{T},Type{U},Bool}} where U<:PowerModels.AbstractPowerModel where T<:Device","page":"PowerSimulations","title":"PowerSimulations.NodalExpressionSpec","text":"Construct NodalExpressionSpec for specific types.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.UpdateRef","page":"PowerSimulations","title":"PowerSimulations.UpdateRef","text":"Reference for parameters update when present\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#Base.show-Tuple{IO,MIME{Symbol(\"text/plain\")},OperationsProblem}","page":"PowerSimulations","title":"Base.show","text":"Base.show(io::IO, ::MIME\"text/plain\", op_problem::OperationsProblem)\n\nThis function goes through the fields in OperationsProblem and then in OperationsProblemTemplate, if the field contains a Device model dictionary, it calls organizedevicemodel() & prints the data by field, key, value. If the field is not a Device model dictionary, and a value exists for that field it prints the value.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._allocate_execution_order-Tuple{Dict{Int64,Int64}}","page":"PowerSimulations","title":"PowerSimulations._allocate_execution_order","text":"Function calculates the total number of stage executions in the simulation and allocates the appropiate vector\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._calculate_interval_inner_counts-Tuple{Dict{Int64,String},Dict{String,Tuple{Dates.TimePeriod,#s113} where #s113<:PowerSimulations.FeedForwardChronology},Dates.TimePeriod}","page":"PowerSimulations","title":"PowerSimulations._calculate_interval_inner_counts","text":"_calculate_interval_inner_counts(order::Dict{Int,String},\n                                      intervals::Dict{String,<:Dates.TimePeriod},\n                                      step_resolution::Dates.TimePeriod)\n\nCalculates how many times a stage is executed for every interval of the previous stage\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._get_data_for_rocc-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,Type{T}}} where T<:ThermalGen","page":"PowerSimulations","title":"PowerSimulations._get_data_for_rocc","text":"This function gets the data for the generators for ramping constraints of thermal generators\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._get_data_for_tdc-Tuple{Array{InitialCondition,1},Array{InitialCondition,1},Dates.TimePeriod}","page":"PowerSimulations","title":"PowerSimulations._get_data_for_tdc","text":"If the fraction of hours that a generator has a duration constraint is less than the fraction of hours that a single time_step represents then it is not binding.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._get_data_startup_ic-Tuple{Array{InitialCondition,1}}","page":"PowerSimulations","title":"PowerSimulations._get_data_startup_ic","text":"This function gets the data for startup initial condition\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._update_stage!-Tuple{Stage,Simulation}","page":"PowerSimulations","title":"PowerSimulations._update_stage!","text":"Required update stage function call\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._write_psi_container-Tuple{PowerSimulations.PSIContainer,String}","page":"PowerSimulations","title":"PowerSimulations._write_psi_container","text":"Exports the OpModel JuMP object in MathOptFormat\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{St}, Tuple{PowerSimulations.PSIContainer,Type{#s110} where #s110<:PowerSimulations.RangeConstraint,Type{PowerSimulations.ReactivePowerVariable},InfrastructureSystems.FlattenIteratorWrapper{St},DeviceModel{St,D},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S<:PowerModels.AbstractPowerModel where D<:PowerSimulations.AbstractStorageFormulation where St<:Storage","page":"PowerSimulations","title":"PowerSimulations.add_constraints!","text":"This function adds the reactive  power limits of generators when there are CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,Type{T},Type{U},InfrastructureSystems.FlattenIteratorWrapper{V},DeviceModel{V,W},Type{X},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where X<:PowerModels.AbstractPowerModel where W<:PowerSimulations.AbstractDeviceFormulation where V<:Device where U<:PowerSimulations.VariableType where T<:PowerSimulations.RangeConstraint","page":"PowerSimulations","title":"PowerSimulations.add_constraints!","text":"Default implementation to add range constraints.\n\nUsers of this function must implement a method for DeviceRangeConstraintSpec for their specific types. Users may also implement custom activepowerconstraints! methods.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_to_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,MarketBidCost,Component}","page":"PowerSimulations","title":"PowerSimulations.add_to_cost!","text":"Adds to the models costs represented by PowerSystems Market-Bid costs\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_to_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,MultiStartCost,Component}","page":"PowerSimulations","title":"PowerSimulations.add_to_cost!","text":"Adds to the models costs represented by PowerSystems Multi-Start costs\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_to_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,ThreePartCost,Component}","page":"PowerSimulations","title":"PowerSimulations.add_to_cost!","text":"Adds to the models costs represented by PowerSystems ThreePart costs\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_to_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,TwoPartCost,Component}","page":"PowerSimulations","title":"PowerSimulations.add_to_cost!","text":"Adds to the models costs represented by PowerSystems TwoPart costs\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_variable!-Union{Tuple{D}, Tuple{PowerSimulations.PSIContainer,D,Symbol,Bool}, Tuple{PowerSimulations.PSIContainer,D,Symbol,Bool,Union{Nothing, Symbol}}, Tuple{PowerSimulations.PSIContainer,D,Symbol,Bool,Union{Nothing, Symbol},Float64}} where D<:Union{Array{#s95,1} where #s95<:Component, InfrastructureSystems.FlattenIteratorWrapper{#s58} where #s58<:Component}","page":"PowerSimulations","title":"PowerSimulations.add_variable!","text":"Adds a variable to the optimization model and to the affine expressions contained in the psi_container model according to the specified sign. Based on the inputs, the variable can be specified as binary.\n\nBounds\n\nlb_value_function <= varstart[name, t] <= ub_value_function\n\nIf binary = true:\n\nvarstart[name, t] in {0,1}\n\nLaTeX\n\nlb ge x^device_t le ub forall t\n\nx^device_t in 01 forall t iff textbinary = true\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\ndevices : Vector or Iterator with the devices\nvar_name::Symbol : Base Name for the variable\nbinary::Bool : Select if the variable is binary\nexpressionname::Symbol : Expressionname name stored in psi_container.expressions to add the variable\nsign::Float64 : sign of the addition of the variable to the expression_name. Default Value is 1.0\n\nAccepted Keyword Arguments\n\nubvalue : Provides the function over device to obtain the value for a upperbound\nlbvalue : Provides the function over device to obtain the value for a lowerbound. If the variable is meant to be positive define lb = x -> 0.0\ninitial_value : Provides the function over device to obtain the warm start value\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_variables!-Tuple{PowerSimulations.PSIContainer,Type{PowerSimulations.SteadyStateFrequencyDeviation}}","page":"PowerSimulations","title":"PowerSimulations.add_variables!","text":"Steady State deviation of the frequency\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_variables!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,Type{T},Union{Array{U,1}, InfrastructureSystems.FlattenIteratorWrapper{U}}}} where U<:Component where T<:PowerSimulations.VariableType","page":"PowerSimulations","title":"PowerSimulations.add_variables!","text":"Add variables to the PSIContainer for any component.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_variables!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,Type{T},U,Array{V,1}}} where V<:Device where U<:Reserve where T<:PowerSimulations.VariableType","page":"PowerSimulations","title":"PowerSimulations.add_variables!","text":"Add variables to the PSIContainer for a service.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.check_activeservice_variables-Tuple{PowerSimulations.PSIContainer,Array{#s111,1} where #s111<:Service}","page":"PowerSimulations","title":"PowerSimulations.check_activeservice_variables","text":"This function checks if the variables for reserves were created\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.commit_hydro_active_power_ub!-Union{Tuple{W}, Tuple{V}, Tuple{PowerSimulations.PSIContainer,Any,DeviceModel{V,W},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where W<:PowerSimulations.AbstractHydroUnitCommitment where V<:HydroGen","page":"PowerSimulations","title":"PowerSimulations.commit_hydro_active_power_ub!","text":"This function define the range constraint specs for the reactive power for Commitment Run of River formulation.     P = multiplier * P_max\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.commitment_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,D},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S<:PowerModels.AbstractPowerModel where D<:PowerSimulations.AbstractThermalFormulation where T<:ThermalGen","page":"PowerSimulations","title":"PowerSimulations.commitment_constraints!","text":"This function adds the Commitment Status constraint when there are CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.compute_sha256-Tuple{AbstractString}","page":"PowerSimulations","title":"PowerSimulations.compute_sha256","text":"Return the SHA 256 hash of a file.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.constraint_current_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel,Int64,Int64,Any,Any,Any,Any}","page":"PowerSimulations","title":"PowerSimulations.constraint_current_balance_ni_expr","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.constraint_current_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel,Int64}","page":"PowerSimulations","title":"PowerSimulations.constraint_current_balance_ni_expr","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractActivePowerModel,Int64,Int64,Any,Any,Any,Any}","page":"PowerSimulations","title":"PowerSimulations.constraint_power_balance_ni_expr","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel,Int64,Int64,Any,Any,Any,Any}","page":"PowerSimulations","title":"PowerSimulations.constraint_power_balance_ni_expr","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel,Int64}","page":"PowerSimulations","title":"PowerSimulations.constraint_power_balance_ni_expr","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_service!-Union{Tuple{SR}, Tuple{PowerSimulations.PSIContainer,Array{SR,1},System,ServiceModel{SR,GroupReserve},Dict{Symbol,DeviceModel},Array{#s111,1} where #s111<:DataType}} where SR<:StaticReserveGroup","page":"PowerSimulations","title":"PowerSimulations.construct_service!","text":"Constructs a service for StaticReserveGroup.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.container_spec-Union{Tuple{M}, Tuple{M,Vararg{Any,N} where N}} where M<:JuMP.AbstractModel","page":"PowerSimulations","title":"PowerSimulations.container_spec","text":"Returns the correct container spec for the selected type of JuMP Model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.cost_function!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,ThermalDispatchNoMin},Type{#s110} where #s110<:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where T<:ThermalGen","page":"PowerSimulations","title":"PowerSimulations.cost_function!","text":"Cost function for generators formulated as No-Min\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.cost_function!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,U},Type{#s108} where #s108<:PowerModels.AbstractPowerModel}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,U},Type{#s107} where #s107<:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where U<:PowerSimulations.AbstractDeviceFormulation where T<:Component","page":"PowerSimulations","title":"PowerSimulations.cost_function!","text":"Add variables to the PSIContainer for a service.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_commitment!-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Symbol,Tuple{Symbol,Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.device_commitment!","text":"Constructs multi-timestep constraint from initial conditions and binary variable tuple.\n\nConstraints\n\nvarstart + varstop <= 1.0\n\nIf t = 1:\n\nvaron[name, 1] == ic.value + varstart[name, 1] - varstop[name, 1]\n\nwhere ic in initial_condtions.\n\nIf t > 1:\n\nvaron[name, t] == varon[name, t-1] + varstart[name, t] - varstop[name, t]\n\nLaTeX\n\nx^on_t + x^off_t leq 10 forall t\n\nx^on_1 = x^on_init + x^start_1 - x^stop_1 text for  t = 1\n\nx^on_t = x^on_t-1 + x^start_t - x^stop_t forall t geq 2\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\ninitial_conditions::Vector{InitialCondition} : for time zero 'varon'\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables\n: var_names[1] : varstart\n: var_names[2] : varstop\n: var_names[3] : varon\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_duration_compact_retrospective!-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.device_duration_compact_retrospective!","text":"This formulation of the duration constraints adds over the start times looking backwards.\n\nLaTeX\n\nMinimum up-time constraint:\n\nsum_i=t-min(d_min^up T)+ 1^t x_i^start - x_t^on leq 0\n\nfor i in the set of time steps.\n\nMinimum down-time constraint:\n\nsum_i=t-min(d_min^down T) + 1^t x_i^stop + x_t^on leq 1\n\nfor i in the set of time steps.\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nduration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down\ninitial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol, Symbol}) : names of the variables\n: var_names[1] : varon\n: var_names[2] : varstart\n: var_names[3] : varstop\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_duration_look_ahead!-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.device_duration_look_ahead!","text":"This formulation of the duration constraints looks ahead in the time frame of the model.\n\nLaTeX\n\nMinimum up-time constraint:\n\nIf t leq d_min^up\n\nd_min^downx_t^stop - sum_i=t-d_min^up + 1^t x_i^on - x_init^up leq 0\n\nfor i in the set of time steps. Otherwise:\n\nd_min^downx_t^stop - sum_i=t-d_min^up + 1^t x_i^on leq 0\n\nfor i in the set of time steps.\n\nMinimum down-time constraint:\n\nIf t leq d_min^down\n\nd_min^upx_t^start - sum_i=t-d_min^down + 1^t (1 - x_i^on) - x_init^down leq 0\n\nfor i in the set of time steps. Otherwise:\n\nd_min^upx_t^start - sum_i=t-d_min^down + 1^t (1 - x_i^on) leq 0\n\nfor i in the set of time steps.\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nduration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down\ninitial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol, Symbol}) : names of the variables\n: var_names[1] : varon\n: var_names[2] : varstart\n: var_names[3] : varstop\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_duration_parameters!-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.device_duration_parameters!","text":"This formulation of the duration constraints considers parameters.\n\nLaTeX\n\nMinimum up-time constraint:\n\nIf t leq d_min^up\n\nd_min^downx_t^stop - sum_i=t-d_min^up + 1^t x_i^on - x_init^up leq 0\n\nfor i in the set of time steps. Otherwise:\n\nsum_i=t-d_min^up + 1^t x_i^start - x_t^on leq 0\n\nfor i in the set of time steps.\n\nMinimum down-time constraint:\n\nIf t leq d_min^down\n\nd_min^upx_t^start - sum_i=t-d_min^down + 1^t (1 - x_i^on) - x_init^down leq 0\n\nfor i in the set of time steps. Otherwise:\n\nsum_i=t-d_min^down + 1^t x_i^stop + x_t^on leq 1\n\nfor i in the set of time steps.\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nduration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down\ninitialdurationon::Vector{InitialCondition} : gives initial number of time steps variable is up\ninitialdurationoff::Vector{InitialCondition} : gives initial number of time steps variable is down\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol, Symbol}) : names of the variables\n: var_names[1] : varon\n: var_names[2] : varstart\n: var_names[3] : varstop\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_duration_retrospective!-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.device_duration_retrospective!","text":"This formulation of the duration constraints adds over the start times looking backwards.\n\nLaTeX\n\nMinimum up-time constraint:\n\nIf t leq d_min^up - d_init^up and d_init^up  0\n\n1 + sum_i=t-d_min^up + 1^t x_i^start - x_t^on leq 0\n\nfor i in the set of time steps. Otherwise:\n\nsum_i=t-d_min^up + 1^t x_i^start - x_t^on leq 0\n\nfor i in the set of time steps.\n\nMinimum down-time constraint:\n\nIf t leq d_min^down - d_init^down and d_init^down  0\n\n1 + sum_i=t-d_min^down + 1^t x_i^stop + x_t^on leq 1\n\nfor i in the set of time steps. Otherwise:\n\nsum_i=t-d_min^down + 1^t x_i^stop + x_t^on leq 1\n\nfor i in the set of time steps.\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nduration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down\ninitial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol, Symbol}) : names of the variables\n: var_names[1] : varon\n: var_names[2] : varstart\n: var_names[3] : varstop\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_energy_budget_param_ub-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1},Symbol,PowerSimulations.UpdateRef,Symbol}","page":"PowerSimulations","title":"PowerSimulations.device_energy_budget_param_ub","text":"This function define the budget constraint (using params) for the active power budget formulation.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_energy_budget_ub-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1},Symbol,Symbol}","page":"PowerSimulations","title":"PowerSimulations.device_energy_budget_ub","text":"This function define the budget constraint for the active power budget formulation.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_linear_rateofchange!-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRampConstraintInfo,1},Symbol,Symbol}","page":"PowerSimulations","title":"PowerSimulations.device_linear_rateofchange!","text":"Constructs allowed rate-of-change constraints from variables, initial condtions, and rate data.\n\nConstraints\n\nIf t = 1:\n\nvariable[name, 1] - initial_conditions[ix].value <= rate_data[1][ix].up\n\ninitial_conditions[ix].value - variable[name, 1] <= rate_data[1][ix].down\n\nIf t > 1:\n\nvariable[name, t] - variable[name, t-1] <= rate_data[1][ix].up\n\nvariable[name, t-1] - variable[name, t] <= rate_data[1][ix].down\n\nLaTeX\n\nr^down leq x_1 - x_init leq r^up text for  t = 1\n\nr^down leq x_t - x_t-1 leq r^up forall t geq 2\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nrate_data::Tuple{Vector{String}, Vector{UpDown}} : gives name (1) and max ramp up/down rates (2)\ninitial_conditions::Vector{InitialCondition} : for time zero 'variable'\ncons_name::Symbol : name of the constraint\nvar_name::Tuple{Symbol, Symbol, Symbol} : the name of the variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_mixedinteger_rateofchange!-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRampConstraintInfo,1},Symbol,Tuple{Symbol,Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.device_mixedinteger_rateofchange!","text":"Constructs allowed rate-of-change constraints from variables, initial condtions, start/stop status, and rate data\n\nEquations\n\nIf t = 1:\n\nvariable[name, 1] - initial_conditions[ix].value <= rate_data[1][ix].up + rate_data[2][ix].max*varstart[name, 1]\n\ninitial_conditions[ix].value - variable[name, 1] <= rate_data[1][ix].down + rate_data[2][ix].min*varstop[name, 1]\n\nIf t > 1:\n\nvariable[name, t] - variable[name, t-1] <= rate_data[1][ix].up + rate_data[2][ix].max*varstart[name, t]\n\nvariable[name, t-1] - variable[name, t] <= rate_data[1][ix].down + rate_data[2][ix].min*varstop[name, t]\n\nLaTeX\n\nr^down + r^min x^stop_1 leq x_1 - x_init leq r^up + r^max x^start_1 text for  t = 1\n\nr^down + r^min x^stop_t leq x_t - x_t-1 leq r^up + r^max x^start_t forall t geq 2\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nrate_data::Tuple{Vector{String}, Vector{UpDown}, Vector{MinMax}} : (1) gives name                                                                    (2) gives min/max ramp rates                                                                    (3) gives min/max for 'variable'\ninitial_conditions::Vector{InitialCondition} : for time zero 'variable'\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables\n: var_names[1] : 'variable'\n: var_names[2] : 'varstart'\n: var_names[3] : 'varstop'\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_multistart_range!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.RangeConstraintSpecInternal}","page":"PowerSimulations","title":"PowerSimulations.device_multistart_range!","text":"Constructs min/max range constraint from device variable and on/off decision variable.\n\nConstraints\n\n        - max(limits.max - lag_ramp_limits.startup, 0) * var_on[name, t] ```\n\n\nvarcts[name, t] <= (limits.max-limits.min)*varbin[name, t])         - max(limits.max - lagramplimits.shutdown, 0) * var_off[name, t] ```\n\nwhere limits and lagramplimits is in range_data.\n\nLaTeX\n\nx^cts leq (limits^max-limits^min) x^bin - max(limits^max - lag^startup 0) x^on\n\nx^cts leq (limits^max-limits^min) x^bin - max(limits^max - lag^shutdown 0) x^off\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nrange_data::Vector{DeviceRange} : contains names and vector of min/max\ncons_name::Symbol : name of the constraint\nvar_name::Symbol : the name of the continuous variable\nbinvar_names::Symbol : the names of the binary variables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_multistart_range_ic!-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceMultiStartRangeConstraintsInfo,1},Array{InitialCondition,2},Symbol,Symbol}","page":"PowerSimulations","title":"PowerSimulations.device_multistart_range_ic!","text":"Constructs min/max range constraint from device variable and on/off decision variable.\n\nConstraints\n\nmax(limits.max - lag_ramp_limits.shutdown, 0) var_off[name, 1] <= initial_power[ix].value         - (limits.max - limits.min)initial_status[ix].value\n\nwhere limits in range_data.\n\nLaTeX\n\nmax(limits^max - lag^shutdown 0) x^off leq initial_condition^power - (limits^max - limits^min) initial_condition^status\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nrange_data::Vector{DeviceRange} : contains names and vector of min/max\ninitial_conditions::Matrix{InitialCondition} :\ncons_name::Symbol : name of the constraint\nvar_name::Symbol : name of the shutdown variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_multistart_rateofchange!-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRampConstraintInfo,1},Symbol,Symbol}","page":"PowerSimulations","title":"PowerSimulations.device_multistart_rateofchange!","text":"Constructs allowed rate-of-change constraints from variables, initial condtions, start/stop status, and rate data\n\nEquations\n\nIf t = 1:\n\nvariable[name, 1] - initial_conditions[ix].value <= rate_data[1][ix].up\n\ninitial_conditions[ix].value - variable[name, 1] <= rate_data[1][ix].down\n\nIf t > 1:\n\nvariable[name, t] - variable[name, t-1] <= rate_data[1][ix].up\n\nvariable[name, t-1] - variable[name, t] <= rate_data[1][ix].down\n\nLaTeX\n\nr^down  leq x_1 - x_init leq r^up  text for  t = 1\n\nr^down leq x_t - x_t-1 leq r^up  forall t geq 2\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nrate_data::Tuple{Vector{String}, Vector{UpDown}, Vector{MinMax}} : (1) gives name                                                                    (2) gives min/max ramp rates                                                                    (3) gives min/max for 'variable'\ninitial_conditions::Vector{InitialCondition} : for time zero 'variable'\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables\n: var_name : 'variable'\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_range!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.RangeConstraintSpecInternal}","page":"PowerSimulations","title":"PowerSimulations.device_range!","text":"Constructs min/max range constraint from device variable.\n\nConstraints\n\nIf min and max within an epsilon width:\n\nvariable[name, t] == limits.max\n\nOtherwise:\n\nlimits.min <= variable[name, t] <= limits.max\n\nwhere limits in constraint_infos.\n\nLaTeX\n\nx = limits^max text for  limits^max - limits^min  varepsilon\n\nlimits^min leq x leq limits^max text otherwise \n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_semicontinuousrange!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.RangeConstraintSpecInternal}","page":"PowerSimulations","title":"PowerSimulations.device_semicontinuousrange!","text":"Constructs min/max range constraint from device variable and on/off decision variable.\n\nConstraints\n\nIf device min = 0:\n\nvarcts[name, t] <= limits.max*varbin[name, t])\n\nvarcts[name, t] >= 0.0\n\nOtherwise:\n\nvarcts[name, t] <= limits.max*varbin[name, t]\n\nvarcts[name, t] >= limits.min*varbin[name, t]\n\nwhere limits in constraint_infos.\n\nLaTeX\n\n0 leq x^cts leq limits^max x^bin text for  limits^min = 0\n\nlimits^min x^bin leq x^cts leq limits^max x^bin text otherwise \n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_start_type_constraint-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceStartTypesConstraintInfo,1},Symbol,Symbol,Tuple{Symbol,Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.device_start_type_constraint","text":"device_start_type_constraint(psi_container::PSIContainer,\n                        data::Vector{DeviceStartTypesConstraintInfo},\n                        cons_name::Symbol,\n                        var_start::Symbol,\n                        var_names::Tuple{Symbol, Symbol, Symbol},)\n\nConstructs contraints that restricts devices to one type of start at a time\n\nEquations\n\nsum(var_starts[name, s, t] for s in starts) = var_start[name, t]\n\nLaTeX\n\nsum^S_g_s=1 δ^s(t)  eq  x^start(t)\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\ndata::Vector{DeviceStartTypesConstraintInfo},\ncons_name::Symbol : name of the constraint\nvar_start::Symbol : name of the startup variable\nvar_starts::Tuple{Symbol, Symbol} : the names of the different start variables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_startup_initial_condition-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceStartUpConstraintInfo,1},Array{InitialCondition,1},Symbol,Tuple{Symbol,Symbol},Symbol}","page":"PowerSimulations","title":"PowerSimulations.device_startup_initial_condition","text":"device_startup_initial_condition(psi_container::PSIContainer,\n                        data::Vector{DeviceStartUpConstraintInfo},\n                        initial_conditions::Vector{InitialCondition},\n                        cons_name::Symbol,\n                        var_names::Tuple{Symbol, Symbol},\n                        bin_name::Symbol,)\n\nConstructs contraints that restricts devices to one type of start at a time\n\nEquations\n\nub: (time_limits[st+1]-1)*δ^{s}(t) + (1 - δ^{s}(t)) * M_VALUE >= sum(1-varbin[name, i]) for i in 1:t) + initial_condition_offtime lb: (time_limits[st]-1)*δ^{s}(t) =< sum(1-varbin[name, i]) for i in 1:t) + initial_condition_offtime\n\nLaTeX\n\nTS^s+1_g δ^s(t) + (1-δ^s(t)) M_VALUE   geq  sum^t_i=1 x^status(i)  +  DT_g^0  forall t in 1 ldots  TS^s+1_g\n\nTS^s_g δ^s(t) leq  sum^t_i=1 x^status(i)  +  DT_g^0  forall t in 1 ldots  TS^s+1_g\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\ndata::Vector{DeviceStartTypesConstraintInfo},\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol} : the names of the different start variables\nbin_name::Symbol : name of the status variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_timeseries_lb!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.TimeSeriesConstraintSpecInternal}","page":"PowerSimulations","title":"PowerSimulations.device_timeseries_lb!","text":"Constructs lower bound for given variable subject to time series data and a multiplier.\n\nConstraint\n\nconstraint_infos[name].multiplier * ts_data[name].timeseries[t] <= variable[name, t]\n\nLaTeX\n\nr^val r_t leq x_t forall t\n\nwhere (name, data) in range_data.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_timeseries_param_lb!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.TimeSeriesConstraintSpecInternal}","page":"PowerSimulations","title":"PowerSimulations.device_timeseries_param_lb!","text":"Constructs lower bound for given variable using a parameter. The constraint is     built with a time series data vector and a multiplier\n\nConstraint\n\nconstraint_infos[name].multiplier * param[name, t] <= variable[name, t]\n\nLaTeX\n\nr^val x^param_t leq x^var_t forall t\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_timeseries_param_ub!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.TimeSeriesConstraintSpecInternal}","page":"PowerSimulations","title":"PowerSimulations.device_timeseries_param_ub!","text":"Constructs upper bound for given variable using a parameter. The constraint is     built with a time series data vector and a multiplier\n\nConstraint\n\nvariable[name, t] <= constraint_infos[name].multiplier * param[name, t]\n\nLaTeX\n\nx^var_t leq r^val x^param_t forall t\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_timeseries_ub!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.TimeSeriesConstraintSpecInternal}","page":"PowerSimulations","title":"PowerSimulations.device_timeseries_ub!","text":"Constructs upper bound for given variable and time series data and a multiplier.\n\nConstraint\n\nvariable[name, t] <= constraint_infos[name].multiplier * ts_data[name].timeseries[t]\n\nLaTeX\n\nx_t leq r^val r_t forall t\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_timeseries_ub_bigM!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.TimeSeriesConstraintSpecInternal}","page":"PowerSimulations","title":"PowerSimulations.device_timeseries_ub_bigM!","text":"Constructs upper bound for variable and time series and a multiplier or confines to 0 depending on binary variable.     Uses BigM constraint type to allow for parameter since ParameterJuMP doesn't support var*parameter\n\nconstraint_infos\n\nvarcts[name, t] - constraint_infos[name].multipliers * param[name, t] <= (1 - varbin[name, t]) * M_value\n\nvarcts[name, t] <= varbin[name, t]*M_value\n\nLaTeX\n\nx^cts_t - r^val x^param_t leq M(1 - x^bin_t ) forall t\n\nx^cts_t leq M x^bin_t forall t\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_timeseries_ub_bin!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.TimeSeriesConstraintSpecInternal}","page":"PowerSimulations","title":"PowerSimulations.device_timeseries_ub_bin!","text":"Constructs upper bound for variable and time series or confines to 0 depending on binary variable.     The upper bound is defined by a time series and a multiplier.\n\nconstraint_infos\n\nvarcts[name, t] <= varbin[name, t]* constraint_infos[name].multiplier * ts_data[name].timeseries[t]\n\nwhere (name, data) in range_data.\n\nLaTeX\n\nx^cts_t leq r^val r_t x^bin_t forall t\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.energy_balance-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Tuple{Array{String,1},Array{NamedTuple{(:in, :out),Tuple{Float64,Float64}},1}},Symbol,Tuple{Symbol,Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.energy_balance","text":"Constructs multi-timestep constraint from initial condition, efficiency data, and variable tuple\n\nConstraints\n\nIf t = 1:\n\nvarenergy[name, 1] == initial_conditions[ix].value + varin[name, 1]*eff_in*fraction_of_hour - varout[name, 1]*fraction_of_hour/eff_out\n\nIf t > 1:\n\nvarenergy[name, t] == varenergy[name, t-1] + varin[name, t]*eff_in*fraction_of_hour - varout[name, t]*fraction_of_hour/eff_out\n\nLaTeX\n\nx^energy_1 == x^energy_init + frhr eta^in x^in_1 - fracfrhreta^out x^out_1 text for  t = 1\n\nx^energy_t == x^energy_t-1 + frhr eta^in x^in_t - fracfrhreta^out x^out_t forall t geq 2\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\ninitial_conditions::Vector{InitialCondition} : for time zero 'varenergy'\nefficiency_data::Tuple{Vector{String}, Vector{InOut}} :: charging/discharging efficiencies\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables\n: var_names[1] : varin\n: var_names[2] : varout\n: var_names[3] : varenergy\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.energy_balance_constraint!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{H},DeviceModel{H,S},Type{#s108} where #s108<:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S<:Union{HydroDispatchPumpedStorage, HydroDispatchPumpedStoragewReservation} where H<:HydroPumpedStorage","page":"PowerSimulations","title":"PowerSimulations.energy_balance_constraint!","text":"This function defines the constraints for the water level (or state of charge) for the HydroPumpedStorage.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.energy_balance_constraint!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{H},DeviceModel{H,S},Type{#s110} where #s110<:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S<:Union{HydroCommitmentReservoirStorage, HydroDispatchReservoirStorage} where H<:HydroEnergyReservoir","page":"PowerSimulations","title":"PowerSimulations.energy_balance_constraint!","text":"This function defines the constraints for the water level (or state of charge) for the Hydro Reservoir.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.energy_balance_hydro!-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Tuple{Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1},Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1}},Tuple{Symbol,Symbol},NTuple{5,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.energy_balance_hydro!","text":"Constructs multi-timestep constraint from initial condition, efficiency data, and variable tuple for pumped hydro\n\nConstraints\n\nIf t = 1: varenergy[name, 1] == initial_conditions[ix].value + (paraminflow[name, t] + varin[name, 1] - varspill[name, 1] - varout[name, 1])*fraction_of_hour If t > 1: varenergy[name, t] == varenergy[name, t-1] + (paraminflow[name, t] + varin[name, t] - varspill[name, t] - varout[name, t])*fraction_of_hour\n\nLaTeX\n\nx^energy_1 == x^energy_init + frhr  (x^in_1 + x^in_1 - x^spillage_1 -  x^out_1) text for  t = 1 x^energy_t == x^energy_t-1 + frhr (x^in_t + x^in_t - x^spillage_t - x^out_t) forall t geq 2\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\ninitial_conditions::Vector{InitialCondition} : for time zero 'varenergy'\ninflow_data::TVector{DeviceTimeSeriesConstraintInfo} :: Inflow energy forecast information\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol, Symbol, Symbol} : the names of the variables\n: var_names[1] : varspill\n: var_names[2] : varout\n: var_names[3] : varenergy\n: var_names[4] : varin\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.energy_balance_hydro!-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Tuple{Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1},Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1}},Tuple{Symbol,Symbol},Tuple{Symbol,Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.energy_balance_hydro!","text":"Constructs multi-timestep constraint from initial condition, efficiency data, and variable tuple\n\nConstraints\n\nIf t = 1: varenergyname 1 == initial_conditionsixvalue + (paraminflowname t - varspillname 1 - varoutname 1)*fraction_of_hour If t > 1: varenergyname t == varenergyname t-1 + (paraminflowname t - varspillname t - varoutname t)*fraction_of_hour `` varenergy[name, end] >= paramenergytarget[name, end]\n\nLaTeX\n\nx^energy_1 == x^energy_init + frhr  (x^in_1 - x^spillage_1 -  x^out_1) text for  t = 1 x^energy_t == x^energy_t-1 + frhr (x^in_t - x^spillage_t - x^out_t) forall t geq 2 x^energy_t = x^energy_target text for  t = end\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\ninitial_conditions::Vector{InitialCondition} : for time zero 'varenergy'\ntimeseriesdata::Tuple{Vector{DeviceTimeSeriesConstraintInfo}, Vector{DeviceTimeSeriesConstraintInfo}} : forecast information\n: timeseriesdata[1] : Inflow energy forecast information\n: timeseriesdata[2] : Target reservoir storage forecast information\ncons_names::Tuple{Symbol, Symbol} : name of the constraints\n: cons_names[1] : energy balance constraint name\n: cons_names[2] : energy target constraint name\nvar_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables\n: var_names[1] : varspill\n: var_names[2] : varout\n: var_names[3] : varenergy\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.energy_balance_hydro_param!-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Tuple{Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1},Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1}},Tuple{Symbol,Symbol},NTuple{5,Symbol},Tuple{PowerSimulations.UpdateRef,PowerSimulations.UpdateRef}}","page":"PowerSimulations","title":"PowerSimulations.energy_balance_hydro_param!","text":"Constructs multi-timestep constraint from initial condition, efficiency data, and variable tuple for pumped hydro\n\nConstraints\n\nIf t = 1: varenergy_up[name, 1] == initial_conditions[ix].value + (param_inflow[name, t] + varin[name, 1] - varspill[name, 1] - varout[name, 1])*fraction_of_hour If t > 1: varenergy_up[name, t] == varenergy_up[name, t-1] + (param_inflow[name, t] + varin[name, t] - varspill[name, t] - varout[name, t])*fraction_of_hour\n\nLaTeX\n\nx^energy_1 == x^energy_init + frhr  (x^in_1 + x^in_1 - x^spillage_1 -  x^out_1) text for  t = 1 x^energy_t == x^energy_t-1 + frhr (x^in_t + x^in_t - x^spillage_t - x^out_t) forall t geq 2\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\ninitialconditions::Vector{InitialCondition} : for time zero 'varenergyup'\ninflow_data::Vector{DeviceTimeSeriesConstraintInfo} :: Inflow energy forecast information\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol, Symbol, Symbol} : the names of the variables\n: var_names[1] : varspill\n: var_names[2] : varout\n: varnames[3] : varenergyup\n: var_names[4] : varin\nparam_reference::UpdateRef : UpdateRef to access the inflow parameter\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.energy_balance_hydro_param!-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Tuple{Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1},Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1}},Tuple{Symbol,Symbol},Tuple{Symbol,Symbol,Symbol},Tuple{PowerSimulations.UpdateRef,PowerSimulations.UpdateRef}}","page":"PowerSimulations","title":"PowerSimulations.energy_balance_hydro_param!","text":"Constructs multi-timestep constraint from initial condition, efficiency data, and variable tuple\n\nConstraints\n\nIf t = 1: varenergyname 1 == initial_conditionsixvalue + (paraminflowname t - varspillname 1 - varoutname 1)*fraction_of_hour If t > 1: varenergyname t == varenergyname t-1 + (paraminflowname t - varspillname t - varoutname t)*fraction_of_hour `` varenergy[name, end] >= paramenergytarget[name, end]\n\nLaTeX\n\nx^energy_1 == x^energy_init + frhr  (x^in_1 - x^spillage_1 -  x^out_1) text for  t = 1 x^energy_t == x^energy_t-1 + frhr (x^in_t - x^spillage_t - x^out_t) forall t geq 2 x^energy_t = x^energy_target text for  t = end\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\ninitial_conditions::Vector{InitialCondition} : for time zero 'varenergy'\ntimeseriesdata::Tuple{Vector{DeviceTimeSeriesConstraintInfo}, Vector{DeviceTimeSeriesConstraintInfo}} : forecast information\n: timeseriesdata[1] : Inflow energy forecast information\n: timeseriesdata[2] : Target reservoir storage forecast information\ncons_names::Tuple{Symbol, Symbol} : name of the constraints\n: cons_names[1] : energy balance constraint name\n: cons_names[2] : energy target constraint name\nvar_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables\n: var_names[1] : varspill\n: var_names[2] : varout\n: var_names[3] : varenergy\nparam_reference::UpdateRef : UpdateRef to access the inflow parameter\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.energy_budget_constraints!-Union{Tuple{H}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{H},DeviceModel{H,#s109} where #s109<:PowerSimulations.AbstractHydroFormulation,Type{#s108} where #s108<:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where H<:HydroGen","page":"PowerSimulations","title":"PowerSimulations.energy_budget_constraints!","text":"This function define the budget constraint for the active power budget formulation.\n\nsum(Pt) = Budget\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.export_op_model-Tuple{OperationsProblem,String}","page":"PowerSimulations","title":"PowerSimulations.export_op_model","text":"Exports the OpModel JuMP object in MathOptFormat\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.find_key_with_value-Tuple{Any,Any}","page":"PowerSimulations","title":"PowerSimulations.find_key_with_value","text":"Return the key for the given value\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.frequency_response_constraint!-Tuple{PowerSimulations.PSIContainer,System}","page":"PowerSimulations","title":"PowerSimulations.frequency_response_constraint!","text":"Expression for the power deviation given deviation in the frequency. This expression allows updating the response of the frequency depending on commitment decisions\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.initial_condition_update!-Tuple{Stage,PowerSimulations.ICKey,Array{InitialCondition,1},InterStageChronology,Simulation}","page":"PowerSimulations","title":"PowerSimulations.initial_condition_update!","text":"Updates the initial conditions of the stage\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.initial_condition_update!-Tuple{Stage,PowerSimulations.ICKey,Array{InitialCondition,1},IntraStageChronology,Simulation}","page":"PowerSimulations","title":"PowerSimulations.initial_condition_update!","text":"Updates the initial conditions of the stage\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.initial_range_constraints!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{ThermalMultiStart},DeviceModel{ThermalMultiStart,ThermalMultiStartUnitCommitment},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S<:PowerModels.AbstractPowerModel","page":"PowerSimulations","title":"PowerSimulations.initial_range_constraints!","text":"This function adds range constraint for the first time period. Constraint (10) from PGLIB formulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.instantiate_bfp_expr-Tuple{PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.instantiate_bfp_expr","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.instantiate_nip_expr-Tuple{PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.instantiate_nip_expr","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.instantiate_nip_expr_model-Tuple{Dict{String,Any},Any}","page":"PowerSimulations","title":"PowerSimulations.instantiate_nip_expr_model","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.integral_limit_ff-Tuple{PowerSimulations.PSIContainer,Symbol,PowerSimulations.UpdateRef,Symbol}","page":"PowerSimulations","title":"PowerSimulations.integral_limit_ff","text":"    integral_limit_ff(psi_container::PSIContainer,\n                    cons_name::Symbol,\n                    param_reference::UpdateRef,\n                    var_name::Symbol)\n\nConstructs a parametrized integral limit constraint to implement feedforward from other models. The Parameters are initialized using the upper boundary values of the provided variables.\n\nConstraints\n\nsum(variable[var_name, t] for t in time_steps)/length(time_steps) <= param_reference[var_name]\n\nLaTeX\n\nsum_t x leq param^max TO DO: New formulation when DataStore available sum_t x * DeltaT_lower leq param^max * DeltaT_upper TO DO: New formulation when Commitment is considered: SemiContinuousFF     P_LL - P_max * ON_upper = 00     P_LL - P_min * ON_upper = 00\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\ncons_name::Symbol : name of the constraint\nparam_reference : Reference to the PJ.ParameterRef used to determine the upperbound\nvar_name::Symbol : the name of the continuous variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.iterate_initial_conditions-Tuple{PowerSimulations.InitialConditions}","page":"PowerSimulations","title":"PowerSimulations.iterate_initial_conditions","text":"Iterate over the keys and vectors of initial conditions.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.must_run_constraints!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{ThermalMultiStart},DeviceModel{ThermalMultiStart,ThermalMultiStartUnitCommitment},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S<:PowerModels.AbstractPowerModel","page":"PowerSimulations","title":"PowerSimulations.must_run_constraints!","text":"This function creates constraints that keep must run devices online\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.nodal_expression!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},Type{U}}} where U<:PowerModels.AbstractPowerModel where T<:Device","page":"PowerSimulations","title":"PowerSimulations.nodal_expression!","text":"Default implementation to add nodal expressions.\n\nUsers of this function must implement a method for NodalExpressionSpec for their specific types. Users may also implement custom nodal_expression! methods.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,Type{S},System}, Tuple{PowerSimulations.PSIContainer,Type{S},System,Any}} where S<:PowerModels.AbstractActivePowerModel","page":"PowerSimulations","title":"PowerSimulations.powermodels_network!","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,Type{S},System}, Tuple{PowerSimulations.PSIContainer,Type{S},System,Any}} where S<:PowerModels.AbstractPowerModel","page":"PowerSimulations","title":"PowerSimulations.powermodels_network!","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.pwl_gencost_linear!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,String,Array{Tuple{Float64,Float64},1},Int64}","page":"PowerSimulations","title":"PowerSimulations.pwl_gencost_linear!","text":"Returns piecewise cost expression using linear implementation for psi_container model.\n\nEquations\n\n0 <= pwl_var[i] <= (cost_data[2][i] - cost_data[2][i-1])\n\nvariable = sum(pwl_var[i])\n\ngen_cost = sum(pwl_var[i]*cost_data[1][i]/cost_data[2][i])\n\nLaTeX\n\n0 = pwl_i = (c_2 i - c_2 i-1)\n\nvariable = (sum_iin I pwl_i)\n\ngen_cost = (sum_iin I  pwl_i) c_1 ic_2 i\n\nReturns gen_cost\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nvariable::JuMP.Containers.DenseAxisArray{JV} : variable array\ncost_data::Vector{NTuple{2, Float64}} : container for quadratic and linear factors\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.pwl_gencost_sos!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,String,Array{Tuple{Float64,Float64},1},Int64}","page":"PowerSimulations","title":"PowerSimulations.pwl_gencost_sos!","text":"Returns piecewise cost expression using SOS Type-2 implementation for psi_container model.\n\nEquations\n\nvariable = sum(sos_var[i]*cost_data[2][i])\n\ngen_cost = sum(sos_var[i]*cost_data[1][i])\n\nLaTeX\n\nvariable = (sum_iin I c_2 i sos_i)\n\ngen_cost = (sum_iin I c_1 i sos_i)\n\nReturns gen_cost\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nvariable::JuMP.Containers.DenseAxisArray{JV} : variable array\ncost_data::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.pwlparamcheck-Tuple{Any}","page":"PowerSimulations","title":"PowerSimulations.pwlparamcheck","text":"Returns True/False depending on compatibility of the cost data with the linear implementation method\n\nReturns flag\n\nArguments\n\ncost_ : container for quadratic and linear factors\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.ramp_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,D},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S<:PowerModels.AbstractPowerModel where D<:PowerSimulations.AbstractThermalFormulation where T<:ThermalGen","page":"PowerSimulations","title":"PowerSimulations.ramp_constraints!","text":"This function adds the ramping limits of generators when there are CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.range_ff-Tuple{PowerSimulations.PSIContainer,Symbol,Array{PowerSimulations.DeviceRangeConstraintInfo,1},Tuple{PowerSimulations.UpdateRef,PowerSimulations.UpdateRef},Symbol}","page":"PowerSimulations","title":"PowerSimulations.range_ff","text":"    range_ff(psi_container::PSIContainer,\n                    cons_name::Symbol,\n                    param_reference::NTuple{2, UpdateRef},\n                    var_name::Symbol)\n\nConstructs min/max range parametrized constraint from device variable to include feedforward.\n\nConstraints\n\nparam_reference[1][var_name] <= variable[var_name, t] variable[var_name, t] <= param_reference[2][var_name]\n\nwhere r in range_data.\n\nLaTeX\n\nparam^min leq x x leq param^max\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nparam_reference::NTuple{2, UpdateRef} : Tuple with the lower bound and upper bound parameter reference\ncons_name::Symbol : name of the constraint\nvar_name::Symbol : the name of the continuous variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.rating_constraint!-Tuple{PowerSimulations.PSIContainer,Array{Tuple{String,Float64},1},Symbol,Tuple{Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.rating_constraint!","text":"Constructs constraint from rating data and related variable tuple.\n\nConstraint\n\nvar1[r[1], t]^2 + var2[r[1], t]^2 <= r[2]^2\n\nwhere r in rating data and t in time steps.\n\nLaTeX\n\nx_1^2 + x_2^2 leq r^2\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nrating_data::Vector{Tuple{String, Float64}} : rating data name (1) and value (2)\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol} : the names of the variables\n: var_names[1] : var1\n: var_names[2] : var2\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_json-Tuple{AbstractString}","page":"PowerSimulations","title":"PowerSimulations.read_json","text":"Return a decoded JSON file.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.remove_chars-Tuple{String,String}","page":"PowerSimulations","title":"PowerSimulations.remove_chars","text":"Removes the string char from the original string\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.replace_chars-Tuple{String,String,String}","page":"PowerSimulations","title":"PowerSimulations.replace_chars","text":"Replaces the string in char with the stringreplacement\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.reserve_device_semicontinuousrange!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.RangeConstraintSpecInternal}","page":"PowerSimulations","title":"PowerSimulations.reserve_device_semicontinuousrange!","text":"Constructs min/max range constraint from device variable and on/off decision variable.\n\nConstraints\n\nIf device min = 0:\n\nvarcts[name, t] <= limits.max * (1 - varbin[name, t])\n\nvarcts[name, t] >= 0.0\n\nOtherwise:\n\nvarcts[name, t] <= limits.max * (1 - varbin[name, t])\n\nvarcts[name, t] >= limits.min * (1 - varbin[name, t])\n\nwhere limits in constraint_infos.\n\nLaTeX\n\n0 leq x^cts leq limits^max (1 - x^bin ) text for  limits^min = 0\n\nlimits^min (1 - x^bin ) leq x^cts leq limits^max (1 - x^bin ) text otherwise \n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.semicontinuousrange_ff-Tuple{PowerSimulations.PSIContainer,Symbol,Array{PowerSimulations.DeviceRangeConstraintInfo,1},PowerSimulations.UpdateRef,Symbol}","page":"PowerSimulations","title":"PowerSimulations.semicontinuousrange_ff","text":"        semicontinuousrange_ff(psi_container::PSIContainer,\n                                cons_name::Symbol,\n                                var_name::Symbol,\n                                param_reference::UpdateRef)\n\nConstructs min/max range constraint from device variable with parameter setting.\n\nConstraints\n\nIf device min = 0:\n\nvariable[var_name, t] <= r[2].max*param_reference[var_name]\n\nOtherwise:\n\nvariable[var_name, t] <= r[2].max*param_reference[var_name]\n\nvariable[var_name, t] >= r[2].min*param_reference[var_name]\n\nwhere r in range_data.\n\nLaTeX\n\n00 leq x^var leq r^max x^param text for  r^min = 0\n\nr^min x^param leq x^var leq r^min x^param text otherwise \n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\ncons_name::Symbol : name of the constraint\nvar_name::Symbol : the name of the continuous variable\nparam_reference::UpdateRef : UpdateRef of the parameter\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.serialize-Tuple{Simulation}","page":"PowerSimulations","title":"PowerSimulations.serialize","text":"serialize(simulation::Simulation, path = \".\")\n\nSerialize the simulation to a directory in path.\n\nReturn the serialized simulation directory name that is created.\n\nArguments\n\nsimulation::Simulation: simulation to serialize\npath = \".\": path in which to create the serialzed directory\nforce = false: If true, delete the directory if it already exists. Otherwise, it will  throw an exception.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.service_requirement_constraint!-Union{Tuple{SR}, Tuple{PowerSimulations.PSIContainer,SR,ServiceModel{SR,GroupReserve},Array{#s110,1} where #s110<:Service}} where SR<:StaticReserveGroup","page":"PowerSimulations","title":"PowerSimulations.service_requirement_constraint!","text":"This function creates the requirement constraint that will be attained by the apropriate services\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.set_variable_bounds!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRangeConstraintInfo,1},AbstractString,Type{T}}} where T<:Component","page":"PowerSimulations","title":"PowerSimulations.set_variable_bounds!","text":"Adds a bounds to a variable in the optimization model.\n\nBounds\n\nbounds.min <= varstart[name, t] <= bounds.max\n\nLaTeX\n\nx^device_t = bound^min forall t\n\nx^device_t = bound^max forall t\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nbounds::DeviceRangeConstraintInfo : contains names and vector of min / max\nvar_type::AbstractString : type of the variable\nT: type of the device\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.sparse_container_spec-Union{Tuple{M}, Tuple{M,Vararg{Any,N} where N}} where M<:JuMP.AbstractModel","page":"PowerSimulations","title":"PowerSimulations.sparse_container_spec","text":"Returns the correct container spec for the selected type of JuMP Model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.startup_initial_condition_constraints!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{ThermalMultiStart},DeviceModel{ThermalMultiStart,ThermalMultiStartUnitCommitment},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S<:PowerModels.AbstractPowerModel","page":"PowerSimulations","title":"PowerSimulations.startup_initial_condition_constraints!","text":"This function creates the initial conditions for multi-start devices\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.startup_time_constraints!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{ThermalMultiStart},DeviceModel{ThermalMultiStart,ThermalMultiStartUnitCommitment},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S<:PowerModels.AbstractPowerModel","page":"PowerSimulations","title":"PowerSimulations.startup_time_constraints!","text":"This function creates the contraints for different types of starts based on generator down-time\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.startup_type_constraints!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{ThermalMultiStart},DeviceModel{ThermalMultiStart,ThermalMultiStartUnitCommitment},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S<:PowerModels.AbstractPowerModel","page":"PowerSimulations","title":"PowerSimulations.startup_type_constraints!","text":"This function creates constraints to select a single type of startup based on off-time\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.status_init-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T<:ThermalGen","page":"PowerSimulations","title":"PowerSimulations.status_init","text":"Status Init is always calculated based on the Power Output of the device This is to make it easier to calculate when the previous model doesn't contain binaries. For instance, looking back on an ED model to find the IC of the UC model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.turbine_temperature-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceStartUpConstraintInfo,1},Symbol,Symbol,Tuple{Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.turbine_temperature","text":"turbine_temperature(psi_container::PSIContainer,\n                        startup_data::Vector{DeviceStartUpConstraintInfo},\n                        cons_name::Symbol,\n                        var_stop::Symbol,\n                        var_starts::Tuple{Symbol, Symbol})\n\nConstructs contraints for different types of starts based on generator down-time\n\nEquations\n\nfor t in time_limits[s+1]:T\n\nvar_starts[name, s, t] <= sum( var_stop[name, t-i] for i in time_limits[s]:(time_limits[s+1]-1)\n\nLaTeX\n\nδ^s(t)  leq sum_i=TS^s_g^TS^s+1_g x^stop(t-i)\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nrate_data::Vector{DeviceStartUpConstraintInfo},\ncons_name::Symbol : name of the constraint\nvar_stop::Symbol : name of the stop variable\nvar_starts::Tuple{Symbol, Symbol} : the names of the different start variables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.ub_ff-Tuple{PowerSimulations.PSIContainer,Symbol,Array{PowerSimulations.DeviceRangeConstraintInfo,1},PowerSimulations.UpdateRef,Symbol}","page":"PowerSimulations","title":"PowerSimulations.ub_ff","text":"    ub_ff(psi_container::PSIContainer,\n          cons_name::Symbol,\n          constraint_infos::Vector{DeviceRangeConstraintInfo},\n          param_reference::UpdateRef,\n          var_name::Symbol)\n\nConstructs a parametrized upper bound constraint to implement feedforward from other models. The Parameters are initialized using the uppper boundary values of the provided variables.\n\nConstraints\n\nvariable[var_name, t] <= param_reference[var_name]\n\nLaTeX\n\nx leq param^max\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\ncons_name::Symbol : name of the constraint\nparam_reference : Reference to the PJ.ParameterRef used to determine the upperbound\nvar_name::Symbol : the name of the continuous variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.update_parameter!-Tuple{PowerSimulations.UpdateRef{JuMP.VariableRef},PowerSimulations.ParameterContainer,Stage,Simulation}","page":"PowerSimulations","title":"PowerSimulations.update_parameter!","text":"Updates the forecast parameter value\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.update_stage!-Union{Tuple{M}, Tuple{Stage{M},Simulation}} where M<:PowerSimulations.PowerSimulationsOperationsProblem","page":"PowerSimulations","title":"PowerSimulations.update_stage!","text":"Generic Stage update function for most problems with no customization\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.variable_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,String,Nothing,Int64}","page":"PowerSimulations","title":"PowerSimulations.variable_cost!","text":"Adds to the cost function cost terms for sum of variables with common factor to be used for cost expression for psi_container model.\n\n# Arguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nvar_name::Symbol: The variable name\ncomponentname::String: The componentname of the variable container\ncost_component::PSY.VariableCost{Float64} : container for cost to be associated with variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.variable_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,String,VariableCost{Array{Tuple{Float64,Float64},1}},Int64}","page":"PowerSimulations","title":"PowerSimulations.variable_cost!","text":"Creates piecewise linear cost function using a sum of variables and expression with sign and time step included.\n\nExpression\n\nJuMP.add_to_expression!(gen_cost, c)\n\nReturns signgen_costdt\n\nLaTeX\n\ncost = signtimes dt sum_vin V c_v\n\nwhere c_v is given by\n\nc_v = sum_iin Ix fracy_i - y_i-1x_i - x_i-1 v^pw_i\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nvar_name::Symbol: The variable name\ncomponentname::String: The componentname of the variable container\ncost_component::PSY.VariableCost{Vector{NTuple{2, Float64}}}\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.variable_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,String,VariableCost{Float64},Int64}","page":"PowerSimulations","title":"PowerSimulations.variable_cost!","text":"Adds to the cost function cost terms for sum of variables with common factor to be used for cost expression for psi_container model.\n\n# Arguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nvar_name::Symbol: The variable name\ncomponentname::String: The componentname of the variable container\ncost_component::PSY.VariableCost{Float64} : container for cost to be associated with variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.variable_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,String,VariableCost{Tuple{Float64,Float64}},Int64}","page":"PowerSimulations","title":"PowerSimulations.variable_cost!","text":"Adds to the cost function cost terms for sum of variables with common factor to be used for cost expression for psi_container model.\n\nEquation\n\ngen_cost = dt*sign*(sum(variable.^2)*cost_data[1] + sum(variable)*cost_data[2])\n\nLaTeX\n\ncost = dttimes sign (sum_iin I c_1 v_i^2 + sum_iin I c_2 v_i )\n\nfor quadratic factor large enough. If the first term of the quadratic objective is 0.0, adds a linear cost term sum(variable)*cost_data[2]\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nvar_name::Symbol: The variable name\ncomponentname::String: The componentname of the variable container\ncost_component::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.variable_reactive_net_injection-Tuple{PowerModels.AbstractActivePowerModel}","page":"PowerSimulations","title":"PowerSimulations.variable_reactive_net_injection","text":"active power only models ignore reactive power variables\n\n\n\n\n\n","category":"method"},{"location":"ref/hydro/#Hydro-Generation-Models","page":"Hydro Models","title":"Hydro Generation Models","text":"","category":"section"},{"location":"ref/hydro/","page":"Hydro Models","title":"Hydro Models","text":"Here we present the mathematical formulation of the different models for Hydro Generation.","category":"page"},{"location":"ref/hydro/#Dispatch-Run-of-River-[HydroDispatchRunOfRiver]","page":"Hydro Models","title":"Dispatch Run of River [HydroDispatchRunOfRiver]","text":"","category":"section"},{"location":"ref/hydro/","page":"Hydro Models","title":"Hydro Models","text":"The following model provides upper bounds for the active power based on run of the river inflow, modeled as a eta_t in 01 coefficient of the maximum active power. Additional bounds for reactive power are considered.","category":"page"},{"location":"ref/hydro/","page":"Hydro Models","title":"Hydro Models","text":"beginalign\n  P^textmin le P_t le eta_t P^textmax \n  Q^textmin le Q_t le Q^textmax\nendalign","category":"page"},{"location":"ref/hydro/#Dispatch-Energy-Budget-[HydroDispatchReservoirBudget]","page":"Hydro Models","title":"Dispatch Energy Budget [HydroDispatchReservoirBudget]","text":"","category":"section"},{"location":"ref/hydro/","page":"Hydro Models","title":"Hydro Models","text":"The following model provides an energy budget over the time horizon for the active power.","category":"page"},{"location":"ref/hydro/","page":"Hydro Models","title":"Hydro Models","text":"beginalign\n  sum_t = 1^N P_t cdot Delta T le E^textbudget \n  P^textmin le P_t le P^textmax \n  Q^textmin le Q_t le Q^textmax\nendalign","category":"page"},{"location":"ref/hydro/#Dispatch-Storage-[HydroDispatchReservoirStorage]","page":"Hydro Models","title":"Dispatch Storage [HydroDispatchReservoirStorage]","text":"","category":"section"},{"location":"ref/hydro/","page":"Hydro Models","title":"Hydro Models","text":"The following model includes a energy level E_t to handle the storage energy. Inflow powerI_t can also be included as time series into the balance equation. Spillage S_t is also considered:","category":"page"},{"location":"ref/hydro/","page":"Hydro Models","title":"Hydro Models","text":"beginalign\n  E_t+1 = E_t + (I_t - S_t - P_t)Delta T \n  P^textmin le P_t le P^textmax \n  Q^textmin le Q_t le Q^textmax\nendalign","category":"page"},{"location":"ref/hydro/","page":"Hydro Models","title":"Hydro Models","text":"Future releases will also implement a requirement of the energy at the last time point N:","category":"page"},{"location":"ref/hydro/","page":"Hydro Models","title":"Hydro Models","text":"beginalign\n E_N ge E^textrequirement\nendalign","category":"page"},{"location":"ref/hydro/#Commitment-Run-of-River-[HydroCommitmentRunOfRiver]","page":"Hydro Models","title":"Commitment Run of River [HydroCommitmentRunOfRiver]","text":"","category":"section"},{"location":"ref/hydro/","page":"Hydro Models","title":"Hydro Models","text":"Similar to the dispatch formulation, but considering a binary variable u_t in 0 1 with semi continuous constraints for both active and reactive power:","category":"page"},{"location":"ref/hydro/","page":"Hydro Models","title":"Hydro Models","text":"beginalign\n  P_t le eta_t P^textmax\n  P_t - u_t P^textmax le 0 \n  P_t - u_t P^textmin ge 0 \n  Q_t - u_t Q^textmax le 0 \n  Q_t - u_t Q^textmin ge 0\nendalign","category":"page"},{"location":"ref/hydro/#Commitment-Energy-Budget-[HydroCommitmentReservoirBudget]","page":"Hydro Models","title":"Commitment Energy Budget [HydroCommitmentReservoirBudget]","text":"","category":"section"},{"location":"ref/hydro/","page":"Hydro Models","title":"Hydro Models","text":"Similar to the dispatch formulation, but considering a binary variable u_t in 0 1 with semi continuous constraints for both active and reactive power:","category":"page"},{"location":"ref/hydro/","page":"Hydro Models","title":"Hydro Models","text":"beginalign\n  sum_t = 1^N P_t cdot Delta T le E^textbudget \n  P_t - u_t P^textmax le 0 \n  P_t - u_t P^textmin ge 0 \n  Q_t - u_t Q^textmax le 0 \n  Q_t - u_t Q^textmin ge 0\nendalign","category":"page"},{"location":"ref/hydro/#Commitment-Energy-Budget-[HydroCommitmentReservoirStorage]","page":"Hydro Models","title":"Commitment Energy Budget [HydroCommitmentReservoirStorage]","text":"","category":"section"},{"location":"ref/hydro/","page":"Hydro Models","title":"Hydro Models","text":"Similar to the dispatch formulation, but considering a binary variable u_t in 0 1 with semi continuous constraints for both active and reactive power:","category":"page"},{"location":"ref/hydro/","page":"Hydro Models","title":"Hydro Models","text":"beginalign\n  E_t+1 = E_t + (I_t - S_t - P_t)Delta T \n  P_t - u_t P^textmax le 0 \n  P_t - u_t P^textmin ge 0 \n  Q_t - u_t Q^textmax le 0 \n  Q_t - u_t Q^textmin ge 0\nendalign","category":"page"},{"location":"man/logging/#Logging","page":"Logging","title":"Logging","text":"","category":"section"},{"location":"man/logging/","page":"Logging","title":"Logging","text":"PowerSimulations will output many log messages when building systems and running simulations. You may want to customize what gets logged to the console and, optionally, a file.","category":"page"},{"location":"man/logging/","page":"Logging","title":"Logging","text":"By default all log messages of level Logging.Info or higher will get displayed to the console.  When you run a simulation a simulation-specific logger will take over and log its messages to a file in the logs directory in the simulation output directory. When finished it will relinquish control back to the global logger.","category":"page"},{"location":"man/logging/#Configuring-the-global-logger","page":"Logging","title":"Configuring the global logger","text":"","category":"section"},{"location":"man/logging/","page":"Logging","title":"Logging","text":"To configure the global logger in a Jupyter Notebook or REPL you may configure your own logger with the Julia Logging standard library or use the convenience function provided by PowerSimulations.  This example will log messages of level Logging.Error to console and Logging.Info and higher to the file power-simulations.log in the current directory.","category":"page"},{"location":"man/logging/","page":"Logging","title":"Logging","text":"import Logging\nusing PowerSimulations\nlogger = configure_logging(\n    console_level = Logging.Error,\n    file_level = Logging.Info,\n    filename = \"power-simulations.log\"\n)","category":"page"},{"location":"man/logging/#Configuring-the-simulation-logger","page":"Logging","title":"Configuring the simulation logger","text":"","category":"section"},{"location":"man/logging/","page":"Logging","title":"Logging","text":"You can configure the logging level used by the simulation logger when you call build!(simulation).  Here is an example that increases logging verbosity:","category":"page"},{"location":"man/logging/","page":"Logging","title":"Logging","text":"import Logging\nusing PowerSimulations\nsimulation = Simulation(...)\nbuild!(simulation, console_level = Logging.Info, file_level = Logging.Debug)","category":"page"},{"location":"man/logging/","page":"Logging","title":"Logging","text":"The log file will be located at <your-output-path>/<simulation-name>/<run-output-dir>/logs/simulation.log.","category":"page"},{"location":"man/logging/#Solver-logs","page":"Logging","title":"Solver logs","text":"","category":"section"},{"location":"man/logging/","page":"Logging","title":"Logging","text":"You can configure logging for the solver you use.  Refer to the solver documentation.  PowerSimulations does not redirect or intercept prints to stdout or stderr from other libraries.","category":"page"},{"location":"man/logging/#Recorder-events","page":"Logging","title":"Recorder events","text":"","category":"section"},{"location":"man/logging/","page":"Logging","title":"Logging","text":"PowerSimulations uses the InfrastructureSystems.Recorder to store simulation events in a log file.  Refer to this link for more information.","category":"page"},{"location":"man/multistart_formulation/#Power-Grid-Lib-Unit-Commitment-/-Multi-Start-Unit-Commitment","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"","category":"section"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"This formulation is from the benchmark library maintained by the IEEE PES Task Force on Benchmarks for Validation of Emerging Power System Algorithms and is designed to evaluate a well established version of the the Unit Commitment problem.","category":"page"},{"location":"man/multistart_formulation/#Formulation-Overview","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Formulation Overview","text":"","category":"section"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"The features of this model are:","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"A global load requirement with time series\nAn optional global spinning reserve requirement with time series\nThermal generators with technical parameters, including\nMinimum and maximum power output\nHourly ramp-up and ramp-down rates\nStart-up and shut-down ramp rates\nMinimum run-times and off-times\nUp to 3 types of startup types (hot, warm, cold)\nOff time dependent start-up costs\nStartup & Shutdown lag/power trajectory constraint\nPiecewise linear convex production costs\nMust run constraints\nNo-load costs\nOptional renewable generators with time series for minimum and maximum production.","category":"page"},{"location":"man/multistart_formulation/#Formulations","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Formulations","text":"","category":"section"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"A detailed description of this mathematical model is available here. This model does have some aaugmentation to constraints but is mathematically equivalent to the formulation found here.","category":"page"},{"location":"man/multistart_formulation/#Indices-and-Sets","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Indices and Sets","text":"","category":"section"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"beginitemize\n\titemg in cG Set of thermal generators\n\titemg in cG_textiton^0 Set of thermal generators which are initially committed (on)\n\titemg in cG_textitoff^0 Set of thermal generators which are not initially committed (off)\n\titemt in cT Hourly time steps 1 ldots T T = tt time_periods\n\titeml in cL_g Piecewise production cost intervals for thermal generator g 1 ldots L_g\n\titems in cS_g Startup categories for thermal generator g from hottest (1) to coldest (S_g) 1 ldots S_g\nenditemize","category":"page"},{"location":"man/multistart_formulation/#Thermal-Generator-Parameters","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Thermal Generator Parameters","text":"","category":"section"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"beginitemize\n\titemCS_g^s  Startup cost in category s for generator g () tt startupcost\n\titemCP_g^l  Cost of operating at piecewise generation point l for generator g (MW) tt piecewise_productioncost\n\titemDT_g    Minimum down time for generator g (h) tt time_down_minimum\n\titemDT^0_g Number of time periods the unit has been off prior to the first time period for generator g tt time_down_t0\n\titemoP_g   Maximum power output for generator g (MW) tt power_output_maximum\n\titemuP_g   Minimum power output for generator g (MW) tt power_output_minimum\n\titemP_g^0   Power output for generator g (MW) in the time period prior to t=1 tt power_output_t0\n\titemP_g^l   Power level for piecewise generation point l for generator g (MW) P^1_g = uP_g and P^L_g_g = oP_g tt piecewise_productionmw\n\titemRD_g    Ramp-down rate for generator g (MWh) tt ramp_down_limit\n\titemRU_g    Ramp-up rate for generator g (MWh) tt ramp_up_limit\n\titemSD_g    Shutdown capability for generator g (MW) tt ramp_shutdown_limit\n\titemSU_g    Startup capability for generator g (MW) tt ramp_startup_limit\n\titemTS^s_g Time offline after which the startup category s becomes active (h) tt startuplag\n\titemUT_g    Minimum up time for generator g (h) tt time_up_minimum\n\titemUT^0_g Number of time periods the unit has been on prior to the first time period for generator g tt time_up_t0\n\titemU_g^0  Initial onoff status for generator g U_g^0=1 for g in cG_textiton^0 U_g^0=0 for g in cG_textitoff^0  tt unit_on_t0\n\titemU_g \tMust-run status for generator g tt must_run\nenditemize","category":"page"},{"location":"man/multistart_formulation/#Variables","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Variables","text":"","category":"section"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"beginitemize\n\titemc_g(t)    Cost of power produced above minimum for thermal generator g at time t (MW) in bbR\n\titemp_g(t)    Power above minimum for thermal generator g at time t (MW) geq 0\n\titemp_w(t)  Renewable generation used from renewable generator w at time t (MW) geq 0\n\titemu_g(t)    Commitment status of thermal generator g at time t in 01\n\titemv_g(t)    Startup status of thermal generator g at time t in 01\n\titemw_g(t)    Shutdown status of thermal generator g at time t in 01 \n\titemdelta^s_g(t) Startup in category s for thermal generator g at time t in 01\n\titemlambda_g^l(t)  Fraction of power from piecewise generation point l for generator g at time t (MW) in 01\n\nenditemize","category":"page"},{"location":"man/multistart_formulation/#Model-Description","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Model Description","text":"","category":"section"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"Below we describe the unit commitment model given by~\\cite{morales2013tight}, with the piecewise production cost description from~\\cite{sridhar2013locally}. The unit commitment problem can then be formulated as:\nObjective Function","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"allowdisplaybreaks\nbeginalign\n     textmin  sum_g in cG sum_t in cT left( c_g(t) + CP_g^1  u_g(t) + sum_s = 1^S_g left( CS^s_g delta^s(t) right) right) labeleqobj tagUC \nendalign\n","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"subject to:\n Active power constraints with Startup/Shutdown lag","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"beginalign\n\t\t U_g^0(P_g^0-uP_g) leq (oP_g - uP_g) U_g^0 - max(oP_g - SD_g)0 w_g(1)  forall g in cG labeleqMaxOutput2Init\n\t\t p_g(t) + r_g(t) leq (oP_g - uP_g) u_g(t) - max(oP_g - SU_g)0 v_g(t)  forall t in cT  forall g in cG labeleqMaxOutput1 \n\t\t p_g(t) + r_g(t) leq (oP_g - uP_g) u_g(t) - max(oP_g - SD_g)0 w_g(t+1)  forall t in cTsetminus T  forall g in cG labeleqMaxOutput2\nendalign","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"Ramp constraints","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"beginalign\n\t\t p_g(1) + r_g(1) - U_g^0(P_g^0-uP_g) leq RU_g  forall g in cG labeleqRampUpInit \n\t\t U_g^0(P_g^0-uP_g) - p_g(1) leq RD_g  forall g in cG labeleqRampDownInit \n\t\t p_g(t) + r_g(t) - p_g(t-1) leq RU_g  forall t in cTsetminus1  forall g in cG labeleqRampUp \n\t\t p_g(t-1) - p_g(t) leq RD_g  forall t in cTsetminus1  forall g in cG labeleqRampDown\nendalign","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"Unit Commitment constraint","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"beginalign\n\t\t u_g(1) - U_g^0 = v_g(1) - w_g(1)  forall g in cG labeleqLogicalInitial \n\t\t u_g(t) - u_g(t-1) = v_g(t) - w_g(t)  forall t in cTsetminus1  forall g in cG labeleqLogical \nendalign","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"Minimum Uptime constraints","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"beginalign\n\t\t UT_g w_g(t) - sum_i=t-UT_g + 1^t u_g(i) - UT_g^0 leq 0  forall t in 1 ldots minUT_gT  forall g in cG labeleqStartupInit \n\t\t sum_i= t-minUT_gT + 1^t v_g(i) leq u_g(t)  forall t in minUT_gT ldots T  forall g in cG labeleqStartup\nendalign","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"Minimum Downtime constraints","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"beginalign\n\t\t DT_g v_g(t) - sum_i=t-DT_g + 1^t u_g(i) - DT_g^0 leq 0  forall t in 1 ldots minDT_gT  forall g in cG labeleqShutdownInit \n\t\t sum_i= t-minDT_gT + 1^t w_g(i) leq 1 - u_g(t)  forall t in minDT_g T ldots T  forall g in cG labeleqShutdown\nendalign","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"Must run constriant","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"beginalign\n\t\t u_g(t) geq U_g  hspace1cm forall t in cT  forall g in cG labeleqMustRun\nendalign","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"Start-up time_limits constraints","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"beginalign\n\t\t delta^s_g(t) leq sum_i = TS^s_g^TS^s+1_g-1 w_g(t-i)  forall t in TS^s+1_gldotsTforall s in cS_gsetminusS_g  forall g in cG labeleqSTISelect\nendalign","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"Start-up type selection constriant","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"beginalign\n\t\t v_g(t) = sum_s = 1^S_g delta^s_g(t)  forall t in cT forall g in cG labeleqSTILink\nendalign","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"Start-up initial condition constraints","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"beginalign\n\t\t (TS^s+1_g - 1)delta^s_g(t) + (1 - delta^s_g(t)) M geq sum_i = 1^t u_g(i) + DT_g^0  forall t in 1ldotsTS^s+1_g -1 forall g in cG labeleqSTInitUB\n\t\t TS^s_g delta^s_g(t)  leq sum_i = 1^t u_g(i) + DT_g^0  forall t in 1ldotsTS^s+1_g-1 forall g in cG labeleqSTInitLB\nendalign","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"Piecewise Cost Constraint","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"beginalign\n\t\t p_g(t) = sum_l in cL_g (P_g^l - P_g^1) lambda_g^l(t) hspace5cm forall t in cT  forall g in cG labeleqPiecewiseParts \n\t\t c_g(t) = sum_l in cL_g (CP_g^l - CP_g^1) lambda_g^l(t)  forall t in cT  forall g in cG labeleqPiecewisePartsCost \n\t\t u_g(t) = sum_l in cL_g lambda_g^l(t)  forall t in cT forall g in cG labeleqPiecewiseLimits\nendalign","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"Active power limits","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"beginalign\n\t\t uP_w(t) leq p_w(t) leq oP_w(t) hspace6cm forall t in cT  forall w in cW labeleqWindLimit\nendalign","category":"page"},{"location":"man/multistart_formulation/#References","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"References","text":"","category":"section"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"[1] Knueven, Bernard, James Ostrowski, and Jean-Paul Watson. \"On mixed integer programming formulations for the unit commitment problem.\" Pre-print available at http://www.optimization-online.org/DB_HTML/2018/11/6930.pdf (2018).","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"[2] Krall, Eric, Michael Higgins, and Richard P. O’Neill. \"RTO unit commitment test system.\" Federal Energy Regulatory Commission. Available: http://ferc.gov/legal/staff-reports/rto-COMMITMENT-TEST.pdf (2012).","category":"page"},{"location":"glossary/#Glossary","page":"Glossary","title":"Glossary","text":"","category":"section"},{"location":"glossary/#Simulation-Sequence-Components","page":"Glossary","title":"Simulation Sequence Components","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"cache: Cache is used to store quantities resulting from the solutions of a stage.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"chronology: The vertical inter-stage relationship dictating how variable results impact the next stage's variable parameters.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Example: feedforward_chronologies = Dict((\"stage-1\" => \"stage-2\") => Synchronize(periods = 24)) This chronology uses the first 24 solutions in the horizon to synchronize with 24 executions of stage 2.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"feedforward: The variable that is used as a parameter for a later stage. A feedforward define both the variable to parameter map and the expected behaviour of the map.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Example: feedforward = Dict((\"stage-2\", :devices, :Generators) => SemiContinuousFF(binary_source_stage = PSI.ON, affected_variables = [PSI.ACTIVE_POWER]) This semi-continuous feedforward passes binary results from the first stage to parameters of the active power of the second stage.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"horizons: The integer count of resolution time periods for a full step resolution of the simulation. (Horizon = 12) x (resolution = 1 Hour) = 12 Hours","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Example: horizons = Dict(\"stage-1\" => 24, \"stage-2\" => 12) The first stage has a horizon of 24, representing 24 1-hour increments. The second stage has a horizon of 12, representing 12 5-min increments","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"initial condition chronology: The structure dictating how initial conditions get updated from previous results in the simulation.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Examples: ini_cond_chronology = InterStageChronology()","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"1\n|\n2                   2 ... (x04)\n|             ┌----/|\n|             |     |\n3 --> 3 ... (x12)   3 --> 3 ... (x12)","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"This represents an inter-stage chronology where the results of each stage feed back into the initial conditions of the stage above it.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"ini_cond_chronology = IntraStageChronology()","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"1\n\n2 ----------------> 2 ... (x04)\n\n3 --> 3 ... (x12)   3 --> 3 ... (x12)","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"This represents an intra-stage chronology where the results of each simulation run feed back into the initial conditions of the next simulation for that stage.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"intervals: The increment of time per stage in each simulation solve, and how results get fed forward into initial conditions between intervals.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Example: intervals = Dict(\"UC\" => (Hour(24), Consecutive()), \"ED\" => (Hour(1), Consecutive()))","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Operations Problem A single-step optimization problem.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Simulations Problem: A multi-step and/or multi-stage optimization problem.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Simulation Sequence: Simulation Sequence formulates the structure and flow of results through the simulation. It sets up the feedforward and initial condition chronologies, the horizon, intervals, and order.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Stage: Each stage represents a formulation of a problem to be solved, such as unit commitment or economic dispatch. Each stage has its own system with a specified time-scale.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Example:","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"\"UC\" => Stage(GenericOpProblem, template, system, optimizer)","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"problem: The optimization problem populated with the specific system to be solved.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"step resolution: The time period representing the time length of the whole simulation before it repeats.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Example: step_resolution = Hour(24)","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"template: The structure of the problem to be solved, without the actual system data that makes it a populated problem.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Time Increments: ***Resolution ≤ Interval ≤ Step Resolution***","category":"page"},{"location":"#PowerSimulations.jl","page":"Introduction","title":"PowerSimulations.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"CurrentModule = PowerSimulations","category":"page"},{"location":"#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"PowerSimulations.jl is a Julia/JuMP package designed to develop and study power system operation models in steady-state. It uses the data model implemented in PowerSystems.jl to construct optimization models.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The package supports to major analysis tools.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Operational Models: Meant to study and analyze multiperiod operational model formulations that can specified by the combination of device formulations and network models.\nSimulations Models: Developed to run sequences of operational models to study model interactions sucha as cost-production-modeling.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The documentation is still work in progress.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The latest stable release of PowerModels can be installed using the Julia package manager with","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"] add PowerSimulations","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For the current development version, \"checkout\" this package with","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"] add PowerSimulations#master","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"An appropiate optimization solver is required for running PowerSimulations models. Refer to JuMP.jl solver's page to select the most appropiate for the application of interest.","category":"page"},{"location":"man/op_problem/#Operational-Model","page":"Operation Model","title":"Operational Model","text":"","category":"section"},{"location":"man/op_problem/","page":"Operation Model","title":"Operation Model","text":"An operational model is defined as the combination of an objective function (\\refeq{gpsimulations}) in terms of state x and control u variables. Equations (\\refeq{dpsimulations}) describe the device model formulations as a function of variables, parameters eta and uncertainty terms omega. Further, equations (\\refeq{n_psimulations}) represents the network modeling and finally the system services.","category":"page"},{"location":"man/op_problem/","page":"Operation Model","title":"Operation Model","text":"In the same fashion as in PowerSystems.jl, the objective is not to list all possible formulations for devices, network, and services in a power system model. Rather, the contribution is to develop a type hierarchy that enables developers to create new formulations and allow analysts a  natural way to describe the functional assumptions used in the model.","category":"page"}]
}
