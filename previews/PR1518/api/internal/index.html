<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · PowerSimulations.jl</title><meta name="title" content="Internals · PowerSimulations.jl"/><meta property="og:title" content="Internals · PowerSimulations.jl"/><meta property="twitter:title" content="Internals · PowerSimulations.jl"/><meta name="description" content="Documentation for PowerSimulations.jl."/><meta property="og:description" content="Documentation for PowerSimulations.jl."/><meta property="twitter:description" content="Documentation for PowerSimulations.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="PowerSimulations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PowerSimulations.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome Page</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/decision_problem/">Single-step Problem</a></li><li><a class="tocitem" href="../../tutorials/pcm_simulation/">Multi-stage Production Cost Simulation</a></li></ul></li><li><span class="tocitem">How to...</span><ul><li><a class="tocitem" href="../../how_to/register_variable/">...register a variable in a custom operation model</a></li><li><a class="tocitem" href="../../how_to/problem_templates/">...create a problem template</a></li><li><a class="tocitem" href="../../how_to/read_results/">...read the simulation results</a></li><li><a class="tocitem" href="../../how_to/debugging_infeasible_models/">...debug an infeasible model</a></li><li><a class="tocitem" href="../../how_to/logging/">...configure logging</a></li><li><a class="tocitem" href="../../how_to/simulation_recorder/">...inspect simulation events using the recorder</a></li><li><a class="tocitem" href="../../how_to/parallel_simulations/">...run a parallel simulation</a></li></ul></li><li><span class="tocitem">Explanation</span><ul><li><a class="tocitem" href="../../explanation/psi_structure/">PowerSimulations.jl Modeling Structure</a></li><li><a class="tocitem" href="../../explanation/feedforward/">Feedforward</a></li><li><a class="tocitem" href="../../explanation/chronologies/">Chronologies</a></li><li><a class="tocitem" href="../../explanation/sequencing/">Sequencing</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../glossary/">Glossary and Acronyms</a></li><li><a class="tocitem" href="../PowerSimulations/">Public API</a></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox" checked/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../developer/">Developer Guidelines</a></li><li class="is-active"><a class="tocitem" href>Internals</a></li></ul></li></ul></li><li><a class="tocitem" href="../../archive_old_docs_content/">Archived Old Docs Content</a></li><li><span class="tocitem">Formulation Library</span><ul><li><a class="tocitem" href="../../formulation_library/Introduction/">Introduction</a></li><li><a class="tocitem" href="../../formulation_library/General/">General</a></li><li><a class="tocitem" href="../../formulation_library/Network/">Network</a></li><li><a class="tocitem" href="../../formulation_library/ThermalGen/">Thermal Generation</a></li><li><a class="tocitem" href="../../formulation_library/RenewableGen/">Renewable Generation</a></li><li><a class="tocitem" href="../../formulation_library/Load/">Load</a></li><li><a class="tocitem" href="../../formulation_library/Branch/">Branch</a></li><li><a class="tocitem" href="../../formulation_library/Source/">Source</a></li><li><a class="tocitem" href="../../formulation_library/Service/">Services</a></li><li><a class="tocitem" href="../../formulation_library/Feedforward/">Feedforwards</a></li><li><a class="tocitem" href="../../formulation_library/Piecewise/">Piecewise Linear Cost</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li><a class="is-disabled">Developers</a></li><li class="is-active"><a href>Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internals</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/NREL-Sienna/PowerSimulations.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/main/docs/src/api/internal.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Internal-API"><a class="docs-heading-anchor" href="#Internal-API">Internal API</a><a id="Internal-API-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-API" title="Permalink"></a></h1><article><details class="docstring"><summary id="PowerSimulations.IGNORABLE_FILES"><a class="docstring-binding" href="#PowerSimulations.IGNORABLE_FILES"><code>PowerSimulations.IGNORABLE_FILES</code></a> — <span class="docstring-category">Constant</span></summary><section><div><p>If the name of an extraneous file that appears in simulation results matches one of these regexes, it is safe to ignore</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/definitions.jl#L108">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.AbstractCostAtMinParameter"><a class="docstring-binding" href="#PowerSimulations.AbstractCostAtMinParameter"><code>PowerSimulations.AbstractCostAtMinParameter</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Parameters to define the cost at the minimum available power</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/parameters.jl#L349">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.AbstractDeviceFormulation"><a class="docstring-binding" href="#PowerSimulations.AbstractDeviceFormulation"><code>PowerSimulations.AbstractDeviceFormulation</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Abstract type for Device Formulations (a.k.a Models)</p><p><strong>Example</strong></p><p>import PowerSimulations const PSI = PowerSimulations struct MyCustomDeviceFormulation &lt;: PSI.AbstractDeviceFormulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/formulations.jl#L1">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.AbstractDynamicBranchRatingTimeSeriesParameter"><a class="docstring-binding" href="#PowerSimulations.AbstractDynamicBranchRatingTimeSeriesParameter"><code>PowerSimulations.AbstractDynamicBranchRatingTimeSeriesParameter</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Abstract type for dynamic ratings of AC branches</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/parameters.jl#L274">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.AbstractPiecewiseLinearBreakpointParameter"><a class="docstring-binding" href="#PowerSimulations.AbstractPiecewiseLinearBreakpointParameter"><code>PowerSimulations.AbstractPiecewiseLinearBreakpointParameter</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Parameters to define the breakpoints of a piecewise linear function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/parameters.jl#L367">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.AbstractPiecewiseLinearSlopeParameter"><a class="docstring-binding" href="#PowerSimulations.AbstractPiecewiseLinearSlopeParameter"><code>PowerSimulations.AbstractPiecewiseLinearSlopeParameter</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Parameters to define the slopes of a piecewise linear cost function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/parameters.jl#L358">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.AbstractSecurityConstrainedPTDFModel"><a class="docstring-binding" href="#PowerSimulations.AbstractSecurityConstrainedPTDFModel"><code>PowerSimulations.AbstractSecurityConstrainedPTDFModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Linear active power approximation using the power transfer distribution factor <a href="https://nrel-sienna.github.io/PowerNetworkMatrices.jl/stable/tutorials/tutorial_PTDF_matrix/">PTDF</a> matrix and line outage distribution factors <a href="https://nrel-sienna.github.io/PowerNetworkMatrices.jl/stable/tutorials/tutorial_LODF_matrix/">LODF</a> for branches outages.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/network_formulations.jl#L5">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.AbstractServiceFormulation"><a class="docstring-binding" href="#PowerSimulations.AbstractServiceFormulation"><code>PowerSimulations.AbstractServiceFormulation</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Abstract type for Service Formulations (a.k.a Models)</p><p><strong>Example</strong></p><p>import PowerSimulations const PSI = PowerSimulations struct MyServiceFormulation &lt;: PSI.AbstractServiceFormulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/formulations.jl#L224">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.AbstractSimulationStatusEvent"><a class="docstring-binding" href="#PowerSimulations.AbstractSimulationStatusEvent"><code>PowerSimulations.AbstractSimulationStatusEvent</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>All events subtyped from this need to be recorded under :simulation_status.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/utils/recorder_events.jl#L1">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.CacheFlushRules"><a class="docstring-binding" href="#PowerSimulations.CacheFlushRules"><code>PowerSimulations.CacheFlushRules</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Informs the flusher on what data to keep in cache.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/cache_utils.jl#L18">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.ContinuousCondition"><a class="docstring-binding" href="#PowerSimulations.ContinuousCondition"><code>PowerSimulations.ContinuousCondition</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ContinuousCondition()</code></pre><p>Establishes an event condition that is triggered at all timesteps.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/event_model.jl#L3">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.ConverterCurrentDirection"><a class="docstring-binding" href="#PowerSimulations.ConverterCurrentDirection"><code>PowerSimulations.ConverterCurrentDirection</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to dispatch the creation of DC Converter Binary for Absolute Value Current Variables for DC formulations Docs abbreviation: <code>\nu_c</code>`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/variables.jl#L232">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.ConverterDCPower"><a class="docstring-binding" href="#PowerSimulations.ConverterDCPower"><code>PowerSimulations.ConverterDCPower</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to dispatch the creation of DC Converter Power Variables for DC formulations Docs abbreviation: <span>$p_c^{dc}$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/variables.jl#L208">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.DCLineCurrentFlowVariable"><a class="docstring-binding" href="#PowerSimulations.DCLineCurrentFlowVariable"><code>PowerSimulations.DCLineCurrentFlowVariable</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to define the creation of HVDC DC Line Current Flow</p><p>Docs abbreviation: <span>$\i_{d}$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/variables.jl#L478">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.DCLineLosses"><a class="docstring-binding" href="#PowerSimulations.DCLineLosses"><code>PowerSimulations.DCLineLosses</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Auxiliary Variable of DC Current Variables for DC Lines formulations Docs abbreviation: <span>$p_l^{loss}$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/auxiliary_variables.jl#L16">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.DCLosslessLine"><a class="docstring-binding" href="#PowerSimulations.DCLosslessLine"><code>PowerSimulations.DCLosslessLine</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Lossless Line Abstract Model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/formulations.jl#L197">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.DecisionModelStore"><a class="docstring-binding" href="#PowerSimulations.DecisionModelStore"><code>PowerSimulations.DecisionModelStore</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Stores results data for one DecisionModel</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/operation/decision_model_store.jl#L1">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.DecisionProblem"><a class="docstring-binding" href="#PowerSimulations.DecisionProblem"><code>PowerSimulations.DecisionProblem</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Abstract type for Decision Problems</p><p><strong>Example</strong></p><p>import PowerSimulations const PSI = PowerSimulations struct MyCustomProblem &lt;: PSI.DecisionProblem</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/operation_model_abstract_types.jl#L7">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.DecrementalCostAtMinParameter"><a class="docstring-binding" href="#PowerSimulations.DecrementalCostAtMinParameter"><code>PowerSimulations.DecrementalCostAtMinParameter</code></a> — <span class="docstring-category">Type</span></summary><section><div><p><a href="#PowerSimulations.AbstractCostAtMinParameter"><code>AbstractCostAtMinParameter</code></a> for the decremental case (power sink)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/parameters.jl#L355">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.DecrementalPiecewiseLinearBreakpointParameter"><a class="docstring-binding" href="#PowerSimulations.DecrementalPiecewiseLinearBreakpointParameter"><code>PowerSimulations.DecrementalPiecewiseLinearBreakpointParameter</code></a> — <span class="docstring-category">Type</span></summary><section><div><p><a href="#PowerSimulations.AbstractPiecewiseLinearBreakpointParameter"><code>AbstractPiecewiseLinearBreakpointParameter</code></a> for the decremental case (power sink)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/parameters.jl#L374">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.DecrementalPiecewiseLinearSlopeParameter"><a class="docstring-binding" href="#PowerSimulations.DecrementalPiecewiseLinearSlopeParameter"><code>PowerSimulations.DecrementalPiecewiseLinearSlopeParameter</code></a> — <span class="docstring-category">Type</span></summary><section><div><p><a href="#PowerSimulations.AbstractPiecewiseLinearSlopeParameter"><code>AbstractPiecewiseLinearSlopeParameter</code></a> for the decremental case (power sink)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/parameters.jl#L364">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.DefaultDecisionProblem"><a class="docstring-binding" href="#PowerSimulations.DefaultDecisionProblem"><code>PowerSimulations.DefaultDecisionProblem</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Abstract type for models than employ PowerSimulations methods. For custom decision problems     use DecisionProblem as the super type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/operation/decision_model.jl#L1">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.DefaultEmulationProblem"><a class="docstring-binding" href="#PowerSimulations.DefaultEmulationProblem"><code>PowerSimulations.DefaultEmulationProblem</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Abstract type for models than employ PowerSimulations methods. For custom emulation problems     use EmulationProblem as the super type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/operation/emulation_model.jl#L1">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.DiscreteEventCondition"><a class="docstring-binding" href="#PowerSimulations.DiscreteEventCondition"><code>PowerSimulations.DiscreteEventCondition</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DiscreteEventCondition(condition_function::Function)</code></pre><p>Establishes an event condition that is triggered if when a user defined function evaluates to true. The function should take SimulationState as its only arguement and return true when the event should be triggered and false otherwise.</p><p><strong>Arguments</strong></p><ul><li><code>condition_function::Function</code>: user defined function <code>f(::SimulationState)</code>to determine if event is triggered.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/event_model.jl#L54">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.EmulationModelStore"><a class="docstring-binding" href="#PowerSimulations.EmulationModelStore"><code>PowerSimulations.EmulationModelStore</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Stores results data for one EmulationModel</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/operation/emulation_model_store.jl#L1">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.EmulationProblem"><a class="docstring-binding" href="#PowerSimulations.EmulationProblem"><code>PowerSimulations.EmulationProblem</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Abstract type for Emulation Problems</p><p><strong>Example</strong></p><p>import PowerSimulations const PSI = PowerSimulations struct MyCustomEmulator &lt;: PSI.EmulationProblem</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/operation_model_abstract_types.jl#L18">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.GenericEmulationProblem"><a class="docstring-binding" href="#PowerSimulations.GenericEmulationProblem"><code>PowerSimulations.GenericEmulationProblem</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Default PowerSimulations Emulation Problem Type for unspecified problems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/operation/emulation_model.jl#L7">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.HVDCActivePowerReceivedFromVariable"><a class="docstring-binding" href="#PowerSimulations.HVDCActivePowerReceivedFromVariable"><code>PowerSimulations.HVDCActivePowerReceivedFromVariable</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to dispatch the creation of HVDC Received Flow at From Bus Variables for PWL formulations</p><p>Docs abbreviation: <span>$x$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/variables.jl#L380">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.HVDCActivePowerReceivedToVariable"><a class="docstring-binding" href="#PowerSimulations.HVDCActivePowerReceivedToVariable"><code>PowerSimulations.HVDCActivePowerReceivedToVariable</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to dispatch the creation of HVDC Received Flow at To Bus Variables for PWL formulations</p><p>Docs abbreviation: <span>$y$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/variables.jl#L387">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.HVDCInverterACCurrentFlowConstraint"><a class="docstring-binding" href="#PowerSimulations.HVDCInverterACCurrentFlowConstraint"><code>PowerSimulations.HVDCInverterACCurrentFlowConstraint</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to create the constraint that calculates the AC Current flowing into the AC side of the inverter.</p><p class="math-container">\[i_	ext{ac}^i = \sqrt{6} \frac{N^i}{\pi}I_d\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/constraints.jl#L406">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.HVDCInverterACCurrentVariable"><a class="docstring-binding" href="#PowerSimulations.HVDCInverterACCurrentVariable"><code>PowerSimulations.HVDCInverterACCurrentVariable</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to define the creation of HVDC AC Line Current flowing into the AC side of Inverter</p><p>Docs abbreviation: <span>$\i_{ac}^i$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/variables.jl#L471">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.HVDCInverterDCLineVoltageConstraint"><a class="docstring-binding" href="#PowerSimulations.HVDCInverterDCLineVoltageConstraint"><code>PowerSimulations.HVDCInverterDCLineVoltageConstraint</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to create the constraint that calculates the Inverter DC line voltage.</p><p class="math-container">\[v_d^i = \frac{3}{\pi}N^i \left( \sqrt{2}rac{a^i v_\text{ac}^i}{t^i}\cos{\gamma^i}-X^i I_d \right)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/constraints.jl#L352">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.HVDCInverterDCVoltageVariable"><a class="docstring-binding" href="#PowerSimulations.HVDCInverterDCVoltageVariable"><code>PowerSimulations.HVDCInverterDCVoltageVariable</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to define the creation of HVDC DC Line Voltage at Inverter Side</p><p>Docs abbreviation: <span>$\v_{d}^i$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/variables.jl#L457">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.HVDCInverterExtinctionAngleVariable"><a class="docstring-binding" href="#PowerSimulations.HVDCInverterExtinctionAngleVariable"><code>PowerSimulations.HVDCInverterExtinctionAngleVariable</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to define the creation of HVDC Inverter Extinction Angle Variable</p><p>Docs abbreviation: <span>$\gamma^i$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/variables.jl#L415">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.HVDCInverterOverlapAngleConstraint"><a class="docstring-binding" href="#PowerSimulations.HVDCInverterOverlapAngleConstraint"><code>PowerSimulations.HVDCInverterOverlapAngleConstraint</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to create the constraint that calculates the Inverter Overlap Angle.</p><p class="math-container">\[\mu^i = \arccos \left( \cos\gamma^i - \frac{\sqrt{2} I_d X^i t^r}{a^i v_\text{ac}^i} \right) - \gamma^i\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/constraints.jl#L370">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.HVDCInverterOverlapAngleVariable"><a class="docstring-binding" href="#PowerSimulations.HVDCInverterOverlapAngleVariable"><code>PowerSimulations.HVDCInverterOverlapAngleVariable</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to define the creation of HVDC Inverter Overlap Angle Variable</p><p>Docs abbreviation: <span>$\mu^i$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/variables.jl#L443">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.HVDCInverterPowerCalculationConstraint"><a class="docstring-binding" href="#PowerSimulations.HVDCInverterPowerCalculationConstraint"><code>PowerSimulations.HVDCInverterPowerCalculationConstraint</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to create the constraint that calculates the AC Power injection at the AC side of the inverter.</p><p class="math-container">\[\begin{align*}
p_\text{ac}^i = \sqrt{3} i_\text{ac}^i \frac{a^i v_\text{ac}^i}{t^i}\cos{\phi^i} \\
q_\text{ac}^i = \sqrt{3} i_\text{ac}^i \frac{a^i v_\text{ac}^i}{t^i}\sin{\phi^i} \\
\end{align*}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/constraints.jl#L427">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.HVDCInverterPowerFactorAngleConstraint"><a class="docstring-binding" href="#PowerSimulations.HVDCInverterPowerFactorAngleConstraint"><code>PowerSimulations.HVDCInverterPowerFactorAngleConstraint</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to create the constraint that calculates the Inverter Power Factor Angle.</p><p class="math-container">\[\phi^i = \arctan \left( \frac{2\mu^i + \sin(2\gamma^i) - \sin(2(\mu^i + \gamma^i))}{\cos(2\gamma^i) - \cos(2(\mu^i + \gamma^i))} \right)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/constraints.jl#L388">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.HVDCInverterPowerFactorAngleVariable"><a class="docstring-binding" href="#PowerSimulations.HVDCInverterPowerFactorAngleVariable"><code>PowerSimulations.HVDCInverterPowerFactorAngleVariable</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to define the creation of HVDC Inverter Power Factor Angle Variable</p><p>Docs abbreviation: <span>$\phi^i$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/variables.jl#L429">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.HVDCInverterTapSettingVariable"><a class="docstring-binding" href="#PowerSimulations.HVDCInverterTapSettingVariable"><code>PowerSimulations.HVDCInverterTapSettingVariable</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to define the creation of HVDC Tap Setting at Inverter Transformer</p><p>Docs abbreviation: <span>$\t^i$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/variables.jl#L492">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.HVDCPiecewiseBinaryLossVariable"><a class="docstring-binding" href="#PowerSimulations.HVDCPiecewiseBinaryLossVariable"><code>PowerSimulations.HVDCPiecewiseBinaryLossVariable</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to dispatch the creation of HVDC Piecewise Binary Loss Variables</p><p>Docs abbreviation: <span>$z$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/variables.jl#L506">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.HVDCPiecewiseLossVariable"><a class="docstring-binding" href="#PowerSimulations.HVDCPiecewiseLossVariable"><code>PowerSimulations.HVDCPiecewiseLossVariable</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to dispatch the creation of HVDC Piecewise Loss Variables</p><p>Docs abbreviation: <span>$h$</span> or <span>$w$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/variables.jl#L499">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.HVDCReactivePowerReceivedFromVariable"><a class="docstring-binding" href="#PowerSimulations.HVDCReactivePowerReceivedFromVariable"><code>PowerSimulations.HVDCReactivePowerReceivedFromVariable</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to dispatch the creation of HVDC Received Reactive Flow From Bus Variables</p><p>Docs abbreviation: <span>$x^r$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/variables.jl#L394">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.HVDCReactivePowerReceivedToVariable"><a class="docstring-binding" href="#PowerSimulations.HVDCReactivePowerReceivedToVariable"><code>PowerSimulations.HVDCReactivePowerReceivedToVariable</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to dispatch the creation of HVDC Received Reactive Flow To Bus Variables</p><p>Docs abbreviation: <span>$y^i$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/variables.jl#L401">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.HVDCRectifierACCurrentFlowConstraint"><a class="docstring-binding" href="#PowerSimulations.HVDCRectifierACCurrentFlowConstraint"><code>PowerSimulations.HVDCRectifierACCurrentFlowConstraint</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to create the constraint that calculates the AC Current flowing into the AC side of the rectifier.</p><p class="math-container">\[i_	ext{ac}^r = \sqrt{6} \frac{N^r}{\pi}I_d\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/constraints.jl#L397">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.HVDCRectifierACCurrentVariable"><a class="docstring-binding" href="#PowerSimulations.HVDCRectifierACCurrentVariable"><code>PowerSimulations.HVDCRectifierACCurrentVariable</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to define the creation of HVDC AC Line Current flowing into the AC side of Rectifier</p><p>Docs abbreviation: <span>$\i_{ac}^r$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/variables.jl#L464">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.HVDCRectifierDCLineVoltageConstraint"><a class="docstring-binding" href="#PowerSimulations.HVDCRectifierDCLineVoltageConstraint"><code>PowerSimulations.HVDCRectifierDCLineVoltageConstraint</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to create the constraint that calculates the Rectifier DC line voltage.</p><p class="math-container">\[v_d^r = \frac{3}{\pi}N^r \left( \sqrt{2}rac{a^r v_\text{ac}^r}{t^r}\cos{\alpha^r}-X^r I_d \right)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/constraints.jl#L343">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.HVDCRectifierDCVoltageVariable"><a class="docstring-binding" href="#PowerSimulations.HVDCRectifierDCVoltageVariable"><code>PowerSimulations.HVDCRectifierDCVoltageVariable</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to define the creation of HVDC DC Line Voltage at Rectifier Side</p><p>Docs abbreviation: <span>$\v_{d}^r$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/variables.jl#L450">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.HVDCRectifierDelayAngleVariable"><a class="docstring-binding" href="#PowerSimulations.HVDCRectifierDelayAngleVariable"><code>PowerSimulations.HVDCRectifierDelayAngleVariable</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to define the creation of HVDC Rectifier Delay Angle Variable</p><p>Docs abbreviation: <span>$\alpha^r$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/variables.jl#L408">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.HVDCRectifierOverlapAngleConstraint"><a class="docstring-binding" href="#PowerSimulations.HVDCRectifierOverlapAngleConstraint"><code>PowerSimulations.HVDCRectifierOverlapAngleConstraint</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to create the constraint that calculates the Rectifier Overlap Angle.</p><p class="math-container">\[\mu^r = \arccos \left( \cos\alpha^r - \frac{\sqrt{2} I_d X^r t^r}{a^r v_\text{ac}^r} \right) - \alpha^r\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/constraints.jl#L361">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.HVDCRectifierOverlapAngleVariable"><a class="docstring-binding" href="#PowerSimulations.HVDCRectifierOverlapAngleVariable"><code>PowerSimulations.HVDCRectifierOverlapAngleVariable</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to define the creation of HVDC Rectifier Overlap Angle Variable</p><p>Docs abbreviation: <span>$\mu^r$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/variables.jl#L436">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.HVDCRectifierPowerCalculationConstraint"><a class="docstring-binding" href="#PowerSimulations.HVDCRectifierPowerCalculationConstraint"><code>PowerSimulations.HVDCRectifierPowerCalculationConstraint</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to create the constraint that calculates the AC Power injection at the AC side of the rectifier.</p><p class="math-container">\[\begin{align*}
p_\text{ac}^r = \sqrt{3} i_\text{ac}^r \frac{a^r v_\text{ac}^r}{t^r}\cos{\phi^r} \\
q_\text{ac}^r = \sqrt{3} i_\text{ac}^r \frac{a^r v_\text{ac}^r}{t^r}\sin{\phi^r} \\
\end{align*}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/constraints.jl#L415">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.HVDCRectifierPowerFactorAngleConstraint"><a class="docstring-binding" href="#PowerSimulations.HVDCRectifierPowerFactorAngleConstraint"><code>PowerSimulations.HVDCRectifierPowerFactorAngleConstraint</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to create the constraint that calculates the Rectifier Power Factor Angle.</p><p class="math-container">\[\phi^r = \arctan \left( \frac{2\mu^r + \sin(2\alpha^r) - \sin(2(\mu^r + \alpha^r))}{\cos(2lpha^r) - \cos(2(\mu^r + \alpha^r))} \right)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/constraints.jl#L379">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.HVDCRectifierPowerFactorAngleVariable"><a class="docstring-binding" href="#PowerSimulations.HVDCRectifierPowerFactorAngleVariable"><code>PowerSimulations.HVDCRectifierPowerFactorAngleVariable</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to define the creation of HVDC Rectifier Power Factor Angle Variable</p><p>Docs abbreviation: <span>$\phi^r$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/variables.jl#L422">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.HVDCRectifierTapSettingVariable"><a class="docstring-binding" href="#PowerSimulations.HVDCRectifierTapSettingVariable"><code>PowerSimulations.HVDCRectifierTapSettingVariable</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to define the creation of HVDC Tap Setting at Rectifier Transformer</p><p>Docs abbreviation: <span>$\t^r$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/variables.jl#L485">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.HVDCTransmissionDCLineConstraint"><a class="docstring-binding" href="#PowerSimulations.HVDCTransmissionDCLineConstraint"><code>PowerSimulations.HVDCTransmissionDCLineConstraint</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to create the constraint that links the AC and DC side of the network.</p><p class="math-container">\[v_d^i = v_d^r - R_d I_d\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/constraints.jl#L439">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.HVDCTwoTerminalLCC"><a class="docstring-binding" href="#PowerSimulations.HVDCTwoTerminalLCC"><code>PowerSimulations.HVDCTwoTerminalLCC</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Branch type to represent non-linear LCC (line commutated converter) model on two-terminal DC lines</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/formulations.jl#L168">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.HVDCTwoTerminalPiecewiseLoss"><a class="docstring-binding" href="#PowerSimulations.HVDCTwoTerminalPiecewiseLoss"><code>PowerSimulations.HVDCTwoTerminalPiecewiseLoss</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Branch type to represent piecewise lossy power flow on two terminal DC lines</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/formulations.jl#L163">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.HdfSimulationStore"><a class="docstring-binding" href="#PowerSimulations.HdfSimulationStore"><code>PowerSimulations.HdfSimulationStore</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Stores simulation data in an HDF file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/hdf_simulation_store.jl#L18">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.InMemorySimulationStore"><a class="docstring-binding" href="#PowerSimulations.InMemorySimulationStore"><code>PowerSimulations.InMemorySimulationStore</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Stores simulation data in memory</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/in_memory_simulation_store.jl#L1">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.IncrementalCostAtMinParameter"><a class="docstring-binding" href="#PowerSimulations.IncrementalCostAtMinParameter"><code>PowerSimulations.IncrementalCostAtMinParameter</code></a> — <span class="docstring-category">Type</span></summary><section><div><p><a href="#PowerSimulations.AbstractCostAtMinParameter"><code>AbstractCostAtMinParameter</code></a> for the incremental case (power source)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/parameters.jl#L352">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.IncrementalPiecewiseLinearBreakpointParameter"><a class="docstring-binding" href="#PowerSimulations.IncrementalPiecewiseLinearBreakpointParameter"><code>PowerSimulations.IncrementalPiecewiseLinearBreakpointParameter</code></a> — <span class="docstring-category">Type</span></summary><section><div><p><a href="#PowerSimulations.AbstractPiecewiseLinearBreakpointParameter"><code>AbstractPiecewiseLinearBreakpointParameter</code></a> for the incremental case (power source)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/parameters.jl#L370">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.IncrementalPiecewiseLinearSlopeParameter"><a class="docstring-binding" href="#PowerSimulations.IncrementalPiecewiseLinearSlopeParameter"><code>PowerSimulations.IncrementalPiecewiseLinearSlopeParameter</code></a> — <span class="docstring-category">Type</span></summary><section><div><p><a href="#PowerSimulations.AbstractPiecewiseLinearSlopeParameter"><code>AbstractPiecewiseLinearSlopeParameter</code></a> for the incremental case (power source)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/parameters.jl#L361">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.InitialConditionChronology"><a class="docstring-binding" href="#PowerSimulations.InitialConditionChronology"><code>PowerSimulations.InitialConditionChronology</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Supertype for initial condition chronologies </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/initial_conditions/initial_condition_chronologies.jl#L1">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.InitialConditionsData"><a class="docstring-binding" href="#PowerSimulations.InitialConditionsData"><code>PowerSimulations.InitialConditionsData</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Stores data to populate initial conditions before the build call</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/initial_conditions.jl#L59">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.LineFlowAuxVariableType"><a class="docstring-binding" href="#PowerSimulations.LineFlowAuxVariableType"><code>PowerSimulations.LineFlowAuxVariableType</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Auxiliary Variable for line power flow results from power flow evaluation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/auxiliary_variables.jl#L37">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.LinearLossConverter"><a class="docstring-binding" href="#PowerSimulations.LinearLossConverter"><code>PowerSimulations.LinearLossConverter</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Linear Loss InterconnectingConverter Model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/formulations.jl#L184">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.MaxInterfaceFlowLimitParameter"><a class="docstring-binding" href="#PowerSimulations.MaxInterfaceFlowLimitParameter"><code>PowerSimulations.MaxInterfaceFlowLimitParameter</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Parameter to define Max Flow limit for interface time series</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/parameters.jl#L301">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.MinInterfaceFlowLimitParameter"><a class="docstring-binding" href="#PowerSimulations.MinInterfaceFlowLimitParameter"><code>PowerSimulations.MinInterfaceFlowLimitParameter</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Parameter to define Min Flow limit for interface time series</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/parameters.jl#L306">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.MultiStartVariable"><a class="docstring-binding" href="#PowerSimulations.MultiStartVariable"><code>PowerSimulations.MultiStartVariable</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Multi-start startup variables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/variables.jl#L49">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.OperationModel"><a class="docstring-binding" href="#PowerSimulations.OperationModel"><code>PowerSimulations.OperationModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Abstract type for Decision Model and Emulation Model. OperationModel structs are parameterized with DecisionProblem or Emulation Problem structs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/operation_model_abstract_types.jl#L1">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.OptimizationOutputCache"><a class="docstring-binding" href="#PowerSimulations.OptimizationOutputCache"><code>PowerSimulations.OptimizationOutputCache</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Cache for a single parameter/variable/dual. Stores arrays chronologically by simulation timestamp.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/optimization_output_cache.jl#L1">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.OptimizationOutputCaches"><a class="docstring-binding" href="#PowerSimulations.OptimizationOutputCaches"><code>PowerSimulations.OptimizationOutputCaches</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Cache for all model results</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/optimization_output_caches.jl#L1">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.PiecewiseLinearBlockDecrementalOffer"><a class="docstring-binding" href="#PowerSimulations.PiecewiseLinearBlockDecrementalOffer"><code>PowerSimulations.PiecewiseLinearBlockDecrementalOffer</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to dispatch the creation of piecewise linear block decremental offer variables for objective function</p><p>Docs abbreviation: <span>$\delta_d$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/variables.jl#L529">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.PiecewiseLinearBlockIncrementalOffer"><a class="docstring-binding" href="#PowerSimulations.PiecewiseLinearBlockIncrementalOffer"><code>PowerSimulations.PiecewiseLinearBlockIncrementalOffer</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to dispatch the creation of piecewise linear block incremental offer variables for objective function</p><p>Docs abbreviation: <span>$\delta$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/variables.jl#L522">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.PiecewiseLinearUpperBoundConstraint"><a class="docstring-binding" href="#PowerSimulations.PiecewiseLinearUpperBoundConstraint"><code>PowerSimulations.PiecewiseLinearUpperBoundConstraint</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Struct to create the PiecewiseLinearUpperBoundConstraint associated with a specified variable.</p><p>See <a href="../../formulation_library/Piecewise/#pwl_cost">Piecewise linear cost functions</a> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/constraints.jl#L233">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.PowerFlowAuxVariableType"><a class="docstring-binding" href="#PowerSimulations.PowerFlowAuxVariableType"><code>PowerSimulations.PowerFlowAuxVariableType</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Auxiliary Variables that are calculated using a <code>PowerFlowEvaluationModel</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/auxiliary_variables.jl#L22">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.PresetTimeCondition"><a class="docstring-binding" href="#PowerSimulations.PresetTimeCondition"><code>PowerSimulations.PresetTimeCondition</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PresetTimeCondition(time_stamps::Vector{Dates.DateTime})</code></pre><p>Establishes an event condition that is triggered at pre-determined times.  </p><p><strong>Arguments</strong></p><ul><li><code>time_stamps::Vector{Dates.DateTime}</code>: times when event is triggered</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/event_model.jl#L10">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.ShutdownCostParameter"><a class="docstring-binding" href="#PowerSimulations.ShutdownCostParameter"><code>PowerSimulations.ShutdownCostParameter</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Parameter to define shutdown cost time series</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/parameters.jl#L346">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.SimulationProblemResults"><a class="docstring-binding" href="#PowerSimulations.SimulationProblemResults"><code>PowerSimulations.SimulationProblemResults</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Holds the results of a simulation problem for plotting or exporting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/simulation_problem_results.jl#L11">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.SimulationStore"><a class="docstring-binding" href="#PowerSimulations.SimulationStore"><code>PowerSimulations.SimulationStore</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Provides storage of simulation data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/abstract_simulation_store.jl#L1">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.StartupCostParameter"><a class="docstring-binding" href="#PowerSimulations.StartupCostParameter"><code>PowerSimulations.StartupCostParameter</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Parameter to define startup cost time series</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/parameters.jl#L343">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.StateVariableValueCondition"><a class="docstring-binding" href="#PowerSimulations.StateVariableValueCondition"><code>PowerSimulations.StateVariableValueCondition</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">StateVariableValueCondition(
    variable_type::Type{&lt;:VariableType}
    device_type::Type{&lt;:PSY.Device}
    device_name::String
    value::Float64
)</code></pre><p>Establishes an event condition that is triggered if a variable of type <code>variable_type</code> for a device of type <code>device_type</code> and name <code>device_name</code> is equal to <code>value</code>. and name </p><p><strong>Arguments</strong></p><ul><li><code>variable_type::Type{&lt;:VariableType}</code>: variable to be monitored</li><li><code>device_type::Type{&lt;:PSY.Device}</code>: device type to be monitored</li><li><code>device_name::String</code>: name of monitored device</li><li><code>value::Float64</code>: value to compare to in p.u.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/event_model.jl#L24">source</a></section></details></article><article><details class="docstring"><summary id="Base.empty!-Tuple{PowerSimulations.EmulationModelStore}"><a class="docstring-binding" href="#Base.empty!-Tuple{PowerSimulations.EmulationModelStore}"><code>Base.empty!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">empty!(store::PowerSimulations.EmulationModelStore)
</code></pre><pre><code class="language-julia hljs">Base.empty!(store::EmulationModelStore)</code></pre><p>Empty the <a href="#PowerSimulations.EmulationModelStore"><code>EmulationModelStore</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/operation/emulation_model_store.jl#L19">source</a></section></details></article><article><details class="docstring"><summary id="Base.empty!-Tuple{PowerSimulations.OptimizationOutputCaches}"><a class="docstring-binding" href="#Base.empty!-Tuple{PowerSimulations.OptimizationOutputCaches}"><code>Base.empty!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">empty!(cache::PowerSimulations.OptimizationOutputCaches)
</code></pre><pre><code class="language-julia hljs">Base.empty!(cache::OptimizationOutputCaches)</code></pre><p>Empty the <a href="#PowerSimulations.OptimizationOutputCaches"><code>OptimizationOutputCaches</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/optimization_output_caches.jl#L26">source</a></section></details></article><article><details class="docstring"><summary id="Base.empty!-Tuple{PowerSimulations.OptimizationOutputCache}"><a class="docstring-binding" href="#Base.empty!-Tuple{PowerSimulations.OptimizationOutputCache}"><code>Base.empty!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">empty!(cache::PowerSimulations.OptimizationOutputCache)
</code></pre><pre><code class="language-julia hljs">Base.empty!(cache::OptimizationOutputCache)</code></pre><p>Empty the <a href="#PowerSimulations.OptimizationOutputCache"><code>OptimizationOutputCache</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/optimization_output_cache.jl#L45">source</a></section></details></article><article><details class="docstring"><summary id="Base.empty!-Tuple{SimulationResults}"><a class="docstring-binding" href="#Base.empty!-Tuple{SimulationResults}"><code>Base.empty!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">empty!(res::SimulationResults)
</code></pre><pre><code class="language-julia hljs">Base.empty!(res::SimulationResults)</code></pre><p>Empty the <a href="../PowerSimulations/#PowerSimulations.SimulationResults"><code>SimulationResults</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/simulation_results.jl#L187">source</a></section></details></article><article><details class="docstring"><summary id="InfrastructureSystems.Optimization.read_results_with_keys-Tuple{PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults}, Vector{&lt;:InfrastructureSystems.Optimization.OptimizationContainerKey}}"><a class="docstring-binding" href="#InfrastructureSystems.Optimization.read_results_with_keys-Tuple{PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults}, Vector{&lt;:InfrastructureSystems.Optimization.OptimizationContainerKey}}"><code>InfrastructureSystems.Optimization.read_results_with_keys</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">read_results_with_keys(
    res::PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults},
    result_keys::Vector{&lt;:InfrastructureSystems.Optimization.OptimizationContainerKey};
    start_time,
    len,
    cols,
    table_format
) -&gt; Dict{InfrastructureSystems.Optimization.OptimizationContainerKey, DataFrames.DataFrame}
</code></pre><p>High-level function to read a DataFrame of results.</p><p><strong>Arguments</strong></p><ul><li><code>res</code>: the results to read.</li><li><code>result_keys::Vector{&lt;:OptimizationContainerKey}</code>: the keys to read. Output will be a <code>Dict{OptimizationContainerKey, DataFrame}</code> with these as the keys</li><li><code>start_time::Union{Nothing, Dates.DateTime} = nothing</code>: the time at which the resulting time series should begin; <code>nothing</code> indicates the first time in the results</li><li><code>len::Union{Int, Nothing} = nothing</code>: the number of steps in the resulting time series; <code>nothing</code> indicates up to the end of the results</li><li><code>cols::Union{Colon, Vector{String}} = (:)</code>: which columns to fetch; defaults to <code>:</code>, i.e., all the columns</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/decision_model_simulation_results.jl#L555">source</a></section></details></article><article><details class="docstring"><summary id="InfrastructureSystems.Optimization.to_matrix-Tuple{Vector}"><a class="docstring-binding" href="#InfrastructureSystems.Optimization.to_matrix-Tuple{Vector}"><code>InfrastructureSystems.Optimization.to_matrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">to_matrix(vec::Vector) -&gt; Matrix
</code></pre><p>Convert Vectors, DenseAxisArrays, and SparkAxisArrays to a matrix.</p><ul><li>If the input is a 1d array or DenseAxisArray, the returned matrix will have a number of rows equal to the length of the input and one column.</li><li>If the input is a 2d DenseAxisArray, the dimensions are transposed, due to the way we store outputs in JuMP.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/utils/jump_utils.jl#L49">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations._add_category_to_map!-Tuple{Vector{DataType}, Vector{Pair{InfrastructureSystems.Optimization.OptimizationContainerKey, Any}}, Dict{DataType, &lt;:Dict}, Dict{InfrastructureSystems.Optimization.OptimizationContainerKey, &lt;:Dict}}"><a class="docstring-binding" href="#PowerSimulations._add_category_to_map!-Tuple{Vector{DataType}, Vector{Pair{InfrastructureSystems.Optimization.OptimizationContainerKey, Any}}, Dict{DataType, &lt;:Dict}, Dict{InfrastructureSystems.Optimization.OptimizationContainerKey, &lt;:Dict}}"><code>PowerSimulations._add_category_to_map!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_add_category_to_map!(
    precedence::Vector{DataType},
    available_keys::Vector{Pair{InfrastructureSystems.Optimization.OptimizationContainerKey, Any}},
    temp_component_map::Dict{DataType, &lt;:Dict},
    pf_data_opt_container_map::Dict{InfrastructureSystems.Optimization.OptimizationContainerKey, &lt;:Dict}
)
</code></pre><pre><code class="language-julia hljs">_add_category_to_map!(
    precedence::Vector{DataType},
    available_keys::Vector{Pair{OptimizationContainerKey, Any}},
    temp_component_map::Union{
        Dict{DataType, Dict{String, Int}},
        Dict{DataType, Dict{Union{Int64, String}, String}},
    },
    pf_data_opt_container_map::Union{
        Dict{OptimizationContainerKey, Dict{String, Int}},
        Dict{OptimizationContainerKey, Dict{Union{Int64, String}, String}},
    },
)</code></pre><p>Helper function that is used in <em>make</em>pf<em>input</em>map! and <em>add</em>two<em>terminal</em>elements<em>map! to configure which variables from the optimization results get written to the PowerFlowData. For every results variable from the optimization, it finds the corresponding mapping between the optimization variable and the PowerFlowData variable. The mappings are added to the `pf</em>data<em>opt</em>container_map` Dict. This step is executed during the build stage of the optimization. The results are written to the PowerFlowData in the solve stage, before the power flow is solved.</p><p><strong>Arguments</strong></p><ul><li><code>precedence::Vector{DataType}</code>: A vector of <code>DataType</code> objects that defines the order of precedence for the variables that correspond to the category of variables (e.g. <code>:active_power</code> - first look for <code>ActivePowerVariable</code> for the component type, if not available then <code>PowerOutput</code>, and finally <code>ActivePowerTimeSeriesParameter</code>).</li><li><code>available_keys::Vector{Pair{OptimizationContainerKey, Any}}</code>: A vector of key-value pairs where the key is an <code>OptimizationContainerKey</code> and the value contains data associated with the key.</li><li><code>temp_component_map::Union{Dict{DataType, Dict{String, Int}}, Dict{DataType, Dict{Union{Int64, String}, String}}}</code>: A mapping for component types to point the component-level results (e.g. as voltage value for bus &quot;A&quot;) to the appropriate variable in PowerFlowData (e.g. row 27 in the bus-related matrices).</li><li><code>pf_data_opt_container_map::Union{Dict{OptimizationContainerKey, Dict{String, Int}}, Dict{OptimizationContainerKey, Dict{Union{Int64, String}, String}}}</code>: The target Dict that contains mappings for all relevant component types.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/network_models/power_flow_evaluation.jl#L152">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations._add_generic_incremental_interpolation_constraint!-Union{Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{S}, Tuple{R}, Tuple{PowerSimulations.OptimizationContainer, R, S, T, U, V, InfrastructureSystems.FlattenIteratorWrapper{W}, Dict{String, Vector{Float64}}, Dict{String, Vector{Float64}}}} where {R&lt;:InfrastructureSystems.Optimization.VariableType, S&lt;:InfrastructureSystems.Optimization.VariableType, T&lt;:InfrastructureSystems.Optimization.VariableType, U&lt;:InfrastructureSystems.Optimization.VariableType, V&lt;:InfrastructureSystems.Optimization.ConstraintType, W&lt;:Component}"><a class="docstring-binding" href="#PowerSimulations._add_generic_incremental_interpolation_constraint!-Union{Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{S}, Tuple{R}, Tuple{PowerSimulations.OptimizationContainer, R, S, T, U, V, InfrastructureSystems.FlattenIteratorWrapper{W}, Dict{String, Vector{Float64}}, Dict{String, Vector{Float64}}}} where {R&lt;:InfrastructureSystems.Optimization.VariableType, S&lt;:InfrastructureSystems.Optimization.VariableType, T&lt;:InfrastructureSystems.Optimization.VariableType, U&lt;:InfrastructureSystems.Optimization.VariableType, V&lt;:InfrastructureSystems.Optimization.ConstraintType, W&lt;:Component}"><code>PowerSimulations._add_generic_incremental_interpolation_constraint!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_add_generic_incremental_interpolation_constraint!(
    container::PowerSimulations.OptimizationContainer,
    ::InfrastructureSystems.Optimization.VariableType,
    ::InfrastructureSystems.Optimization.VariableType,
    ::InfrastructureSystems.Optimization.VariableType,
    ::InfrastructureSystems.Optimization.VariableType,
    ::InfrastructureSystems.Optimization.ConstraintType,
    devices::InfrastructureSystems.FlattenIteratorWrapper{W&lt;:Component},
    dic_var_bkpts::Dict{String, Vector{Float64}},
    dic_function_bkpts::Dict{String, Vector{Float64}};
    meta
)
</code></pre><pre><code class="language-julia hljs">_add_generic_incremental_interpolation_constraint!(container, ::R, ::S, ::T, ::U, ::V, devices, dic_var_bkpts, dic_function_bkpts; meta)</code></pre><p>Add incremental piecewise linear interpolation constraints to an optimization container.</p><p>This function implements the incremental method for piecewise linear approximation in optimization models. It creates constraints that relate the original variable (x) to its piecewise linear approximation (y = f(x)) using interpolation variables (δ) and binary variables (z) to ensure proper ordering.</p><p>The incremental method represents each segment of the PWL function as:</p><ul><li>x = x₁ + Σᵢ δᵢ(xᵢ₊₁ - xᵢ) where δᵢ ∈ [0,1]</li><li>y = y₁ + Σᵢ δᵢ(yᵢ₊₁ - yᵢ) where yᵢ = f(xᵢ)</li></ul><p>Binary variables z ensure the incremental property: δᵢ₊₁ ≤ zᵢ ≤ δᵢ for adjacent segments.</p><p><strong>Arguments</strong></p><ul><li><code>container::OptimizationContainer</code>: The optimization container to add constraints to</li><li><code>::R</code>: Type parameter for the original variable (x)</li><li><code>::S</code>: Type parameter for the approximated variable (y = f(x))  </li><li><code>::T</code>: Type parameter for the interpolation variables (δ)</li><li><code>::U</code>: Type parameter for the binary interpolation variables (z)</li><li><code>::V</code>: Type parameter for the constraint type</li><li><code>devices::IS.FlattenIteratorWrapper{W}</code>: Collection of devices to apply constraints to</li><li><code>dic_var_bkpts::Dict{String, Vector{Float64}}</code>: Breakpoints in the domain (x-coordinates) for each device</li><li><code>dic_function_bkpts::Dict{String, Vector{Float64}}</code>: Function values at breakpoints (y-coordinates) for each device</li><li><code>meta</code>: Metadata for constraint naming (default: empty)</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>R &lt;: VariableType</code>: Original variable type</li><li><code>S &lt;: VariableType</code>: Approximated variable type  </li><li><code>T &lt;: VariableType</code>: Interpolation variable type</li><li><code>U &lt;: VariableType</code>: Binary interpolation variable type</li><li><code>V &lt;: ConstraintType</code>: Constraint type</li><li><code>W &lt;: PSY.Component</code>: Component type for devices</li></ul><p><strong>Notes</strong></p><ul><li>Creates two types of constraints: variable interpolation and function interpolation</li><li>Adds ordering constraints for binary variables to ensure incremental property</li><li>All constraints are applied for each device and time step</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_pwl_methods.jl#L149">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations._add_pwl_constraint!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, U, Vector{Float64}, PowerSimulations.SOSStatusVariableModule.SOSStatusVariable, Int64}} where {T&lt;:Component, U&lt;:InfrastructureSystems.Optimization.VariableType}"><a class="docstring-binding" href="#PowerSimulations._add_pwl_constraint!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, U, Vector{Float64}, PowerSimulations.SOSStatusVariableModule.SOSStatusVariable, Int64}} where {T&lt;:Component, U&lt;:InfrastructureSystems.Optimization.VariableType}"><code>PowerSimulations._add_pwl_constraint!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_add_pwl_constraint!(
    container::PowerSimulations.OptimizationContainer,
    component::Component,
    _::InfrastructureSystems.Optimization.VariableType,
    break_points::Vector{Float64},
    sos_status::PowerSimulations.SOSStatusVariableModule.SOSStatusVariable,
    period::Int64
)
</code></pre><p>Implement the constraints for PWL variables. That is:</p><p class="math-container">\[\sum_{k\in\mathcal{K}} P_k^{max} \delta_{k,t} = p_t \\
\sum_{k\in\mathcal{K}} \delta_{k,t} = on_t\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/objective_function/piecewise_linear.jl#L103">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations._add_pwl_constraint!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, U, Vector{Float64}, PowerSimulations.SOSStatusVariableModule.SOSStatusVariable, Int64}} where {T&lt;:Component, U&lt;:PowerAboveMinimumVariable}"><a class="docstring-binding" href="#PowerSimulations._add_pwl_constraint!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, U, Vector{Float64}, PowerSimulations.SOSStatusVariableModule.SOSStatusVariable, Int64}} where {T&lt;:Component, U&lt;:PowerAboveMinimumVariable}"><code>PowerSimulations._add_pwl_constraint!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_add_pwl_constraint!(
    container::PowerSimulations.OptimizationContainer,
    component::Component,
    _::PowerAboveMinimumVariable,
    break_points::Vector{Float64},
    sos_status::PowerSimulations.SOSStatusVariableModule.SOSStatusVariable,
    period::Int64
)
</code></pre><p>Implement the constraints for PWL variables for Compact form. That is:</p><p class="math-container">\[\sum_{k\in\mathcal{K}} P_k^{max} \delta_{k,t} = p_t + P_min * u_t \\
\sum_{k\in\mathcal{K}} \delta_{k,t} = on_t\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/objective_function/piecewise_linear.jl#L151">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations._add_pwl_constraint!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, U, Vector{Float64}, PowerSimulations.SOSStatusVariableModule.SOSStatusVariable, Int64}} where {T&lt;:ReserveDemandCurve, U&lt;:ServiceRequirementVariable}"><a class="docstring-binding" href="#PowerSimulations._add_pwl_constraint!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, U, Vector{Float64}, PowerSimulations.SOSStatusVariableModule.SOSStatusVariable, Int64}} where {T&lt;:ReserveDemandCurve, U&lt;:ServiceRequirementVariable}"><code>PowerSimulations._add_pwl_constraint!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_add_pwl_constraint!(
    container::PowerSimulations.OptimizationContainer,
    component::ReserveDemandCurve,
    _::ServiceRequirementVariable,
    break_points::Vector{Float64},
    sos_status::PowerSimulations.SOSStatusVariableModule.SOSStatusVariable,
    period::Int64
)
</code></pre><p>Implement the constraints for PWL Block Offer variables for ORDC. That is:</p><p class="math-container">\[\sum_{k\in\mathcal{K}} \delta_{k,t} = p_t \\
\sum_{k\in\mathcal{K}} \delta_{k,t} &lt;= P_{k+1,t}^{max} - P_{k,t}^{max}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/objective_function/market_bid.jl#L598">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations._add_pwl_constraint!-Union{Tuple{W}, Tuple{V}, Tuple{D}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, U, D, Vector{&lt;:Union{Float64, JuMP.AbstractJuMPScalar}}, Int64, Type{V}, Type{W}}} where {T&lt;:Component, U&lt;:InfrastructureSystems.Optimization.VariableType, D&lt;:PowerSimulations.AbstractDeviceFormulation, V&lt;:PowerSimulations.AbstractPiecewiseLinearBlockOffer, W&lt;:PowerSimulations.AbstractPiecewiseLinearBlockOfferConstraint}"><a class="docstring-binding" href="#PowerSimulations._add_pwl_constraint!-Union{Tuple{W}, Tuple{V}, Tuple{D}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, U, D, Vector{&lt;:Union{Float64, JuMP.AbstractJuMPScalar}}, Int64, Type{V}, Type{W}}} where {T&lt;:Component, U&lt;:InfrastructureSystems.Optimization.VariableType, D&lt;:PowerSimulations.AbstractDeviceFormulation, V&lt;:PowerSimulations.AbstractPiecewiseLinearBlockOffer, W&lt;:PowerSimulations.AbstractPiecewiseLinearBlockOfferConstraint}"><code>PowerSimulations._add_pwl_constraint!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_add_pwl_constraint!(
    container::PowerSimulations.OptimizationContainer,
    component::Component,
    _::InfrastructureSystems.Optimization.VariableType,
    _::PowerSimulations.AbstractDeviceFormulation,
    break_points::Vector{&lt;:Union{Float64, JuMP.AbstractJuMPScalar}},
    period::Int64,
    _::Type{V&lt;:PowerSimulations.AbstractPiecewiseLinearBlockOffer},
    _::Type{W&lt;:PowerSimulations.AbstractPiecewiseLinearBlockOfferConstraint}
)
</code></pre><p>Implement the constraints for PWL Block Offer variables. That is:</p><p class="math-container">\[\sum_{k\in\mathcal{K}} \delta_{k,t} = p_t \\
\sum_{k\in\mathcal{K}} \delta_{k,t} &lt;= P_{k+1,t}^{max} - P_{k,t}^{max}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/objective_function/market_bid.jl#L537">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations._add_pwl_sos_constraint!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, U, Vector{Float64}, PowerSimulations.SOSStatusVariableModule.SOSStatusVariable, Int64}} where {T&lt;:Component, U&lt;:InfrastructureSystems.Optimization.VariableType}"><a class="docstring-binding" href="#PowerSimulations._add_pwl_sos_constraint!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, U, Vector{Float64}, PowerSimulations.SOSStatusVariableModule.SOSStatusVariable, Int64}} where {T&lt;:Component, U&lt;:InfrastructureSystems.Optimization.VariableType}"><code>PowerSimulations._add_pwl_sos_constraint!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_add_pwl_sos_constraint!(
    container::PowerSimulations.OptimizationContainer,
    component::Component,
    _::InfrastructureSystems.Optimization.VariableType,
    break_points::Vector{Float64},
    sos_status::PowerSimulations.SOSStatusVariableModule.SOSStatusVariable,
    period::Int64
)
</code></pre><p>Implement the SOS for PWL variables. That is:</p><p class="math-container">\[\{\delta_{i,t}, ..., \delta_{k,t}\} \in \text{SOS}_2\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/objective_function/piecewise_linear.jl#L220">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations._add_pwl_term!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Union{CostCurve{PiecewisePointCurve}, FuelCurve{PiecewisePointCurve}}, U, V}} where {T&lt;:Component, U&lt;:InfrastructureSystems.Optimization.VariableType, V&lt;:PowerSimulations.AbstractDeviceFormulation}"><a class="docstring-binding" href="#PowerSimulations._add_pwl_term!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Union{CostCurve{PiecewisePointCurve}, FuelCurve{PiecewisePointCurve}}, U, V}} where {T&lt;:Component, U&lt;:InfrastructureSystems.Optimization.VariableType, V&lt;:PowerSimulations.AbstractDeviceFormulation}"><code>PowerSimulations._add_pwl_term!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_add_pwl_term!(
    container::PowerSimulations.OptimizationContainer,
    component::Component,
    cost_function::Union{CostCurve{PiecewisePointCurve}, FuelCurve{PiecewisePointCurve}},
    _::InfrastructureSystems.Optimization.VariableType,
    _::PowerSimulations.AbstractDeviceFormulation
) -&gt; Vector{JuMP.AffExpr}
</code></pre><p>Add PWL cost terms for data coming from a PiecewisePointCurve</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/objective_function/piecewise_linear.jl#L341">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations._add_pwl_term!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Union{CostCurve{PiecewisePointCurve}, FuelCurve{PiecewisePointCurve}}, U, V}} where {T&lt;:ThermalGen, U&lt;:InfrastructureSystems.Optimization.VariableType, V&lt;:ThermalDispatchNoMin}"><a class="docstring-binding" href="#PowerSimulations._add_pwl_term!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Union{CostCurve{PiecewisePointCurve}, FuelCurve{PiecewisePointCurve}}, U, V}} where {T&lt;:ThermalGen, U&lt;:InfrastructureSystems.Optimization.VariableType, V&lt;:ThermalDispatchNoMin}"><code>PowerSimulations._add_pwl_term!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_add_pwl_term!(
    container::PowerSimulations.OptimizationContainer,
    component::ThermalGen,
    cost_function::Union{CostCurve{PiecewisePointCurve}, FuelCurve{PiecewisePointCurve}},
    _::InfrastructureSystems.Optimization.VariableType,
    _::ThermalDispatchNoMin
) -&gt; Vector{JuMP.AffExpr}
</code></pre><p>Add PWL cost terms for data coming from a PiecewisePointCurve for ThermalDispatchNoMin formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/objective_function/piecewise_linear.jl#L396">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations._add_two_terminal_elements_map!-Tuple{System, PowerFlows.PowerFlowData, Vector{Pair{InfrastructureSystems.Optimization.OptimizationContainerKey, Any}}, Dict{Symbol, &lt;:Dict{InfrastructureSystems.Optimization.OptimizationContainerKey, &lt;:Dict}}}"><a class="docstring-binding" href="#PowerSimulations._add_two_terminal_elements_map!-Tuple{System, PowerFlows.PowerFlowData, Vector{Pair{InfrastructureSystems.Optimization.OptimizationContainerKey, Any}}, Dict{Symbol, &lt;:Dict{InfrastructureSystems.Optimization.OptimizationContainerKey, &lt;:Dict}}}"><code>PowerSimulations._add_two_terminal_elements_map!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_add_two_terminal_elements_map!(
    sys::System,
    pf_data::PowerFlows.PowerFlowData,
    available_keys::Vector{Pair{InfrastructureSystems.Optimization.OptimizationContainerKey, Any}},
    input_key_map::Dict{Symbol, &lt;:Dict{InfrastructureSystems.Optimization.OptimizationContainerKey, &lt;:Dict}}
)
</code></pre><pre><code class="language-julia hljs">_add_two_terminal_elements_map!(
    sys::PSY.System,
    pf_data::PFS.PowerFlowData,
    available_keys::Vector{Pair{OptimizationContainerKey, Any}},
    input_key_map::Dict{Symbol, Dict{OptimizationContainerKey, Dict{String, Int64}}}
)</code></pre><p>Adds mappings for two-terminal elements (HVDC components) that connect the power flow results (from -&gt; to, to -&gt; from) to be added to the mappings for all component types. The results for these elements are added as bus injections in the <code>PowerFlowData</code> as a simplified representation of these components.</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>: <code>System</code> instance representing the power system model.</li><li><code>pf_data::PFS.PowerFlowData</code>: The power flow data used internally for power flow calculations.</li><li><code>available_keys::Vector{Pair{OptimizationContainerKey, Any}}</code>: A vector of available optimization container keys and their associated values.</li><li><code>input_key_map::Dict{Symbol, Dict{OptimizationContainerKey, Dict{String, Int64}}}</code>: A dictionary mapping categories to optimization container keys and their associated mappings. To be extended in this function by the mappings for the two-terminal elements to the respective buses in the <code>PowerFlowData</code> instance.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/network_models/power_flow_evaluation.jl#L221">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, CostCurve{LinearCurve}, U}} where {T&lt;:InfrastructureSystems.Optimization.VariableType, U&lt;:PowerSimulations.AbstractDeviceFormulation}"><a class="docstring-binding" href="#PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, CostCurve{LinearCurve}, U}} where {T&lt;:InfrastructureSystems.Optimization.VariableType, U&lt;:PowerSimulations.AbstractDeviceFormulation}"><code>PowerSimulations._add_variable_cost_to_objective!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_add_variable_cost_to_objective!(
    container::PowerSimulations.OptimizationContainer,
    _::InfrastructureSystems.Optimization.VariableType,
    component::Component,
    cost_function::CostCurve{LinearCurve},
    _::PowerSimulations.AbstractDeviceFormulation
)
</code></pre><p>Adds to the cost function cost terms for sum of variables with common factor to be used for cost expression for optimization_container model.</p><p><strong>Arguments</strong></p><ul><li>container::OptimizationContainer : the optimization_container model built in PowerSimulations</li><li>var_key::VariableKey: The variable name</li><li>component<em>name::String: The component</em>name of the variable container</li><li>cost_component::PSY.CostCurve{PSY.LinearCurve} : container for cost to be associated with variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/objective_function/linear_curve.jl#L66">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, CostCurve{PiecewisePointCurve}, U}} where {T&lt;:InfrastructureSystems.Optimization.VariableType, U&lt;:PowerSimulations.AbstractDeviceFormulation}"><a class="docstring-binding" href="#PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, CostCurve{PiecewisePointCurve}, U}} where {T&lt;:InfrastructureSystems.Optimization.VariableType, U&lt;:PowerSimulations.AbstractDeviceFormulation}"><code>PowerSimulations._add_variable_cost_to_objective!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_add_variable_cost_to_objective!(
    container::PowerSimulations.OptimizationContainer,
    _::InfrastructureSystems.Optimization.VariableType,
    component::Component,
    cost_function::CostCurve{PiecewisePointCurve},
    _::PowerSimulations.AbstractDeviceFormulation
)
</code></pre><p>Creates piecewise linear cost function using a sum of variables and expression with sign and time step included.</p><p><strong>Arguments</strong></p><ul><li>container::OptimizationContainer : the optimization_container model built in PowerSimulations</li><li>var_key::VariableKey: The variable name</li><li>component<em>name::String: The component</em>name of the variable container</li><li>cost_function::PSY.CostCurve{PSY.PiecewisePointCurve}: container for piecewise linear cost</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/objective_function/piecewise_linear.jl#L471">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, CostCurve{QuadraticCurve}, U}} where {T&lt;:InfrastructureSystems.Optimization.VariableType, U&lt;:PowerSimulations.AbstractDeviceFormulation}"><a class="docstring-binding" href="#PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, CostCurve{QuadraticCurve}, U}} where {T&lt;:InfrastructureSystems.Optimization.VariableType, U&lt;:PowerSimulations.AbstractDeviceFormulation}"><code>PowerSimulations._add_variable_cost_to_objective!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_add_variable_cost_to_objective!(
    container::PowerSimulations.OptimizationContainer,
    _::InfrastructureSystems.Optimization.VariableType,
    component::Component,
    cost_function::CostCurve{QuadraticCurve},
    _::PowerSimulations.AbstractDeviceFormulation
)
</code></pre><p>Adds to the cost function cost terms for sum of variables with common factor to be used for cost expression for optimization_container model.</p><p><strong>Equation</strong></p><p><code>gen_cost = dt*sign*(sum(variable.^2)*cost_data[1] + sum(variable)*cost_data[2])</code></p><p><strong>LaTeX</strong></p><p><span>$cost = dt\times sign (sum_{i\in I} c_1 v_i^2 + sum_{i\in I} c_2 v_i )$</span></p><p>for quadratic factor large enough. If the first term of the quadratic objective is 0.0, adds a linear cost term <code>sum(variable)*cost_data[2]</code></p><p><strong>Arguments</strong></p><ul><li>container::OptimizationContainer : the optimization_container model built in PowerSimulations</li><li>var_key::VariableKey: The variable name</li><li>component<em>name::String: The component</em>name of the variable container</li><li>cost_component::PSY.CostCurve{PSY.QuadraticCurve} : container for quadratic factors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/objective_function/quadratic_curve.jl#L116">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, FuelCurve{LinearCurve}, U}} where {T&lt;:InfrastructureSystems.Optimization.VariableType, U&lt;:PowerSimulations.AbstractDeviceFormulation}"><a class="docstring-binding" href="#PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, FuelCurve{LinearCurve}, U}} where {T&lt;:InfrastructureSystems.Optimization.VariableType, U&lt;:PowerSimulations.AbstractDeviceFormulation}"><code>PowerSimulations._add_variable_cost_to_objective!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_add_variable_cost_to_objective!(
    container::PowerSimulations.OptimizationContainer,
    _::InfrastructureSystems.Optimization.VariableType,
    component::Component,
    cost_function::FuelCurve{LinearCurve},
    _::PowerSimulations.AbstractDeviceFormulation
)
</code></pre><p>Adds to the cost function cost terms for sum of variables with common factor to be used for cost expression for optimization_container model.</p><p><strong>Arguments</strong></p><ul><li>container::OptimizationContainer : the optimization_container model built in PowerSimulations</li><li>var_key::VariableKey: The variable name</li><li>component<em>name::String: The component</em>name of the variable container</li><li>cost_component::PSY.FuelCurve{PSY.LinearCurve} : container for cost to be associated with variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/objective_function/linear_curve.jl#L126">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, FuelCurve{PiecewisePointCurve}, U}} where {T&lt;:InfrastructureSystems.Optimization.VariableType, U&lt;:PowerSimulations.AbstractDeviceFormulation}"><a class="docstring-binding" href="#PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, FuelCurve{PiecewisePointCurve}, U}} where {T&lt;:InfrastructureSystems.Optimization.VariableType, U&lt;:PowerSimulations.AbstractDeviceFormulation}"><code>PowerSimulations._add_variable_cost_to_objective!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_add_variable_cost_to_objective!(
    container::PowerSimulations.OptimizationContainer,
    _::InfrastructureSystems.Optimization.VariableType,
    component::Component,
    cost_function::FuelCurve{PiecewisePointCurve},
    _::PowerSimulations.AbstractDeviceFormulation
)
</code></pre><p>Creates piecewise linear cost function using a sum of variables and expression with sign and time step included.</p><p><strong>Arguments</strong></p><ul><li>container::OptimizationContainer : the optimization_container model built in PowerSimulations</li><li>var_key::VariableKey: The variable name</li><li>component<em>name::String: The component</em>name of the variable container</li><li>cost_function::PSY.CostCurve{PSY.PiecewisePointCurve}: container for piecewise linear cost</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/objective_function/piecewise_linear.jl#L513">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, FuelCurve{QuadraticCurve}, U}} where {T&lt;:InfrastructureSystems.Optimization.VariableType, U&lt;:PowerSimulations.AbstractDeviceFormulation}"><a class="docstring-binding" href="#PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, FuelCurve{QuadraticCurve}, U}} where {T&lt;:InfrastructureSystems.Optimization.VariableType, U&lt;:PowerSimulations.AbstractDeviceFormulation}"><code>PowerSimulations._add_variable_cost_to_objective!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_add_variable_cost_to_objective!(
    container::PowerSimulations.OptimizationContainer,
    _::InfrastructureSystems.Optimization.VariableType,
    component::Component,
    cost_function::FuelCurve{QuadraticCurve},
    _::PowerSimulations.AbstractDeviceFormulation
)
</code></pre><p>Adds to the cost function cost terms for sum of variables with common factor to be used for cost expression for optimization_container model.</p><p><strong>Equation</strong></p><p><code>gen_cost = dt*(sum(variable.^2)*cost_data[1]*fuel_cost + sum(variable)*cost_data[2]*fuel_cost)</code></p><p><strong>LaTeX</strong></p><p><span>$cost = dt\times  (sum_{i\in I} c_f c_1 v_i^2 + sum_{i\in I} c_f c_2 v_i )$</span></p><p>for quadratic factor large enough. If the first term of the quadratic objective is 0.0, adds a linear cost term <code>sum(variable)*cost_data[2]</code></p><p><strong>Arguments</strong></p><ul><li>container::OptimizationContainer : the optimization_container model built in PowerSimulations</li><li>var_key::VariableKey: The variable name</li><li>component<em>name::String: The component</em>name of the variable container</li><li>cost_component::PSY.FuelCurve{PSY.QuadraticCurve} : container for quadratic factors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/objective_function/quadratic_curve.jl#L224">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, OfferCurveCost, U}} where {T&lt;:InfrastructureSystems.Optimization.VariableType, U&lt;:PowerSimulations.AbstractDeviceFormulation}"><a class="docstring-binding" href="#PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, OfferCurveCost, U}} where {T&lt;:InfrastructureSystems.Optimization.VariableType, U&lt;:PowerSimulations.AbstractDeviceFormulation}"><code>PowerSimulations._add_variable_cost_to_objective!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_add_variable_cost_to_objective!(
    container::PowerSimulations.OptimizationContainer,
    _::InfrastructureSystems.Optimization.VariableType,
    component::Component,
    cost_function::OfferCurveCost,
    _::PowerSimulations.AbstractDeviceFormulation
)
</code></pre><p>Creates piecewise linear market bid function using a sum of variables and expression for market participants. Decremental offers are not accepted for most components, except Storage systems and loads.</p><p><strong>Arguments</strong></p><ul><li>container::OptimizationContainer : the optimization_container model built in PowerSimulations</li><li>var_key::VariableKey: The variable name</li><li>component<em>name::String: The component</em>name of the variable container</li><li>cost_function::MarketBidCost : container for market bid cost</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/objective_function/market_bid.jl#L879">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{V}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, V, U}} where {T&lt;:InfrastructureSystems.Optimization.VariableType, V&lt;:Union{CostCurve{PiecewiseAverageCurve}, CostCurve{PiecewiseIncrementalCurve}}, U&lt;:PowerSimulations.AbstractDeviceFormulation}"><a class="docstring-binding" href="#PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{V}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, V, U}} where {T&lt;:InfrastructureSystems.Optimization.VariableType, V&lt;:Union{CostCurve{PiecewiseAverageCurve}, CostCurve{PiecewiseIncrementalCurve}}, U&lt;:PowerSimulations.AbstractDeviceFormulation}"><code>PowerSimulations._add_variable_cost_to_objective!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_add_variable_cost_to_objective!(
    container::PowerSimulations.OptimizationContainer,
    _::InfrastructureSystems.Optimization.VariableType,
    component::Component,
    cost_function::Union{CostCurve{PiecewiseAverageCurve}, CostCurve{PiecewiseIncrementalCurve}},
    _::PowerSimulations.AbstractDeviceFormulation
)
</code></pre><p>Creates piecewise linear cost function using a sum of variables and expression with sign and time step included.</p><p><strong>Arguments</strong></p><ul><li>container::OptimizationContainer : the optimization_container model built in PowerSimulations</li><li>var_key::VariableKey: The variable name</li><li>component<em>name::String: The component</em>name of the variable container</li><li>cost_function::PSY.Union{PSY.CostCurve{PSY.PiecewiseIncrementalCurve}, PSY.CostCurve{PSY.PiecewiseAverageCurve}}: container for piecewise linear cost</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/objective_function/piecewise_linear.jl#L578">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{V}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, V, U}} where {T&lt;:InfrastructureSystems.Optimization.VariableType, V&lt;:Union{FuelCurve{PiecewiseAverageCurve}, FuelCurve{PiecewiseIncrementalCurve}}, U&lt;:PowerSimulations.AbstractDeviceFormulation}"><a class="docstring-binding" href="#PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{V}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, V, U}} where {T&lt;:InfrastructureSystems.Optimization.VariableType, V&lt;:Union{FuelCurve{PiecewiseAverageCurve}, FuelCurve{PiecewiseIncrementalCurve}}, U&lt;:PowerSimulations.AbstractDeviceFormulation}"><code>PowerSimulations._add_variable_cost_to_objective!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_add_variable_cost_to_objective!(
    container::PowerSimulations.OptimizationContainer,
    _::InfrastructureSystems.Optimization.VariableType,
    component::Component,
    cost_function::Union{FuelCurve{PiecewiseAverageCurve}, FuelCurve{PiecewiseIncrementalCurve}},
    _::PowerSimulations.AbstractDeviceFormulation
)
</code></pre><p>Creates piecewise linear fuel cost function using a sum of variables and expression with sign and time step included.</p><p><strong>Arguments</strong></p><ul><li>container::OptimizationContainer : the optimization_container model built in PowerSimulations</li><li>var_key::VariableKey: The variable name</li><li>component<em>name::String: The component</em>name of the variable container</li><li>cost_function::PSY.Union{PSY.FuelCurve{PSY.PiecewiseIncrementalCurve}, PSY.FuelCurve{PSY.PiecewiseAverageCurve}}: container for piecewise linear cost</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/objective_function/piecewise_linear.jl#L624">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations._allocate_execution_order-Tuple{Vector{Int64}}"><a class="docstring-binding" href="#PowerSimulations._allocate_execution_order-Tuple{Vector{Int64}}"><code>PowerSimulations._allocate_execution_order</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_allocate_execution_order(
    interval_run_counts::Vector{Int64}
) -&gt; Vector{Int64}
</code></pre><p>Function calculates the total number of problem executions in the simulation and allocates the appropiate vector</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/simulation_sequence.jl#L73">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations._calculate_interval_inner_counts-Tuple{OrderedDict{Symbol, Dates.Millisecond}}"><a class="docstring-binding" href="#PowerSimulations._calculate_interval_inner_counts-Tuple{OrderedDict{Symbol, Dates.Millisecond}}"><code>PowerSimulations._calculate_interval_inner_counts</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_calculate_interval_inner_counts(
    intervals::OrderedDict{Symbol, Dates.Millisecond}
) -&gt; Vector{Int64}
</code></pre><p><em>calculate</em>interval<em>inner</em>counts(intervals::OrderedDict{String,&lt;:Dates.TimePeriod})</p><p>Calculates how many times a problem is executed for every interval of the previous problem</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/simulation_sequence.jl#L44">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations._get_breakpoints_for_pwl_function-Tuple{Float64, Float64, Any}"><a class="docstring-binding" href="#PowerSimulations._get_breakpoints_for_pwl_function-Tuple{Float64, Float64, Any}"><code>PowerSimulations._get_breakpoints_for_pwl_function</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_get_breakpoints_for_pwl_function(
    min_val::Float64,
    max_val::Float64,
    f;
    num_segments
) -&gt; Tuple{Vector{Float64}, Vector{Float64}}
</code></pre><pre><code class="language-julia hljs">_get_breakpoints_for_pwl_function(min_val, max_val, f; num_segments = DEFAULT_INTERPOLATION_LENGTH)</code></pre><p>Generate breakpoints for piecewise linear (PWL) approximation of a nonlinear function.</p><p>This function creates equally-spaced breakpoints over the specified domain [min<em>val, max</em>val] and evaluates the given function at each breakpoint to construct a piecewise linear approximation. The breakpoints are used in optimization problems to linearize nonlinear constraints or objectives.</p><p><strong>Arguments</strong></p><ul><li><code>min_val::Float64</code>: Minimum value of the domain for the PWL approximation</li><li><code>max_val::Float64</code>: Maximum value of the domain for the PWL approximation  </li><li><code>f</code>: Function to be approximated (must be callable with Float64 input)</li><li><code>num_segments::Int</code>: Number of linear segments in the PWL approximation (default: DEFAULT<em>INTERPOLATION</em>LENGTH)</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Vector{Float64}, Vector{Float64}}</code>: A tuple containing:<ul><li><code>x_bkpts</code>: Vector of x-coordinates (breakpoints) in the domain</li><li><code>y_bkpts</code>: Vector of y-coordinates (function values at breakpoints)</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>The number of breakpoints is <code>num_segments + 1</code></li><li>Breakpoints are equally spaced across the domain</li><li>The first breakpoint is always at <code>min_val</code> and the last at <code>max_val</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_pwl_methods.jl#L1">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations._get_data_for_tdc-Union{Tuple{U}, Tuple{T}, Tuple{Vector{T}, Vector{U}, Dates.TimePeriod}} where {T&lt;:InitialCondition, U&lt;:InitialCondition}"><a class="docstring-binding" href="#PowerSimulations._get_data_for_tdc-Union{Tuple{U}, Tuple{T}, Tuple{Vector{T}, Vector{U}, Dates.TimePeriod}} where {T&lt;:InitialCondition, U&lt;:InitialCondition}"><code>PowerSimulations._get_data_for_tdc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_get_data_for_tdc(
    initial_conditions_on::Array{T&lt;:InitialCondition, 1},
    initial_conditions_off::Array{U&lt;:InitialCondition, 1},
    resolution::Dates.TimePeriod
) -&gt; Tuple{Matrix{InitialCondition}, Vector{@NamedTuple{up::Float64, down::Float64}}}
</code></pre><p>If the fraction of hours that a generator has a duration constraint is less than the fraction of hours that a single time_step represents then it is not binding.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/thermal_generation.jl#L1333">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations._get_initial_condition_type-Tuple{Type{RampConstraint}, Type{&lt;:ThermalGen}, Type{&lt;:PowerSimulations.AbstractThermalFormulation}}"><a class="docstring-binding" href="#PowerSimulations._get_initial_condition_type-Tuple{Type{RampConstraint}, Type{&lt;:ThermalGen}, Type{&lt;:PowerSimulations.AbstractThermalFormulation}}"><code>PowerSimulations._get_initial_condition_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_get_initial_condition_type(
    _::Type{RampConstraint},
    _::Type{&lt;:ThermalGen},
    _::Type{&lt;:PowerSimulations.AbstractThermalFormulation}
) -&gt; Type{PowerSimulations.DeviceAboveMinPower}
</code></pre><p>This function gets the data for the generators for ramping constraints of thermal generators</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/thermal_generation.jl#L1004">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations._get_pwl_cost_expression-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Int64, Vector{Float64}, Float64}} where T&lt;:ReserveDemandCurve"><a class="docstring-binding" href="#PowerSimulations._get_pwl_cost_expression-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Int64, Vector{Float64}, Float64}} where T&lt;:ReserveDemandCurve"><code>PowerSimulations._get_pwl_cost_expression</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_get_pwl_cost_expression(
    container::PowerSimulations.OptimizationContainer,
    component::ReserveDemandCurve,
    time_period::Int64,
    slopes_normalized::Vector{Float64},
    multiplier::Float64
) -&gt; JuMP.AffExpr
</code></pre><p>Get cost expression for StepwiseCostReserve</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/objective_function/market_bid.jl#L686">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations._lookup_maybe_time_variant_param-Union{Tuple{U}, Tuple{F}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Int64, Val{false}, F, U}} where {T&lt;:Component, F&lt;:Function, U&lt;:InfrastructureSystems.Optimization.ParameterType}"><a class="docstring-binding" href="#PowerSimulations._lookup_maybe_time_variant_param-Union{Tuple{U}, Tuple{F}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Int64, Val{false}, F, U}} where {T&lt;:Component, F&lt;:Function, U&lt;:InfrastructureSystems.Optimization.ParameterType}"><code>PowerSimulations._lookup_maybe_time_variant_param</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_lookup_maybe_time_variant_param(
    _::PowerSimulations.OptimizationContainer,
    component::Component,
    _::Int64,
    _::Val{false},
    getter_func::Function,
    _::InfrastructureSystems.Optimization.ParameterType
) -&gt; Any
</code></pre><p>Either looks up a value in the component using <code>getter_func</code> or fetches the value from the parameter <code>U()</code>, depending on whether we are in the time-variant case or not</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/objective_function/common.jl#L44">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations._summary_to_dict!-Tuple{OptimizerStats, JuMP.Model}"><a class="docstring-binding" href="#PowerSimulations._summary_to_dict!-Tuple{OptimizerStats, JuMP.Model}"><code>PowerSimulations._summary_to_dict!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_summary_to_dict!(
    optimizer_stats::OptimizerStats,
    jump_model::JuMP.Model
)
</code></pre><p>Run this function only when getting detailed solver stats</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/utils/jump_utils.jl#L532">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations._validate_eltype-Union{Tuple{T}, Tuple{Type{T}, Component, TimeSeriesKey}, Tuple{Type{T}, Component, TimeSeriesKey, Any}} where T"><a class="docstring-binding" href="#PowerSimulations._validate_eltype-Union{Tuple{T}, Tuple{Type{T}, Component, TimeSeriesKey}, Tuple{Type{T}, Component, TimeSeriesKey, Any}} where T"><code>PowerSimulations._validate_eltype</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_validate_eltype(
    ::Type{T},
    component::Component,
    ts_key::TimeSeriesKey
) -&gt; Any
_validate_eltype(
    ::Type{T},
    component::Component,
    ts_key::TimeSeriesKey,
    msg
) -&gt; Any
</code></pre><p>Validate that the eltype of the time series, or the field itself if it&#39;s not a time series, is of the type given</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/utils/time_series_utils.jl#L33">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_constraints!-Union{Tuple{F}, Tuple{R}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, Union{InfrastructureSystems.FlattenIteratorWrapper{V}, Vector{V}}, R, ServiceModel{R, F}, NetworkModel{&lt;:PowerSimulations.AbstractPTDFModel}}} where {T&lt;:PostContingencyGenerationBalanceConstraint, U&lt;:PostContingencyActivePowerBalance, V&lt;:Generator, R&lt;:Union{Reserve{ReserveDown}, Reserve{ReserveUp}}, F&lt;:PowerSimulations.AbstractSecurityConstrainedReservesFormulation}"><a class="docstring-binding" href="#PowerSimulations.add_constraints!-Union{Tuple{F}, Tuple{R}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, Union{InfrastructureSystems.FlattenIteratorWrapper{V}, Vector{V}}, R, ServiceModel{R, F}, NetworkModel{&lt;:PowerSimulations.AbstractPTDFModel}}} where {T&lt;:PostContingencyGenerationBalanceConstraint, U&lt;:PostContingencyActivePowerBalance, V&lt;:Generator, R&lt;:Union{Reserve{ReserveDown}, Reserve{ReserveUp}}, F&lt;:PowerSimulations.AbstractSecurityConstrainedReservesFormulation}"><code>PowerSimulations.add_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_constraints!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:PostContingencyGenerationBalanceConstraint},
    _::Type{U&lt;:PostContingencyActivePowerBalance},
    contributing_devices::Union{Array{V&lt;:Generator, 1}, InfrastructureSystems.FlattenIteratorWrapper{V&lt;:Generator}},
    service::Union{Reserve{ReserveDown}, Reserve{ReserveUp}},
    model::ServiceModel{R&lt;:Union{Reserve{ReserveDown}, Reserve{ReserveUp}}, F&lt;:PowerSimulations.AbstractSecurityConstrainedReservesFormulation},
    _::NetworkModel{&lt;:PowerSimulations.AbstractPTDFModel}
)
</code></pre><p>Add post-contingency Generation Balance Constraints for Generators for G-1 formulation and G-1 with reserves (SecurityConstrainedReservesFormulation)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/static_injection_security_constrained_models.jl#L450">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_constraints!-Union{Tuple{F}, Tuple{R}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, Union{InfrastructureSystems.FlattenIteratorWrapper{V}, Vector{V}}, R, Union{DeviceModel{R, F}, ServiceModel{R, F}}, NetworkModel{&lt;:PowerSimulations.AbstractPTDFModel}}} where {T&lt;:PostContingencyEmergencyRateLimitConstrain, U&lt;:PostContingencyBranchFlow, V&lt;:ACTransmission, R&lt;:Union{Generator, Reserve{ReserveDown}, Reserve{ReserveUp}}, F&lt;:Union{PowerSimulations.AbstractSecurityConstrainedReservesFormulation, PowerSimulations.AbstractSecurityConstrainedUnitCommitment}}"><a class="docstring-binding" href="#PowerSimulations.add_constraints!-Union{Tuple{F}, Tuple{R}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, Union{InfrastructureSystems.FlattenIteratorWrapper{V}, Vector{V}}, R, Union{DeviceModel{R, F}, ServiceModel{R, F}}, NetworkModel{&lt;:PowerSimulations.AbstractPTDFModel}}} where {T&lt;:PostContingencyEmergencyRateLimitConstrain, U&lt;:PostContingencyBranchFlow, V&lt;:ACTransmission, R&lt;:Union{Generator, Reserve{ReserveDown}, Reserve{ReserveUp}}, F&lt;:Union{PowerSimulations.AbstractSecurityConstrainedReservesFormulation, PowerSimulations.AbstractSecurityConstrainedUnitCommitment}}"><code>PowerSimulations.add_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_constraints!(
    container::PowerSimulations.OptimizationContainer,
    cons_type::Type{T&lt;:PostContingencyEmergencyRateLimitConstrain},
    _::Type{U&lt;:PostContingencyBranchFlow},
    branches::Union{Array{V&lt;:ACTransmission, 1}, InfrastructureSystems.FlattenIteratorWrapper{V&lt;:ACTransmission}},
    service::Union{Generator, Reserve{ReserveDown}, Reserve{ReserveUp}},
    device_model::Union{DeviceModel{R&lt;:Union{Generator, Reserve{ReserveDown}, Reserve{ReserveUp}}, F&lt;:Union{PowerSimulations.AbstractSecurityConstrainedReservesFormulation, PowerSimulations.AbstractSecurityConstrainedUnitCommitment}}, ServiceModel{R&lt;:Union{Generator, Reserve{ReserveDown}, Reserve{ReserveUp}}, F&lt;:Union{PowerSimulations.AbstractSecurityConstrainedReservesFormulation, PowerSimulations.AbstractSecurityConstrainedUnitCommitment}}},
    network_model::NetworkModel{&lt;:PowerSimulations.AbstractPTDFModel}
)
</code></pre><p>Add branch post-contingency rate limit constraints for ACBranch after a G-k outage</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/static_injection_security_constrained_models.jl#L594">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_constraints!-Union{Tuple{N}, Tuple{F}, Tuple{R}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, Type{T}, Type{U}, Union{InfrastructureSystems.FlattenIteratorWrapper{V}, Vector{V}}, Union{DeviceModel{R, F}, ServiceModel{R, F}}, NetworkModel{N}}} where {T&lt;:PostContingencyRampConstraint, U&lt;:PowerSimulations.AbstractContingencyVariableType, V&lt;:Generator, R&lt;:Union{Nothing, Reserve{ReserveDown}, Reserve{ReserveUp}}, F&lt;:Union{PowerSimulations.AbstractSecurityConstrainedReservesFormulation, PowerSimulations.AbstractSecurityConstrainedUnitCommitment}, N&lt;:PowerSimulations.AbstractPTDFModel}"><a class="docstring-binding" href="#PowerSimulations.add_constraints!-Union{Tuple{N}, Tuple{F}, Tuple{R}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, Type{T}, Type{U}, Union{InfrastructureSystems.FlattenIteratorWrapper{V}, Vector{V}}, Union{DeviceModel{R, F}, ServiceModel{R, F}}, NetworkModel{N}}} where {T&lt;:PostContingencyRampConstraint, U&lt;:PowerSimulations.AbstractContingencyVariableType, V&lt;:Generator, R&lt;:Union{Nothing, Reserve{ReserveDown}, Reserve{ReserveUp}}, F&lt;:Union{PowerSimulations.AbstractSecurityConstrainedReservesFormulation, PowerSimulations.AbstractSecurityConstrainedUnitCommitment}, N&lt;:PowerSimulations.AbstractPTDFModel}"><code>PowerSimulations.add_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_constraints!(
    container::PowerSimulations.OptimizationContainer,
    sys::System,
    ::Type{T&lt;:PostContingencyRampConstraint},
    ::Type{U&lt;:PowerSimulations.AbstractContingencyVariableType},
    devices::Union{Array{V&lt;:Generator, 1}, InfrastructureSystems.FlattenIteratorWrapper{V&lt;:Generator}},
    model::Union{DeviceModel{R&lt;:Union{Nothing, Reserve{ReserveDown}, Reserve{ReserveUp}}, F&lt;:Union{PowerSimulations.AbstractSecurityConstrainedReservesFormulation, PowerSimulations.AbstractSecurityConstrainedUnitCommitment}}, ServiceModel{R&lt;:Union{Nothing, Reserve{ReserveDown}, Reserve{ReserveUp}}, F&lt;:Union{PowerSimulations.AbstractSecurityConstrainedReservesFormulation, PowerSimulations.AbstractSecurityConstrainedUnitCommitment}}},
    ::NetworkModel{N&lt;:PowerSimulations.AbstractPTDFModel};
    service
)
</code></pre><p>This function adds the post-contingency ramping limits</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/static_injection_security_constrained_models.jl#L704">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_constraints!-Union{Tuple{SR}, Tuple{PowerSimulations.OptimizationContainer, Type{RequirementConstraint}, SR, Vector{&lt;:Service}, ServiceModel{SR, GroupReserve}}} where SR&lt;:ConstantReserveGroup"><a class="docstring-binding" href="#PowerSimulations.add_constraints!-Union{Tuple{SR}, Tuple{PowerSimulations.OptimizationContainer, Type{RequirementConstraint}, SR, Vector{&lt;:Service}, ServiceModel{SR, GroupReserve}}} where SR&lt;:ConstantReserveGroup"><code>PowerSimulations.add_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_constraints!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{RequirementConstraint},
    service::ConstantReserveGroup,
    contributing_services::Vector{&lt;:Service},
    model::ServiceModel{SR&lt;:ConstantReserveGroup, GroupReserve}
)
</code></pre><p>This function creates the requirement constraint that will be attained by the appropriate services</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/services_models/reserve_group.jl#L33">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{B}, Tuple{PowerSimulations.OptimizationContainer, Type{FlowRateConstraintFromTo}, InfrastructureSystems.FlattenIteratorWrapper{B}, DeviceModel{B, &lt;:PowerSimulations.AbstractBranchFormulation}, NetworkModel{T}}} where {B&lt;:ACTransmission, T&lt;:PowerModels.AbstractPowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{B}, Tuple{PowerSimulations.OptimizationContainer, Type{FlowRateConstraintFromTo}, InfrastructureSystems.FlattenIteratorWrapper{B}, DeviceModel{B, &lt;:PowerSimulations.AbstractBranchFormulation}, NetworkModel{T}}} where {B&lt;:ACTransmission, T&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.add_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_constraints!(
    container::PowerSimulations.OptimizationContainer,
    cons_type::Type{FlowRateConstraintFromTo},
    devices::InfrastructureSystems.FlattenIteratorWrapper{B&lt;:ACTransmission},
    device_model::DeviceModel{B&lt;:ACTransmission, &lt;:PowerSimulations.AbstractBranchFormulation},
    network_model::NetworkModel{T&lt;:PowerModels.AbstractPowerModel}
)
</code></pre><p>Add rate limit from to constraints for ACBranch with AbstractPowerModel</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/AC_branches.jl#L516">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{B}, Tuple{PowerSimulations.OptimizationContainer, Type{FlowRateConstraintToFrom}, InfrastructureSystems.FlattenIteratorWrapper{B}, DeviceModel{B, &lt;:PowerSimulations.AbstractBranchFormulation}, NetworkModel{T}}} where {B&lt;:ACTransmission, T&lt;:PowerModels.AbstractPowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{B}, Tuple{PowerSimulations.OptimizationContainer, Type{FlowRateConstraintToFrom}, InfrastructureSystems.FlattenIteratorWrapper{B}, DeviceModel{B, &lt;:PowerSimulations.AbstractBranchFormulation}, NetworkModel{T}}} where {B&lt;:ACTransmission, T&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.add_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_constraints!(
    container::PowerSimulations.OptimizationContainer,
    cons_type::Type{FlowRateConstraintToFrom},
    devices::InfrastructureSystems.FlattenIteratorWrapper{B&lt;:ACTransmission},
    device_model::DeviceModel{B&lt;:ACTransmission, &lt;:PowerSimulations.AbstractBranchFormulation},
    network_model::NetworkModel{T&lt;:PowerModels.AbstractPowerModel}
)
</code></pre><p>Add rate limit to from constraints for ACBranch with AbstractPowerModel</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/AC_branches.jl#L568">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{FlowLimitConstraint}, InfrastructureSystems.FlattenIteratorWrapper{AreaInterchange}, DeviceModel{AreaInterchange, StaticBranch}, NetworkModel{T}}} where T&lt;:PowerModels.AbstractActivePowerModel"><a class="docstring-binding" href="#PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{FlowLimitConstraint}, InfrastructureSystems.FlattenIteratorWrapper{AreaInterchange}, DeviceModel{AreaInterchange, StaticBranch}, NetworkModel{T}}} where T&lt;:PowerModels.AbstractActivePowerModel"><code>PowerSimulations.add_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_constraints!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{FlowLimitConstraint},
    devices::InfrastructureSystems.FlattenIteratorWrapper{AreaInterchange},
    model::DeviceModel{AreaInterchange, StaticBranch},
    _::NetworkModel{T&lt;:PowerModels.AbstractActivePowerModel}
)
</code></pre><p>Add flow constraints for area interchanges</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/area_interchange.jl#L73">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{NetworkFlowConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, PhaseAngleControl}, NetworkModel{&lt;:PowerSimulations.AbstractPTDFModel}}} where T&lt;:PhaseShiftingTransformer"><a class="docstring-binding" href="#PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{NetworkFlowConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, PhaseAngleControl}, NetworkModel{&lt;:PowerSimulations.AbstractPTDFModel}}} where T&lt;:PhaseShiftingTransformer"><code>PowerSimulations.add_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_constraints!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{NetworkFlowConstraint},
    devices::InfrastructureSystems.FlattenIteratorWrapper{T&lt;:PhaseShiftingTransformer},
    model::DeviceModel{T&lt;:PhaseShiftingTransformer, PhaseAngleControl},
    network_model::NetworkModel{&lt;:PowerSimulations.AbstractPTDFModel}
)
</code></pre><p>Add network flow constraints for PhaseShiftingTransformer and NetworkModel with &lt;: AbstractPTDFModel</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/AC_branches.jl#L841">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{NetworkFlowConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, PhaseAngleControl}, NetworkModel{DCPPowerModel}}} where T&lt;:PhaseShiftingTransformer"><a class="docstring-binding" href="#PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{NetworkFlowConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, PhaseAngleControl}, NetworkModel{DCPPowerModel}}} where T&lt;:PhaseShiftingTransformer"><code>PowerSimulations.add_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_constraints!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{NetworkFlowConstraint},
    devices::InfrastructureSystems.FlattenIteratorWrapper{T&lt;:PhaseShiftingTransformer},
    model::DeviceModel{T&lt;:PhaseShiftingTransformer, PhaseAngleControl},
    _::NetworkModel{DCPPowerModel}
)
</code></pre><p>Add network flow constraints for PhaseShiftingTransformer and NetworkModel with PM.DCPPowerModel</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/AC_branches.jl#L1024">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{NetworkFlowConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, StaticBranchBounds}, NetworkModel{&lt;:PowerSimulations.AbstractPTDFModel}}} where T&lt;:ACTransmission"><a class="docstring-binding" href="#PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{NetworkFlowConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, StaticBranchBounds}, NetworkModel{&lt;:PowerSimulations.AbstractPTDFModel}}} where T&lt;:ACTransmission"><code>PowerSimulations.add_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_constraints!(
    container::PowerSimulations.OptimizationContainer,
    cons_type::Type{NetworkFlowConstraint},
    devices::InfrastructureSystems.FlattenIteratorWrapper{T&lt;:ACTransmission},
    device_model::DeviceModel{T&lt;:ACTransmission, StaticBranchBounds},
    network_model::NetworkModel{&lt;:PowerSimulations.AbstractPTDFModel}
)
</code></pre><p>Add network flow constraints for ACBranch and NetworkModel with &lt;: AbstractPTDFModel</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/AC_branches.jl#L780">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{StartTypeConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, ThermalMultiStartUnitCommitment}, NetworkModel}} where T&lt;:ThermalMultiStart"><a class="docstring-binding" href="#PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{StartTypeConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, ThermalMultiStartUnitCommitment}, NetworkModel}} where T&lt;:ThermalMultiStart"><code>PowerSimulations.add_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_constraints!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{StartTypeConstraint},
    devices::InfrastructureSystems.FlattenIteratorWrapper{T&lt;:ThermalMultiStart},
    model::DeviceModel{T&lt;:ThermalMultiStart, ThermalMultiStartUnitCommitment},
    _::NetworkModel
)
</code></pre><p>Constructs contraints that restricts devices to one type of start at a time</p><p><strong>Equations</strong></p><p><code>sum(var_starts[name, s, t] for s in starts) = var_start[name, t]</code></p><p><strong>LaTeX</strong></p><p><span>$\sum^{S_g}_{s=1} δ^{s}(t)  \eq  x^{start}(t)$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/thermal_generation.jl#L1196">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{StartupInitialConditionConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, ThermalMultiStartUnitCommitment}, NetworkModel}} where T&lt;:ThermalMultiStart"><a class="docstring-binding" href="#PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{StartupInitialConditionConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, ThermalMultiStartUnitCommitment}, NetworkModel}} where T&lt;:ThermalMultiStart"><code>PowerSimulations.add_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_constraints!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{StartupInitialConditionConstraint},
    devices::InfrastructureSystems.FlattenIteratorWrapper{T&lt;:ThermalMultiStart},
    model::DeviceModel{T&lt;:ThermalMultiStart, ThermalMultiStartUnitCommitment},
    _::NetworkModel
)
</code></pre><p>Constructs contraints that restricts devices to one type of start at a time</p><p><strong>Equations</strong></p><p>ub: <code>(time_limits[st+1]-1)*δ^{s}(t) + (1 - δ^{s}(t)) * M_VALUE &gt;= sum(1-varbin[name, i]) for i in 1:t) + initial_condition_offtime</code> lb: <code>(time_limits[st]-1)*δ^{s}(t) =&lt; sum(1-varbin[name, i]) for i in 1:t) + initial_condition_offtime</code></p><p><strong>LaTeX</strong></p><p><span>$TS^{s+1}_{g} δ^{s}(t) + (1-δ^{s}(t)) M_VALUE   \geq  \sum^{t}_{i=1} x^{status}(i)  +  DT_{g}^{0}  \forall t in \{1, \ldots,  TS^{s+1}_{g}$</span></p><p><span>$TS^{s}_{g} δ^{s}(t) \leq  \sum^{t}_{i=1} x^{status}(i)  +  DT_{g}^{0}  \forall t in \{1, \ldots,  TS^{s+1}_{g}$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/thermal_generation.jl#L1244">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{StartupTimeLimitTemperatureConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, ThermalMultiStartUnitCommitment}, NetworkModel}} where T&lt;:ThermalMultiStart"><a class="docstring-binding" href="#PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{StartupTimeLimitTemperatureConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, ThermalMultiStartUnitCommitment}, NetworkModel}} where T&lt;:ThermalMultiStart"><code>PowerSimulations.add_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_constraints!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{StartupTimeLimitTemperatureConstraint},
    devices::InfrastructureSystems.FlattenIteratorWrapper{T&lt;:ThermalMultiStart},
    model::DeviceModel{T&lt;:ThermalMultiStart, ThermalMultiStartUnitCommitment},
    _::NetworkModel
)
</code></pre><p>Constructs contraints for different types of starts based on generator down-time</p><p><strong>Equations</strong></p><p>for t in time_limits[s+1]:T</p><p><code>var_starts[name, s, t] &lt;= sum( var_stop[name, t-i] for i in time_limits[s]:(time_limits[s+1]-1)</code></p><p><strong>LaTeX</strong></p><p><span>$δ^{s}(t)  \leq \sum_{i=TS^{s}_{g}}^{TS^{s+1}_{g}} x^{stop}(t-i)$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/thermal_generation.jl#L1121">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_constraints!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{PhaseAngleControlLimit}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, PhaseAngleControl}, NetworkModel{U}}} where {T&lt;:PhaseShiftingTransformer, U&lt;:PowerModels.AbstractActivePowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_constraints!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{PhaseAngleControlLimit}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, PhaseAngleControl}, NetworkModel{U}}} where {T&lt;:PhaseShiftingTransformer, U&lt;:PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.add_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_constraints!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{PhaseAngleControlLimit},
    devices::InfrastructureSystems.FlattenIteratorWrapper{T&lt;:PhaseShiftingTransformer},
    model::DeviceModel{T&lt;:PhaseShiftingTransformer, PhaseAngleControl},
    _::NetworkModel{U&lt;:PowerModels.AbstractActivePowerModel}
)
</code></pre><p>Add phase angle limits for phase shifters</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/AC_branches.jl#L1003">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_constraints!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{FlowLimitConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, U}, NetworkModel{V}}} where {T&lt;:Union{MonitoredLine, PhaseShiftingTransformer}, U&lt;:PowerSimulations.AbstractBranchFormulation, V&lt;:PowerModels.AbstractDCPModel}"><a class="docstring-binding" href="#PowerSimulations.add_constraints!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{FlowLimitConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, U}, NetworkModel{V}}} where {T&lt;:Union{MonitoredLine, PhaseShiftingTransformer}, U&lt;:PowerSimulations.AbstractBranchFormulation, V&lt;:PowerModels.AbstractDCPModel}"><code>PowerSimulations.add_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_constraints!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{FlowLimitConstraint},
    devices::InfrastructureSystems.FlattenIteratorWrapper{T&lt;:Union{MonitoredLine, PhaseShiftingTransformer}},
    model::DeviceModel{T&lt;:Union{MonitoredLine, PhaseShiftingTransformer}, U&lt;:PowerSimulations.AbstractBranchFormulation},
    _::NetworkModel{V&lt;:PowerModels.AbstractDCPModel}
)
</code></pre><p>Add branch flow constraints for monitored lines with DC Power Model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/AC_branches.jl#L906">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_constraints!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{FlowLimitToFromConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, U}, NetworkModel{V}}} where {T&lt;:MonitoredLine, U&lt;:StaticBranchUnbounded, V&lt;:PowerModels.AbstractActivePowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_constraints!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{FlowLimitToFromConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, U}, NetworkModel{V}}} where {T&lt;:MonitoredLine, U&lt;:StaticBranchUnbounded, V&lt;:PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.add_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_constraints!(
    _::PowerSimulations.OptimizationContainer,
    _::Type{FlowLimitToFromConstraint},
    devices::InfrastructureSystems.FlattenIteratorWrapper{T&lt;:MonitoredLine},
    model::DeviceModel{T&lt;:MonitoredLine, U&lt;:StaticBranchUnbounded},
    _::NetworkModel{V&lt;:PowerModels.AbstractActivePowerModel}
)
</code></pre><p>Don&#39;t add branch flow constraints for monitored lines if formulation is StaticBranchUnbounded</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/AC_branches.jl#L986">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_constraints!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{FlowRateConstraintFromTo}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, U}, NetworkModel{V}}} where {T&lt;:MonitoredLine, U&lt;:StaticBranchUnbounded, V&lt;:PowerModels.AbstractActivePowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_constraints!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{FlowRateConstraintFromTo}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, U}, NetworkModel{V}}} where {T&lt;:MonitoredLine, U&lt;:StaticBranchUnbounded, V&lt;:PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.add_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_constraints!(
    _::PowerSimulations.OptimizationContainer,
    _::Type{FlowRateConstraintFromTo},
    devices::InfrastructureSystems.FlattenIteratorWrapper{T&lt;:MonitoredLine},
    model::DeviceModel{T&lt;:MonitoredLine, U&lt;:StaticBranchUnbounded},
    _::NetworkModel{V&lt;:PowerModels.AbstractActivePowerModel}
)
</code></pre><p>Don&#39;t add branch flow constraints for monitored lines if formulation is StaticBranchUnbounded</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/AC_branches.jl#L931">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_constraints!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{FlowRateConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, U}, NetworkModel{V}}} where {T&lt;:ACTransmission, U&lt;:PowerSimulations.AbstractBranchFormulation, V&lt;:PowerModels.AbstractActivePowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_constraints!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{FlowRateConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, U}, NetworkModel{V}}} where {T&lt;:ACTransmission, U&lt;:PowerSimulations.AbstractBranchFormulation, V&lt;:PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.add_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_constraints!(
    container::PowerSimulations.OptimizationContainer,
    cons_type::Type{FlowRateConstraint},
    devices::InfrastructureSystems.FlattenIteratorWrapper{T&lt;:ACTransmission},
    device_model::DeviceModel{T&lt;:ACTransmission, U&lt;:PowerSimulations.AbstractBranchFormulation},
    network_model::NetworkModel{V&lt;:PowerModels.AbstractActivePowerModel}
)
</code></pre><p>Add branch rate limit constraints for ACBranch with AbstractActivePowerModel</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/AC_branches.jl#L373">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_constraints!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{PostContingencyEmergencyRateLimitConstrain}, InfrastructureSystems.FlattenIteratorWrapper{ACTransmission}, Vector{T}, DeviceModel{T, U}, NetworkModel{V}}} where {T&lt;:ACTransmission, U&lt;:PowerSimulations.AbstractBranchFormulation, V&lt;:PowerSimulations.AbstractSecurityConstrainedPTDFModel}"><a class="docstring-binding" href="#PowerSimulations.add_constraints!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{PostContingencyEmergencyRateLimitConstrain}, InfrastructureSystems.FlattenIteratorWrapper{ACTransmission}, Vector{T}, DeviceModel{T, U}, NetworkModel{V}}} where {T&lt;:ACTransmission, U&lt;:PowerSimulations.AbstractBranchFormulation, V&lt;:PowerSimulations.AbstractSecurityConstrainedPTDFModel}"><code>PowerSimulations.add_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_constraints!(
    container::PowerSimulations.OptimizationContainer,
    cons_type::Type{PostContingencyEmergencyRateLimitConstrain},
    branches::InfrastructureSystems.FlattenIteratorWrapper{ACTransmission},
    branches_outages::Array{T&lt;:ACTransmission, 1},
    device_model::DeviceModel{T&lt;:ACTransmission, U&lt;:PowerSimulations.AbstractBranchFormulation},
    network_model::NetworkModel{V&lt;:PowerSimulations.AbstractSecurityConstrainedPTDFModel}
)
</code></pre><p>Add branch post-contingency rate limit constraints for ACBranch considering LODF and Security Constraints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/network_models/security_constrained_models.jl#L18">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_constraints!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, Type{PostContingencyActivePowerVariableLimitsConstraint}, InfrastructureSystems.FlattenIteratorWrapper{S}, Vector{T}, DeviceModel{T, U}, NetworkModel{V}}} where {S&lt;:Generator, T&lt;:Generator, U&lt;:PowerSimulations.AbstractSecurityConstrainedUnitCommitment, V&lt;:PowerSimulations.AbstractPTDFModel}"><a class="docstring-binding" href="#PowerSimulations.add_constraints!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, Type{PostContingencyActivePowerVariableLimitsConstraint}, InfrastructureSystems.FlattenIteratorWrapper{S}, Vector{T}, DeviceModel{T, U}, NetworkModel{V}}} where {S&lt;:Generator, T&lt;:Generator, U&lt;:PowerSimulations.AbstractSecurityConstrainedUnitCommitment, V&lt;:PowerSimulations.AbstractPTDFModel}"><code>PowerSimulations.add_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_constraints!(
    container::PowerSimulations.OptimizationContainer,
    cons_type::Type{PostContingencyActivePowerVariableLimitsConstraint},
    devices::InfrastructureSystems.FlattenIteratorWrapper{S&lt;:Generator},
    generator_outages::Array{T&lt;:Generator, 1},
    device_model::DeviceModel{T&lt;:Generator, U&lt;:PowerSimulations.AbstractSecurityConstrainedUnitCommitment},
    network_model::NetworkModel{V&lt;:PowerSimulations.AbstractPTDFModel}
)
</code></pre><p>Add post-contingency rate limit constraints for Generators for G-1 formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/static_injection_security_constrained_models.jl#L287">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_constraints!-Union{Tuple{V}, Tuple{U}, Tuple{X}, Tuple{T}, Tuple{S}, Tuple{R}, Tuple{PowerSimulations.OptimizationContainer, Type{R}, Union{InfrastructureSystems.FlattenIteratorWrapper{S}, Vector{S}}, Union{InfrastructureSystems.FlattenIteratorWrapper{T}, Vector{T}}, DeviceModel{X, U}, NetworkModel{V}}} where {R&lt;:PostContingencyGenerationBalanceConstraint, S&lt;:Generator, T&lt;:Generator, X&lt;:Generator, U&lt;:PowerSimulations.AbstractSecurityConstrainedUnitCommitment, V&lt;:PowerSimulations.AbstractPTDFModel}"><a class="docstring-binding" href="#PowerSimulations.add_constraints!-Union{Tuple{V}, Tuple{U}, Tuple{X}, Tuple{T}, Tuple{S}, Tuple{R}, Tuple{PowerSimulations.OptimizationContainer, Type{R}, Union{InfrastructureSystems.FlattenIteratorWrapper{S}, Vector{S}}, Union{InfrastructureSystems.FlattenIteratorWrapper{T}, Vector{T}}, DeviceModel{X, U}, NetworkModel{V}}} where {R&lt;:PostContingencyGenerationBalanceConstraint, S&lt;:Generator, T&lt;:Generator, X&lt;:Generator, U&lt;:PowerSimulations.AbstractSecurityConstrainedUnitCommitment, V&lt;:PowerSimulations.AbstractPTDFModel}"><code>PowerSimulations.add_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_constraints!(
    container::PowerSimulations.OptimizationContainer,
    cons_type::Type{R&lt;:PostContingencyGenerationBalanceConstraint},
    devices::Union{Array{S&lt;:Generator, 1}, InfrastructureSystems.FlattenIteratorWrapper{S&lt;:Generator}},
    generator_outages::Union{Array{T&lt;:Generator, 1}, InfrastructureSystems.FlattenIteratorWrapper{T&lt;:Generator}},
    _::DeviceModel{X&lt;:Generator, U&lt;:PowerSimulations.AbstractSecurityConstrainedUnitCommitment},
    network_model::NetworkModel{V&lt;:PowerSimulations.AbstractPTDFModel}
)
</code></pre><p>Add post-contingency Generation Balance Constraints for Generators for G-1 formulation and G-1 with reserves (SecurityConstrainedReservesFormulation)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/static_injection_security_constrained_models.jl#L417">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{U}, Tuple{PowerSimulations.OptimizationContainer, Type{RampConstraint}, InfrastructureSystems.FlattenIteratorWrapper{U}, DeviceModel{U, V}, NetworkModel{W}}} where {U&lt;:ThermalGen, V&lt;:PowerSimulations.AbstractThermalUnitCommitment, W&lt;:PowerModels.AbstractPowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{U}, Tuple{PowerSimulations.OptimizationContainer, Type{RampConstraint}, InfrastructureSystems.FlattenIteratorWrapper{U}, DeviceModel{U, V}, NetworkModel{W}}} where {U&lt;:ThermalGen, V&lt;:PowerSimulations.AbstractThermalUnitCommitment, W&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.add_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_constraints!(
    container::PowerSimulations.OptimizationContainer,
    T::Type{RampConstraint},
    devices::InfrastructureSystems.FlattenIteratorWrapper{U&lt;:ThermalGen},
    model::DeviceModel{U&lt;:ThermalGen, V&lt;:PowerSimulations.AbstractThermalUnitCommitment},
    _::NetworkModel{W&lt;:PowerModels.AbstractPowerModel}
)
</code></pre><p>This function adds the ramping limits of generators when there are CommitmentVariables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/thermal_generation.jl#L1023">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{&lt;:ActivePowerVariableLimitsConstraint}, Type{&lt;:InfrastructureSystems.Optimization.VariableType}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {V&lt;:ThermalMultiStart, W&lt;:ThermalMultiStartUnitCommitment, X&lt;:PowerModels.AbstractPowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{&lt;:ActivePowerVariableLimitsConstraint}, Type{&lt;:InfrastructureSystems.Optimization.VariableType}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {V&lt;:ThermalMultiStart, W&lt;:ThermalMultiStartUnitCommitment, X&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.add_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_constraints!(
    container::PowerSimulations.OptimizationContainer,
    T::Type{&lt;:ActivePowerVariableLimitsConstraint},
    U::Type{&lt;:InfrastructureSystems.Optimization.VariableType},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:ThermalMultiStart},
    _::DeviceModel{V&lt;:ThermalMultiStart, W&lt;:ThermalMultiStartUnitCommitment},
    _::NetworkModel{X&lt;:PowerModels.AbstractPowerModel}
)
</code></pre><p>This function adds range constraint for the first time period. Constraint (10) from PGLIB formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/thermal_generation.jl#L498">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{&lt;:PowerSimulations.PowerVariableLimitsConstraint}, Type{&lt;:Union{InfrastructureSystems.Optimization.ExpressionType, InfrastructureSystems.Optimization.VariableType}}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {V&lt;:ThermalGen, W&lt;:PowerSimulations.AbstractThermalDispatchFormulation, X&lt;:PowerModels.AbstractPowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{&lt;:PowerSimulations.PowerVariableLimitsConstraint}, Type{&lt;:Union{InfrastructureSystems.Optimization.ExpressionType, InfrastructureSystems.Optimization.VariableType}}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {V&lt;:ThermalGen, W&lt;:PowerSimulations.AbstractThermalDispatchFormulation, X&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.add_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_constraints!(
    container::PowerSimulations.OptimizationContainer,
    T::Type{&lt;:PowerSimulations.PowerVariableLimitsConstraint},
    U::Type{&lt;:Union{InfrastructureSystems.Optimization.ExpressionType, InfrastructureSystems.Optimization.VariableType}},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:ThermalGen},
    model::DeviceModel{V&lt;:ThermalGen, W&lt;:PowerSimulations.AbstractThermalDispatchFormulation},
    _::NetworkModel{X&lt;:PowerModels.AbstractPowerModel}
)
</code></pre><p>Semicontinuous range constraints for thermal dispatch formulations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/thermal_generation.jl#L304">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{&lt;:PowerSimulations.PowerVariableLimitsConstraint}, Type{&lt;:Union{InfrastructureSystems.Optimization.ExpressionType, InfrastructureSystems.Optimization.VariableType}}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {V&lt;:ThermalGen, W&lt;:PowerSimulations.AbstractThermalUnitCommitment, X&lt;:PowerModels.AbstractPowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{&lt;:PowerSimulations.PowerVariableLimitsConstraint}, Type{&lt;:Union{InfrastructureSystems.Optimization.ExpressionType, InfrastructureSystems.Optimization.VariableType}}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {V&lt;:ThermalGen, W&lt;:PowerSimulations.AbstractThermalUnitCommitment, X&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.add_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_constraints!(
    container::PowerSimulations.OptimizationContainer,
    T::Type{&lt;:PowerSimulations.PowerVariableLimitsConstraint},
    U::Type{&lt;:Union{InfrastructureSystems.Optimization.ExpressionType, InfrastructureSystems.Optimization.VariableType}},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:ThermalGen},
    model::DeviceModel{V&lt;:ThermalGen, W&lt;:PowerSimulations.AbstractThermalUnitCommitment},
    _::NetworkModel{X&lt;:PowerModels.AbstractPowerModel}
)
</code></pre><p>Semicontinuous range constraints for unit commitment formulations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/thermal_generation.jl#L386">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{&lt;:PowerSimulations.PowerVariableLimitsConstraint}, Type{&lt;:Union{PowerAboveMinimumVariable, InfrastructureSystems.Optimization.ExpressionType}}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {V&lt;:ThermalGen, W&lt;:ThermalCompactDispatch, X&lt;:PowerModels.AbstractPowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{&lt;:PowerSimulations.PowerVariableLimitsConstraint}, Type{&lt;:Union{PowerAboveMinimumVariable, InfrastructureSystems.Optimization.ExpressionType}}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {V&lt;:ThermalGen, W&lt;:ThermalCompactDispatch, X&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.add_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_constraints!(
    container::PowerSimulations.OptimizationContainer,
    T::Type{&lt;:PowerSimulations.PowerVariableLimitsConstraint},
    U::Type{&lt;:Union{PowerAboveMinimumVariable, InfrastructureSystems.Optimization.ExpressionType}},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:ThermalGen},
    model::DeviceModel{V&lt;:ThermalGen, W&lt;:ThermalCompactDispatch},
    network_model::NetworkModel{X&lt;:PowerModels.AbstractPowerModel}
)
</code></pre><p>Range constraints for thermal compact dispatch</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/thermal_generation.jl#L261">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{&lt;:ReactivePowerVariableLimitsConstraint}, Type{&lt;:ReactivePowerVariable}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {V&lt;:ElectricLoad, W&lt;:PowerSimulations.AbstractControllablePowerLoadFormulation, X&lt;:PowerModels.AbstractPowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{&lt;:ReactivePowerVariableLimitsConstraint}, Type{&lt;:ReactivePowerVariable}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {V&lt;:ElectricLoad, W&lt;:PowerSimulations.AbstractControllablePowerLoadFormulation, X&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.add_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_constraints!(
    container::PowerSimulations.OptimizationContainer,
    T::Type{&lt;:ReactivePowerVariableLimitsConstraint},
    U::Type{&lt;:ReactivePowerVariable},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:ElectricLoad},
    _::DeviceModel{V&lt;:ElectricLoad, W&lt;:PowerSimulations.AbstractControllablePowerLoadFormulation},
    network_model::NetworkModel{X&lt;:PowerModels.AbstractPowerModel}
)
</code></pre><p>Reactive Power Constraints on Controllable Loads Assume Constant power_factor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/electric_loads.jl#L73">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{&lt;:ReactivePowerVariableLimitsConstraint}, Type{&lt;:ReactivePowerVariable}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {V&lt;:RenewableGen, W&lt;:RenewableConstantPowerFactor, X&lt;:PowerModels.AbstractPowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{&lt;:ReactivePowerVariableLimitsConstraint}, Type{&lt;:ReactivePowerVariable}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {V&lt;:RenewableGen, W&lt;:RenewableConstantPowerFactor, X&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.add_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_constraints!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{&lt;:ReactivePowerVariableLimitsConstraint},
    _::Type{&lt;:ReactivePowerVariable},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:RenewableGen},
    _::DeviceModel{V&lt;:RenewableGen, W&lt;:RenewableConstantPowerFactor},
    _::NetworkModel{X&lt;:PowerModels.AbstractPowerModel}
)
</code></pre><p>Reactive Power Constraints on Renewable Gen Constant power_factor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/renewable_generation.jl#L80">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_feedforward_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, DeviceModel, InfrastructureSystems.FlattenIteratorWrapper{T}, UpperBoundFeedforward}} where T&lt;:Component"><a class="docstring-binding" href="#PowerSimulations.add_feedforward_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, DeviceModel, InfrastructureSystems.FlattenIteratorWrapper{T}, UpperBoundFeedforward}} where T&lt;:Component"><code>PowerSimulations.add_feedforward_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_feedforward_constraints!(
    container::PowerSimulations.OptimizationContainer,
    _::DeviceModel,
    devices::InfrastructureSystems.FlattenIteratorWrapper{T&lt;:Component},
    ff::UpperBoundFeedforward
)
</code></pre><pre><code class="language-julia hljs">    ub_ff(container::OptimizationContainer,
          cons_name::Symbol,
          constraint_infos,
          param_reference,
          var_key::VariableKey)</code></pre><p>Constructs a parameterized upper bound constraint to implement feedforward from other models. The Parameters are initialized using the uppper boundary values of the provided variables.</p><p><code>variable[var_name, t] &lt;= param_reference[var_name]</code></p><p><strong>LaTeX</strong></p><p><span>$x \leq param^{max}$</span></p><p><strong>Arguments</strong></p><ul><li>container::OptimizationContainer : the optimization_container model built in PowerSimulations</li><li>cons_name::Symbol : name of the constraint</li><li>param_reference : Reference to the JuMP.VariableRef used to determine the upperbound</li><li>var_key::VariableKey : the name of the continuous variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/feedforward/feedforward_constraints.jl#L289">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_feedforward_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, DeviceModel, Union{InfrastructureSystems.FlattenIteratorWrapper{T}, Vector{T}}, FixValueFeedforward}} where T&lt;:Component"><a class="docstring-binding" href="#PowerSimulations.add_feedforward_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, DeviceModel, Union{InfrastructureSystems.FlattenIteratorWrapper{T}, Vector{T}}, FixValueFeedforward}} where T&lt;:Component"><code>PowerSimulations.add_feedforward_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_feedforward_constraints!(
    container::PowerSimulations.OptimizationContainer,
    _::DeviceModel,
    devices::Union{Array{T&lt;:Component, 1}, InfrastructureSystems.FlattenIteratorWrapper{T&lt;:Component}},
    ff::FixValueFeedforward
)
</code></pre><pre><code class="language-julia hljs">    add_feedforward_constraints(
        container::OptimizationContainer,
        ::DeviceModel,
        devices::IS.FlattenIteratorWrapper{T},
        ff::FixValueFeedforward,
    ) where {T &lt;: PSY.Component}</code></pre><p>Constructs a equality constraint to a fix a variable in one model using the variable value from other model results.</p><p><code>variable[var_name, t] == param[var_name, t]</code></p><p><strong>LaTeX</strong></p><p><span>$x == param$</span></p><p><strong>Arguments</strong></p><ul><li>container::OptimizationContainer : the optimization_container model built in PowerSimulations</li><li>model::DeviceModel : the device model</li><li>devices::IS.FlattenIteratorWrapper{T} : list of devices</li><li>ff::FixValueFeedforward : a instance of the FixValue Feedforward</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/feedforward/feedforward_constraints.jl#L476">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_feedforward_constraints!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, DeviceModel{T, U}, InfrastructureSystems.FlattenIteratorWrapper{T}, LowerBoundFeedforward}} where {T&lt;:Component, U&lt;:PowerSimulations.AbstractDeviceFormulation}"><a class="docstring-binding" href="#PowerSimulations.add_feedforward_constraints!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, DeviceModel{T, U}, InfrastructureSystems.FlattenIteratorWrapper{T}, LowerBoundFeedforward}} where {T&lt;:Component, U&lt;:PowerSimulations.AbstractDeviceFormulation}"><code>PowerSimulations.add_feedforward_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_feedforward_constraints!(
    container::PowerSimulations.OptimizationContainer,
    _::DeviceModel{T&lt;:Component, U&lt;:PowerSimulations.AbstractDeviceFormulation},
    devices::InfrastructureSystems.FlattenIteratorWrapper{T&lt;:Component},
    ff::LowerBoundFeedforward
)
</code></pre><pre><code class="language-julia hljs">    lb_ff(container::OptimizationContainer,
          cons_name::Symbol,
          constraint_infos,
          param_reference,
          var_key::VariableKey)</code></pre><p>Constructs a parameterized upper bound constraint to implement feedforward from other models. The Parameters are initialized using the uppper boundary values of the provided variables.</p><p><code>variable[var_name, t] &lt;= param_reference[var_name]</code></p><p><strong>LaTeX</strong></p><p><span>$x \leq param^{max}$</span></p><p><strong>Arguments</strong></p><ul><li>container::OptimizationContainer : the optimization_container model built in PowerSimulations</li><li>cons_name::Symbol : name of the constraint</li><li>param_reference : Reference to the JuMP.VariableRef used to determine the upperbound</li><li>var_key::VariableKey : the name of the continuous variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/feedforward/feedforward_constraints.jl#L348">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_linear_ramp_constraints!-Union{Tuple{F}, Tuple{R}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, Type{T}, Type{U}, Union{InfrastructureSystems.FlattenIteratorWrapper{V}, Vector{V}}, Union{DeviceModel{R, F}, ServiceModel{R, F}}, Type{&lt;:PowerSimulations.AbstractPTDFModel}}} where {T&lt;:PowerSimulations.PostContingencyConstraintType, U&lt;:PowerSimulations.AbstractContingencyVariableType, V&lt;:Generator, R&lt;:Union{Generator, Reserve{ReserveDown}, Reserve{ReserveUp}}, F&lt;:Union{PowerSimulations.AbstractSecurityConstrainedReservesFormulation, PowerSimulations.AbstractSecurityConstrainedUnitCommitment}}"><a class="docstring-binding" href="#PowerSimulations.add_linear_ramp_constraints!-Union{Tuple{F}, Tuple{R}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, Type{T}, Type{U}, Union{InfrastructureSystems.FlattenIteratorWrapper{V}, Vector{V}}, Union{DeviceModel{R, F}, ServiceModel{R, F}}, Type{&lt;:PowerSimulations.AbstractPTDFModel}}} where {T&lt;:PowerSimulations.PostContingencyConstraintType, U&lt;:PowerSimulations.AbstractContingencyVariableType, V&lt;:Generator, R&lt;:Union{Generator, Reserve{ReserveDown}, Reserve{ReserveUp}}, F&lt;:Union{PowerSimulations.AbstractSecurityConstrainedReservesFormulation, PowerSimulations.AbstractSecurityConstrainedUnitCommitment}}"><code>PowerSimulations.add_linear_ramp_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_linear_ramp_constraints!(
    container::PowerSimulations.OptimizationContainer,
    sys::System,
    ::Type{T&lt;:PowerSimulations.PostContingencyConstraintType},
    ::Type{U&lt;:PowerSimulations.AbstractContingencyVariableType},
    devices::Union{Array{V&lt;:Generator, 1}, InfrastructureSystems.FlattenIteratorWrapper{V&lt;:Generator}},
    model::Union{DeviceModel{R&lt;:Union{Generator, Reserve{ReserveDown}, Reserve{ReserveUp}}, F&lt;:Union{PowerSimulations.AbstractSecurityConstrainedReservesFormulation, PowerSimulations.AbstractSecurityConstrainedUnitCommitment}}, ServiceModel{R&lt;:Union{Generator, Reserve{ReserveDown}, Reserve{ReserveUp}}, F&lt;:Union{PowerSimulations.AbstractSecurityConstrainedReservesFormulation, PowerSimulations.AbstractSecurityConstrainedUnitCommitment}}},
    ::Type{&lt;:PowerSimulations.AbstractPTDFModel};
    service
)
</code></pre><p>Constructs allowed rate-of-change constraints for G-1 formulations from change_variables, and rate data.</p><p><code>change_variable[name, t] &lt;= rate_data[1][ix].up</code></p><p><code>change_variable[name, t-1] &gt;= rate_data[1][ix].down</code></p><p><strong>LaTeX</strong></p><p><span>$r^{down} \leq \Delta x_t  \leq r^{up}, \forall t \geq$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/static_injection_security_constrained_models.jl#L738">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_linear_ramp_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, Type{&lt;:InfrastructureSystems.Optimization.ConstraintType}, Type{S}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{&lt;:PowerModels.AbstractPowerModel}}} where {S&lt;:Union{ActivePowerVariable, PowerAboveMinimumVariable}, V&lt;:Component, W&lt;:PowerSimulations.AbstractDeviceFormulation}"><a class="docstring-binding" href="#PowerSimulations.add_linear_ramp_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, Type{&lt;:InfrastructureSystems.Optimization.ConstraintType}, Type{S}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{&lt;:PowerModels.AbstractPowerModel}}} where {S&lt;:Union{ActivePowerVariable, PowerAboveMinimumVariable}, V&lt;:Component, W&lt;:PowerSimulations.AbstractDeviceFormulation}"><code>PowerSimulations.add_linear_ramp_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_linear_ramp_constraints!(
    container::PowerSimulations.OptimizationContainer,
    T::Type{&lt;:InfrastructureSystems.Optimization.ConstraintType},
    U::Type{S&lt;:Union{ActivePowerVariable, PowerAboveMinimumVariable}},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:Component},
    model::DeviceModel{V&lt;:Component, W&lt;:PowerSimulations.AbstractDeviceFormulation},
    _::Type{&lt;:PowerModels.AbstractPowerModel}
)
</code></pre><p>Constructs allowed rate-of-change constraints from variables, initial condtions, and rate data.</p><p>If t = 1:</p><p><code>variable[name, 1] - initial_conditions[ix].value &lt;= rate_data[1][ix].up</code></p><p><code>initial_conditions[ix].value - variable[name, 1] &lt;= rate_data[1][ix].down</code></p><p>If t &gt; 1:</p><p><code>variable[name, t] - variable[name, t-1] &lt;= rate_data[1][ix].up</code></p><p><code>variable[name, t-1] - variable[name, t] &lt;= rate_data[1][ix].down</code></p><p><strong>LaTeX</strong></p><p><span>$r^{down} \leq x_1 - x_{init} \leq r^{up}, \text{ for } t = 1$</span></p><p><span>$r^{down} \leq x_t - x_{t-1} \leq r^{up}, \forall t \geq 2$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/rateofchange_constraints.jl#L54">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_pwl_term!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{Bool, PowerSimulations.OptimizationContainer, T, OfferCurveCost, U, V}} where {T&lt;:Component, U&lt;:InfrastructureSystems.Optimization.VariableType, V&lt;:PowerSimulations.AbstractDeviceFormulation}"><a class="docstring-binding" href="#PowerSimulations.add_pwl_term!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{Bool, PowerSimulations.OptimizationContainer, T, OfferCurveCost, U, V}} where {T&lt;:Component, U&lt;:InfrastructureSystems.Optimization.VariableType, V&lt;:PowerSimulations.AbstractDeviceFormulation}"><code>PowerSimulations.add_pwl_term!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_pwl_term!(
    is_decremental::Bool,
    container::PowerSimulations.OptimizationContainer,
    component::Component,
    _::OfferCurveCost,
    _::InfrastructureSystems.Optimization.VariableType,
    _::PowerSimulations.AbstractDeviceFormulation
)
</code></pre><p>Add PWL cost terms for data coming from the MarketBidCost with a fixed incremental offer curve</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/objective_function/market_bid.jl#L763">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_range_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {T&lt;:InfrastructureSystems.Optimization.ConstraintType, U&lt;:InfrastructureSystems.Optimization.VariableType, V&lt;:Component, W&lt;:PowerSimulations.AbstractDeviceFormulation, X&lt;:PowerModels.AbstractPowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_range_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {T&lt;:InfrastructureSystems.Optimization.ConstraintType, U&lt;:InfrastructureSystems.Optimization.VariableType, V&lt;:Component, W&lt;:PowerSimulations.AbstractDeviceFormulation, X&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.add_range_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_range_constraints!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:InfrastructureSystems.Optimization.ConstraintType},
    _::Type{U&lt;:InfrastructureSystems.Optimization.VariableType},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:Component},
    model::DeviceModel{V&lt;:Component, W&lt;:PowerSimulations.AbstractDeviceFormulation},
    _::Type{X&lt;:PowerModels.AbstractPowerModel}
)
</code></pre><p>Constructs min/max range constraint from device variable.</p><p>If min and max within an epsilon width:</p><p><code>variable[name, t] == limits.max</code></p><p>Otherwise:</p><p><code>limits.min &lt;= variable[name, t] &lt;= limits.max</code></p><p>where limits in constraint_infos.</p><p><strong>LaTeX</strong></p><p><span>$x = limits^{max}, \text{ for } |limits^{max} - limits^{min}| &lt; \varepsilon$</span></p><p><span>$limits^{min} \leq x \leq limits^{max}, \text{ otherwise }$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/range_constraint.jl#L21">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_reserve_range_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {T&lt;:InputActivePowerVariableLimitsConstraint, U&lt;:InfrastructureSystems.Optimization.VariableType, V&lt;:Component, W&lt;:PowerSimulations.AbstractDeviceFormulation, X&lt;:PowerModels.AbstractPowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_reserve_range_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {T&lt;:InputActivePowerVariableLimitsConstraint, U&lt;:InfrastructureSystems.Optimization.VariableType, V&lt;:Component, W&lt;:PowerSimulations.AbstractDeviceFormulation, X&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.add_reserve_range_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_reserve_range_constraints!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:InputActivePowerVariableLimitsConstraint},
    _::Type{U&lt;:InfrastructureSystems.Optimization.VariableType},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:Component},
    model::DeviceModel{V&lt;:Component, W&lt;:PowerSimulations.AbstractDeviceFormulation},
    _::Type{X&lt;:PowerModels.AbstractPowerModel}
)
</code></pre><p>Constructs min/max range constraint from device variable and reservation decision variable.</p><p><code>varcts[name, t] &lt;= limits.max * (1 - varbin[name, t])</code></p><p><code>varcts[name, t] &gt;= limits.min * (1 - varbin[name, t])</code></p><p>where limits in constraint_infos.</p><p><strong>LaTeX</strong></p><p><span>$0 \leq x^{cts} \leq limits^{max} (1 - x^{bin}), \text{ for } limits^{min} = 0$</span></p><p><span>$limits^{min} (1 - x^{bin}) \leq x^{cts} \leq limits^{max} (1 - x^{bin}), \text{ otherwise }$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/range_constraint.jl#L365">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_reserve_range_constraints!-Union{Tuple{Y}, Tuple{X}, Tuple{W}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{W}, DeviceModel{W, X}, Type{Y}}} where {T&lt;:Union{ActivePowerVariableLimitsConstraint, OutputActivePowerVariableLimitsConstraint, ReactivePowerVariableLimitsConstraint}, U&lt;:InfrastructureSystems.Optimization.ExpressionType, W&lt;:Component, X&lt;:PowerSimulations.AbstractDeviceFormulation, Y&lt;:PowerModels.AbstractPowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_reserve_range_constraints!-Union{Tuple{Y}, Tuple{X}, Tuple{W}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{W}, DeviceModel{W, X}, Type{Y}}} where {T&lt;:Union{ActivePowerVariableLimitsConstraint, OutputActivePowerVariableLimitsConstraint, ReactivePowerVariableLimitsConstraint}, U&lt;:InfrastructureSystems.Optimization.ExpressionType, W&lt;:Component, X&lt;:PowerSimulations.AbstractDeviceFormulation, Y&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.add_reserve_range_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_reserve_range_constraints!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:Union{ActivePowerVariableLimitsConstraint, OutputActivePowerVariableLimitsConstraint, ReactivePowerVariableLimitsConstraint}},
    _::Type{U&lt;:InfrastructureSystems.Optimization.ExpressionType},
    devices::InfrastructureSystems.FlattenIteratorWrapper{W&lt;:Component},
    model::DeviceModel{W&lt;:Component, X&lt;:PowerSimulations.AbstractDeviceFormulation},
    _::Type{Y&lt;:PowerModels.AbstractPowerModel}
)
</code></pre><p>Constructs min/max range constraint from device variable and reservation decision variable.</p><p><code>varcts[name, t] &lt;= limits.max * varbin[name, t]</code></p><p><code>varcts[name, t] &gt;= limits.min * varbin[name, t]</code></p><p>where limits in constraint_infos.</p><p><strong>LaTeX</strong></p><p><span>$limits^{min} x^{bin} \leq x^{cts} \leq limits^{max} x^{bin},$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/range_constraint.jl#L532">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_reserve_range_constraints!-Union{Tuple{Y}, Tuple{X}, Tuple{W}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{W}, DeviceModel{W, X}, Type{Y}}} where {T&lt;:Union{ActivePowerVariableLimitsConstraint, OutputActivePowerVariableLimitsConstraint, ReactivePowerVariableLimitsConstraint}, U&lt;:InfrastructureSystems.Optimization.VariableType, W&lt;:Component, X&lt;:PowerSimulations.AbstractDeviceFormulation, Y&lt;:PowerModels.AbstractPowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_reserve_range_constraints!-Union{Tuple{Y}, Tuple{X}, Tuple{W}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{W}, DeviceModel{W, X}, Type{Y}}} where {T&lt;:Union{ActivePowerVariableLimitsConstraint, OutputActivePowerVariableLimitsConstraint, ReactivePowerVariableLimitsConstraint}, U&lt;:InfrastructureSystems.Optimization.VariableType, W&lt;:Component, X&lt;:PowerSimulations.AbstractDeviceFormulation, Y&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.add_reserve_range_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_reserve_range_constraints!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:Union{ActivePowerVariableLimitsConstraint, OutputActivePowerVariableLimitsConstraint, ReactivePowerVariableLimitsConstraint}},
    _::Type{U&lt;:InfrastructureSystems.Optimization.VariableType},
    devices::InfrastructureSystems.FlattenIteratorWrapper{W&lt;:Component},
    model::DeviceModel{W&lt;:Component, X&lt;:PowerSimulations.AbstractDeviceFormulation},
    _::Type{Y&lt;:PowerModels.AbstractPowerModel}
)
</code></pre><p>Constructs min/max range constraint from device variable and reservation decision variable.</p><p><code>varcts[name, t] &lt;= limits.max * varbin[name, t]</code></p><p><code>varcts[name, t] &gt;= limits.min * varbin[name, t]</code></p><p>where limits in constraint_infos.</p><p><strong>LaTeX</strong></p><p><span>$limits^{min} x^{bin} \leq x^{cts} \leq limits^{max} x^{bin},$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/range_constraint.jl#L492">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_result!-Tuple{PowerSimulations.OptimizationOutputCache, Dates.DateTime, Array{Float64}, Bool}"><a class="docstring-binding" href="#PowerSimulations.add_result!-Tuple{PowerSimulations.OptimizationOutputCache, Dates.DateTime, Array{Float64}, Bool}"><code>PowerSimulations.add_result!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_result!(
    cache::PowerSimulations.OptimizationOutputCache,
    timestamp::Dates.DateTime,
    array::Array{Float64},
    system_cache_is_full::Bool
) -&gt; Int64
</code></pre><p>Add result to the cache.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/optimization_output_cache.jl#L57">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_semicontinuous_ramp_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, Type{&lt;:InfrastructureSystems.Optimization.ConstraintType}, Type{S}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{&lt;:PowerModels.AbstractPowerModel}}} where {S&lt;:Union{ActivePowerVariable, PowerAboveMinimumVariable}, V&lt;:Component, W&lt;:PowerSimulations.AbstractDeviceFormulation}"><a class="docstring-binding" href="#PowerSimulations.add_semicontinuous_ramp_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, Type{&lt;:InfrastructureSystems.Optimization.ConstraintType}, Type{S}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{&lt;:PowerModels.AbstractPowerModel}}} where {S&lt;:Union{ActivePowerVariable, PowerAboveMinimumVariable}, V&lt;:Component, W&lt;:PowerSimulations.AbstractDeviceFormulation}"><code>PowerSimulations.add_semicontinuous_ramp_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_semicontinuous_ramp_constraints!(
    container::PowerSimulations.OptimizationContainer,
    T::Type{&lt;:InfrastructureSystems.Optimization.ConstraintType},
    U::Type{S&lt;:Union{ActivePowerVariable, PowerAboveMinimumVariable}},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:Component},
    model::DeviceModel{V&lt;:Component, W&lt;:PowerSimulations.AbstractDeviceFormulation},
    _::Type{&lt;:PowerModels.AbstractPowerModel}
)
</code></pre><p>Constructs allowed rate-of-change constraints from variables, initial condtions, start/stop status, and rate data</p><p><strong>Equations</strong></p><p>If t = 1:</p><p><code>variable[name, 1] - initial_conditions[ix].value &lt;= rate_data[1][ix].up + rate_data[2][ix].max*varstart[name, 1]</code></p><p><code>initial_conditions[ix].value - variable[name, 1] &lt;= rate_data[1][ix].down + rate_data[2][ix].min*varstop[name, 1]</code></p><p>If t &gt; 1:</p><p><code>variable[name, t] - variable[name, t-1] &lt;= rate_data[1][ix].up + rate_data[2][ix].max*varstart[name, t]</code></p><p><code>variable[name, t-1] - variable[name, t] &lt;= rate_data[1][ix].down + rate_data[2][ix].min*varstop[name, t]</code></p><p><strong>LaTeX</strong></p><p><span>$r^{down} + r^{min} x^{stop}_1 \leq x_1 - x_{init} \leq r^{up} + r^{max} x^{start}_1, \text{ for } t = 1$</span></p><p><span>$r^{down} + r^{min} x^{stop}_t \leq x_t - x_{t-1} \leq r^{up} + r^{max} x^{start}_t, \forall t \geq 2$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/rateofchange_constraints.jl#L313">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_semicontinuous_range_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {T&lt;:InfrastructureSystems.Optimization.ConstraintType, U&lt;:InfrastructureSystems.Optimization.VariableType, V&lt;:Component, W&lt;:PowerSimulations.AbstractDeviceFormulation, X&lt;:PowerModels.AbstractPowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_semicontinuous_range_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {T&lt;:InfrastructureSystems.Optimization.ConstraintType, U&lt;:InfrastructureSystems.Optimization.VariableType, V&lt;:Component, W&lt;:PowerSimulations.AbstractDeviceFormulation, X&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.add_semicontinuous_range_constraints!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_semicontinuous_range_constraints!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:InfrastructureSystems.Optimization.ConstraintType},
    _::Type{U&lt;:InfrastructureSystems.Optimization.VariableType},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:Component},
    model::DeviceModel{V&lt;:Component, W&lt;:PowerSimulations.AbstractDeviceFormulation},
    _::Type{X&lt;:PowerModels.AbstractPowerModel}
)
</code></pre><p>Constructs min/max range constraint from device variable and on/off decision variable.</p><p>If device min = 0:</p><p><code>varcts[name, t] &lt;= limits.max*varbin[name, t])</code></p><p><code>varcts[name, t] &gt;= 0.0</code></p><p>Otherwise:</p><p><code>varcts[name, t] &lt;= limits.max*varbin[name, t]</code></p><p><code>varcts[name, t] &gt;= limits.min*varbin[name, t]</code></p><p>where limits in constraint_infos.</p><p><strong>LaTeX</strong></p><p><span>$0 \leq x^{cts} \leq limits^{max} x^{bin}, \text{ for } limits^{min} = 0$</span></p><p><span>$limits^{min} x^{bin} \leq x^{cts} \leq limits^{max} x^{bin}, \text{ otherwise }$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/range_constraint.jl#L143">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_sparse_pwl_interpolation_variables!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Any, DeviceModel{U, V}}, Tuple{PowerSimulations.OptimizationContainer, T, Any, DeviceModel{U, V}, Any}} where {T&lt;:Union{PowerSimulations.BinaryInterpolationVariableType, PowerSimulations.InterpolationVariableType}, U&lt;:Component, V&lt;:PowerSimulations.AbstractDeviceFormulation}"><a class="docstring-binding" href="#PowerSimulations.add_sparse_pwl_interpolation_variables!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Any, DeviceModel{U, V}}, Tuple{PowerSimulations.OptimizationContainer, T, Any, DeviceModel{U, V}, Any}} where {T&lt;:Union{PowerSimulations.BinaryInterpolationVariableType, PowerSimulations.InterpolationVariableType}, U&lt;:Component, V&lt;:PowerSimulations.AbstractDeviceFormulation}"><code>PowerSimulations.add_sparse_pwl_interpolation_variables!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_sparse_pwl_interpolation_variables!(
    container::PowerSimulations.OptimizationContainer,
    ::Union{PowerSimulations.BinaryInterpolationVariableType, PowerSimulations.InterpolationVariableType},
    devices,
    model::DeviceModel{U&lt;:Component, V&lt;:PowerSimulations.AbstractDeviceFormulation}
)
add_sparse_pwl_interpolation_variables!(
    container::PowerSimulations.OptimizationContainer,
    ::Union{PowerSimulations.BinaryInterpolationVariableType, PowerSimulations.InterpolationVariableType},
    devices,
    model::DeviceModel{U&lt;:Component, V&lt;:PowerSimulations.AbstractDeviceFormulation},
    num_segments
)
</code></pre><pre><code class="language-julia hljs">add_sparse_pwl_interpolation_variables!(container, devices, ::T, model, num_segments = DEFAULT_INTERPOLATION_LENGTH)</code></pre><p>Add piecewise linear interpolation variables to an optimization container.</p><p>This function creates the necessary variables for piecewise linear (PWL) approximation in optimization models. It adds either continuous interpolation variables (δ) or binary interpolation variables (z) depending on the variable type <code>T</code>. These variables are used in the incremental method for PWL approximation where:</p><ul><li><strong>Interpolation variables (δ)</strong>: Continuous variables ∈ [0,1] that represent weights for each segment</li><li><strong>Binary interpolation variables (z)</strong>: Binary variables that enforce ordering constraints in incremental method</li></ul><p>The function creates a 3-dimensional variable structure indexed by (device<em>name, segment</em>index, time_step). For binary variables, the number of variables is one less than for continuous variables since they control transitions between segments.</p><p><strong>Arguments</strong></p><ul><li><code>container::OptimizationContainer</code>: The optimization container to add variables to</li><li><code>devices</code>: Collection of devices for which to create PWL variables</li><li><code>::T</code>: Type parameter specifying the variable type (InterpolationVariableType or BinaryInterpolationVariableType)</li><li><code>model::DeviceModel{U, V}</code>: Device model containing formulation information for bounds</li><li><code>num_segments::Int</code>: Number of linear segments in the PWL approximation (default: DEFAULT<em>INTERPOLATION</em>LENGTH)</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T &lt;: Union{InterpolationVariableType, BinaryInterpolationVariableType}</code>: Variable type to create</li><li><code>U &lt;: PSY.Component</code>: Component type for devices</li><li><code>V &lt;: AbstractDeviceFormulation</code>: Device formulation type for bounds</li></ul><p><strong>Notes</strong></p><ul><li>Binary variables have <code>num_segments - 1</code> variables (control transitions between segments)</li><li>Continuous variables have <code>num_segments</code> variables (one per segment)</li><li>Variable bounds are set based on the device formulation if available</li><li>Variables are created for all devices and time steps in the optimization horizon</li></ul><p><strong>See Also</strong></p><ul><li><code>_add_generic_incremental_interpolation_constraint!</code>: Function that uses these variables in constraints</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_pwl_methods.jl#L57">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{N}, Tuple{F}, Tuple{R}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, Type{T}, Type{U}, Union{InfrastructureSystems.FlattenIteratorWrapper{V}, Vector{V}}, R, ServiceModel{R, F}, NetworkModel{N}}} where {T&lt;:PostContingencyActivePowerBalance, U&lt;:PowerSimulations.AbstractContingencyVariableType, V&lt;:Generator, R&lt;:Union{Reserve{ReserveDown}, Reserve{ReserveUp}}, F&lt;:PowerSimulations.AbstractSecurityConstrainedReservesFormulation, N&lt;:PowerSimulations.AbstractPTDFModel}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{N}, Tuple{F}, Tuple{R}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, Type{T}, Type{U}, Union{InfrastructureSystems.FlattenIteratorWrapper{V}, Vector{V}}, R, ServiceModel{R, F}, NetworkModel{N}}} where {T&lt;:PostContingencyActivePowerBalance, U&lt;:PowerSimulations.AbstractContingencyVariableType, V&lt;:Generator, R&lt;:Union{Reserve{ReserveDown}, Reserve{ReserveUp}}, F&lt;:PowerSimulations.AbstractSecurityConstrainedReservesFormulation, N&lt;:PowerSimulations.AbstractPTDFModel}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    sys::System,
    _::Type{T&lt;:PostContingencyActivePowerBalance},
    _::Type{U&lt;:PowerSimulations.AbstractContingencyVariableType},
    contributing_devices::Union{Array{V&lt;:Generator, 1}, InfrastructureSystems.FlattenIteratorWrapper{V&lt;:Generator}},
    service::Union{Reserve{ReserveDown}, Reserve{ReserveUp}},
    reserves_model::ServiceModel{R&lt;:Union{Reserve{ReserveDown}, Reserve{ReserveUp}}, F&lt;:PowerSimulations.AbstractSecurityConstrainedReservesFormulation},
    network_model::NetworkModel{N&lt;:PowerSimulations.AbstractPTDFModel}
)
</code></pre><p>Default implementation to add Reserve deployment variables to PostContingencySystemBalanceExpressions for G-1 formulation with reserves</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/static_injection_security_constrained_models.jl#L1238">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{N}, Tuple{F}, Tuple{R}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, Array{@NamedTuple{component::V, supplemental_attribute::PowerSystems.UnplannedOutage}, 1}, R, ServiceModel{R, F}, NetworkModel{N}}} where {T&lt;:PostContingencyActivePowerBalance, U&lt;:InfrastructureSystems.Optimization.VariableType, V&lt;:Generator, R&lt;:Union{Reserve{ReserveDown}, Reserve{ReserveUp}}, F&lt;:PowerSimulations.AbstractSecurityConstrainedReservesFormulation, N&lt;:PowerSimulations.AbstractPTDFModel}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{N}, Tuple{F}, Tuple{R}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, Array{@NamedTuple{component::V, supplemental_attribute::PowerSystems.UnplannedOutage}, 1}, R, ServiceModel{R, F}, NetworkModel{N}}} where {T&lt;:PostContingencyActivePowerBalance, U&lt;:InfrastructureSystems.Optimization.VariableType, V&lt;:Generator, R&lt;:Union{Reserve{ReserveDown}, Reserve{ReserveUp}}, F&lt;:PowerSimulations.AbstractSecurityConstrainedReservesFormulation, N&lt;:PowerSimulations.AbstractPTDFModel}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:PostContingencyActivePowerBalance},
    _::Type{U&lt;:InfrastructureSystems.Optimization.VariableType},
    attribute_device_map::Array{@NamedTuple{component::V&lt;:Generator, supplemental_attribute::PowerSystems.UnplannedOutage}, 1},
    service::Union{Reserve{ReserveDown}, Reserve{ReserveUp}},
    reserves_model::ServiceModel{R&lt;:Union{Reserve{ReserveDown}, Reserve{ReserveUp}}, F&lt;:PowerSimulations.AbstractSecurityConstrainedReservesFormulation},
    network_model::NetworkModel{N&lt;:PowerSimulations.AbstractPTDFModel}
)
</code></pre><p>Default implementation to add active power variables variables to PostContingencySystemBalanceExpressions for G-1 formulation with reserves</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/static_injection_security_constrained_models.jl#L1184">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{N}, Tuple{W}, Tuple{X}, Tuple{V}, Tuple{Y}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, Type{Y}, InfrastructureSystems.FlattenIteratorWrapper{V}, Vector{X}, DeviceModel{X, W}, NetworkModel{N}}} where {T&lt;:PostContingencyActivePowerBalance, U&lt;:InfrastructureSystems.Optimization.VariableType, Y&lt;:PowerSimulations.AbstractContingencyVariableType, V&lt;:Generator, X&lt;:Generator, W&lt;:PowerSimulations.AbstractSecurityConstrainedUnitCommitment, N&lt;:PowerSimulations.AbstractPTDFModel}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{N}, Tuple{W}, Tuple{X}, Tuple{V}, Tuple{Y}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, Type{Y}, InfrastructureSystems.FlattenIteratorWrapper{V}, Vector{X}, DeviceModel{X, W}, NetworkModel{N}}} where {T&lt;:PostContingencyActivePowerBalance, U&lt;:InfrastructureSystems.Optimization.VariableType, Y&lt;:PowerSimulations.AbstractContingencyVariableType, V&lt;:Generator, X&lt;:Generator, W&lt;:PowerSimulations.AbstractSecurityConstrainedUnitCommitment, N&lt;:PowerSimulations.AbstractPTDFModel}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:PostContingencyActivePowerBalance},
    _::Type{U&lt;:InfrastructureSystems.Optimization.VariableType},
    _::Type{Y&lt;:PowerSimulations.AbstractContingencyVariableType},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:Generator},
    devices_outages::Array{X&lt;:Generator, 1},
    device_model::DeviceModel{X&lt;:Generator, W&lt;:PowerSimulations.AbstractSecurityConstrainedUnitCommitment},
    network_model::NetworkModel{N&lt;:PowerSimulations.AbstractPTDFModel}
)
</code></pre><p>Default implementation to add variables to PostContingencySystemBalanceExpressions for G-1 formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/static_injection_security_constrained_models.jl#L361">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{PhaseShiftingTransformer}, DeviceModel{PhaseShiftingTransformer, V}, NetworkModel{&lt;:PowerSimulations.AbstractPTDFModel}}} where {T&lt;:ActivePowerBalance, U&lt;:PhaseShifterAngle, V&lt;:PhaseAngleControl}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{PhaseShiftingTransformer}, DeviceModel{PhaseShiftingTransformer, V}, NetworkModel{&lt;:PowerSimulations.AbstractPTDFModel}}} where {T&lt;:ActivePowerBalance, U&lt;:PhaseShifterAngle, V&lt;:PhaseAngleControl}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:ActivePowerBalance},
    _::Type{U&lt;:PhaseShifterAngle},
    devices::InfrastructureSystems.FlattenIteratorWrapper{PhaseShiftingTransformer},
    _::DeviceModel{PhaseShiftingTransformer, V&lt;:PhaseAngleControl},
    network_model::NetworkModel{&lt;:PowerSimulations.AbstractPTDFModel}
)
</code></pre><p>Implementation of add<em>to</em>expression! for lossless branch/network models</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_to_expression.jl#L1730">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{AreaBalancePowerModel}}} where {T&lt;:ActivePowerBalance, U&lt;:ActivePowerTimeSeriesParameter, V&lt;:MotorLoad, W&lt;:StaticPowerLoad}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{AreaBalancePowerModel}}} where {T&lt;:ActivePowerBalance, U&lt;:ActivePowerTimeSeriesParameter, V&lt;:MotorLoad, W&lt;:StaticPowerLoad}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:ActivePowerBalance},
    _::Type{U&lt;:ActivePowerTimeSeriesParameter},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:MotorLoad},
    model::DeviceModel{V&lt;:MotorLoad, W&lt;:StaticPowerLoad},
    network_model::NetworkModel{AreaBalancePowerModel}
)
</code></pre><p>Motor load implementation to add constant power to ActivePowerBalance expression for AreaBalancePowerModel</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_to_expression.jl#L215">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{CopperPlatePowerModel}}} where {T&lt;:ActivePowerBalance, U&lt;:ActivePowerTimeSeriesParameter, V&lt;:MotorLoad, W&lt;:StaticPowerLoad}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{CopperPlatePowerModel}}} where {T&lt;:ActivePowerBalance, U&lt;:ActivePowerTimeSeriesParameter, V&lt;:MotorLoad, W&lt;:StaticPowerLoad}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:ActivePowerBalance},
    _::Type{U&lt;:ActivePowerTimeSeriesParameter},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:MotorLoad},
    device_model::DeviceModel{V&lt;:MotorLoad, W&lt;:StaticPowerLoad},
    network_model::NetworkModel{CopperPlatePowerModel}
)
</code></pre><p>Motor load implementation to add parameters to SystemBalanceExpressions CopperPlate</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_to_expression.jl#L1193">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{CopperPlatePowerModel}}} where {T&lt;:ActivePowerBalance, U&lt;:FlowActivePowerVariable, V&lt;:ACBranch, W&lt;:PowerSimulations.AbstractBranchFormulation}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{CopperPlatePowerModel}}} where {T&lt;:ActivePowerBalance, U&lt;:FlowActivePowerVariable, V&lt;:ACBranch, W&lt;:PowerSimulations.AbstractBranchFormulation}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:ActivePowerBalance},
    _::Type{U&lt;:FlowActivePowerVariable},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:ACBranch},
    _::DeviceModel{V&lt;:ACBranch, W&lt;:PowerSimulations.AbstractBranchFormulation},
    network_model::NetworkModel{CopperPlatePowerModel}
)
</code></pre><p>Implementation of add<em>to</em>expression! for lossless branch/network models</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_to_expression.jl#L1687">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{CopperPlatePowerModel}}} where {T&lt;:ActivePowerBalance, U&lt;:InfrastructureSystems.Optimization.VariableType, V&lt;:StaticInjection, W&lt;:PowerSimulations.AbstractDeviceFormulation}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{CopperPlatePowerModel}}} where {T&lt;:ActivePowerBalance, U&lt;:InfrastructureSystems.Optimization.VariableType, V&lt;:StaticInjection, W&lt;:PowerSimulations.AbstractDeviceFormulation}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:ActivePowerBalance},
    _::Type{U&lt;:InfrastructureSystems.Optimization.VariableType},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:StaticInjection},
    device_model::DeviceModel{V&lt;:StaticInjection, W&lt;:PowerSimulations.AbstractDeviceFormulation},
    network_model::NetworkModel{CopperPlatePowerModel}
)
</code></pre><p>Default implementation to add variables to SystemBalanceExpressions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_to_expression.jl#L1251">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{CopperPlatePowerModel}}} where {T&lt;:SystemBalanceExpressions, U&lt;:InfrastructureSystems.Optimization.TimeSeriesParameter, V&lt;:StaticInjection, W&lt;:PowerSimulations.AbstractDeviceFormulation}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{CopperPlatePowerModel}}} where {T&lt;:SystemBalanceExpressions, U&lt;:InfrastructureSystems.Optimization.TimeSeriesParameter, V&lt;:StaticInjection, W&lt;:PowerSimulations.AbstractDeviceFormulation}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:SystemBalanceExpressions},
    _::Type{U&lt;:InfrastructureSystems.Optimization.TimeSeriesParameter},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:StaticInjection},
    device_model::DeviceModel{V&lt;:StaticInjection, W&lt;:PowerSimulations.AbstractDeviceFormulation},
    network_model::NetworkModel{CopperPlatePowerModel}
)
</code></pre><p>Default implementation to add parameters to SystemBalanceExpressions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_to_expression.jl#L1146">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{Union{PTDFPowerModel, SecurityConstrainedPTDFPowerModel}}}} where {T&lt;:ActivePowerBalance, U&lt;:FlowActivePowerToFromVariable, V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.AbstractTwoTerminalDCLineFormulation}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{Union{PTDFPowerModel, SecurityConstrainedPTDFPowerModel}}}} where {T&lt;:ActivePowerBalance, U&lt;:FlowActivePowerToFromVariable, V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.AbstractTwoTerminalDCLineFormulation}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:ActivePowerBalance},
    _::Type{U&lt;:FlowActivePowerToFromVariable},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:TwoTerminalHVDC},
    _::DeviceModel{V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.AbstractTwoTerminalDCLineFormulation},
    network_model::NetworkModel{Union{PTDFPowerModel, SecurityConstrainedPTDFPowerModel}}
)
</code></pre><p>Default implementation to add branch variables to SystemBalanceExpressions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_to_expression.jl#L467">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{D}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, Type{D}, InfrastructureSystems.FlattenIteratorWrapper{V}, Vector{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:PostContingencyActivePowerGeneration, U&lt;:ActivePowerVariable, D&lt;:PostContingencyActivePowerChangeVariable, V&lt;:Generator, W&lt;:PowerSimulations.AbstractSecurityConstrainedUnitCommitment, X&lt;:PowerSimulations.AbstractPTDFModel}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{D}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, Type{D}, InfrastructureSystems.FlattenIteratorWrapper{V}, Vector{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:PostContingencyActivePowerGeneration, U&lt;:ActivePowerVariable, D&lt;:PostContingencyActivePowerChangeVariable, V&lt;:Generator, W&lt;:PowerSimulations.AbstractSecurityConstrainedUnitCommitment, X&lt;:PowerSimulations.AbstractPTDFModel}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:PostContingencyActivePowerGeneration},
    _::Type{U&lt;:ActivePowerVariable},
    _::Type{D&lt;:PostContingencyActivePowerChangeVariable},
    generators::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:Generator},
    generator_outages::Array{V&lt;:Generator, 1},
    _::DeviceModel{V&lt;:Generator, W&lt;:PowerSimulations.AbstractSecurityConstrainedUnitCommitment},
    network_model::NetworkModel{X&lt;:PowerSimulations.AbstractPTDFModel}
)
</code></pre><p>Default implementation to add generators Expressions for Post-Contingency Generation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_to_expression.jl#L905">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{ACTransmission}, Vector{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:PostContingencyBranchFlow, U&lt;:FlowActivePowerVariable, V&lt;:ACTransmission, W&lt;:PowerSimulations.AbstractBranchFormulation, X&lt;:PowerSimulations.AbstractSecurityConstrainedPTDFModel}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{ACTransmission}, Vector{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:PostContingencyBranchFlow, U&lt;:FlowActivePowerVariable, V&lt;:ACTransmission, W&lt;:PowerSimulations.AbstractBranchFormulation, X&lt;:PowerSimulations.AbstractSecurityConstrainedPTDFModel}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:PostContingencyBranchFlow},
    _::Type{U&lt;:FlowActivePowerVariable},
    branches::InfrastructureSystems.FlattenIteratorWrapper{ACTransmission},
    branches_outages::Array{V&lt;:ACTransmission, 1},
    _::DeviceModel{V&lt;:ACTransmission, W&lt;:PowerSimulations.AbstractBranchFormulation},
    network_model::NetworkModel{X&lt;:PowerSimulations.AbstractSecurityConstrainedPTDFModel}
)
</code></pre><p>Default implementation to add branch Expressions for Post-Contingency Flows</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_to_expression.jl#L966">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ActivePowerBalance, U&lt;:ActivePowerTimeSeriesParameter, V&lt;:MotorLoad, W&lt;:StaticPowerLoad, X&lt;:PowerModels.AbstractPowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ActivePowerBalance, U&lt;:ActivePowerTimeSeriesParameter, V&lt;:MotorLoad, W&lt;:StaticPowerLoad, X&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:ActivePowerBalance},
    _::Type{U&lt;:ActivePowerTimeSeriesParameter},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:MotorLoad},
    model::DeviceModel{V&lt;:MotorLoad, W&lt;:StaticPowerLoad},
    network_model::NetworkModel{X&lt;:PowerModels.AbstractPowerModel}
)
</code></pre><p>Motor load implementation to add constant power to ActivePowerBalance expression</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_to_expression.jl#L184">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ActivePowerBalance, U&lt;:ActivePowerTimeSeriesParameter, V&lt;:MotorLoad, W&lt;:StaticPowerLoad, X&lt;:PowerSimulations.AbstractPTDFModel}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ActivePowerBalance, U&lt;:ActivePowerTimeSeriesParameter, V&lt;:MotorLoad, W&lt;:StaticPowerLoad, X&lt;:PowerSimulations.AbstractPTDFModel}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:ActivePowerBalance},
    _::Type{U&lt;:ActivePowerTimeSeriesParameter},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:MotorLoad},
    device_model::DeviceModel{V&lt;:MotorLoad, W&lt;:StaticPowerLoad},
    network_model::NetworkModel{X&lt;:PowerSimulations.AbstractPTDFModel}
)
</code></pre><p>Motor Load implementation to add constant motor power to PTDF SystemBalanceExpressions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_to_expression.jl#L1438">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ActivePowerBalance, U&lt;:FlowActivePowerFromToVariable, V&lt;:Branch, W&lt;:PowerSimulations.AbstractDeviceFormulation, X&lt;:PowerModels.AbstractPowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ActivePowerBalance, U&lt;:FlowActivePowerFromToVariable, V&lt;:Branch, W&lt;:PowerSimulations.AbstractDeviceFormulation, X&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:ActivePowerBalance},
    _::Type{U&lt;:FlowActivePowerFromToVariable},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:Branch},
    _::DeviceModel{V&lt;:Branch, W&lt;:PowerSimulations.AbstractDeviceFormulation},
    network_model::NetworkModel{X&lt;:PowerModels.AbstractPowerModel}
)
</code></pre><p>Default implementation to add branch variables to SystemBalanceExpressions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_to_expression.jl#L805">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ActivePowerBalance, U&lt;:FlowActivePowerFromToVariable, V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.AbstractTwoTerminalDCLineFormulation, X&lt;:CopperPlatePowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ActivePowerBalance, U&lt;:FlowActivePowerFromToVariable, V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.AbstractTwoTerminalDCLineFormulation, X&lt;:CopperPlatePowerModel}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:ActivePowerBalance},
    _::Type{U&lt;:FlowActivePowerFromToVariable},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:TwoTerminalHVDC},
    _::DeviceModel{V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.AbstractTwoTerminalDCLineFormulation},
    network_model::NetworkModel{X&lt;:CopperPlatePowerModel}
)
</code></pre><p>Default implementation to add branch variables to SystemBalanceExpressions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_to_expression.jl#L771">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ActivePowerBalance, U&lt;:FlowActivePowerFromToVariable, V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.AbstractTwoTerminalDCLineFormulation, X&lt;:PowerSimulations.AbstractPTDFModel}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ActivePowerBalance, U&lt;:FlowActivePowerFromToVariable, V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.AbstractTwoTerminalDCLineFormulation, X&lt;:PowerSimulations.AbstractPTDFModel}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:ActivePowerBalance},
    _::Type{U&lt;:FlowActivePowerFromToVariable},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:TwoTerminalHVDC},
    _::DeviceModel{V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.AbstractTwoTerminalDCLineFormulation},
    network_model::NetworkModel{X&lt;:PowerSimulations.AbstractPTDFModel}
)
</code></pre><p>Default implementation to add branch variables to SystemBalanceExpressions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_to_expression.jl#L502">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ActivePowerBalance, U&lt;:FlowActivePowerToFromVariable, V&lt;:ACBranch, W&lt;:PowerSimulations.AbstractDeviceFormulation, X&lt;:PowerModels.AbstractPowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ActivePowerBalance, U&lt;:FlowActivePowerToFromVariable, V&lt;:ACBranch, W&lt;:PowerSimulations.AbstractDeviceFormulation, X&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:ActivePowerBalance},
    _::Type{U&lt;:FlowActivePowerToFromVariable},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:ACBranch},
    _::DeviceModel{V&lt;:ACBranch, W&lt;:PowerSimulations.AbstractDeviceFormulation},
    network_model::NetworkModel{X&lt;:PowerModels.AbstractPowerModel}
)
</code></pre><p>Default implementation to add branch variables to SystemBalanceExpressions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_to_expression.jl#L840">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ActivePowerBalance, U&lt;:FlowActivePowerToFromVariable, V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.AbstractTwoTerminalDCLineFormulation, X&lt;:CopperPlatePowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ActivePowerBalance, U&lt;:FlowActivePowerToFromVariable, V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.AbstractTwoTerminalDCLineFormulation, X&lt;:CopperPlatePowerModel}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:ActivePowerBalance},
    _::Type{U&lt;:FlowActivePowerToFromVariable},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:TwoTerminalHVDC},
    _::DeviceModel{V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.AbstractTwoTerminalDCLineFormulation},
    network_model::NetworkModel{X&lt;:CopperPlatePowerModel}
)
</code></pre><p>Default implementation to add branch variables to SystemBalanceExpressions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_to_expression.jl#L737">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ActivePowerBalance, U&lt;:FlowActivePowerVariable, V&lt;:ACBranch, W&lt;:PowerSimulations.AbstractBranchFormulation, X&lt;:PowerModels.AbstractActivePowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ActivePowerBalance, U&lt;:FlowActivePowerVariable, V&lt;:ACBranch, W&lt;:PowerSimulations.AbstractBranchFormulation, X&lt;:PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:ActivePowerBalance},
    _::Type{U&lt;:FlowActivePowerVariable},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:ACBranch},
    _::DeviceModel{V&lt;:ACBranch, W&lt;:PowerSimulations.AbstractBranchFormulation},
    network_model::NetworkModel{X&lt;:PowerModels.AbstractActivePowerModel}
)
</code></pre><p>Implementation of add<em>to</em>expression! for lossless branch/network models</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_to_expression.jl#L1559">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ActivePowerBalance, U&lt;:FlowActivePowerVariable, V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.AbstractBranchFormulation, X&lt;:Union{PTDFPowerModel, SecurityConstrainedPTDFPowerModel}}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ActivePowerBalance, U&lt;:FlowActivePowerVariable, V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.AbstractBranchFormulation, X&lt;:Union{PTDFPowerModel, SecurityConstrainedPTDFPowerModel}}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:ActivePowerBalance},
    _::Type{U&lt;:FlowActivePowerVariable},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:TwoTerminalHVDC},
    _::DeviceModel{V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.AbstractBranchFormulation},
    network_model::NetworkModel{X&lt;:Union{PTDFPowerModel, SecurityConstrainedPTDFPowerModel}}
)
</code></pre><p>Implementation of add<em>to</em>expression! for lossless branch/network models</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_to_expression.jl#L1647">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ActivePowerBalance, U&lt;:HVDCLosses, V&lt;:TwoTerminalHVDC, W&lt;:HVDCTwoTerminalDispatch, X&lt;:Union{CopperPlatePowerModel, PTDFPowerModel, SecurityConstrainedPTDFPowerModel}}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ActivePowerBalance, U&lt;:HVDCLosses, V&lt;:TwoTerminalHVDC, W&lt;:HVDCTwoTerminalDispatch, X&lt;:Union{CopperPlatePowerModel, PTDFPowerModel, SecurityConstrainedPTDFPowerModel}}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:ActivePowerBalance},
    _::Type{U&lt;:HVDCLosses},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:TwoTerminalHVDC},
    _::DeviceModel{V&lt;:TwoTerminalHVDC, W&lt;:HVDCTwoTerminalDispatch},
    network_model::NetworkModel{X&lt;:Union{CopperPlatePowerModel, PTDFPowerModel, SecurityConstrainedPTDFPowerModel}}
)
</code></pre><p>Default implementation to add branch variables to SystemBalanceExpressions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_to_expression.jl#L396">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ActivePowerBalance, U&lt;:InfrastructureSystems.Optimization.VariableType, V&lt;:StaticInjection, W&lt;:PowerSimulations.AbstractDeviceFormulation, X&lt;:PTDFPowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ActivePowerBalance, U&lt;:InfrastructureSystems.Optimization.VariableType, V&lt;:StaticInjection, W&lt;:PowerSimulations.AbstractDeviceFormulation, X&lt;:PTDFPowerModel}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:ActivePowerBalance},
    _::Type{U&lt;:InfrastructureSystems.Optimization.VariableType},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:StaticInjection},
    device_model::DeviceModel{V&lt;:StaticInjection, W&lt;:PowerSimulations.AbstractDeviceFormulation},
    network_model::NetworkModel{X&lt;:PTDFPowerModel}
)
</code></pre><p>Default implementation to add variables to SystemBalanceExpressions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_to_expression.jl#L1396">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ActivePowerBalance, U&lt;:PowerSimulations.HVDCActivePowerReceivedFromVariable, V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.HVDCTwoTerminalLCC, X&lt;:ACPPowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ActivePowerBalance, U&lt;:PowerSimulations.HVDCActivePowerReceivedFromVariable, V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.HVDCTwoTerminalLCC, X&lt;:ACPPowerModel}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:ActivePowerBalance},
    _::Type{U&lt;:PowerSimulations.HVDCActivePowerReceivedFromVariable},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:TwoTerminalHVDC},
    _::DeviceModel{V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.HVDCTwoTerminalLCC},
    network_model::NetworkModel{X&lt;:ACPPowerModel}
)
</code></pre><p>HVDC LCC implementation to add ActivePowerBalance expression for HVDCActivePowerReceivedFromVariable variable</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_to_expression.jl#L576">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ActivePowerBalance, U&lt;:PowerSimulations.HVDCActivePowerReceivedFromVariable, V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.HVDCTwoTerminalPiecewiseLoss, X&lt;:PowerSimulations.AbstractPTDFModel}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ActivePowerBalance, U&lt;:PowerSimulations.HVDCActivePowerReceivedFromVariable, V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.HVDCTwoTerminalPiecewiseLoss, X&lt;:PowerSimulations.AbstractPTDFModel}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:ActivePowerBalance},
    _::Type{U&lt;:PowerSimulations.HVDCActivePowerReceivedFromVariable},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:TwoTerminalHVDC},
    _::DeviceModel{V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.HVDCTwoTerminalPiecewiseLoss},
    network_model::NetworkModel{X&lt;:PowerSimulations.AbstractPTDFModel}
)
</code></pre><p>PWL implementation to add FromTo branch variables to SystemBalanceExpressions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_to_expression.jl#L539">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ActivePowerBalance, U&lt;:PowerSimulations.HVDCActivePowerReceivedToVariable, V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.HVDCTwoTerminalLCC, X&lt;:ACPPowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ActivePowerBalance, U&lt;:PowerSimulations.HVDCActivePowerReceivedToVariable, V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.HVDCTwoTerminalLCC, X&lt;:ACPPowerModel}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:ActivePowerBalance},
    _::Type{U&lt;:PowerSimulations.HVDCActivePowerReceivedToVariable},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:TwoTerminalHVDC},
    _::DeviceModel{V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.HVDCTwoTerminalLCC},
    network_model::NetworkModel{X&lt;:ACPPowerModel}
)
</code></pre><p>HVDC LCC implementation to add ActivePowerBalance expression for HVDCActivePowerReceivedToVariable variable</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_to_expression.jl#L607">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ActivePowerBalance, U&lt;:PowerSimulations.HVDCActivePowerReceivedToVariable, V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.HVDCTwoTerminalPiecewiseLoss, X&lt;:PowerSimulations.AbstractPTDFModel}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ActivePowerBalance, U&lt;:PowerSimulations.HVDCActivePowerReceivedToVariable, V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.HVDCTwoTerminalPiecewiseLoss, X&lt;:PowerSimulations.AbstractPTDFModel}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:ActivePowerBalance},
    _::Type{U&lt;:PowerSimulations.HVDCActivePowerReceivedToVariable},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:TwoTerminalHVDC},
    _::DeviceModel{V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.HVDCTwoTerminalPiecewiseLoss},
    network_model::NetworkModel{X&lt;:PowerSimulations.AbstractPTDFModel}
)
</code></pre><p>PWL implementation to add FromTo branch variables to SystemBalanceExpressions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_to_expression.jl#L700">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ReactivePowerBalance, U&lt;:PowerSimulations.HVDCReactivePowerReceivedFromVariable, V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.HVDCTwoTerminalLCC, X&lt;:ACPPowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ReactivePowerBalance, U&lt;:PowerSimulations.HVDCReactivePowerReceivedFromVariable, V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.HVDCTwoTerminalLCC, X&lt;:ACPPowerModel}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:ReactivePowerBalance},
    _::Type{U&lt;:PowerSimulations.HVDCReactivePowerReceivedFromVariable},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:TwoTerminalHVDC},
    _::DeviceModel{V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.HVDCTwoTerminalLCC},
    network_model::NetworkModel{X&lt;:ACPPowerModel}
)
</code></pre><p>HVDC LCC implementation to add ReactivePowerBalance expression for HVDCReactivePowerReceivedFromVariable variable</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_to_expression.jl#L638">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ReactivePowerBalance, U&lt;:PowerSimulations.HVDCReactivePowerReceivedToVariable, V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.HVDCTwoTerminalLCC, X&lt;:ACPPowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ReactivePowerBalance, U&lt;:PowerSimulations.HVDCReactivePowerReceivedToVariable, V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.HVDCTwoTerminalLCC, X&lt;:ACPPowerModel}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:ReactivePowerBalance},
    _::Type{U&lt;:PowerSimulations.HVDCReactivePowerReceivedToVariable},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:TwoTerminalHVDC},
    _::DeviceModel{V&lt;:TwoTerminalHVDC, W&lt;:PowerSimulations.HVDCTwoTerminalLCC},
    network_model::NetworkModel{X&lt;:ACPPowerModel}
)
</code></pre><p>HVDC LCC implementation to add ReactivePowerBalance expression for HVDCReactivePowerReceivedToVariable variable</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_to_expression.jl#L669">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ReactivePowerBalance, U&lt;:ReactivePowerTimeSeriesParameter, V&lt;:MotorLoad, W&lt;:StaticPowerLoad, X&lt;:ACPPowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:ReactivePowerBalance, U&lt;:ReactivePowerTimeSeriesParameter, V&lt;:MotorLoad, W&lt;:StaticPowerLoad, X&lt;:ACPPowerModel}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:ReactivePowerBalance},
    _::Type{U&lt;:ReactivePowerTimeSeriesParameter},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:MotorLoad},
    model::DeviceModel{V&lt;:MotorLoad, W&lt;:StaticPowerLoad},
    network_model::NetworkModel{X&lt;:ACPPowerModel}
)
</code></pre><p>Motor load implementation to add constant power to ActivePowerBalance expression</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_to_expression.jl#L246">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:SystemBalanceExpressions, U&lt;:InfrastructureSystems.Optimization.TimeSeriesParameter, V&lt;:Device, W&lt;:PowerSimulations.AbstractDeviceFormulation, X&lt;:PowerModels.AbstractPowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:SystemBalanceExpressions, U&lt;:InfrastructureSystems.Optimization.TimeSeriesParameter, V&lt;:Device, W&lt;:PowerSimulations.AbstractDeviceFormulation, X&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:SystemBalanceExpressions},
    _::Type{U&lt;:InfrastructureSystems.Optimization.TimeSeriesParameter},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:Device},
    model::DeviceModel{V&lt;:Device, W&lt;:PowerSimulations.AbstractDeviceFormulation},
    network_model::NetworkModel{X&lt;:PowerModels.AbstractPowerModel}
)
</code></pre><p>Default implementation to add parameters to SystemBalanceExpressions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_to_expression.jl#L137">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:SystemBalanceExpressions, U&lt;:InfrastructureSystems.Optimization.TimeSeriesParameter, V&lt;:StaticInjection, W&lt;:PowerSimulations.AbstractDeviceFormulation, X&lt;:PowerSimulations.AbstractPTDFModel}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:SystemBalanceExpressions, U&lt;:InfrastructureSystems.Optimization.TimeSeriesParameter, V&lt;:StaticInjection, W&lt;:PowerSimulations.AbstractDeviceFormulation, X&lt;:PowerSimulations.AbstractPTDFModel}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:SystemBalanceExpressions},
    _::Type{U&lt;:InfrastructureSystems.Optimization.TimeSeriesParameter},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:StaticInjection},
    device_model::DeviceModel{V&lt;:StaticInjection, W&lt;:PowerSimulations.AbstractDeviceFormulation},
    network_model::NetworkModel{X&lt;:PowerSimulations.AbstractPTDFModel}
)
</code></pre><p>Default implementation to add parameters to SystemBalanceExpressions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_to_expression.jl#L1314">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:SystemBalanceExpressions, U&lt;:InfrastructureSystems.Optimization.VariableType, V&lt;:StaticInjection, W&lt;:PowerSimulations.AbstractDeviceFormulation, X&lt;:PowerModels.AbstractPowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:SystemBalanceExpressions, U&lt;:InfrastructureSystems.Optimization.VariableType, V&lt;:StaticInjection, W&lt;:PowerSimulations.AbstractDeviceFormulation, X&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:SystemBalanceExpressions},
    _::Type{U&lt;:InfrastructureSystems.Optimization.VariableType},
    devices::InfrastructureSystems.FlattenIteratorWrapper{V&lt;:StaticInjection},
    _::DeviceModel{V&lt;:StaticInjection, W&lt;:PowerSimulations.AbstractDeviceFormulation},
    network_model::NetworkModel{X&lt;:PowerModels.AbstractPowerModel}
)
</code></pre><p>Default implementation to add device variables to SystemBalanceExpressions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_to_expression.jl#L334">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, Union{InfrastructureSystems.FlattenIteratorWrapper{V}, Vector{V}}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:SystemBalanceExpressions, U&lt;:PowerSimulations.EventParameter, V&lt;:Device, W&lt;:PowerSimulations.AbstractDeviceFormulation, X&lt;:PowerModels.AbstractPowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, Union{InfrastructureSystems.FlattenIteratorWrapper{V}, Vector{V}}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:SystemBalanceExpressions, U&lt;:PowerSimulations.EventParameter, V&lt;:Device, W&lt;:PowerSimulations.AbstractDeviceFormulation, X&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:SystemBalanceExpressions},
    _::Type{U&lt;:PowerSimulations.EventParameter},
    devices::Union{Array{V&lt;:Device, 1}, InfrastructureSystems.FlattenIteratorWrapper{V&lt;:Device}},
    model::DeviceModel{V&lt;:Device, W&lt;:PowerSimulations.AbstractDeviceFormulation},
    network_model::NetworkModel{X&lt;:PowerModels.AbstractPowerModel}
)
</code></pre><p>Default implementation to add parameters to SystemBalanceExpressions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/contingency_model/contingency_arguments.jl#L352">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, Union{InfrastructureSystems.FlattenIteratorWrapper{V}, Vector{V}}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:SystemBalanceExpressions, U&lt;:PowerSimulations.EventParameter, V&lt;:StaticInjection, W&lt;:PowerSimulations.AbstractDeviceFormulation, X&lt;:CopperPlatePowerModel}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, Union{InfrastructureSystems.FlattenIteratorWrapper{V}, Vector{V}}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:SystemBalanceExpressions, U&lt;:PowerSimulations.EventParameter, V&lt;:StaticInjection, W&lt;:PowerSimulations.AbstractDeviceFormulation, X&lt;:CopperPlatePowerModel}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:SystemBalanceExpressions},
    _::Type{U&lt;:PowerSimulations.EventParameter},
    devices::Union{Array{V&lt;:StaticInjection, 1}, InfrastructureSystems.FlattenIteratorWrapper{V&lt;:StaticInjection}},
    device_model::DeviceModel{V&lt;:StaticInjection, W&lt;:PowerSimulations.AbstractDeviceFormulation},
    network_model::NetworkModel{X&lt;:CopperPlatePowerModel}
)
</code></pre><p>Default implementation to add parameters to SystemBalanceExpressions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/contingency_model/contingency_arguments.jl#L280">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, Union{InfrastructureSystems.FlattenIteratorWrapper{V}, Vector{V}}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:SystemBalanceExpressions, U&lt;:PowerSimulations.EventParameter, V&lt;:StaticInjection, W&lt;:PowerSimulations.AbstractDeviceFormulation, X&lt;:PowerSimulations.AbstractPTDFModel}"><a class="docstring-binding" href="#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, Union{InfrastructureSystems.FlattenIteratorWrapper{V}, Vector{V}}, DeviceModel{V, W}, NetworkModel{X}}} where {T&lt;:SystemBalanceExpressions, U&lt;:PowerSimulations.EventParameter, V&lt;:StaticInjection, W&lt;:PowerSimulations.AbstractDeviceFormulation, X&lt;:PowerSimulations.AbstractPTDFModel}"><code>PowerSimulations.add_to_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_to_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:SystemBalanceExpressions},
    _::Type{U&lt;:PowerSimulations.EventParameter},
    devices::Union{Array{V&lt;:StaticInjection, 1}, InfrastructureSystems.FlattenIteratorWrapper{V&lt;:StaticInjection}},
    device_model::DeviceModel{V&lt;:StaticInjection, W&lt;:PowerSimulations.AbstractDeviceFormulation},
    network_model::NetworkModel{X&lt;:PowerSimulations.AbstractPTDFModel}
)
</code></pre><p>Default implementation to add parameters to SystemBalanceExpressions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/contingency_model/contingency_arguments.jl#L315">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_variable!-Union{Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, D, Any}} where {T&lt;:ServiceRequirementVariable, D&lt;:ReserveDemandCurve}"><a class="docstring-binding" href="#PowerSimulations.add_variable!-Union{Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, D, Any}} where {T&lt;:ServiceRequirementVariable, D&lt;:ReserveDemandCurve}"><code>PowerSimulations.add_variable!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_variable!(
    container::PowerSimulations.OptimizationContainer,
    variable_type::ServiceRequirementVariable,
    service::ReserveDemandCurve,
    formulation
)
</code></pre><p>Add variables for ServiceRequirementVariable for StepWiseCostReserve</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/services_models/reserves.jl#L101">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_variable!-Union{Tuple{U}, Tuple{D}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.Optimization.AuxVariableType, U, Any}} where {D&lt;:Component, U&lt;:Union{InfrastructureSystems.FlattenIteratorWrapper{D}, Vector{D}}}"><a class="docstring-binding" href="#PowerSimulations.add_variable!-Union{Tuple{U}, Tuple{D}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.Optimization.AuxVariableType, U, Any}} where {D&lt;:Component, U&lt;:Union{InfrastructureSystems.FlattenIteratorWrapper{D}, Vector{D}}}"><code>PowerSimulations.add_variable!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_variable!(
    container::PowerSimulations.OptimizationContainer,
    var_type::InfrastructureSystems.Optimization.AuxVariableType,
    devices::Union{Array{D&lt;:Component, 1}, InfrastructureSystems.FlattenIteratorWrapper{D&lt;:Component}},
    formulation
)
</code></pre><p>Default implementation of adding auxiliary variable to the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_auxiliary_variable.jl#L14">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_variable!-Union{Tuple{U}, Tuple{T}, Tuple{D}, Tuple{PowerSimulations.OptimizationContainer, T, U, Any}} where {D&lt;:Component, T&lt;:InfrastructureSystems.Optimization.VariableType, U&lt;:Union{InfrastructureSystems.FlattenIteratorWrapper{D}, Vector{D}}}"><a class="docstring-binding" href="#PowerSimulations.add_variable!-Union{Tuple{U}, Tuple{T}, Tuple{D}, Tuple{PowerSimulations.OptimizationContainer, T, U, Any}} where {D&lt;:Component, T&lt;:InfrastructureSystems.Optimization.VariableType, U&lt;:Union{InfrastructureSystems.FlattenIteratorWrapper{D}, Vector{D}}}"><code>PowerSimulations.add_variable!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_variable!(
    container::PowerSimulations.OptimizationContainer,
    variable_type::InfrastructureSystems.Optimization.VariableType,
    devices::Union{Array{D&lt;:Component, 1}, InfrastructureSystems.FlattenIteratorWrapper{D&lt;:Component}},
    formulation
)
</code></pre><p>Adds a variable to the optimization model and to the affine expressions contained in the optimization_container model according to the specified sign. Based on the inputs, the variable can be specified as binary.</p><p><strong>Bounds</strong></p><p><code>lb_value_function &lt;= varstart[name, t] &lt;= ub_value_function</code></p><p>If binary = true:</p><p><code>varstart[name, t] in {0,1}</code></p><p><strong>LaTeX</strong></p><p><span>$lb \ge x^{device}_t \le ub \forall t$</span></p><p><span>$x^{device}_t \in {0,1} \forall t iff \text{binary = true}$</span></p><p><strong>Arguments</strong></p><ul><li>container::OptimizationContainer : the optimization_container model built in PowerSimulations</li><li>devices : Vector or Iterator with the devices</li><li>var_key::VariableKey : Base Name for the variable</li><li>binary::Bool : Select if the variable is binary</li><li>expression<em>name::Symbol : Expression</em>name name stored in container.expressions to add the variable</li><li>sign::Float64 : sign of the addition of the variable to the expression_name. Default Value is 1.0</li></ul><p><strong>Accepted Keyword Arguments</strong></p><ul><li>ub<em>value : Provides the function over device to obtain the value for a upper</em>bound</li><li>lb<em>value : Provides the function over device to obtain the value for a lower</em>bound. If the variable is meant to be positive define lb = x -&gt; 0.0</li><li>initial_value : Provides the function over device to obtain the warm start value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_variable.jl#L46">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_variable!-Union{Tuple{U}, Tuple{T}, Tuple{D}, Tuple{PowerSimulations.OptimizationContainer, T, U, PowerSimulations.AbstractThermalFormulation}} where {D&lt;:ThermalGen, T&lt;:Union{OnVariable, StartVariable, StopVariable}, U&lt;:Union{InfrastructureSystems.FlattenIteratorWrapper{D}, Vector{D}}}"><a class="docstring-binding" href="#PowerSimulations.add_variable!-Union{Tuple{U}, Tuple{T}, Tuple{D}, Tuple{PowerSimulations.OptimizationContainer, T, U, PowerSimulations.AbstractThermalFormulation}} where {D&lt;:ThermalGen, T&lt;:Union{OnVariable, StartVariable, StopVariable}, U&lt;:Union{InfrastructureSystems.FlattenIteratorWrapper{D}, Vector{D}}}"><code>PowerSimulations.add_variable!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_variable!(
    container::PowerSimulations.OptimizationContainer,
    variable_type::Union{OnVariable, StartVariable, StopVariable},
    devices::Union{Array{D&lt;:ThermalGen, 1}, InfrastructureSystems.FlattenIteratorWrapper{D&lt;:ThermalGen}},
    formulation::PowerSimulations.AbstractThermalFormulation
)
</code></pre><p>Adds a variable to the optimization model for the OnVariable of Thermal Units</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/thermal_generation.jl#L340">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_variables!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Union{InfrastructureSystems.FlattenIteratorWrapper{U}, Vector{U}}, Union{PowerSimulations.AbstractDeviceFormulation, PowerSimulations.AbstractServiceFormulation}}} where {T&lt;:InfrastructureSystems.Optimization.AuxVariableType, U&lt;:Component}"><a class="docstring-binding" href="#PowerSimulations.add_variables!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Union{InfrastructureSystems.FlattenIteratorWrapper{U}, Vector{U}}, Union{PowerSimulations.AbstractDeviceFormulation, PowerSimulations.AbstractServiceFormulation}}} where {T&lt;:InfrastructureSystems.Optimization.AuxVariableType, U&lt;:Component}"><code>PowerSimulations.add_variables!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_variables!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:InfrastructureSystems.Optimization.AuxVariableType},
    devices::Union{Array{U&lt;:Component, 1}, InfrastructureSystems.FlattenIteratorWrapper{U&lt;:Component}},
    formulation::Union{PowerSimulations.AbstractDeviceFormulation, PowerSimulations.AbstractServiceFormulation}
)
</code></pre><p>Add variables to the OptimizationContainer for any component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_auxiliary_variable.jl#L1">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_variables!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Union{InfrastructureSystems.FlattenIteratorWrapper{U}, Vector{U}}, Union{PowerSimulations.AbstractDeviceFormulation, PowerSimulations.AbstractServiceFormulation}}} where {T&lt;:InfrastructureSystems.Optimization.VariableType, U&lt;:Component}"><a class="docstring-binding" href="#PowerSimulations.add_variables!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Union{InfrastructureSystems.FlattenIteratorWrapper{U}, Vector{U}}, Union{PowerSimulations.AbstractDeviceFormulation, PowerSimulations.AbstractServiceFormulation}}} where {T&lt;:InfrastructureSystems.Optimization.VariableType, U&lt;:Component}"><code>PowerSimulations.add_variables!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_variables!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:InfrastructureSystems.Optimization.VariableType},
    devices::Union{Array{U&lt;:Component, 1}, InfrastructureSystems.FlattenIteratorWrapper{U&lt;:Component}},
    formulation::Union{PowerSimulations.AbstractDeviceFormulation, PowerSimulations.AbstractServiceFormulation}
)
</code></pre><p>Add variables to the OptimizationContainer for any component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_variable.jl#L1">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.add_variables!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, U, Union{InfrastructureSystems.FlattenIteratorWrapper{V}, Vector{V}}, PowerSimulations.AbstractReservesFormulation}} where {T&lt;:InfrastructureSystems.Optimization.VariableType, U&lt;:AbstractReserve, V&lt;:Component}"><a class="docstring-binding" href="#PowerSimulations.add_variables!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, U, Union{InfrastructureSystems.FlattenIteratorWrapper{V}, Vector{V}}, PowerSimulations.AbstractReservesFormulation}} where {T&lt;:InfrastructureSystems.Optimization.VariableType, U&lt;:AbstractReserve, V&lt;:Component}"><code>PowerSimulations.add_variables!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_variables!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{T&lt;:InfrastructureSystems.Optimization.VariableType},
    service::AbstractReserve,
    contributing_devices::Union{Array{V&lt;:Component, 1}, InfrastructureSystems.FlattenIteratorWrapper{V&lt;:Component}},
    formulation::PowerSimulations.AbstractReservesFormulation
)
</code></pre><p>Add variables to the OptimizationContainer for a service.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/add_variable.jl#L31">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.apply_maybe_across_time_series-Tuple{Function, Component, TimeSeriesKey}"><a class="docstring-binding" href="#PowerSimulations.apply_maybe_across_time_series-Tuple{Function, Component, TimeSeriesKey}"><code>PowerSimulations.apply_maybe_across_time_series</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">apply_maybe_across_time_series(
    fn::Function,
    component::Component,
    ts_key::TimeSeriesKey
) -&gt; Any
</code></pre><p>Helper function to look up a time series if necessary then apply a function (typically a validation routine in a <code>do</code> block) to every element in it</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/utils/time_series_utils.jl#L13">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.build_model!-Tuple{DecisionModel{&lt;:PowerSimulations.DefaultDecisionProblem}}"><a class="docstring-binding" href="#PowerSimulations.build_model!-Tuple{DecisionModel{&lt;:PowerSimulations.DefaultDecisionProblem}}"><code>PowerSimulations.build_model!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">build_model!(
    model::DecisionModel{&lt;:PowerSimulations.DefaultDecisionProblem}
)
</code></pre><p>Default implementation of build method for Operational Problems for models conforming with DecisionProblem specification. Overload this function to implement a custom build method</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/operation/decision_model.jl#L403">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.build_model!-Tuple{EmulationModel}"><a class="docstring-binding" href="#PowerSimulations.build_model!-Tuple{EmulationModel}"><code>PowerSimulations.build_model!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">build_model!(model::EmulationModel)
</code></pre><p>Default implementation of build method for Emulation Problems for models conforming with  DecisionProblem specification. Overload this function to implement a custom build method</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/operation/emulation_model.jl#L384">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.check_activeservice_variables-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Vector{T}}} where T&lt;:Service"><a class="docstring-binding" href="#PowerSimulations.check_activeservice_variables-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Vector{T}}} where T&lt;:Service"><code>PowerSimulations.check_activeservice_variables</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">check_activeservice_variables(
    container::PowerSimulations.OptimizationContainer,
    contributing_services::Array{T&lt;:Service, 1}
)
</code></pre><p>This function checks if the variables for reserves were created</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/services_models/reserve_group.jl#L14">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.check_file_integrity-Tuple{String}"><a class="docstring-binding" href="#PowerSimulations.check_file_integrity-Tuple{String}"><code>PowerSimulations.check_file_integrity</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">check_file_integrity(path::String)
</code></pre><pre><code class="language-julia hljs">check_file_integrity(path::String)</code></pre><p>Checks the hash value for each file made with the file is written with the new hash_value to verify the file hasn&#39;t been tampered with since written</p><p><strong>Arguments</strong></p><ul><li><code>path::String</code>: this is the folder path that contains the results and the check.sha256 file</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/utils/file_utils.jl#L40">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.construct_device!-Union{Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ArgumentConstructStage, DeviceModel{T, D}, NetworkModel{&lt;:PowerModels.AbstractActivePowerModel}}} where {T&lt;:Source, D&lt;:ImportExportSourceModel}"><a class="docstring-binding" href="#PowerSimulations.construct_device!-Union{Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ArgumentConstructStage, DeviceModel{T, D}, NetworkModel{&lt;:PowerModels.AbstractActivePowerModel}}} where {T&lt;:Source, D&lt;:ImportExportSourceModel}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">construct_device!(
    container::PowerSimulations.OptimizationContainer,
    sys::System,
    _::InfrastructureSystems.Optimization.ArgumentConstructStage,
    model::DeviceModel{T&lt;:Source, D&lt;:ImportExportSourceModel},
    network_model::NetworkModel{&lt;:PowerModels.AbstractActivePowerModel}
)
</code></pre><p>This function creates the arguments for the model for an import/export formulation for Source devices</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/device_constructors/source_constructor.jl#L159">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.construct_device!-Union{Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ArgumentConstructStage, DeviceModel{T, D}, NetworkModel{&lt;:PowerModels.AbstractActivePowerModel}}} where {T&lt;:ThermalGen, D&lt;:PowerSimulations.AbstractSecurityConstrainedUnitCommitment}"><a class="docstring-binding" href="#PowerSimulations.construct_device!-Union{Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ArgumentConstructStage, DeviceModel{T, D}, NetworkModel{&lt;:PowerModels.AbstractActivePowerModel}}} where {T&lt;:ThermalGen, D&lt;:PowerSimulations.AbstractSecurityConstrainedUnitCommitment}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">construct_device!(
    container::PowerSimulations.OptimizationContainer,
    sys::System,
    _::InfrastructureSystems.Optimization.ArgumentConstructStage,
    model::DeviceModel{T&lt;:ThermalGen, D&lt;:PowerSimulations.AbstractSecurityConstrainedUnitCommitment},
    network_model::NetworkModel{&lt;:PowerModels.AbstractActivePowerModel}
)
</code></pre><p>This function creates the arguments model for a full thermal Security-Constrained dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/static_injection_security_constrained_models.jl#L72">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.construct_device!-Union{Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ArgumentConstructStage, DeviceModel{T, D}, NetworkModel{&lt;:PowerModels.AbstractActivePowerModel}}} where {T&lt;:ThermalGen, D&lt;:PowerSimulations.AbstractStandardUnitCommitment}"><a class="docstring-binding" href="#PowerSimulations.construct_device!-Union{Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ArgumentConstructStage, DeviceModel{T, D}, NetworkModel{&lt;:PowerModels.AbstractActivePowerModel}}} where {T&lt;:ThermalGen, D&lt;:PowerSimulations.AbstractStandardUnitCommitment}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">construct_device!(
    container::PowerSimulations.OptimizationContainer,
    sys::System,
    _::InfrastructureSystems.Optimization.ArgumentConstructStage,
    device_model::DeviceModel{T&lt;:ThermalGen, D&lt;:PowerSimulations.AbstractStandardUnitCommitment},
    network_model::NetworkModel{&lt;:PowerModels.AbstractActivePowerModel}
)
</code></pre><p>This function creates the arguments model for a full thermal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/device_constructors/thermalgeneration_constructor.jl#L219">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.construct_device!-Union{Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ArgumentConstructStage, DeviceModel{T, D}, NetworkModel}} where {T&lt;:Source, D&lt;:ImportExportSourceModel}"><a class="docstring-binding" href="#PowerSimulations.construct_device!-Union{Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ArgumentConstructStage, DeviceModel{T, D}, NetworkModel}} where {T&lt;:Source, D&lt;:ImportExportSourceModel}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">construct_device!(
    container::PowerSimulations.OptimizationContainer,
    sys::System,
    _::InfrastructureSystems.Optimization.ArgumentConstructStage,
    model::DeviceModel{T&lt;:Source, D&lt;:ImportExportSourceModel},
    network_model::NetworkModel
)
</code></pre><p>This function creates the arguments for the model for an import/export formulation for Source devices</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/device_constructors/source_constructor.jl#L1">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.construct_device!-Union{Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ArgumentConstructStage, DeviceModel{T, D}, NetworkModel}} where {T&lt;:ThermalGen, D&lt;:PowerSimulations.AbstractStandardUnitCommitment}"><a class="docstring-binding" href="#PowerSimulations.construct_device!-Union{Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ArgumentConstructStage, DeviceModel{T, D}, NetworkModel}} where {T&lt;:ThermalGen, D&lt;:PowerSimulations.AbstractStandardUnitCommitment}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">construct_device!(
    container::PowerSimulations.OptimizationContainer,
    sys::System,
    _::InfrastructureSystems.Optimization.ArgumentConstructStage,
    device_model::DeviceModel{T&lt;:ThermalGen, D&lt;:PowerSimulations.AbstractStandardUnitCommitment},
    network_model::NetworkModel
)
</code></pre><p>This function creates the arguments for the model for a full thermal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/device_constructors/thermalgeneration_constructor.jl#L56">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.construct_device!-Union{Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ModelConstructStage, DeviceModel{T, D}, NetworkModel{&lt;:PowerModels.AbstractActivePowerModel}}} where {T&lt;:Source, D&lt;:ImportExportSourceModel}"><a class="docstring-binding" href="#PowerSimulations.construct_device!-Union{Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ModelConstructStage, DeviceModel{T, D}, NetworkModel{&lt;:PowerModels.AbstractActivePowerModel}}} where {T&lt;:Source, D&lt;:ImportExportSourceModel}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">construct_device!(
    container::PowerSimulations.OptimizationContainer,
    sys::System,
    _::InfrastructureSystems.Optimization.ModelConstructStage,
    model::DeviceModel{T&lt;:Source, D&lt;:ImportExportSourceModel},
    network_model::NetworkModel{&lt;:PowerModels.AbstractActivePowerModel}
)
</code></pre><p>This function creates the constraints for the model for an import/export formulation for Source devices</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/device_constructors/source_constructor.jl#L246">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.construct_device!-Union{Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ModelConstructStage, DeviceModel{T, D}, NetworkModel{&lt;:PowerModels.AbstractActivePowerModel}}} where {T&lt;:ThermalGen, D&lt;:PowerSimulations.AbstractSecurityConstrainedUnitCommitment}"><a class="docstring-binding" href="#PowerSimulations.construct_device!-Union{Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ModelConstructStage, DeviceModel{T, D}, NetworkModel{&lt;:PowerModels.AbstractActivePowerModel}}} where {T&lt;:ThermalGen, D&lt;:PowerSimulations.AbstractSecurityConstrainedUnitCommitment}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">construct_device!(
    container::PowerSimulations.OptimizationContainer,
    sys::System,
    _::InfrastructureSystems.Optimization.ModelConstructStage,
    model::DeviceModel{T&lt;:ThermalGen, D&lt;:PowerSimulations.AbstractSecurityConstrainedUnitCommitment},
    network_model::NetworkModel{&lt;:PowerModels.AbstractActivePowerModel}
)
</code></pre><p>This function creates the constraints for the model for a full thermal Security-Constrained dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/static_injection_security_constrained_models.jl#L145">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.construct_device!-Union{Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ModelConstructStage, DeviceModel{T, D}, NetworkModel}} where {T&lt;:Source, D&lt;:ImportExportSourceModel}"><a class="docstring-binding" href="#PowerSimulations.construct_device!-Union{Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ModelConstructStage, DeviceModel{T, D}, NetworkModel}} where {T&lt;:Source, D&lt;:ImportExportSourceModel}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">construct_device!(
    container::PowerSimulations.OptimizationContainer,
    sys::System,
    _::InfrastructureSystems.Optimization.ModelConstructStage,
    model::DeviceModel{T&lt;:Source, D&lt;:ImportExportSourceModel},
    network_model::NetworkModel
)
</code></pre><p>This function creates the constraints for the model for an import/export formulation for Source devices</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/device_constructors/source_constructor.jl#L82">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.construct_device!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ArgumentConstructStage, DeviceModel{T, ThermalBasicUnitCommitment}, NetworkModel{&lt;:PowerModels.AbstractActivePowerModel}}} where T&lt;:ThermalGen"><a class="docstring-binding" href="#PowerSimulations.construct_device!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ArgumentConstructStage, DeviceModel{T, ThermalBasicUnitCommitment}, NetworkModel{&lt;:PowerModels.AbstractActivePowerModel}}} where T&lt;:ThermalGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">construct_device!(
    container::PowerSimulations.OptimizationContainer,
    sys::System,
    _::InfrastructureSystems.Optimization.ArgumentConstructStage,
    device_model::DeviceModel{T&lt;:ThermalGen, ThermalBasicUnitCommitment},
    network_model::NetworkModel{&lt;:PowerModels.AbstractActivePowerModel}
)
</code></pre><p>This function creates the arguments for the model for a full thermal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/device_constructors/thermalgeneration_constructor.jl#L501">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.construct_device!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ArgumentConstructStage, DeviceModel{T, ThermalBasicUnitCommitment}, NetworkModel}} where T&lt;:ThermalGen"><a class="docstring-binding" href="#PowerSimulations.construct_device!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ArgumentConstructStage, DeviceModel{T, ThermalBasicUnitCommitment}, NetworkModel}} where T&lt;:ThermalGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">construct_device!(
    container::PowerSimulations.OptimizationContainer,
    sys::System,
    _::InfrastructureSystems.Optimization.ArgumentConstructStage,
    device_model::DeviceModel{T&lt;:ThermalGen, ThermalBasicUnitCommitment},
    network_model::NetworkModel
)
</code></pre><p>This function creates the model for a full thermal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/device_constructors/thermalgeneration_constructor.jl#L347">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.construct_device!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ArgumentConstructStage, DeviceModel{T, ThermalStandardDispatch}, NetworkModel{&lt;:PowerModels.AbstractActivePowerModel}}} where T&lt;:ThermalGen"><a class="docstring-binding" href="#PowerSimulations.construct_device!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ArgumentConstructStage, DeviceModel{T, ThermalStandardDispatch}, NetworkModel{&lt;:PowerModels.AbstractActivePowerModel}}} where T&lt;:ThermalGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">construct_device!(
    container::PowerSimulations.OptimizationContainer,
    sys::System,
    _::InfrastructureSystems.Optimization.ArgumentConstructStage,
    device_model::DeviceModel{T&lt;:ThermalGen, ThermalStandardDispatch},
    network_model::NetworkModel{&lt;:PowerModels.AbstractActivePowerModel}
)
</code></pre><p>This function creates the arguments for the model for a full thermal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/device_constructors/thermalgeneration_constructor.jl#L771">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.construct_device!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ArgumentConstructStage, DeviceModel{T, ThermalStandardDispatch}, NetworkModel}} where T&lt;:ThermalGen"><a class="docstring-binding" href="#PowerSimulations.construct_device!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ArgumentConstructStage, DeviceModel{T, ThermalStandardDispatch}, NetworkModel}} where T&lt;:ThermalGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">construct_device!(
    container::PowerSimulations.OptimizationContainer,
    sys::System,
    _::InfrastructureSystems.Optimization.ArgumentConstructStage,
    device_model::DeviceModel{T&lt;:ThermalGen, ThermalStandardDispatch},
    network_model::NetworkModel
)
</code></pre><p>This function creates the model for a full thermal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/device_constructors/thermalgeneration_constructor.jl#L637">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.construct_device!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ModelConstructStage, DeviceModel{T, &lt;:PowerSimulations.AbstractStandardUnitCommitment}, NetworkModel{&lt;:PowerModels.AbstractActivePowerModel}}} where T&lt;:ThermalGen"><a class="docstring-binding" href="#PowerSimulations.construct_device!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ModelConstructStage, DeviceModel{T, &lt;:PowerSimulations.AbstractStandardUnitCommitment}, NetworkModel{&lt;:PowerModels.AbstractActivePowerModel}}} where T&lt;:ThermalGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">construct_device!(
    container::PowerSimulations.OptimizationContainer,
    sys::System,
    _::InfrastructureSystems.Optimization.ModelConstructStage,
    device_model::DeviceModel{T&lt;:ThermalGen, &lt;:PowerSimulations.AbstractStandardUnitCommitment},
    network_model::NetworkModel{&lt;:PowerModels.AbstractActivePowerModel}
)
</code></pre><p>This function creates the constraints for the model for a full thermal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/device_constructors/thermalgeneration_constructor.jl#L292">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.construct_device!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ModelConstructStage, DeviceModel{T, ThermalBasicUnitCommitment}, NetworkModel{&lt;:PowerModels.AbstractActivePowerModel}}} where T&lt;:ThermalGen"><a class="docstring-binding" href="#PowerSimulations.construct_device!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ModelConstructStage, DeviceModel{T, ThermalBasicUnitCommitment}, NetworkModel{&lt;:PowerModels.AbstractActivePowerModel}}} where T&lt;:ThermalGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">construct_device!(
    container::PowerSimulations.OptimizationContainer,
    sys::System,
    _::InfrastructureSystems.Optimization.ModelConstructStage,
    device_model::DeviceModel{T&lt;:ThermalGen, ThermalBasicUnitCommitment},
    network_model::NetworkModel{&lt;:PowerModels.AbstractActivePowerModel}
)
</code></pre><p>This function creates the constraints for the model for a full thermal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/device_constructors/thermalgeneration_constructor.jl#L583">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.construct_device!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ModelConstructStage, DeviceModel{T, ThermalBasicUnitCommitment}, NetworkModel}} where T&lt;:ThermalGen"><a class="docstring-binding" href="#PowerSimulations.construct_device!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ModelConstructStage, DeviceModel{T, ThermalBasicUnitCommitment}, NetworkModel}} where T&lt;:ThermalGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">construct_device!(
    container::PowerSimulations.OptimizationContainer,
    sys::System,
    _::InfrastructureSystems.Optimization.ModelConstructStage,
    device_model::DeviceModel{T&lt;:ThermalGen, ThermalBasicUnitCommitment},
    network_model::NetworkModel
)
</code></pre><p>This function creates the model for a full thermal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/device_constructors/thermalgeneration_constructor.jl#L438">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.construct_device!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ModelConstructStage, DeviceModel{T, ThermalStandardDispatch}, NetworkModel{&lt;:PowerModels.AbstractActivePowerModel}}} where T&lt;:ThermalGen"><a class="docstring-binding" href="#PowerSimulations.construct_device!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ModelConstructStage, DeviceModel{T, ThermalStandardDispatch}, NetworkModel{&lt;:PowerModels.AbstractActivePowerModel}}} where T&lt;:ThermalGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">construct_device!(
    container::PowerSimulations.OptimizationContainer,
    sys::System,
    _::InfrastructureSystems.Optimization.ModelConstructStage,
    device_model::DeviceModel{T&lt;:ThermalGen, ThermalStandardDispatch},
    network_model::NetworkModel{&lt;:PowerModels.AbstractActivePowerModel}
)
</code></pre><p>This function creates the constraints for the model for a full thermal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/device_constructors/thermalgeneration_constructor.jl#L844">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.construct_device!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ModelConstructStage, DeviceModel{T, ThermalStandardDispatch}, NetworkModel}} where T&lt;:ThermalGen"><a class="docstring-binding" href="#PowerSimulations.construct_device!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ModelConstructStage, DeviceModel{T, ThermalStandardDispatch}, NetworkModel}} where T&lt;:ThermalGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">construct_device!(
    container::PowerSimulations.OptimizationContainer,
    sys::System,
    _::InfrastructureSystems.Optimization.ModelConstructStage,
    device_model::DeviceModel{T&lt;:ThermalGen, ThermalStandardDispatch},
    network_model::NetworkModel
)
</code></pre><p>This function creates the model for a full thermal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/device_constructors/thermalgeneration_constructor.jl#L719">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.construct_device!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ModelConstructStage, DeviceModel{T, U}, NetworkModel}} where {T&lt;:ThermalGen, U&lt;:Union{PowerSimulations.AbstractSecurityConstrainedUnitCommitment, PowerSimulations.AbstractStandardUnitCommitment}}"><a class="docstring-binding" href="#PowerSimulations.construct_device!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ModelConstructStage, DeviceModel{T, U}, NetworkModel}} where {T&lt;:ThermalGen, U&lt;:Union{PowerSimulations.AbstractSecurityConstrainedUnitCommitment, PowerSimulations.AbstractStandardUnitCommitment}}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">construct_device!(
    container::PowerSimulations.OptimizationContainer,
    sys::System,
    _::InfrastructureSystems.Optimization.ModelConstructStage,
    device_model::DeviceModel{T&lt;:ThermalGen, U&lt;:Union{PowerSimulations.AbstractSecurityConstrainedUnitCommitment, PowerSimulations.AbstractStandardUnitCommitment}},
    network_model::NetworkModel
)
</code></pre><p>This function creates the constraints for the model for a full thermal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/device_constructors/thermalgeneration_constructor.jl#L140">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.construct_service!-Union{Tuple{SR}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ArgumentConstructStage, ServiceModel{SR, GroupReserve}, Dict{Symbol, DeviceModel}, Set{&lt;:DataType}, NetworkModel}} where SR&lt;:ConstantReserveGroup"><a class="docstring-binding" href="#PowerSimulations.construct_service!-Union{Tuple{SR}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ArgumentConstructStage, ServiceModel{SR, GroupReserve}, Dict{Symbol, DeviceModel}, Set{&lt;:DataType}, NetworkModel}} where SR&lt;:ConstantReserveGroup"><code>PowerSimulations.construct_service!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">construct_service!(
    container::PowerSimulations.OptimizationContainer,
    sys::System,
    _::InfrastructureSystems.Optimization.ArgumentConstructStage,
    model::ServiceModel{SR&lt;:ConstantReserveGroup, GroupReserve},
    _::Dict{Symbol, DeviceModel},
    _::Set{&lt;:DataType},
    _::NetworkModel
)
</code></pre><pre><code class="language-julia hljs">Constructs a service for ConstantReserveGroup.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/services_models/services_constructor.jl#L355">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.container_spec-Tuple{Type{Float64}, Vararg{Any}}"><a class="docstring-binding" href="#PowerSimulations.container_spec-Tuple{Type{Float64}, Vararg{Any}}"><code>PowerSimulations.container_spec</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">container_spec(
    _::Type{Float64},
    axs...
) -&gt; JuMP.Containers.DenseAxisArray
</code></pre><p>Returns the correct container specification for the selected type of JuMP Model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/utils/jump_utils.jl#L437">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.container_spec-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any}}} where T"><a class="docstring-binding" href="#PowerSimulations.container_spec-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any}}} where T"><code>PowerSimulations.container_spec</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">container_spec(
    _::Type{T},
    axs...
) -&gt; JuMP.Containers.DenseAxisArray
</code></pre><p>Returns the correct container specification for the selected type of JuMP Model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/utils/jump_utils.jl#L430">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.device_duration_compact_retrospective!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Vector{@NamedTuple{up::Float64, down::Float64}}, Matrix{InitialCondition}, InfrastructureSystems.Optimization.ConstraintType, Tuple{InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType}, Type{T}}} where T&lt;:Component"><a class="docstring-binding" href="#PowerSimulations.device_duration_compact_retrospective!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Vector{@NamedTuple{up::Float64, down::Float64}}, Matrix{InitialCondition}, InfrastructureSystems.Optimization.ConstraintType, Tuple{InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType}, Type{T}}} where T&lt;:Component"><code>PowerSimulations.device_duration_compact_retrospective!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">device_duration_compact_retrospective!(
    container::PowerSimulations.OptimizationContainer,
    duration_data::Vector{@NamedTuple{up::Float64, down::Float64}},
    initial_duration::Matrix{InitialCondition},
    cons_type::InfrastructureSystems.Optimization.ConstraintType,
    var_types::Tuple{InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType},
    _::Type{T&lt;:Component}
)
</code></pre><p>This formulation of the duration constraints adds over the start times looking backwards.</p><p><strong>LaTeX</strong></p><ul><li>Minimum up-time constraint:</li></ul><p><span>$\sum_{i=t-min(d_{min}^{up}, T)+ 1}^t x_i^{start} - x_t^{on} \leq 0$</span></p><p>for i in the set of time steps.</p><ul><li>Minimum down-time constraint:</li></ul><p><span>$\sum_{i=t-min(d_{min}^{down}, T) + 1}^t x_i^{stop} + x_t^{on} \leq 1$</span></p><p>for i in the set of time steps.</p><p><strong>Arguments</strong></p><ul><li>container::OptimizationContainer : the optimization_container model built in PowerSimulations</li><li>duration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down</li><li>initial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)</li><li>cons_name::Symbol : name of the constraint</li><li>var_keys::Tuple{VariableKey, VariableKey, VariableKey}) : names of the variables</li><li>: var_keys[1] : varon</li><li>: var_keys[2] : varstart</li><li>: var_keys[3] : varstop</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/duration_constraints.jl#L353">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.device_duration_look_ahead!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Vector{@NamedTuple{up::Float64, down::Float64}}, Matrix{InitialCondition}, InfrastructureSystems.Optimization.ConstraintType, InfrastructureSystems.Optimization.ConstraintType, Tuple{InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType}, Type{T}}} where T&lt;:Component"><a class="docstring-binding" href="#PowerSimulations.device_duration_look_ahead!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Vector{@NamedTuple{up::Float64, down::Float64}}, Matrix{InitialCondition}, InfrastructureSystems.Optimization.ConstraintType, InfrastructureSystems.Optimization.ConstraintType, Tuple{InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType}, Type{T}}} where T&lt;:Component"><code>PowerSimulations.device_duration_look_ahead!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">device_duration_look_ahead!(
    container::PowerSimulations.OptimizationContainer,
    duration_data::Vector{@NamedTuple{up::Float64, down::Float64}},
    initial_duration::Matrix{InitialCondition},
    cons_type_up::InfrastructureSystems.Optimization.ConstraintType,
    cons_type_down::InfrastructureSystems.Optimization.ConstraintType,
    var_types::Tuple{InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType},
    _::Type{T&lt;:Component}
)
</code></pre><p>This formulation of the duration constraints looks ahead in the time frame of the model.</p><p><strong>LaTeX</strong></p><ul><li>Minimum up-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{up}$</span></p><p><span>$d_{min}^{down}x_t^{stop} - \sum_{i=t-d_{min}^{up} + 1}^t x_i^{on} - x_{init}^{up} \leq 0$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$d_{min}^{down}x_t^{stop} - \sum_{i=t-d_{min}^{up} + 1}^t x_i^{on} \leq 0$</span></p><p>for i in the set of time steps.</p><ul><li>Minimum down-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{down}$</span></p><p><span>$d_{min}^{up}x_t^{start} - \sum_{i=t-d_{min^{down} + 1}^t (1 - x_i^{on}) - x_{init}^{down} \leq 0$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$d_{min}^{up}x_t^{start} - \sum_{i=t-d_{min^{down} + 1}^t (1 - x_i^{on}) \leq 0$</span></p><p>for i in the set of time steps.</p><p><strong>Arguments</strong></p><ul><li>container::OptimizationContainer : the optimization_container model built in PowerSimulations</li><li>duration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down</li><li>initial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)</li><li>cons_name::Symbol : name of the constraint</li><li>var_keys::Tuple{VariableKey, VariableKey, VariableKey}) : names of the variables</li><li>: var_keys[1] : varon</li><li>: var_keys[2] : varstart</li><li>: var_keys[3] : varstop</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/duration_constraints.jl#L114">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.device_duration_parameters!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Vector{@NamedTuple{up::Float64, down::Float64}}, Matrix{InitialCondition}, InfrastructureSystems.Optimization.ConstraintType, Tuple{InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType}, Type{T}}} where T&lt;:Component"><a class="docstring-binding" href="#PowerSimulations.device_duration_parameters!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Vector{@NamedTuple{up::Float64, down::Float64}}, Matrix{InitialCondition}, InfrastructureSystems.Optimization.ConstraintType, Tuple{InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType}, Type{T}}} where T&lt;:Component"><code>PowerSimulations.device_duration_parameters!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">device_duration_parameters!(
    container::PowerSimulations.OptimizationContainer,
    duration_data::Vector{@NamedTuple{up::Float64, down::Float64}},
    initial_duration::Matrix{InitialCondition},
    cons_type::InfrastructureSystems.Optimization.ConstraintType,
    var_types::Tuple{InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType},
    _::Type{T&lt;:Component}
)
</code></pre><p>This formulation of the duration constraints considers parameters.</p><p><strong>LaTeX</strong></p><ul><li>Minimum up-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{up}$</span></p><p><span>$d_{min}^{down}x_t^{stop} - \sum_{i=t-d_{min}^{up} + 1}^t x_i^{on} - x_{init}^{up} \leq 0$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$\sum_{i=t-d_{min}^{up} + 1}^t x_i^{start} - x_t^{on} \leq 0$</span></p><p>for i in the set of time steps.</p><ul><li>Minimum down-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{down}$</span></p><p><span>$d_{min}^{up}x_t^{start} - \sum_{i=t-d_{min^{down} + 1}^t (1 - x_i^{on}) - x_{init}^{down} \leq 0$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$\sum_{i=t-d_{min}^{down} + 1}^t x_i^{stop} + x_t^{on} \leq 1$</span></p><p>for i in the set of time steps.</p><p><strong>Arguments</strong></p><ul><li>container::OptimizationContainer : the optimization_container model built in PowerSimulations</li><li>duration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down</li><li>initial<em>duration</em>on::Vector{InitialCondition} : gives initial number of time steps variable is up</li><li>initial<em>duration</em>off::Vector{InitialCondition} : gives initial number of time steps variable is down</li><li>cons_name::Symbol : name of the constraint</li><li>var_keys::Tuple{VariableKey, VariableKey, VariableKey}) : names of the variables</li><li>: var_keys[1] : varon</li><li>: var_keys[2] : varstart</li><li>: var_keys[3] : varstop</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/duration_constraints.jl#L218">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.device_duration_retrospective!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Vector{@NamedTuple{up::Float64, down::Float64}}, Matrix{InitialCondition}, InfrastructureSystems.Optimization.ConstraintType, Tuple{InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType}, Type{T}}} where T&lt;:Component"><a class="docstring-binding" href="#PowerSimulations.device_duration_retrospective!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Vector{@NamedTuple{up::Float64, down::Float64}}, Matrix{InitialCondition}, InfrastructureSystems.Optimization.ConstraintType, Tuple{InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType}, Type{T}}} where T&lt;:Component"><code>PowerSimulations.device_duration_retrospective!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">device_duration_retrospective!(
    container::PowerSimulations.OptimizationContainer,
    duration_data::Vector{@NamedTuple{up::Float64, down::Float64}},
    initial_duration::Matrix{InitialCondition},
    cons_type::InfrastructureSystems.Optimization.ConstraintType,
    var_types::Tuple{InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType},
    _::Type{T&lt;:Component}
)
</code></pre><p>This formulation of the duration constraints adds over the start times looking backwards.</p><p><strong>LaTeX</strong></p><ul><li>Minimum up-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{up} - d_{init}^{up}$</span> and <span>$d_{init}^{up} &gt; 0$</span></p><p><span>$1 + \sum_{i=t-d_{min}^{up} + 1}^t x_i^{start} - x_t^{on} \leq 0$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$\sum_{i=t-d_{min}^{up} + 1}^t x_i^{start} - x_t^{on} \leq 0$</span></p><p>for i in the set of time steps.</p><ul><li>Minimum down-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{down} - d_{init}^{down}$</span> and <span>$d_{init}^{down} &gt; 0$</span></p><p><span>$1 + \sum_{i=t-d_{min}^{down} + 1}^t x_i^{stop} + x_t^{on} \leq 1$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$\sum_{i=t-d_{min}^{down} + 1}^t x_i^{stop} + x_t^{on} \leq 1$</span></p><p>for i in the set of time steps.</p><p><strong>Arguments</strong></p><ul><li>container::OptimizationContainer : the optimization_container model built in PowerSimulations</li><li>duration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down</li><li>initial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)</li><li>cons_name::Symbol : name of the constraint</li><li>var_keys::Tuple{VariableKey, VariableKey, VariableKey}) : names of the variables</li><li>: var_keys[1] : varon</li><li>: var_keys[2] : varstart</li><li>: var_keys[3] : varstop</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/duration_constraints.jl#L1">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.find_key_with_value-Tuple{Any, Any}"><a class="docstring-binding" href="#PowerSimulations.find_key_with_value-Tuple{Any, Any}"><code>PowerSimulations.find_key_with_value</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_key_with_value(d, value) -&gt; Any
</code></pre><p>Return the key for the given value</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/utils/file_utils.jl#L17">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.find_timestamp_index-Tuple{Union{StepRange{Dates.DateTime, Dates.Millisecond}, Vector{Dates.DateTime}}, Dates.DateTime}"><a class="docstring-binding" href="#PowerSimulations.find_timestamp_index-Tuple{Union{StepRange{Dates.DateTime, Dates.Millisecond}, Vector{Dates.DateTime}}, Dates.DateTime}"><code>PowerSimulations.find_timestamp_index</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_timestamp_index(
    dates::Union{StepRange{Dates.DateTime, Dates.Millisecond}, Vector{Dates.DateTime}},
    date::Dates.DateTime
) -&gt; Int64
</code></pre><p>calculates the index in the time series corresponding to the data. Assumes that the dates vector is sorted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/utils/datetime_utils.jl#L1">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.generate_formulation_combinations"><a class="docstring-binding" href="#PowerSimulations.generate_formulation_combinations"><code>PowerSimulations.generate_formulation_combinations</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">generate_formulation_combinations(

) -&gt; Dict{String, Vector{Any}}
generate_formulation_combinations(
    sys
) -&gt; Dict{String, Vector{Any}}
</code></pre><p>Generate valid combinations of device<em>type/formulation and service</em>type/formulation. Return vectors of dictionaries with Julia types.</p><p><strong>Arguments</strong></p><ul><li><code>sys::Union{Nothing, System}</code>: If set, only include component types present in the system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/utils/generate_valid_formulations.jl#L1">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_absolute_step_range-Tuple{SimulationPartitions, Int64}"><a class="docstring-binding" href="#PowerSimulations.get_absolute_step_range-Tuple{SimulationPartitions, Int64}"><code>PowerSimulations.get_absolute_step_range</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_absolute_step_range(
    partitions::SimulationPartitions,
    index::Int64
) -&gt; UnitRange{Int64}
</code></pre><p>Return a UnitRange for the steps in the partition with the given index. Includes overlap.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/simulation_partitions.jl#L34">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_column_names-Tuple{PowerSimulations.OptimizationContainer, Symbol, Any, InfrastructureSystems.Optimization.OptimizationContainerKey}"><a class="docstring-binding" href="#PowerSimulations.get_column_names-Tuple{PowerSimulations.OptimizationContainer, Symbol, Any, InfrastructureSystems.Optimization.OptimizationContainerKey}"><code>PowerSimulations.get_column_names</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_column_names(
    _::PowerSimulations.OptimizationContainer,
    field::Symbol,
    subcontainer,
    key::InfrastructureSystems.Optimization.OptimizationContainerKey
) -&gt; Any
</code></pre><p>Get the column names for the specified container in the OptimizationContainer.</p><p><strong>Arguments</strong></p><ul><li><code>container::OptimizationContainer</code>: The optimization container.</li><li><code>field::Symbol</code>: The field for which to retrieve the column names.</li><li><code>key::OptimizationContainerKey</code>: The key for which to retrieve the column names.</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple</code>: Tuple of Vector{String}.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/optimization_container.jl#L2125">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_column_names_from_key-Tuple{InfrastructureSystems.Optimization.OptimizationContainerKey}"><a class="docstring-binding" href="#PowerSimulations.get_column_names_from_key-Tuple{InfrastructureSystems.Optimization.OptimizationContainerKey}"><code>PowerSimulations.get_column_names_from_key</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_column_names_from_key(
    key::InfrastructureSystems.Optimization.OptimizationContainerKey
) -&gt; Tuple{Vector{String}}
</code></pre><p>Return the column names from a key as a tuple of vector of strings. Only useful for 1d DenseAxisArrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/utils/jump_utils.jl#L179">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_dirty_data_to_flush!-Tuple{PowerSimulations.OptimizationOutputCache}"><a class="docstring-binding" href="#PowerSimulations.get_dirty_data_to_flush!-Tuple{PowerSimulations.OptimizationOutputCache}"><code>PowerSimulations.get_dirty_data_to_flush!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_dirty_data_to_flush!(
    cache::PowerSimulations.OptimizationOutputCache
) -&gt; Tuple{Vector{Dates.DateTime}, Any}
</code></pre><p>Return all dirty data from the cache. Mark the timestamps as clean.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/optimization_output_cache.jl#L107">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_enum_value-Tuple{Any, String}"><a class="docstring-binding" href="#PowerSimulations.get_enum_value-Tuple{Any, String}"><code>PowerSimulations.get_enum_value</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_enum_value(enum, value::String) -&gt; Any
</code></pre><p>Get the enum value for the string. Case insensitive.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/definitions.jl#L143">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_last_updated_timestamp-Tuple{PowerSimulations.DatasetContainer, InfrastructureSystems.Optimization.OptimizationContainerKey}"><a class="docstring-binding" href="#PowerSimulations.get_last_updated_timestamp-Tuple{PowerSimulations.DatasetContainer, InfrastructureSystems.Optimization.OptimizationContainerKey}"><code>PowerSimulations.get_last_updated_timestamp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_last_updated_timestamp(
    container::PowerSimulations.DatasetContainer,
    key::InfrastructureSystems.Optimization.OptimizationContainerKey
) -&gt; Dates.DateTime
</code></pre><p>Return the timestamp from most recent data row updated in the dataset. This value may not be the same as the result from <code>get_update_timestamp</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/dataset_container.jl#L202">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_last_updated_timestamp-Tuple{PowerSimulations.HDF5Dataset}"><a class="docstring-binding" href="#PowerSimulations.get_last_updated_timestamp-Tuple{PowerSimulations.HDF5Dataset}"><code>PowerSimulations.get_last_updated_timestamp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_last_updated_timestamp(
    s::PowerSimulations.HDF5Dataset
) -&gt; Dates.DateTime
</code></pre><p>Return the timestamp from most recent data row updated in the dataset. This value may not be the same as the result from <code>get_update_timestamp</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/dataset.jl#L272">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_last_updated_timestamp-Tuple{PowerSimulations.InMemoryDataset}"><a class="docstring-binding" href="#PowerSimulations.get_last_updated_timestamp-Tuple{PowerSimulations.InMemoryDataset}"><code>PowerSimulations.get_last_updated_timestamp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_last_updated_timestamp(
    s::PowerSimulations.InMemoryDataset
) -&gt; Dates.DateTime
</code></pre><p>Return the timestamp from most recent data row updated in the dataset. This value may not be the same as the result from <code>get_update_timestamp</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/dataset.jl#L155">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_min_max_limits-Tuple{ACTransmission, Type{&lt;:InfrastructureSystems.Optimization.ConstraintType}, Type{&lt;:PowerSimulations.AbstractBranchFormulation}}"><a class="docstring-binding" href="#PowerSimulations.get_min_max_limits-Tuple{ACTransmission, Type{&lt;:InfrastructureSystems.Optimization.ConstraintType}, Type{&lt;:PowerSimulations.AbstractBranchFormulation}}"><code>PowerSimulations.get_min_max_limits</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_min_max_limits(
    device::ACTransmission,
    _::Type{&lt;:InfrastructureSystems.Optimization.ConstraintType},
    _::Type{&lt;:PowerSimulations.AbstractBranchFormulation}
) -&gt; @NamedTuple{min::Float64, max::Float64}
</code></pre><p>Min and max limits for Abstract Branch Formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/AC_branches.jl#L338">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_min_max_limits-Tuple{ACTransmission, Type{&lt;:PostContingencyEmergencyRateLimitConstrain}, Type{&lt;:PowerSimulations.AbstractBranchFormulation}, NetworkModel{&lt;:PowerSimulations.AbstractPTDFModel}}"><a class="docstring-binding" href="#PowerSimulations.get_min_max_limits-Tuple{ACTransmission, Type{&lt;:PostContingencyEmergencyRateLimitConstrain}, Type{&lt;:PowerSimulations.AbstractBranchFormulation}, NetworkModel{&lt;:PowerSimulations.AbstractPTDFModel}}"><code>PowerSimulations.get_min_max_limits</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_min_max_limits(
    branch::ACTransmission,
    _::Type{&lt;:PostContingencyEmergencyRateLimitConstrain},
    _::Type{&lt;:PowerSimulations.AbstractBranchFormulation},
    _::NetworkModel{&lt;:PowerSimulations.AbstractPTDFModel}
) -&gt; NamedTuple{(:min, :max), &lt;:Tuple{Any, Any}}
</code></pre><p>Min and max limits for post-contingency branch flows for Abstract Branch Formulation and SecurityConstrainedPTDF Network formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/network_models/security_constrained_models.jl#L1">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_min_max_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{&lt;:PowerSimulations.AbstractCompactUnitCommitment}}"><a class="docstring-binding" href="#PowerSimulations.get_min_max_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{&lt;:PowerSimulations.AbstractCompactUnitCommitment}}"><code>PowerSimulations.get_min_max_limits</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_min_max_limits(
    device,
    _::Type{ActivePowerVariableLimitsConstraint},
    _::Type{&lt;:PowerSimulations.AbstractCompactUnitCommitment}
) -&gt; NamedTuple{(:min, :max), &lt;:Tuple{Float64, Any}}
</code></pre><p>Min and Max active power limits for Compact Unit Commitment</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/thermal_generation.jl#L426">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_min_max_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{&lt;:PowerSimulations.AbstractThermalDispatchFormulation}}"><a class="docstring-binding" href="#PowerSimulations.get_min_max_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{&lt;:PowerSimulations.AbstractThermalDispatchFormulation}}"><code>PowerSimulations.get_min_max_limits</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_min_max_limits(
    device,
    _::Type{ActivePowerVariableLimitsConstraint},
    _::Type{&lt;:PowerSimulations.AbstractThermalDispatchFormulation}
) -&gt; NamedTuple{(:min, :max), &lt;:Tuple{Float64, Any}}
</code></pre><p>Min and max active power limits of generators for thermal dispatch formulations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/thermal_generation.jl#L238">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_min_max_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{&lt;:PowerSimulations.AbstractThermalUnitCommitment}}"><a class="docstring-binding" href="#PowerSimulations.get_min_max_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{&lt;:PowerSimulations.AbstractThermalUnitCommitment}}"><code>PowerSimulations.get_min_max_limits</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_min_max_limits(
    device,
    _::Type{ActivePowerVariableLimitsConstraint},
    _::Type{&lt;:PowerSimulations.AbstractThermalUnitCommitment}
) -&gt; NamedTuple{(:min, :max), &lt;:Tuple{Float64, Any}}
</code></pre><p>Min and max active power limits of generators for thermal unit commitment formulations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/thermal_generation.jl#L250">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_min_max_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{ThermalCompactDispatch}}"><a class="docstring-binding" href="#PowerSimulations.get_min_max_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{ThermalCompactDispatch}}"><code>PowerSimulations.get_min_max_limits</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_min_max_limits(
    device,
    _::Type{ActivePowerVariableLimitsConstraint},
    _::Type{ThermalCompactDispatch}
) -&gt; NamedTuple{(:min, :max), &lt;:Tuple{Float64, Any}}
</code></pre><p>Min and max active power limits of generators for thermal dispatch compact formulations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/thermal_generation.jl#L278">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_min_max_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{ThermalDispatchNoMin}}"><a class="docstring-binding" href="#PowerSimulations.get_min_max_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{ThermalDispatchNoMin}}"><code>PowerSimulations.get_min_max_limits</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_min_max_limits(
    device,
    _::Type{ActivePowerVariableLimitsConstraint},
    _::Type{ThermalDispatchNoMin}
) -&gt; NamedTuple{(:min, :max), &lt;:Tuple{Float64, Any}}
</code></pre><p>Min and max active power limits of generators for thermal dispatch no minimum formulations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/thermal_generation.jl#L293">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_min_max_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{ThermalMultiStartUnitCommitment}}"><a class="docstring-binding" href="#PowerSimulations.get_min_max_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{ThermalMultiStartUnitCommitment}}"><code>PowerSimulations.get_min_max_limits</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_min_max_limits(
    device,
    _::Type{ActivePowerVariableLimitsConstraint},
    _::Type{ThermalMultiStartUnitCommitment}
) -&gt; NamedTuple{(:min, :max), &lt;:Tuple{Float64, Any}}
</code></pre><p>Min and max active power limits for multi-start unit commitment formulations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/thermal_generation.jl#L325">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_min_max_limits-Tuple{Any, Type{ReactivePowerVariableLimitsConstraint}, Type{&lt;:PowerSimulations.AbstractThermalDispatchFormulation}}"><a class="docstring-binding" href="#PowerSimulations.get_min_max_limits-Tuple{Any, Type{ReactivePowerVariableLimitsConstraint}, Type{&lt;:PowerSimulations.AbstractThermalDispatchFormulation}}"><code>PowerSimulations.get_min_max_limits</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_min_max_limits(
    device,
    _::Type{ReactivePowerVariableLimitsConstraint},
    _::Type{&lt;:PowerSimulations.AbstractThermalDispatchFormulation}
) -&gt; Any
</code></pre><p>Reactive power limits of generators for all dispatch formulations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/thermal_generation.jl#L738">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_min_max_limits-Tuple{Any, Type{ReactivePowerVariableLimitsConstraint}, Type{&lt;:PowerSimulations.AbstractThermalUnitCommitment}}"><a class="docstring-binding" href="#PowerSimulations.get_min_max_limits-Tuple{Any, Type{ReactivePowerVariableLimitsConstraint}, Type{&lt;:PowerSimulations.AbstractThermalUnitCommitment}}"><code>PowerSimulations.get_min_max_limits</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_min_max_limits(
    device,
    _::Type{ReactivePowerVariableLimitsConstraint},
    _::Type{&lt;:PowerSimulations.AbstractThermalUnitCommitment}
) -&gt; Any
</code></pre><p>Reactive power limits of generators when there CommitmentVariables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/thermal_generation.jl#L749">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_min_max_limits-Tuple{MonitoredLine, Type{&lt;:InfrastructureSystems.Optimization.ConstraintType}, Type{&lt;:PowerSimulations.AbstractBranchFormulation}}"><a class="docstring-binding" href="#PowerSimulations.get_min_max_limits-Tuple{MonitoredLine, Type{&lt;:InfrastructureSystems.Optimization.ConstraintType}, Type{&lt;:PowerSimulations.AbstractBranchFormulation}}"><code>PowerSimulations.get_min_max_limits</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_min_max_limits(
    device::MonitoredLine,
    _::Type{&lt;:InfrastructureSystems.Optimization.ConstraintType},
    _::Type{&lt;:PowerSimulations.AbstractBranchFormulation}
) -&gt; @NamedTuple{min::Float64, max::Float64}
</code></pre><p>Min and max limits for monitored line</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/AC_branches.jl#L883">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_min_max_limits-Tuple{MonitoredLine, Type{FlowLimitFromToConstraint}, Type{&lt;:PowerSimulations.AbstractBranchFormulation}}"><a class="docstring-binding" href="#PowerSimulations.get_min_max_limits-Tuple{MonitoredLine, Type{FlowLimitFromToConstraint}, Type{&lt;:PowerSimulations.AbstractBranchFormulation}}"><code>PowerSimulations.get_min_max_limits</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_min_max_limits(
    device::MonitoredLine,
    _::Type{FlowLimitFromToConstraint},
    _::Type{&lt;:PowerSimulations.AbstractBranchFormulation}
) -&gt; @NamedTuple{min::Float64, max::Float64}
</code></pre><p>Min and max limits for flow limit from-to constraint</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/AC_branches.jl#L948">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_min_max_limits-Tuple{MonitoredLine, Type{FlowLimitToFromConstraint}, Type{&lt;:PowerSimulations.AbstractBranchFormulation}}"><a class="docstring-binding" href="#PowerSimulations.get_min_max_limits-Tuple{MonitoredLine, Type{FlowLimitToFromConstraint}, Type{&lt;:PowerSimulations.AbstractBranchFormulation}}"><code>PowerSimulations.get_min_max_limits</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_min_max_limits(
    device::MonitoredLine,
    _::Type{FlowLimitToFromConstraint},
    _::Type{&lt;:PowerSimulations.AbstractBranchFormulation}
) -&gt; @NamedTuple{min::Float64, max::Float64}
</code></pre><p>Min and max limits for flow limit to-from constraint</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/AC_branches.jl#L967">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_min_max_limits-Tuple{PhaseShiftingTransformer, Type{PhaseAngleControlLimit}, Type{PhaseAngleControl}}"><a class="docstring-binding" href="#PowerSimulations.get_min_max_limits-Tuple{PhaseShiftingTransformer, Type{PhaseAngleControlLimit}, Type{PhaseAngleControl}}"><code>PowerSimulations.get_min_max_limits</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_min_max_limits(
    _::PhaseShiftingTransformer,
    _::Type{PhaseAngleControlLimit},
    _::Type{PhaseAngleControl}
) -&gt; @NamedTuple{min::Float64, max::Float64}
</code></pre><p>Min and max limits for Abstract Branch Formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/AC_branches.jl#L349">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_min_max_limits-Tuple{PowerNetworkMatrices.BranchesParallel, Type{&lt;:InfrastructureSystems.Optimization.ConstraintType}, Type{&lt;:PowerSimulations.AbstractBranchFormulation}}"><a class="docstring-binding" href="#PowerSimulations.get_min_max_limits-Tuple{PowerNetworkMatrices.BranchesParallel, Type{&lt;:InfrastructureSystems.Optimization.ConstraintType}, Type{&lt;:PowerSimulations.AbstractBranchFormulation}}"><code>PowerSimulations.get_min_max_limits</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_min_max_limits(
    double_circuit::PowerNetworkMatrices.BranchesParallel,
    constraint_type::Type{&lt;:InfrastructureSystems.Optimization.ConstraintType},
    branch_formulation::Type{&lt;:PowerSimulations.AbstractBranchFormulation}
) -&gt; NamedTuple{(:min, :max), &lt;:Tuple{Any, Any}}
</code></pre><p>Min and max limits for Abstract Branch Formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/AC_branches.jl#L273">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_min_max_limits-Tuple{PowerNetworkMatrices.BranchesSeries, Type{&lt;:InfrastructureSystems.Optimization.ConstraintType}, Type{&lt;:PowerSimulations.AbstractBranchFormulation}}"><a class="docstring-binding" href="#PowerSimulations.get_min_max_limits-Tuple{PowerNetworkMatrices.BranchesSeries, Type{&lt;:InfrastructureSystems.Optimization.ConstraintType}, Type{&lt;:PowerSimulations.AbstractBranchFormulation}}"><code>PowerSimulations.get_min_max_limits</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_min_max_limits(
    series_chain::PowerNetworkMatrices.BranchesSeries,
    constraint_type::Type{&lt;:InfrastructureSystems.Optimization.ConstraintType},
    branch_formulation::Type{&lt;:PowerSimulations.AbstractBranchFormulation}
) -&gt; NamedTuple{(:min, :max), &lt;:Tuple{Any, Any}}
</code></pre><p>Min and max limits for Abstract Branch Formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/AC_branches.jl#L320">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_min_max_limits-Tuple{PowerNetworkMatrices.ThreeWindingTransformerWinding, Type{&lt;:InfrastructureSystems.Optimization.ConstraintType}, Type{&lt;:PowerSimulations.AbstractBranchFormulation}}"><a class="docstring-binding" href="#PowerSimulations.get_min_max_limits-Tuple{PowerNetworkMatrices.ThreeWindingTransformerWinding, Type{&lt;:InfrastructureSystems.Optimization.ConstraintType}, Type{&lt;:PowerSimulations.AbstractBranchFormulation}}"><code>PowerSimulations.get_min_max_limits</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_min_max_limits(
    transformer_entry::PowerNetworkMatrices.ThreeWindingTransformerWinding,
    constraint_type::Type{&lt;:InfrastructureSystems.Optimization.ConstraintType},
    branch_formulation::Type{&lt;:PowerSimulations.AbstractBranchFormulation}
) -&gt; @NamedTuple{min::Float64, max::Float64}
</code></pre><p>Min and max limits for Abstract Branch Formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/AC_branches.jl#L291">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_piecewise_curve_per_system_unit-Tuple{PiecewiseStepData, UnitSystem, Float64, Float64}"><a class="docstring-binding" href="#PowerSimulations.get_piecewise_curve_per_system_unit-Tuple{PiecewiseStepData, UnitSystem, Float64, Float64}"><code>PowerSimulations.get_piecewise_curve_per_system_unit</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_piecewise_curve_per_system_unit(
    cost_component::PiecewiseStepData,
    unit_system::UnitSystem,
    system_base_power::Float64,
    device_base_power::Float64
) -&gt; PiecewiseStepData
</code></pre><p>Obtain the normalized PiecewiseStepData in system base per unit depending on the specified power units.</p><p>Note that the costs (y-axis) are in /MWh, /(sys pu h) or /(device pu h), so they also require transformation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/utils/powersystems_utils.jl#L287">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_piecewise_pointcurve_per_system_unit-Tuple{PiecewiseLinearData, UnitSystem, Float64, Float64}"><a class="docstring-binding" href="#PowerSimulations.get_piecewise_pointcurve_per_system_unit-Tuple{PiecewiseLinearData, UnitSystem, Float64, Float64}"><code>PowerSimulations.get_piecewise_pointcurve_per_system_unit</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_piecewise_pointcurve_per_system_unit(
    cost_component::PiecewiseLinearData,
    unit_system::UnitSystem,
    system_base_power::Float64,
    device_base_power::Float64
) -&gt; PiecewiseLinearData
</code></pre><p>Obtain the normalized PiecewiseLinear cost data in system base per unit depending on the specified power units.</p><p>Note that the costs (y-axis) are always in /h so they do not require transformation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/utils/powersystems_utils.jl#L228">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_proportional_cost_per_system_unit-Tuple{Float64, UnitSystem, Float64, Float64}"><a class="docstring-binding" href="#PowerSimulations.get_proportional_cost_per_system_unit-Tuple{Float64, UnitSystem, Float64, Float64}"><code>PowerSimulations.get_proportional_cost_per_system_unit</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_proportional_cost_per_system_unit(
    cost_term::Float64,
    unit_system::UnitSystem,
    system_base_power::Float64,
    device_base_power::Float64
) -&gt; Float64
</code></pre><p>Obtain proportional (marginal or slope) cost data in system base per unit depending on the specified power units</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/utils/powersystems_utils.jl#L138">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_quadratic_cost_per_system_unit-Tuple{Float64, UnitSystem, Float64, Float64}"><a class="docstring-binding" href="#PowerSimulations.get_quadratic_cost_per_system_unit-Tuple{Float64, UnitSystem, Float64, Float64}"><code>PowerSimulations.get_quadratic_cost_per_system_unit</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_quadratic_cost_per_system_unit(
    cost_term::Float64,
    unit_system::UnitSystem,
    system_base_power::Float64,
    device_base_power::Float64
) -&gt; Float64
</code></pre><p>Obtain quadratic cost data in system base per unit depending on the specified power units</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/utils/powersystems_utils.jl#L183">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_startup_shutdown_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{&lt;:PowerSimulations.AbstractCompactUnitCommitment}}"><a class="docstring-binding" href="#PowerSimulations.get_startup_shutdown_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{&lt;:PowerSimulations.AbstractCompactUnitCommitment}}"><code>PowerSimulations.get_startup_shutdown_limits</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_startup_shutdown_limits(
    device,
    _::Type{ActivePowerVariableLimitsConstraint},
    _::Type{&lt;:PowerSimulations.AbstractCompactUnitCommitment}
) -&gt; @NamedTuple{startup::Float64, shutdown::Float64}
</code></pre><p>Startup shutdown limits for Compact Unit Commitment</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/thermal_generation.jl#L441">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_startup_shutdown_limits-Tuple{ThermalMultiStart, Type{ActivePowerVariableLimitsConstraint}, Type{ThermalMultiStartUnitCommitment}}"><a class="docstring-binding" href="#PowerSimulations.get_startup_shutdown_limits-Tuple{ThermalMultiStart, Type{ActivePowerVariableLimitsConstraint}, Type{ThermalMultiStartUnitCommitment}}"><code>PowerSimulations.get_startup_shutdown_limits</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_startup_shutdown_limits(
    device::ThermalMultiStart,
    _::Type{ActivePowerVariableLimitsConstraint},
    _::Type{ThermalMultiStartUnitCommitment}
) -&gt; @NamedTuple{startup::Float64, shutdown::Float64}
</code></pre><p>Startup and shutdown active power limits for Compact Unit Commitment</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/thermal_generation.jl#L405">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_update_timestamp-Tuple{PowerSimulations.AbstractDataset}"><a class="docstring-binding" href="#PowerSimulations.get_update_timestamp-Tuple{PowerSimulations.AbstractDataset}"><code>PowerSimulations.get_update_timestamp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_update_timestamp(
    s::PowerSimulations.AbstractDataset
) -&gt; Any
</code></pre><p>Return the timestamp from the data used in the last update</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/dataset.jl#L6">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_update_timestamp-Tuple{PowerSimulations.DatasetContainer, InfrastructureSystems.Optimization.OptimizationContainerKey}"><a class="docstring-binding" href="#PowerSimulations.get_update_timestamp-Tuple{PowerSimulations.DatasetContainer, InfrastructureSystems.Optimization.OptimizationContainerKey}"><code>PowerSimulations.get_update_timestamp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_update_timestamp(
    container::PowerSimulations.DatasetContainer,
    key::InfrastructureSystems.Optimization.OptimizationContainerKey
) -&gt; Any
</code></pre><p>Return the timestamp from the data used in the last update</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/dataset_container.jl#L195">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_valid_step_length-Tuple{SimulationPartitions, Int64}"><a class="docstring-binding" href="#PowerSimulations.get_valid_step_length-Tuple{SimulationPartitions, Int64}"><code>PowerSimulations.get_valid_step_length</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_valid_step_length(
    partitions::SimulationPartitions,
    index::Int64
) -&gt; Int64
</code></pre><p>Return the length of valid data at the given index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/simulation_partitions.jl#L61">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.get_valid_step_offset-Tuple{SimulationPartitions, Int64}"><a class="docstring-binding" href="#PowerSimulations.get_valid_step_offset-Tuple{SimulationPartitions, Int64}"><code>PowerSimulations.get_valid_step_offset</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_valid_step_offset(
    partitions::SimulationPartitions,
    index::Int64
) -&gt; Int64
</code></pre><p>Return the step offset for valid data at the given index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/simulation_partitions.jl#L53">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.has_dirty-Tuple{PowerSimulations.OptimizationOutputCaches}"><a class="docstring-binding" href="#PowerSimulations.has_dirty-Tuple{PowerSimulations.OptimizationOutputCaches}"><code>PowerSimulations.has_dirty</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_dirty(
    cache::PowerSimulations.OptimizationOutputCaches
) -&gt; Bool
</code></pre><p>Return true if the cache has data that has not been flushed to storage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/optimization_output_caches.jl#L59">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.is_cached-Tuple{PowerSimulations.OptimizationOutputCaches, Any, Any, Any}"><a class="docstring-binding" href="#PowerSimulations.is_cached-Tuple{PowerSimulations.OptimizationOutputCaches, Any, Any, Any}"><code>PowerSimulations.is_cached</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_cached(
    cache::PowerSimulations.OptimizationOutputCaches,
    model_name,
    key,
    index
) -&gt; Bool
</code></pre><p>Return true if the data for <code>timestamp</code> is stored in cache.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/optimization_output_caches.jl#L84">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.is_from_power_flow-Tuple{Type{&lt;:InfrastructureSystems.Optimization.AuxVariableType}}"><a class="docstring-binding" href="#PowerSimulations.is_from_power_flow-Tuple{Type{&lt;:InfrastructureSystems.Optimization.AuxVariableType}}"><code>PowerSimulations.is_from_power_flow</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_from_power_flow(
    _::Type{&lt;:InfrastructureSystems.Optimization.AuxVariableType}
) -&gt; Bool
</code></pre><p>Whether the auxiliary variable is calculated using a <code>PowerFlowEvaluationModel</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/auxiliary_variables.jl#L82">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.join_simulation-Tuple{AbstractString}"><a class="docstring-binding" href="#PowerSimulations.join_simulation-Tuple{AbstractString}"><code>PowerSimulations.join_simulation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">join_simulation(path::AbstractString)
</code></pre><p>Combine all partition simulation files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/simulation_partition_results.jl#L31">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.latest_solved_power_flow_evaluation_data-Tuple{PowerSimulations.OptimizationContainer}"><a class="docstring-binding" href="#PowerSimulations.latest_solved_power_flow_evaluation_data-Tuple{PowerSimulations.OptimizationContainer}"><code>PowerSimulations.latest_solved_power_flow_evaluation_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">latest_solved_power_flow_evaluation_data(
    container::PowerSimulations.OptimizationContainer
) -&gt; PowerSimulations.PowerFlowEvaluationData
</code></pre><p>Fetch the most recently solved <code>PowerFlowEvaluationData</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/network_models/power_flow_evaluation.jl#L563">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.list_decision_model_keys-Tuple{PowerSimulations.HdfSimulationStore, Symbol, Symbol}"><a class="docstring-binding" href="#PowerSimulations.list_decision_model_keys-Tuple{PowerSimulations.HdfSimulationStore, Symbol, Symbol}"><code>PowerSimulations.list_decision_model_keys</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">list_decision_model_keys(
    store::PowerSimulations.HdfSimulationStore,
    model::Symbol,
    container_type::Symbol
) -&gt; Vector
</code></pre><p>Return the fields stored for the <code>problem</code> and <code>container_type</code> (duals/parameters/variables).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/hdf_simulation_store.jl#L169">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.list_decision_models-Tuple{PowerSimulations.HdfSimulationStore}"><a class="docstring-binding" href="#PowerSimulations.list_decision_models-Tuple{PowerSimulations.HdfSimulationStore}"><code>PowerSimulations.list_decision_models</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">list_decision_models(
    store::PowerSimulations.HdfSimulationStore
) -&gt; Base.KeySet{Symbol, OrderedDict{Symbol, PowerSimulations.DatasetContainer{PowerSimulations.HDF5Dataset}}}
</code></pre><p>Return the problem names in order of execution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/hdf_simulation_store.jl#L164">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.log_cache_hit_percentages-Tuple{PowerSimulations.OptimizationOutputCaches}"><a class="docstring-binding" href="#PowerSimulations.log_cache_hit_percentages-Tuple{PowerSimulations.OptimizationOutputCaches}"><code>PowerSimulations.log_cache_hit_percentages</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">log_cache_hit_percentages(
    cache::PowerSimulations.OptimizationOutputCaches
)
</code></pre><p>Log the cache hit percentages for all caches.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/optimization_output_caches.jl#L97">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.lookup_additional_axes-Tuple{Any}"><a class="docstring-binding" href="#PowerSimulations.lookup_additional_axes-Tuple{Any}"><code>PowerSimulations.lookup_additional_axes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lookup_additional_axes(parameter_array) -&gt; Any
</code></pre><p>Given a parameter array, get any additional axes, i.e., those that aren&#39;t the first (component) or the last (time)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/parameters/add_parameters.jl#L457">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.onvar_cost-Tuple{PowerSimulations.OptimizationContainer, ThermalGenerationCost, OnVariable, ThermalGen, PowerSimulations.AbstractThermalFormulation, Int64}"><a class="docstring-binding" href="#PowerSimulations.onvar_cost-Tuple{PowerSimulations.OptimizationContainer, ThermalGenerationCost, OnVariable, ThermalGen, PowerSimulations.AbstractThermalFormulation, Int64}"><code>PowerSimulations.onvar_cost</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">onvar_cost(
    container::PowerSimulations.OptimizationContainer,
    cost::ThermalGenerationCost,
    _::OnVariable,
    d::ThermalGen,
    _::PowerSimulations.AbstractThermalFormulation,
    t::Int64
) -&gt; Any
</code></pre><p>Theoretical Cost at power output zero. Mathematically is the intercept with the y-axis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/thermal_generation.jl#L151">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.open_store"><a class="docstring-binding" href="#PowerSimulations.open_store"><code>PowerSimulations.open_store</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">open_store(
    ::Type{PowerSimulations.HdfSimulationStore},
    directory::AbstractString;
    ...
) -&gt; PowerSimulations.HdfSimulationStore
open_store(
    ::Type{PowerSimulations.HdfSimulationStore},
    directory::AbstractString,
    mode;
    filename
) -&gt; PowerSimulations.HdfSimulationStore
</code></pre><p>Construct and open an HdfSimulationStore.</p><p>When reading or writing results in a program you should use the method that accepts a function in order to guarantee that the file handle gets closed.</p><p><strong>Arguments</strong></p><ul><li><code>directory::AbstractString</code>: Directory containing the store file</li><li><code>mode::AbstractString</code>: Mode to use to open the store file</li><li><code>filename::AbstractString</code>: Base name of the store file</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Assumes a simulation has been executed in the &#39;./rts&#39; directory with these parameters.
path = &quot;./rts&quot;
problem = :ED
var_name = :P__ThermalStandard
timestamp = DateTime(&quot;2020-01-01T05:00:00&quot;)
store = open_store(HdfSimulationStore, path)
df = PowerSimulations.read_result(DataFrame, store, model, :variables, var_name, timestamp)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/hdf_simulation_store.jl#L65">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.process_market_bid_parameters!"><a class="docstring-binding" href="#PowerSimulations.process_market_bid_parameters!"><code>PowerSimulations.process_market_bid_parameters!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">process_market_bid_parameters!(
    container::PowerSimulations.OptimizationContainer,
    devices_in,
    model::DeviceModel
)
process_market_bid_parameters!(
    container::PowerSimulations.OptimizationContainer,
    devices_in,
    model::DeviceModel,
    incremental::Bool
)
process_market_bid_parameters!(
    container::PowerSimulations.OptimizationContainer,
    devices_in,
    model::DeviceModel,
    incremental::Bool,
    decremental::Bool
)
</code></pre><p>Validate MarketBidCosts and add the appropriate parameters</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/objective_function/market_bid.jl#L412">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.read_dataframe-Tuple{AbstractString}"><a class="docstring-binding" href="#PowerSimulations.read_dataframe-Tuple{AbstractString}"><code>PowerSimulations.read_dataframe</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">read_dataframe(
    filename::AbstractString
) -&gt; DataFrames.DataFrame
</code></pre><p>Return a DataFrame from a CSV file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/utils/file_utils.jl#L10">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.read_json-Tuple{AbstractString}"><a class="docstring-binding" href="#PowerSimulations.read_json-Tuple{AbstractString}"><code>PowerSimulations.read_json</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">read_json(
    filename::AbstractString
) -&gt; Union{Nothing, Bool, Float64, Int64, String, JSON3.Array, JSON3.Object}
</code></pre><p>Return a decoded JSON file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/utils/file_utils.jl#L1">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.read_result-Tuple{PowerSimulations.OptimizationOutputCaches, Any, Any, Any}"><a class="docstring-binding" href="#PowerSimulations.read_result-Tuple{PowerSimulations.OptimizationOutputCaches, Any, Any, Any}"><code>PowerSimulations.read_result</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">read_result(
    cache::PowerSimulations.OptimizationOutputCaches,
    model_name,
    key,
    timestamp
) -&gt; Array
</code></pre><p>Read the result from cache. Callers must first call <a href="#PowerSimulations.is_cached-Tuple{PowerSimulations.OptimizationOutputCaches, Any, Any, Any}"><code>is_cached</code></a> to check if the timestamp is present.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/optimization_output_caches.jl#L109">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.read_result-Tuple{Type{DataFrames.DataFrame}, PowerSimulations.HdfSimulationStore, Symbol, InfrastructureSystems.Optimization.OptimizationContainerKey, Union{Int64, Dates.DateTime}}"><a class="docstring-binding" href="#PowerSimulations.read_result-Tuple{Type{DataFrames.DataFrame}, PowerSimulations.HdfSimulationStore, Symbol, InfrastructureSystems.Optimization.OptimizationContainerKey, Union{Int64, Dates.DateTime}}"><code>PowerSimulations.read_result</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">read_result(
    _::Type{DataFrames.DataFrame},
    store::PowerSimulations.HdfSimulationStore,
    model_name::Symbol,
    key::InfrastructureSystems.Optimization.OptimizationContainerKey,
    index::Union{Int64, Dates.DateTime}
) -&gt; DataFrames.DataFrame
</code></pre><p>Return DataFrame, DenseAxisArray, or Array for a model result at a timestamp.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/hdf_simulation_store.jl#L351">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.serialize_formulation_combinations"><a class="docstring-binding" href="#PowerSimulations.serialize_formulation_combinations"><code>PowerSimulations.serialize_formulation_combinations</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">serialize_formulation_combinations(

) -&gt; Dict{String, Vector{Any}}
serialize_formulation_combinations(
    sys
) -&gt; Dict{String, Vector{Any}}
</code></pre><p>Generate valid combinations of device<em>type/formulation and service</em>type/formulation. Return vectors of dictionaries with Julia types encoded as strings.</p><p><strong>Arguments</strong></p><ul><li><code>sys::Union{Nothing, System}</code>: If set, only include component types present in the system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/utils/generate_valid_formulations.jl#L29">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.serialize_jump_optimization_model-Tuple{JuMP.Model, String}"><a class="docstring-binding" href="#PowerSimulations.serialize_jump_optimization_model-Tuple{JuMP.Model, String}"><code>PowerSimulations.serialize_jump_optimization_model</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">serialize_jump_optimization_model(
    jump_model::JuMP.Model,
    save_path::String
)
</code></pre><p>Exports the JuMP object in MathOptFormat</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/utils/jump_utils.jl#L608">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.serialize_simulation-Tuple{Simulation}"><a class="docstring-binding" href="#PowerSimulations.serialize_simulation-Tuple{Simulation}"><code>PowerSimulations.serialize_simulation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">serialize_simulation(sim::Simulation; path, force) -&gt; String
</code></pre><pre><code class="language-julia hljs">serialize_simulation(sim::Simulation, path = &quot;.&quot;)</code></pre><p>Serialize the simulation to a directory in path.</p><p>Return the serialized simulation directory name that is created.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Simulation</code>: simulation to serialize</li><li><code>path = &quot;.&quot;</code>: path in which to create the serialzed directory</li><li><code>force = false</code>: If true, delete the directory if it already exists. Otherwise, it will throw an exception.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/simulation.jl#L1179">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.set_expression!-Union{Tuple{T}, Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, Type{S}, JuMP.AbstractJuMPScalar, T, Int64}} where {S&lt;:CostExpressions, T&lt;:Component}"><a class="docstring-binding" href="#PowerSimulations.set_expression!-Union{Tuple{T}, Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, Type{S}, JuMP.AbstractJuMPScalar, T, Int64}} where {S&lt;:CostExpressions, T&lt;:Component}"><code>PowerSimulations.set_expression!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_expression!(
    container::PowerSimulations.OptimizationContainer,
    _::Type{S&lt;:CostExpressions},
    cost_expression::JuMP.AbstractJuMPScalar,
    component::Component,
    time_period::Int64
)
</code></pre><p>Replaces an expression value in the expression container if the key exists</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/devices_models/devices/common/set_expression.jl#L1">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.set_ic_quantity!-Union{Tuple{T}, Tuple{InitialCondition{T, Float64}, Float64}} where T&lt;:InfrastructureSystems.Optimization.InitialConditionType"><a class="docstring-binding" href="#PowerSimulations.set_ic_quantity!-Union{Tuple{T}, Tuple{InitialCondition{T, Float64}, Float64}} where T&lt;:InfrastructureSystems.Optimization.InitialConditionType"><code>PowerSimulations.set_ic_quantity!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_ic_quantity!(
    ic::InitialCondition{T&lt;:InfrastructureSystems.Optimization.InitialConditionType, Float64},
    var_value::Float64
)
</code></pre><p>Default implementation of set<em>initial</em>condition_value</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/initial_conditions/calculate_initial_condition.jl#L13">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.set_ic_quantity!-Union{Tuple{T}, Tuple{InitialCondition{T, JuMP.VariableRef}, Float64}} where T&lt;:InfrastructureSystems.Optimization.InitialConditionType"><a class="docstring-binding" href="#PowerSimulations.set_ic_quantity!-Union{Tuple{T}, Tuple{InitialCondition{T, JuMP.VariableRef}, Float64}} where T&lt;:InfrastructureSystems.Optimization.InitialConditionType"><code>PowerSimulations.set_ic_quantity!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_ic_quantity!(
    ic::InitialCondition{T&lt;:InfrastructureSystems.Optimization.InitialConditionType, JuMP.VariableRef},
    var_value::Float64
)
</code></pre><p>Default implementation of set<em>initial</em>condition_value</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/initial_conditions/calculate_initial_condition.jl#L1">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.solve_impl!-Tuple{PowerSimulations.OptimizationContainer, System}"><a class="docstring-binding" href="#PowerSimulations.solve_impl!-Tuple{PowerSimulations.OptimizationContainer, System}"><code>PowerSimulations.solve_impl!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solve_impl!(
    container::PowerSimulations.OptimizationContainer,
    system::System
) -&gt; Any
</code></pre><p>Default solve method for OptimizationContainer</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/core/optimization_container.jl#L885">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.sparse_container_spec-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any}}} where T&lt;:JuMP.AbstractJuMPScalar"><a class="docstring-binding" href="#PowerSimulations.sparse_container_spec-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any}}} where T&lt;:JuMP.AbstractJuMPScalar"><code>PowerSimulations.sparse_container_spec</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sparse_container_spec(
    _::Type{T&lt;:JuMP.AbstractJuMPScalar},
    axs...
) -&gt; JuMP.Containers.SparseAxisArray
</code></pre><p>Returns the correct container specification for the selected type of JuMP Model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/utils/jump_utils.jl#L446">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.to_dataframe-Union{Tuple{T}, Tuple{JuMP.Containers.DenseAxisArray{T, 2, Ax, L} where {Ax, L&lt;:Tuple{JuMP.Containers._AxisLookup, JuMP.Containers._AxisLookup}}, InfrastructureSystems.Optimization.OptimizationContainerKey}} where T&lt;:Union{Number, Tuple{Vararg{Number}}, Vector{&lt;:Tuple{Number, Number}}}"><a class="docstring-binding" href="#PowerSimulations.to_dataframe-Union{Tuple{T}, Tuple{JuMP.Containers.DenseAxisArray{T, 2, Ax, L} where {Ax, L&lt;:Tuple{JuMP.Containers._AxisLookup, JuMP.Containers._AxisLookup}}, InfrastructureSystems.Optimization.OptimizationContainerKey}} where T&lt;:Union{Number, Tuple{Vararg{Number}}, Vector{&lt;:Tuple{Number, Number}}}"><code>PowerSimulations.to_dataframe</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">to_dataframe(
    array::JuMP.Containers.DenseAxisArray{T&lt;:Union{Number, Tuple{Vararg{Number}}, Vector{&lt;:Tuple{Number, Number}}}, 2, Ax, L} where {Ax, L&lt;:Tuple{JuMP.Containers._AxisLookup, JuMP.Containers._AxisLookup}},
    key::InfrastructureSystems.Optimization.OptimizationContainerKey
) -&gt; DataFrames.DataFrame
</code></pre><p>Create a DataFrame from a JuMP DenseAxisArray or SparseAxisArray.</p><p><strong>Arguments</strong></p><ul><li><code>array</code>: JuMP DenseAxisArray or SparseAxisArray to convert</li><li><code>key::OptimizationContainerKey</code>:</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/utils/jump_utils.jl#L195">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.to_results_dataframe-Tuple{JuMP.Containers.DenseAxisArray, Any}"><a class="docstring-binding" href="#PowerSimulations.to_results_dataframe-Tuple{JuMP.Containers.DenseAxisArray, Any}"><code>PowerSimulations.to_results_dataframe</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">to_results_dataframe(
    array::JuMP.Containers.DenseAxisArray,
    timestamps
) -&gt; Any
</code></pre><p>Convert a DenseAxisArray containing components to a results DataFrame consumable by users.</p><p><strong>Arguments</strong></p><ul><li><code>array: DenseAxisArray</code>: JuMP DenseAxisArray to convert</li><li><code>timestamps</code>: Iterable of timestamps for each component or nothing if time is not known. The resulting DataFrame will have the column &quot;DateTime&quot; if timestamps is not nothing. Otherwise, it will have the column &quot;time_index&quot;, representing the index of the time dimension.</li><li><code>::Val{TableFormat}</code>: Format of the table to create. If it is TableFormat.LONG, the DataFrame will have the column &quot;name&quot;, and, if the data has three dimensions, &quot;name2.&quot; If it is TableFormat.WIDE, the DataFrame will have columns for each component. Wide format does not support arrays with more than two dimensions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/utils/jump_utils.jl#L231">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.update_container_parameter_values!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.OperationModel, InfrastructureSystems.Optimization.ParameterKey{T, U}, PowerSimulations.DatasetContainer{PowerSimulations.InMemoryDataset}}} where {T&lt;:InfrastructureSystems.Optimization.ParameterType, U&lt;:Component}"><a class="docstring-binding" href="#PowerSimulations.update_container_parameter_values!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.OperationModel, InfrastructureSystems.Optimization.ParameterKey{T, U}, PowerSimulations.DatasetContainer{PowerSimulations.InMemoryDataset}}} where {T&lt;:InfrastructureSystems.Optimization.ParameterType, U&lt;:Component}"><code>PowerSimulations.update_container_parameter_values!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update_container_parameter_values!(
    optimization_container::PowerSimulations.OptimizationContainer,
    model::PowerSimulations.OperationModel,
    key::InfrastructureSystems.Optimization.ParameterKey{T&lt;:InfrastructureSystems.Optimization.ParameterType, U&lt;:Component},
    input::PowerSimulations.DatasetContainer{PowerSimulations.InMemoryDataset}
)
</code></pre><p>Update parameter function an OperationModel</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/parameters/update_container_parameter_values.jl#L473">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.update_model!-Tuple{PowerSimulations.OperationModel, Simulation}"><a class="docstring-binding" href="#PowerSimulations.update_model!-Tuple{PowerSimulations.OperationModel, Simulation}"><code>PowerSimulations.update_model!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update_model!(
    model::PowerSimulations.OperationModel,
    sim::Simulation
)
</code></pre><p>Default problem update function for most problems with no customization</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/simulation.jl#L936">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.update_parameter_values!-Union{Tuple{U}, Tuple{T}, Tuple{EmulationModel, InfrastructureSystems.Optimization.ParameterKey{T, U}, PowerSimulations.DatasetContainer{PowerSimulations.InMemoryDataset}}} where {T&lt;:InfrastructureSystems.Optimization.ParameterType, U&lt;:Component}"><a class="docstring-binding" href="#PowerSimulations.update_parameter_values!-Union{Tuple{U}, Tuple{T}, Tuple{EmulationModel, InfrastructureSystems.Optimization.ParameterKey{T, U}, PowerSimulations.DatasetContainer{PowerSimulations.InMemoryDataset}}} where {T&lt;:InfrastructureSystems.Optimization.ParameterType, U&lt;:Component}"><code>PowerSimulations.update_parameter_values!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update_parameter_values!(
    model::EmulationModel,
    key::InfrastructureSystems.Optimization.ParameterKey{T&lt;:InfrastructureSystems.Optimization.ParameterType, U&lt;:Component},
    input::PowerSimulations.DatasetContainer{PowerSimulations.InMemoryDataset}
)
</code></pre><p>Update parameter function an OperationModel</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/operation/emulation_model.jl#L457">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.update_parameter_values!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OperationModel, InfrastructureSystems.Optimization.ParameterKey{T, U}, PowerSimulations.SimulationState}} where {T&lt;:InfrastructureSystems.Optimization.ParameterType, U&lt;:Component}"><a class="docstring-binding" href="#PowerSimulations.update_parameter_values!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OperationModel, InfrastructureSystems.Optimization.ParameterKey{T, U}, PowerSimulations.SimulationState}} where {T&lt;:InfrastructureSystems.Optimization.ParameterType, U&lt;:Component}"><code>PowerSimulations.update_parameter_values!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update_parameter_values!(
    model::PowerSimulations.OperationModel,
    key::InfrastructureSystems.Optimization.ParameterKey{T&lt;:InfrastructureSystems.Optimization.ParameterType, U&lt;:Component},
    simulation_state::PowerSimulations.SimulationState
)
</code></pre><p>Update parameter function an OperationModel</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/parameters/update_parameters.jl#L1">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.update_pf_data!-Tuple{PowerSimulations.PowerFlowEvaluationData{PowerFlows.PSSEExporter}, PowerSimulations.OptimizationContainer, Int64}"><a class="docstring-binding" href="#PowerSimulations.update_pf_data!-Tuple{PowerSimulations.PowerFlowEvaluationData{PowerFlows.PSSEExporter}, PowerSimulations.OptimizationContainer, Int64}"><code>PowerSimulations.update_pf_data!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update_pf_data!(
    pf_e_data::PowerSimulations.PowerFlowEvaluationData{PowerFlows.PSSEExporter},
    container::PowerSimulations.OptimizationContainer,
    time_step::Int64
)
</code></pre><p>Update a <code>PowerFlowEvaluationData</code> containing a <code>PowerFlowContainer</code> that does not <code>supports_multi_period</code> using a single <code>time_step</code> of the <code>OptimizationContainer</code>. To properly keep track of outer step number, time steps must be passed in sequentially, starting with 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/network_models/power_flow_evaluation.jl#L538">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.variable_reactive_net_injection-Tuple{PowerModels.AbstractActivePowerModel}"><a class="docstring-binding" href="#PowerSimulations.variable_reactive_net_injection-Tuple{PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.variable_reactive_net_injection</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">variable_reactive_net_injection(
    pm::PowerModels.AbstractActivePowerModel;
    kwargs...
)
</code></pre><p>active power only models ignore reactive power variables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/network_models/powermodels_interface.jl#L216">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.write_formulation_combinations"><a class="docstring-binding" href="#PowerSimulations.write_formulation_combinations"><code>PowerSimulations.write_formulation_combinations</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">write_formulation_combinations(filename::AbstractString)
write_formulation_combinations(
    filename::AbstractString,
    sys
)
</code></pre><p>Generate valid combinations of device<em>type/formulation and service</em>type/formulation and write the result to a JSON file.</p><p><strong>Arguments</strong></p><ul><li><code>sys::Union{Nothing, System}</code>: If set, only include component types present in the system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/utils/generate_valid_formulations.jl#L55">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.write_result!-Tuple{PowerSimulations.HdfSimulationStore, Symbol, InfrastructureSystems.Optimization.OptimizationContainerKey, Dates.DateTime, Dates.DateTime, JuMP.Containers.DenseAxisArray{Float64, 3, var&quot;#s250&quot;, L} where {var&quot;#s250&quot;&lt;:Tuple{Any, Any, Any}, L&lt;:Tuple{JuMP.Containers._AxisLookup, JuMP.Containers._AxisLookup, JuMP.Containers._AxisLookup}}}"><a class="docstring-binding" href="#PowerSimulations.write_result!-Tuple{PowerSimulations.HdfSimulationStore, Symbol, InfrastructureSystems.Optimization.OptimizationContainerKey, Dates.DateTime, Dates.DateTime, JuMP.Containers.DenseAxisArray{Float64, 3, var&quot;#s250&quot;, L} where {var&quot;#s250&quot;&lt;:Tuple{Any, Any, Any}, L&lt;:Tuple{JuMP.Containers._AxisLookup, JuMP.Containers._AxisLookup, JuMP.Containers._AxisLookup}}}"><code>PowerSimulations.write_result!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">write_result!(
    store::PowerSimulations.HdfSimulationStore,
    model_name::Symbol,
    key::InfrastructureSystems.Optimization.OptimizationContainerKey,
    index::Dates.DateTime,
    _::Dates.DateTime,
    data::JuMP.Containers.DenseAxisArray{Float64, 3, var&quot;#s250&quot;, L} where {var&quot;#s250&quot;&lt;:Tuple{Any, Any, Any}, L&lt;:Tuple{JuMP.Containers._AxisLookup, JuMP.Containers._AxisLookup, JuMP.Containers._AxisLookup}}
)
</code></pre><p>Write a decision model result for a timestamp to the store.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/hdf_simulation_store.jl#L596">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.write_result!-Tuple{PowerSimulations.HdfSimulationStore, Symbol, InfrastructureSystems.Optimization.OptimizationContainerKey, Int64, Dates.DateTime, JuMP.Containers.DenseAxisArray{Float64, 2, Ax, L} where {Ax, L&lt;:Tuple{JuMP.Containers._AxisLookup, JuMP.Containers._AxisLookup}}}"><a class="docstring-binding" href="#PowerSimulations.write_result!-Tuple{PowerSimulations.HdfSimulationStore, Symbol, InfrastructureSystems.Optimization.OptimizationContainerKey, Int64, Dates.DateTime, JuMP.Containers.DenseAxisArray{Float64, 2, Ax, L} where {Ax, L&lt;:Tuple{JuMP.Containers._AxisLookup, JuMP.Containers._AxisLookup}}}"><code>PowerSimulations.write_result!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">write_result!(
    store::PowerSimulations.HdfSimulationStore,
    _::Symbol,
    key::InfrastructureSystems.Optimization.OptimizationContainerKey,
    index::Int64,
    simulation_time::Dates.DateTime,
    array::JuMP.Containers.DenseAxisArray{Float64, 2, Ax, L} where {Ax, L&lt;:Tuple{JuMP.Containers._AxisLookup, JuMP.Containers._AxisLookup}}
)
</code></pre><p>Write an emulation model result for an execution index value and the timestamp of the update</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/hdf_simulation_store.jl#L636">source</a></section></details></article><article><details class="docstring"><summary id="PowerSimulations.write_result!-Union{Tuple{N}, Tuple{PowerSimulations.HdfSimulationStore, Symbol, InfrastructureSystems.Optimization.OptimizationContainerKey, Dates.DateTime, Dates.DateTime, JuMP.Containers.DenseAxisArray{Float64, N, var&quot;#s250&quot;, L} where {var&quot;#s250&quot;&lt;:NTuple{N, Any}, L&lt;:NTuple{N, JuMP.Containers._AxisLookup}}}} where N"><a class="docstring-binding" href="#PowerSimulations.write_result!-Union{Tuple{N}, Tuple{PowerSimulations.HdfSimulationStore, Symbol, InfrastructureSystems.Optimization.OptimizationContainerKey, Dates.DateTime, Dates.DateTime, JuMP.Containers.DenseAxisArray{Float64, N, var&quot;#s250&quot;, L} where {var&quot;#s250&quot;&lt;:NTuple{N, Any}, L&lt;:NTuple{N, JuMP.Containers._AxisLookup}}}} where N"><code>PowerSimulations.write_result!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">write_result!(
    store::PowerSimulations.HdfSimulationStore,
    model_name::Symbol,
    key::InfrastructureSystems.Optimization.OptimizationContainerKey,
    index::Dates.DateTime,
    _::Dates.DateTime,
    data::JuMP.Containers.DenseAxisArray{Float64, N, var&quot;#s250&quot;, L} where {var&quot;#s250&quot;&lt;:NTuple{N, Any}, L&lt;:NTuple{N, JuMP.Containers._AxisLookup}}
)
</code></pre><p>Write a decision model result for a timestamp to the store.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/hdf_simulation_store.jl#L562">source</a></section></details></article><article><details class="docstring"><summary id="PowerSystems.get_component-Tuple{InfrastructureSystems.Results, Base.UUID}"><a class="docstring-binding" href="#PowerSystems.get_component-Tuple{InfrastructureSystems.Results, Base.UUID}"><code>PowerSystems.get_component</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_component(
    res::InfrastructureSystems.Results,
    uuid::Base.UUID
) -&gt; Union{Nothing, InfrastructureSystems.InfrastructureSystemsComponent}
</code></pre><p>Calling <code>get_component</code> on a <code>Results</code> is the same as calling [<code>get_available_component</code>] on the system attached to the results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/get_components_interface.jl#L37">source</a></section></details></article><article><details class="docstring"><summary id="PowerSystems.get_components-Union{Tuple{T}, Tuple{Type{T}, InfrastructureSystems.Results}} where T&lt;:InfrastructureSystems.InfrastructureSystemsComponent"><a class="docstring-binding" href="#PowerSystems.get_components-Union{Tuple{T}, Tuple{Type{T}, InfrastructureSystems.Results}} where T&lt;:InfrastructureSystems.InfrastructureSystemsComponent"><code>PowerSystems.get_components</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_components(
    ::Type{T&lt;:InfrastructureSystems.InfrastructureSystemsComponent},
    res::InfrastructureSystems.Results;
    subsystem_name
) -&gt; InfrastructureSystems.FlattenIteratorWrapper{T, I} where {T&lt;:InfrastructureSystems.InfrastructureSystemsComponent, I&lt;:(Vector)}
</code></pre><p>Calling <code>get_components</code> on a <code>Results</code> is the same as calling [<code>get_available_components</code>] on the system attached to the results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/get_components_interface.jl#L4">source</a></section></details></article><article><details class="docstring"><summary id="PowerSystems.get_groups-Tuple{Union{Nothing, Function}, ComponentSelector, InfrastructureSystems.Results}"><a class="docstring-binding" href="#PowerSystems.get_groups-Tuple{Union{Nothing, Function}, ComponentSelector, InfrastructureSystems.Results}"><code>PowerSystems.get_groups</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_groups(
    scope_limiter::Union{Nothing, Function},
    selector::ComponentSelector,
    res::InfrastructureSystems.Results
) -&gt; Any
</code></pre><p>Calling <code>get_groups</code> on a <code>Results</code> is the same as calling [<code>get_available_groups</code>] on the system attached to the results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSimulations.jl/blob/21ae8544162a1cab7877e7a485f30d0b58d3f96f/src/simulation/get_components_interface.jl#L62">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../developer/">« Developer Guidelines</a><a class="docs-footer-nextpage" href="../../archive_old_docs_content/">Archived Old Docs Content »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 14 January 2026 02:16">Wednesday 14 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
