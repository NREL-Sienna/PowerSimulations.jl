<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · PowerSimulations.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="PowerSimulations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PowerSimulations.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome Page</a></li><li><a class="tocitem" href="../../quick_start_guide/">Quick Start Guide</a></li><li><span class="tocitem">Modeler Guide</span><ul><li><a class="tocitem" href="../../modeler_guide/definitions/">Definitions</a></li><li><a class="tocitem" href="../../modeler_guide/psi_structure/">PowerSimulations.jl Modeling Structure</a></li><li><a class="tocitem" href="../../modeler_guide/problem_templates/">Operations <code>ProblemTemplate</code>s</a></li><li><a class="tocitem" href="../../modeler_guide/running_a_simulation/">Simulation</a></li><li><a class="tocitem" href="../../modeler_guide/simulation_recorder/">Simulation Recorder</a></li><li><a class="tocitem" href="../../modeler_guide/logging/">Logging</a></li><li><a class="tocitem" href="../../modeler_guide/tips_and_tricks/">Tips and tricks</a></li><li><a class="tocitem" href="../../modeler_guide/debugging_infeasible_models/">Debugging infeasible models</a></li><li><a class="tocitem" href="../../modeler_guide/parallel_simulations/">Parallel Simulations</a></li><li><a class="tocitem" href="../../modeler_guide/modeling_faq/">Modeling FAQ</a></li></ul></li><li><span class="tocitem">Model Developer Guide</span><ul><li><a class="tocitem" href="../../model_developer_guide/adding_new_device_formulation/">Adding Formulations</a></li><li><a class="tocitem" href="../../model_developer_guide/adding_new_problem_model/">Adding Problems</a></li><li><a class="tocitem" href="../../model_developer_guide/troubleshooting/">Troubleshooting</a></li></ul></li><li><span class="tocitem">Code Base Developer Guide</span><ul><li><a class="tocitem" href="../../code_base_developer_guide/developer/">Developer Guide</a></li><li><a class="tocitem" href="../../code_base_developer_guide/troubleshooting/">Troubleshooting</a></li></ul></li><li><span class="tocitem">Formulation Library</span><ul><li><a class="tocitem" href="../../formulation_library/General/">General</a></li><li><a class="tocitem" href="../../formulation_library/ThermalGen/">Thermal Generation</a></li><li><a class="tocitem" href="../../formulation_library/HydroGen/">Hydro Generation</a></li><li><a class="tocitem" href="../../formulation_library/RenewableGen/">Renewable Generation</a></li><li><a class="tocitem" href="../../formulation_library/Storage/">Storage</a></li><li><a class="tocitem" href="../../formulation_library/Load/">Load</a></li><li><a class="tocitem" href="../../formulation_library/Network/">Network</a></li><li><a class="tocitem" href="../../formulation_library/Branch/">Branch</a></li></ul></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Device-Models"><span>Device Models</span></a></li><li class="toplevel"><a class="tocitem" href="#Decision-Models"><span>Decision Models</span></a></li><li class="toplevel"><a class="tocitem" href="#Emulation-Models"><span>Emulation Models</span></a></li><li class="toplevel"><a class="tocitem" href="#Simulation-Models"><span>Simulation Models</span></a></li><li class="toplevel"><a class="tocitem" href="#Variables"><span>Variables</span></a></li><li><a class="tocitem" href="#Common-Variables"><span>Common Variables</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/master/docs/src/api/PowerSimulations.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h3 id="Table-of-Contents"><a class="docs-heading-anchor" href="#Table-of-Contents">Table of Contents</a><a id="Table-of-Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Table-of-Contents" title="Permalink"></a></h3><ol><li><a href="#Device-Models">Device Models</a></li><li><a href="#Decision-Models">Decision Models</a></li><li><a href="#Emulation-Models">Emulation Models</a></li><li><a href="#Simulation-Models">Simulation Models</a></li><li><a href="#Variables">Variables</a></li></ol><h1 id="Device-Models"><a class="docs-heading-anchor" href="#Device-Models">Device Models</a><a id="Device-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Device-Models" title="Permalink"></a></h1><p>List of structures and methods for Device models</p><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceModel" href="#PowerSimulations.DeviceModel"><code>PowerSimulations.DeviceModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DeviceModel(
    ::Type{D},
    ::Type{B},
    feedforwards::Vector{&lt;:AbstractAffectFeedforward}
    use_slacks::Bool,
    duals::Vector{DataType},
    services::Vector{ServiceModel}
    attributes::Dict{String, Any}
)</code></pre><p>Establishes the model for a particular device specified by type. Uses the keyword argument feedforward to enable passing values between operation model at simulation time</p><p><strong>Arguments</strong></p><ul><li><code>::Type{D} where D&lt;:PSY.Device</code>: Power System Device Type</li><li><code>::Type{B} where B&lt;:AbstractDeviceFormulation</code>: Abstract Device Formulation</li><li><code>feedforward::Array{&lt;:AbstractAffectFeedforward} = Vector{AbstractAffectFeedforward}()</code> : use to pass parameters between models</li><li><code>use_slacks::Bool = false</code> : Add slacks to the device model</li><li><code>duals::Vector{DataType} = Vector{DataType}()</code>: use to pass constraint type to calculate the duals</li><li><code>time_series_names::Dict{Type{&lt;:TimeSeriesParameter}, String} = get_default_time_series_names(D, B)</code> : use to specify time series names associated to the device`</li><li><code>attributes::Dict{String, Any} = get_default_attributes(D, B)</code> : use to specify attributes to the device</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">thermal_gens = DeviceModel(ThermalStandard, ThermalBasicUnitCommitment)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3d577a9e7b08265b5df6976fee74bd55ce42796d/src/core/device_model.jl#L18">source</a></section></article><h3 id="Formulations"><a class="docs-heading-anchor" href="#Formulations">Formulations</a><a id="Formulations-1"></a><a class="docs-heading-anchor-permalink" href="#Formulations" title="Permalink"></a></h3><p>Refer to the <a href="https://nrel-siip.github.io/PowerSimulations.jl/latest/formulation_library/General/">Formulations Page</a> for each Abstract Device Formulation.</p><h3 id="Problem-Templates"><a class="docs-heading-anchor" href="#Problem-Templates">Problem Templates</a><a id="Problem-Templates-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-Templates" title="Permalink"></a></h3><p>Refer to the <a href="https://nrel-siip.github.io/PowerSimulations.jl/latest/modeler_guide/problem_templates/">Problem Templates Page</a> for available <code>ProblemTemplate</code>s.</p>&nbsp;
&nbsp;<h1 id="Decision-Models"><a class="docs-heading-anchor" href="#Decision-Models">Decision Models</a><a id="Decision-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Decision-Models" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DecisionModel" href="#PowerSimulations.DecisionModel"><code>PowerSimulations.DecisionModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DecisionModel{M}(
    template::ProblemTemplate,
    sys::PSY.System,
    jump_model::Union{Nothing, JuMP.Model}=nothing;
    kwargs...) where {M&lt;:DecisionProblem}</code></pre><p>This builds the optimization problem of type M with the specific system and template.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{M} where M&lt;:DecisionProblem</code>: The abstract operation model type</li><li><code>template::ProblemTemplate</code>: The model reference made up of transmission, devices, branches, and services.</li><li><code>sys::PSY.System</code>: the system created using Power Systems</li><li><code>jump_model::Union{Nothing, JuMP.Model}</code>: Enables passing a custom JuMP model. Use with care</li><li><code>name = nothing</code>: name of model, string or symbol; defaults to the type of template converted to a symbol.</li><li><code>optimizer::Union{Nothing,MOI.OptimizerWithAttributes} = nothing</code> : The optimizer does not get serialized. Callers should pass whatever they passed to the original problem.</li><li><code>horizon::Int = UNSET_HORIZON</code>: Manually specify the length of the forecast Horizon</li><li><code>warm_start::Bool = true</code>: True will use the current operation point in the system to initialize variable values. False initializes all variables to zero. Default is true</li><li><code>system_to_file::Bool = true:</code>: True to create a copy of the system used in the model.</li><li><code>initialize_model::Bool = true</code>: Option to decide to initialize the model or not.</li><li><code>initialization_file::String = &quot;&quot;</code>: TODO</li><li><code>deserialize_initial_conditions::Bool = false</code>: Option to deserialize conditions</li><li><code>export_pwl_vars::Bool = false</code>: True to export all the pwl intermediate variables. It can slow down significantly the solve time.</li><li><code>allow_fails::Bool = false</code>: True to allow the simulation to continue even if the optimization step fails. Use with care.</li><li><code>optimizer_solve_log_print::Bool = false</code>: Uses JuMP.unset_silent() to print the optimizer&#39;s log. By default all solvers are set to MOI.Silent()</li><li><code>detailed_optimizer_stats::Bool = false</code>: True to save detailed optimizer stats log.</li><li><code>calculate_conflict::Bool = false</code>: True to use solver to calculate conflicts for infeasible problems. Only specific solvers are able to calculate conflicts.</li><li><code>direct_mode_optimizer::Bool = false</code>: True to use the solver in direct mode. Creates a <a href="https://jump.dev/JuMP.jl/dev/reference/models/#JuMP.direct_model">JuMP.direct_model</a>.</li><li><code>store_variable_names::Bool = false</code>: True to store variable names in optimization model.</li><li><code>rebuild_model::Bool = false</code>: TODO</li><li><code>initial_time::Dates.DateTime = UNSET_INI_TIME</code>: Initial Time for the model solve.</li><li><code>time_series_cache_size::Int = IS.TIME_SERIES_CACHE_SIZE_BYTES</code>: Size in bytes to cache for each time array. Default is 1 MiB. Set to 0 to disable.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">template = ProblemTemplate(CopperPlatePowerModel, devices, branches, services)
OpModel = DecisionModel(MockOperationProblem, template, system)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3d577a9e7b08265b5df6976fee74bd55ce42796d/src/operation/decision_model.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DecisionModel-Tuple{Type{M} where M&lt;:PowerSimulations.DecisionProblem, ProblemTemplate, System, Union{Nothing, JuMP.Model}}" href="#PowerSimulations.DecisionModel-Tuple{Type{M} where M&lt;:PowerSimulations.DecisionProblem, ProblemTemplate, System, Union{Nothing, JuMP.Model}}"><code>PowerSimulations.DecisionModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DecisionModel(
    ::Type{M&lt;:PowerSimulations.DecisionProblem},
    template::ProblemTemplate,
    sys::System
) -&gt; Any
DecisionModel(
    ::Type{M&lt;:PowerSimulations.DecisionProblem},
    template::ProblemTemplate,
    sys::System,
    jump_model::Union{Nothing, JuMP.Model};
    kwargs...
) -&gt; Any
</code></pre><p>This builds the optimization problem of type M with the specific system and template</p><p><strong>Arguments</strong></p><ul><li><code>::Type{M} where M&lt;:DecisionProblem</code>: The abstract operation model type</li><li><code>template::ProblemTemplate</code>: The model reference made up of transmission, devices, branches, and services.</li><li><code>sys::PSY.System</code>: the system created using Power Systems</li><li><code>jump_model::Union{Nothing, JuMP.Model}</code> = nothing: Enables passing a custom JuMP model. Use with care.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">template = ProblemTemplate(CopperPlatePowerModel, devices, branches, services)
problem = DecisionModel(MyOpProblemType, template, system, optimizer)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3d577a9e7b08265b5df6976fee74bd55ce42796d/src/operation/decision_model.jl#L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DecisionModel-Tuple{AbstractString, MathOptInterface.OptimizerWithAttributes}" href="#PowerSimulations.DecisionModel-Tuple{AbstractString, MathOptInterface.OptimizerWithAttributes}"><code>PowerSimulations.DecisionModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DecisionModel(
    directory::AbstractString,
    optimizer::MathOptInterface.OptimizerWithAttributes;
    jump_model,
    system
) -&gt; Any
</code></pre><p>Construct an DecisionProblem from a serialized file.</p><p><strong>Arguments</strong></p><ul><li><code>directory::AbstractString</code>: Directory containing a serialized model</li><li><code>jump_model::Union{Nothing, JuMP.Model}</code> = nothing: The JuMP model does not get serialized. Callers should pass whatever they passed to the original problem.</li><li><code>optimizer::Union{Nothing,MOI.OptimizerWithAttributes}</code> = nothing: The optimizer does not get serialized. Callers should pass whatever they passed to the original problem.</li><li><code>system::Union{Nothing, PSY.System}</code>: Optionally, the system used for the model. If nothing and sys<em>to</em>file was set to true when the model was created, the system will be deserialized from a file.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3d577a9e7b08265b5df6976fee74bd55ce42796d/src/operation/decision_model.jl#L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.build!-Tuple{DecisionModel}" href="#PowerSimulations.build!-Tuple{DecisionModel}"><code>PowerSimulations.build!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">build!(
    model::DecisionModel;
    output_dir,
    recorders,
    console_level,
    file_level,
    disable_timer_outputs
)
</code></pre><p>Build the Decision Model based on the specified DecisionProblem.</p><p><strong>Arguments</strong></p><ul><li><code>model::DecisionModel{&lt;:DecisionProblem}</code>: DecisionModel object</li><li><code>output_dir::String</code>: Output directory for results</li><li><code>recorders::Vector{Symbol} = []</code>: recorder names to register</li><li><code>console_level = Logging.Error</code>: </li><li><code>file_level = Logging.Info</code>:</li><li><code>disable_timer_outputs = false</code> : Enable/Disable timing outputs</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3d577a9e7b08265b5df6976fee74bd55ce42796d/src/operation/decision_model.jl#L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.solve!-Tuple{DecisionModel}" href="#PowerSimulations.solve!-Tuple{DecisionModel}"><code>PowerSimulations.solve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve!(
    model::DecisionModel;
    export_problem_results,
    console_level,
    file_level,
    disable_timer_outputs,
    serialize,
    kwargs...
) -&gt; RunStatus
</code></pre><p>Default solve method for models that conform to the requirements of DecisionModel{&lt;: DecisionProblem}.</p><p>This will call <a href="#PowerSimulations.build!-Tuple{DecisionModel}"><code>build!</code></a> on the model if it is not already built. It will forward all keyword arguments to that function.</p><p><strong>Arguments</strong></p><ul><li><code>model::OperationModel = model</code>: operation model</li><li><code>export_problem_results::Bool = false</code>: If true, export ProblemResults DataFrames to CSV files.</li><li><code>console_level = Logging.Error</code>: </li><li><code>file_level = Logging.Info</code>:</li><li><code>disable_timer_outputs = false</code> : Enable/Disable timing outputs</li><li><code>serialize::Bool = true</code>: If true, serialize the model to a file to allow re-execution later.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">results = solve!(OpModel)
results = solve!(OpModel, export_problem_results = true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3d577a9e7b08265b5df6976fee74bd55ce42796d/src/operation/decision_model.jl#L337">source</a></section></article>&nbsp;
&nbsp;<h1 id="Emulation-Models"><a class="docs-heading-anchor" href="#Emulation-Models">Emulation Models</a><a id="Emulation-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Emulation-Models" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.EmulationModel" href="#PowerSimulations.EmulationModel"><code>PowerSimulations.EmulationModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EmulationModel{M}(
    template::ProblemTemplate,
    sys::PSY.System,
    jump_model::Union{Nothing, JuMP.Model}=nothing;
    kwargs...) where {M&lt;:EmulationProblem}</code></pre><p>This builds the optimization problem of type M with the specific system and template.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{M} where M&lt;:EmulationProblem</code>: The abstract Emulation model type</li><li><code>template::ProblemTemplate</code>: The model reference made up of transmission, devices, branches, and services.</li><li><code>sys::PSY.System</code>: the system created using Power Systems</li><li><code>jump_model::Union{Nothing, JuMP.Model}</code>: Enables passing a custom JuMP model. Use with care</li><li><code>name = nothing</code>: name of model, string or symbol; defaults to the type of template converted to a symbol.</li><li><code>optimizer::Union{Nothing,MOI.OptimizerWithAttributes} = nothing</code> : The optimizer does not get serialized. Callers should pass whatever they passed to the original problem.</li><li><code>warm_start::Bool = true</code>: True will use the current operation point in the system to initialize variable values. False initializes all variables to zero. Default is true</li><li><code>system_to_file::Bool = true:</code>: True to create a copy of the system used in the model.</li><li><code>initialize_model::Bool = true</code>: Option to decide to initialize the model or not.</li><li><code>initialization_file::String = &quot;&quot;</code>: TODO</li><li><code>deserialize_initial_conditions::Bool = false</code>: Option to deserialize conditions</li><li><code>export_pwl_vars::Bool = false</code>: True to export all the pwl intermediate variables. It can slow down significantly the solve time.</li><li><code>allow_fails::Bool = false</code>: True to allow the simulation to continue even if the optimization step fails. Use with care.</li><li><code>calculate_conflict::Bool = false</code>: True to use solver to calculate conflicts for infeasible problems. Only specific solvers are able to calculate conflicts.</li><li><code>optimizer_solve_log_print::Bool = false</code>: Uses JuMP.unset_silent() to print the optimizer&#39;s log. By default all solvers are set to MOI.Silent()</li><li><code>detailed_optimizer_stats::Bool = false</code>: True to save detailed optimizer stats log.</li><li><code>direct_mode_optimizer::Bool = false</code>: True to use the solver in direct mode. Creates a <a href="https://jump.dev/JuMP.jl/dev/reference/models/#JuMP.direct_model">JuMP.direct_model</a>.</li><li><code>store_variable_names::Bool = false</code>: True to store variable names in optimization model.</li><li><code>rebuild_model::Bool = false</code>: TODO</li><li><code>initial_time::Dates.DateTime = UNSET_INI_TIME</code>: Initial Time for the model solve.</li><li><code>time_series_cache_size::Int = IS.TIME_SERIES_CACHE_SIZE_BYTES</code>: Size in bytes to cache for each time array. Default is 1 MiB. Set to 0 to disable.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">template = ProblemTemplate(CopperPlatePowerModel, devices, branches, services)
OpModel = EmulationModel(MockEmulationProblem, template, system)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3d577a9e7b08265b5df6976fee74bd55ce42796d/src/operation/emulation_model.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.EmulationModel-Tuple{Type{M} where M&lt;:PowerSimulations.EmulationProblem, ProblemTemplate, System, Union{Nothing, JuMP.Model}}" href="#PowerSimulations.EmulationModel-Tuple{Type{M} where M&lt;:PowerSimulations.EmulationProblem, ProblemTemplate, System, Union{Nothing, JuMP.Model}}"><code>PowerSimulations.EmulationModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">EmulationModel(
    ::Type{M&lt;:PowerSimulations.EmulationProblem},
    template::ProblemTemplate,
    sys::System
) -&gt; Any
EmulationModel(
    ::Type{M&lt;:PowerSimulations.EmulationProblem},
    template::ProblemTemplate,
    sys::System,
    jump_model::Union{Nothing, JuMP.Model};
    kwargs...
) -&gt; Any
</code></pre><p>This builds the optimization problem of type M with the specific system and template</p><p><strong>Arguments</strong></p><ul><li><code>::Type{M} where M&lt;:EmulationProblem</code>: The abstract Emulation model type</li><li><code>template::ProblemTemplate</code>: The model reference made up of transmission, devices, branches, and services.</li><li><code>sys::PSY.System</code>: the system created using Power Systems</li><li><code>jump_model::Union{Nothing, JuMP.Model}</code>: Enables passing a custom JuMP model. Use with care</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">template = ProblemTemplate(CopperPlatePowerModel, devices, branches, services)
problem = EmulationModel(MyEmProblemType, template, system, optimizer)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3d577a9e7b08265b5df6976fee74bd55ce42796d/src/operation/emulation_model.jl#L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.EmulationModel-Tuple{AbstractString, MathOptInterface.OptimizerWithAttributes}" href="#PowerSimulations.EmulationModel-Tuple{AbstractString, MathOptInterface.OptimizerWithAttributes}"><code>PowerSimulations.EmulationModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">EmulationModel(
    directory::AbstractString,
    optimizer::MathOptInterface.OptimizerWithAttributes;
    jump_model,
    system,
    kwargs...
) -&gt; Any
</code></pre><p>Construct an EmulationProblem from a serialized file.</p><p><strong>Arguments</strong></p><ul><li><code>directory::AbstractString</code>: Directory containing a serialized model.</li><li><code>optimizer::MOI.OptimizerWithAttributes</code>: The optimizer does not get serialized. Callers should pass whatever they passed to the original problem.</li><li><code>jump_model::Union{Nothing, JuMP.Model}</code> = nothing: The JuMP model does not get serialized. Callers should pass whatever they passed to the original problem.</li><li><code>system::Union{Nothing, PSY.System}</code>: Optionally, the system used for the model. If nothing and sys<em>to</em>file was set to true when the model was created, the system will be deserialized from a file.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3d577a9e7b08265b5df6976fee74bd55ce42796d/src/operation/emulation_model.jl#L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.build!-Tuple{EmulationModel}" href="#PowerSimulations.build!-Tuple{EmulationModel}"><code>PowerSimulations.build!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">build!(
    model::EmulationModel;
    executions,
    output_dir,
    recorders,
    console_level,
    file_level,
    disable_timer_outputs
)
</code></pre><p>Implementation of build for any EmulationProblem</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3d577a9e7b08265b5df6976fee74bd55ce42796d/src/operation/emulation_model.jl#L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.run!-Tuple{EmulationModel}" href="#PowerSimulations.run!-Tuple{EmulationModel}"><code>PowerSimulations.run!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run!(
    model::EmulationModel;
    export_problem_results,
    console_level,
    file_level,
    disable_timer_outputs,
    serialize,
    kwargs...
) -&gt; RunStatus
</code></pre><p>Default run method for problems that conform to the requirements of EmulationModel{&lt;: EmulationProblem}</p><p>This will call <a href="#PowerSimulations.build!-Tuple{DecisionModel}"><code>build!</code></a> on the model if it is not already built. It will forward all keyword arguments to that function.</p><p><strong>Arguments</strong></p><ul><li><code>model::EmulationModel = model</code>: Emulation model</li><li><code>optimizer::MOI.OptimizerWithAttributes</code>: The optimizer that is used to solve the model</li><li><code>executions::Int</code>: Number of executions for the emulator run</li><li><code>export_problem_results::Bool</code>: If true, export ProblemResults DataFrames to CSV files.</li><li><code>output_dir::String</code>: Required if the model is not already built, otherwise ignored</li><li><code>enable_progress_bar::Bool</code>: Enables/Disable progress bar printing</li><li><code>serialize::Bool</code>: If true, serialize the model to a file to allow re-execution later.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">status = run!(model; optimizer = GLPK.Optimizer, executions = 10)
status = run!(model; output_dir = ./model_output, optimizer = GLPK.Optimizer, executions = 10)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3d577a9e7b08265b5df6976fee74bd55ce42796d/src/operation/emulation_model.jl#L397">source</a></section></article>&nbsp;
&nbsp;<h1 id="Simulation-Models"><a class="docs-heading-anchor" href="#Simulation-Models">Simulation Models</a><a id="Simulation-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-Models" title="Permalink"></a></h1><p>Refer to the <a href="https://nrel-siip.github.io/PowerSimulations.jl/latest/modeler_guide/running_a_simulation/">Simulations Page</a> to explanations on how to setup a Simulation, with Sequencing and Feedforwards.</p><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.SimulationModels" href="#PowerSimulations.SimulationModels"><code>PowerSimulations.SimulationModels</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimulationModels(
    decision_models::Vector{&lt;:DecisionModel},
    emulation_models::Union{Nothing, EmulationModel}
)</code></pre><p>Stores the OperationProblem definitions to be used in the simulation. When creating the SimulationModels, the order in which the models are created determines the order on which the simulation is executed.</p><p><strong>Arguments</strong></p><ul><li><code>decision_models::Vector{&lt;:DecisionModel}</code>: Vector of decision models.</li><li><code>emulation_models::Union{Nothing, EmulationModel}</code>: Optional argument to include</li></ul><p>an EmulationModel in the Simulation</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">template_uc = template_unit_commitment()
template_ed = template_economic_dispatch()
my_decision_model_uc = DecisionModel(template_1, sys_uc, optimizer, name = &quot;UC&quot;)
my_decision_model_ed = DecisionModel(template_ed, sys_ed, optimizer, name = &quot;ED&quot;)
models = SimulationModels(
    decision_models = [
        my_decision_model_uc,
        my_decision_model_ed
    ]
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3d577a9e7b08265b5df6976fee74bd55ce42796d/src/simulation/simulation_models.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.SimulationSequence" href="#PowerSimulations.SimulationSequence"><code>PowerSimulations.SimulationSequence</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimulationSequence(
    models::SimulationModels,
    feedforward::Dict{String, Vector{&lt;:AbstractAffectFeedforward}}
    ini_cond_chronology::InitialConditionChronology
)</code></pre><p>Construct the simulation sequence between decision and emulation models.</p><p><strong>Arguments</strong></p><ul><li><code>models::SimulationModels</code>: Vector of decisions and emulation models.</li><li><code>feedforward = Dict{String, Vector{&lt;:AbstractAffectFeedforward}}()</code>: Optional dictionary to specify how information</li></ul><p>and variables are exchanged between decision and emulation models.</p><ul><li><code>ini_cond_chronology::nitialConditionChronology =  InterProblemChronology()</code>: TODO</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">template_uc = template_unit_commitment()
template_ed = template_economic_dispatch()
my_decision_model_uc = DecisionModel(template_1, sys_uc, optimizer, name = &quot;UC&quot;)
my_decision_model_ed = DecisionModel(template_ed, sys_ed, optimizer, name = &quot;ED&quot;)
models = SimulationModels(
    decision_models = [
        my_decision_model_uc,
        my_decision_model_ed
    ]
)
# The following sequence set the commitment variables (`OnVariable`) for `ThermalStandard` units from UC to ED.
sequence = SimulationSequence(;
    models = models,
    feedforwards = Dict(
        &quot;ED&quot; =&gt; [
            SemiContinuousFeedforward(;
                component_type = ThermalStandard,
                source = OnVariable,
                affected_values = [ActivePowerVariable],
            ),
        ],
    ),
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3d577a9e7b08265b5df6976fee74bd55ce42796d/src/simulation/simulation_sequence.jl#L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.Simulation" href="#PowerSimulations.Simulation"><code>PowerSimulations.Simulation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Simulation(
    sequence::SimulationSequence,
    name::String,
    steps::Int
    models::SimulationModels,        
    simulation_folder::String,        
    initial_time::Union{Nothing, Dates.DateTime}
)</code></pre><p>Construct the Simulation structure to run the sequence of decision and emulation models specified.</p><p><strong>Arguments</strong></p><p>-<code>sequence::SimulationSequence</code>: Simulation sequence that specify how the decision and emulation models will be executed.   -<code>name::String</code>: Name of the Simulation   -<code>steps::Int</code>: Number of steps on which the sequence of models will be executed   -<code>models::SimulationModels</code>: List of Decision and Emulation Models   -<code>simulation_folder::String</code>: Folder on which results will be stored   -<code>initial_time::Union{Nothing, Dates.DateTime} = nothing</code>: Initial time of which the simulation starts. If nothing it will default to the first timestamp     of time series of the system.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">template_uc = template_unit_commitment()
template_ed = template_economic_dispatch()
my_decision_model_uc = DecisionModel(template_1, sys_uc, optimizer, name = &quot;UC&quot;)
my_decision_model_ed = DecisionModel(template_ed, sys_ed, optimizer, name = &quot;ED&quot;)
models = SimulationModels(
    decision_models = [
        my_decision_model_uc,
        my_decision_model_ed
    ]
)
# The following sequence set the commitment variables (`OnVariable`) for `ThermalStandard` units from UC to ED.
sequence = SimulationSequence(;
    models = models,
    feedforwards = Dict(
        &quot;ED&quot; =&gt; [
            SemiContinuousFeedforward(;
                component_type = ThermalStandard,
                source = OnVariable,
                affected_values = [ActivePowerVariable],
            ),
        ],
    ),
)

sim = Simulation(
    sequence = sequence,
    name = &quot;Sim&quot;,
    steps = 5,
    models = models,
    simulation_folder = mktempdir(cleanup=true),
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3d577a9e7b08265b5df6976fee74bd55ce42796d/src/simulation/simulation.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.Simulation-Tuple{AbstractString, Dict}" href="#PowerSimulations.Simulation-Tuple{AbstractString, Dict}"><code>PowerSimulations.Simulation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Simulation(directory::AbstractString, model_info::Dict)
</code></pre><p>Constructs Simulation from a serialized directory. Callers should pass any kwargs here that they passed to the original Simulation.</p><p><strong>Arguments</strong></p><ul><li><code>directory::AbstractString</code>: the directory returned from the call to serialize</li><li><code>model_info::Dict</code>: Two-level dictionary containing model parameters that cannot be serialized. The outer dict should be keyed by the problem name. The inner dict must contain &#39;optimizer&#39; and may contain &#39;jump_model&#39;. These should be the same values used for the original simulation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3d577a9e7b08265b5df6976fee74bd55ce42796d/src/simulation/simulation.jl#L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.build!-Tuple{Simulation}" href="#PowerSimulations.build!-Tuple{Simulation}"><code>PowerSimulations.build!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">build!(
    sim::Simulation;
    recorders,
    console_level,
    file_level,
    serialize,
    partitions,
    index
) -&gt; BuildStatus
</code></pre><p>Build the Simulation, problems and the related folder structure.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Simulation</code>: simulation object</li><li><code>recorders::Vector{Symbol} = []</code>: recorder names to register</li><li><code>serialize::Bool = true</code>: serializes the simulation objects in the simulation</li><li><code>console_level = Logging.Error</code>:</li><li><code>file_level = Logging.Info</code>:</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3d577a9e7b08265b5df6976fee74bd55ce42796d/src/simulation/simulation.jl#L600">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.execute!-Tuple{Simulation}" href="#PowerSimulations.execute!-Tuple{Simulation}"><code>PowerSimulations.execute!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">execute!(sim::Simulation; kwargs...) -&gt; RunStatus
</code></pre><p>Solves the simulation model for sequential Simulations.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Simulation=sim</code>: simulation object created by Simulation()</li></ul><p>The optional keyword argument <code>exports</code> controls exporting of results to CSV files as the simulation runs. Refer to <a href="api/@ref"><code>export_results</code></a> for a description of this argument.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">sim = Simulation(&quot;Test&quot;, 7, problems, &quot;/Users/folder&quot;)
execute!(sim::Simulation; kwargs...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3d577a9e7b08265b5df6976fee74bd55ce42796d/src/simulation/simulation.jl#L937">source</a></section></article>&nbsp;
&nbsp;<h1 id="Variables"><a class="docs-heading-anchor" href="#Variables">Variables</a><a id="Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Variables" title="Permalink"></a></h1><h2 id="Common-Variables"><a class="docs-heading-anchor" href="#Common-Variables">Common Variables</a><a id="Common-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Variables" title="Permalink"></a></h2></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../formulation_library/Branch/">« Branch</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 21 April 2023 21:26">Friday 21 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
