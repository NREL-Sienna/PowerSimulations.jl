var documenterSearchIndex = {"docs":
[{"location":"formulation_library/Network/#network_formulations","page":"Network","title":"Network Formulations","text":"Network formulations are used to describe how the network and buses are handled when constructing constraints. The most common constraint decided by the network formulation is the supply-demand balance constraint.\n\nAvailable Network Models are:\n\nFormulation Description\nCopperPlatePowerModel Copper plate connection between all components, i.e. infinite transmission capacity\nAreaBalancePowerModel Network model approximation to represent inter-area flow with each area represented as a single node\nPTDFPowerModel Uses the PTDF factor matrix to compute the fraction of power transferred in the network across the branches\nAreaPTDFPowerModel Uses the PTDF factor matrix to compute the fraction of power transferred in the network across the branches and balances power by Area instead of system-wide\n\nPowerModels.jl available formulations:\n\nExact non-convex models: ACPPowerModel, ACRPowerModel, ACTPowerModel.\nLinear approximations: DCPPowerModel, NFAPowerModel.\nQuadratic approximations: DCPLLPowerModel, LPACCPowerModel\nQuadratic relaxations: SOCWRPowerModel, SOCWRConicPowerModel, SOCBFPowerModel, SOCBFConicPowerModel, QCRMPowerModel, QCLSPowerModel.\nSDP relaxations: SDPWRMPowerModel.\n\nAll of these formulations are described in the PowerModels.jl documentation and will not be described here.\n\n","category":"section"},{"location":"formulation_library/Network/#CopperPlatePowerModel","page":"Network","title":"CopperPlatePowerModel","text":"Variables:\n\nIf Slack variables are enabled:\n\nSystemBalanceSlackUp:\nBounds: [0.0, ]\nDefault initial value: 0.0\nDefault proportional cost: 1e6\nSymbol: p^textslup\nSystemBalanceSlackDown:\nBounds: [0.0, ]\nDefault initial value: 0.0\nDefault proportional cost: 1e6\nSymbol: p^textsldn\n\nObjective:\n\nAdd a large proportional cost to the objective function if slack variables are used + (p^textslup + p^textsldn) cdot 10^6\n\nExpressions:\n\nAdds p^textslup and p^textsldn terms to the respective active power balance expressions ActivePowerBalance created by this CopperPlatePowerModel network formulation.\n\nConstraints:\n\nAdds the CopperPlateBalanceConstraint to balance the active power of all components available in the system\n\nbeginalign\n  sum_c in textcomponents p_t^c = 0 quad forall t in 1 dots T\nendalign\n\n","category":"section"},{"location":"formulation_library/Network/#AreaBalancePowerModel","page":"Network","title":"AreaBalancePowerModel","text":"Variables: If Slack variables are enabled:\n\nSystemBalanceSlackUp by area:\nBounds: [0.0, ]\nDefault initial value: 0.0\nDefault proportional cost: 1e6\nSymbol: p^textslup\nSystemBalanceSlackDown by area:\nBounds: [0.0, ]\nDefault initial value: 0.0\nDefault proportional cost: 1e6\nSymbol: p^textsldn\n\nObjective:\n\nAdds p^textslup and p^textsldn terms to the respective active power balance expressions ActivePowerBalance per area.\n\nExpressions:\n\nCreates ActivePowerBalance expressions for each area that then are used to balance active power for all buses within a single area.\n\nConstraints:\n\nAdds the CopperPlateBalanceConstraint to balance the active power of all components available in an area.\n\nbeginalign\n  sum_c in textcomponents_a p_t^c = 0 quad forall ain 1dots A t in 1 dots T\nendalign\n\n","category":"section"},{"location":"formulation_library/Network/#PTDFPowerModel","page":"Network","title":"PTDFPowerModel","text":"Variables:\n\nIf Slack variables are enabled:\n\nSystemBalanceSlackUp:\nBounds: [0.0, ]\nDefault initial value: 0.0\nDefault proportional cost: 1e6\nSymbol: p^textslup\nSystemBalanceSlackDown:\nBounds: [0.0, ]\nDefault initial value: 0.0\nDefault proportional cost: 1e6\nSymbol: p^textsldn\n\nObjective:\n\nAdd a large proportional cost to the objective function if slack variables are used + (p^textslup + p^textsldn) cdot 10^6\n\nExpressions:\n\nAdds p^textslup and p^textsldn terms to the respective system-wide active power balance expressions ActivePowerBalance created by this CopperPlatePowerModel network formulation. In addition, it creates ActivePowerBalance expressions for each bus to be used in the calculation of branch flows.\n\nConstraints:\n\nAdds the CopperPlateBalanceConstraint to balance the active power of all components available in the system\n\nbeginalign\n  sum_c in textcomponents p_t^c = 0 quad forall t in 1 dots T\nendalign\n\nIn addition creates NodalBalanceActiveConstraint for HVDC buses balance, if DC components are connected to an HVDC network.","category":"section"},{"location":"formulation_library/Network/#AreaPTDFPowerModel","page":"Network","title":"AreaPTDFPowerModel","text":"Variables\n\nSlack variables are not supported.\n\nObjective Function\n\nNo changes to the objective function.\n\nExpressions\n\nCreates the area-wide and nodal-wide active power balance expressions ActivePowerBalance to balance power based on each area independently. The flows across areas are computed based on the PTDF factors of lines connecting areas.\n\nConstraints:\n\nAdds the ActivePowerBalance constraint to balance the active power of all components available for each area.\n\nbeginalign\n  sum_c in textcomponents_a p_t^c = 0 quad forall ain 1dots A t in 1 dots T\nendalign\n\nThis includes the flows of lines based on the PTDF factors.","category":"section"},{"location":"formulation_library/Network/#PowerSimulations.NetworkModel","page":"Network","title":"PowerSimulations.NetworkModel","text":"Establishes the NetworkModel for a given PowerModels formulation type.\n\nArguments\n\n::Type{T} where T <: PM.AbstractPowerModel: the power-system formulation type.\n\nAccepted keyword arguments\n\nuse_slacks::Bool = false   Adds slack buses to the network modeling.\nPTDF_matrix::Union{PNM.PowerNetworkMatrix, Nothing} = nothing   PTDF/VirtualPTDF matrix produced by PowerNetworkMatrices (optional).\nLODF_matrix::Union{PNM.PowerNetworkMatrix, Nothing} = nothing   LODF/VirtualLODF matrix produced by PowerNetworkMatrices (optional).\nreduce_radial_branches::Bool = false   Enable radial branch reduction when building network matrices.\nreduce_degree_two_branches::Bool = false   Enable degree-two branch reduction when building network matrices.\nsubnetworks::Dict{Int, Set{Int}} = Dict()   Optional mapping of reference bus → set of mapped buses. If not provided,   subnetworks are inferred from PTDF/VirtualPTDF or discovered from the system.\nduals::Vector{DataType} = Vector{DataType}()   Constraint types for which duals should be recorded.\npower_flow_evaluation::Union{PFS.PowerFlowEvaluationModel, Vector{PFS.PowerFlowEvaluationModel}}   Power-flow evaluation model(s). A single model is flattened to a vector internally.\n\nNotes\n\nmodeled_ac_branch_types and reduced_branch_tracker are internal fields managed by the model.\nsubsystem can be set after construction via set_subsystem!(model, id).\nPTDF/LODF inputs are validated against the requested reduction flags and may raise a ConflictingInputsError if they are inconsistent with reduce_radial_branches or reduce_degree_two_branches.\n\nExamples\n\nptdf = PNM.VirtualPTDF(system) nw = NetworkModel(PTDFPowerModel; PTDFmatrix = ptdf, reduceradialbranches = true,                   powerflow_evaluation = PFS.PowerFlowEvaluationModel())\n\nnw2 = NetworkModel(CopperPlatePowerModel; subnetworks = Dict(1 => Set([1,2,3])))\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Network/#PowerSimulations.CopperPlatePowerModel","page":"Network","title":"PowerSimulations.CopperPlatePowerModel","text":"Infinite capacity approximation of network flow to represent entire system with a single node.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Network/#PowerSimulations.AreaBalancePowerModel","page":"Network","title":"PowerSimulations.AreaBalancePowerModel","text":"Approximation to represent inter-area flow with each area represented as a single node.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Network/#PowerSimulations.PTDFPowerModel","page":"Network","title":"PowerSimulations.PTDFPowerModel","text":"Linear active power approximation using the power transfer distribution factor PTDF matrix.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Network/#PowerSimulations.AreaPTDFPowerModel","page":"Network","title":"PowerSimulations.AreaPTDFPowerModel","text":"Linear active power approximation using the power transfer distribution factor PTDF matrix. Balancing areas as well as synchrounous regions.\n\n\n\n\n\n","category":"type"},{"location":"how_to/adding_new_problem_model/#Adding-an-Operations-Problem-Model","page":"Adding an Operations Problem Model","title":"Adding an Operations Problem Model","text":"This tutorial will show how to create a custom decision problem model. These cases are the ones where the user want to solve a fully specified problem. Some examples of custom decision models include:\n\nSolving a custom Security Constrained Unit Commitment Problem\nSolving a market agent utility maximization Problem. See examples of this functionality in HybridSystemsSimulations.jl\n\nThe tutorial follows the usual steps for operational model building. First, build the decision model in isolation and second, integrate it into a simulation. In most cases there will be more than one way of achieving the same objective when it comes to implementing the model. This guide shows a general set of steps and requirements but it is by no means an exhaustive and detailed guide on developing custom decision models.\n\nwarning: Warning\nAll the code in this tutorial is considered \"pseudo-code\". Copy-paste will likely not work out of the box. You need to develop the internals of the functions correctly for the examples below to work.","category":"section"},{"location":"how_to/adding_new_problem_model/#General-Rules","page":"Adding an Operations Problem Model","title":"General Rules","text":"As a general rule you need to understand Julia's terminology such as multiple dispatch, parametric structs and method overloading, among others. Developing custom models for an operational simulation is a highly technical task and requires skilled development. This tutorial also requires good understanding of PowerSystems.jl data structures and features which are covered in the tutorials section of PowerSystems.jl documentation. Finally, developing a custom model decision model that will employ an optimization model under the hood requires understanding JuMP.jl.\nNeed to employ anonymous constraints and variables in JuMP and register the constraints, variables and other optimization objects into PowerSimulations.jl's optimization container. Otherwise the features to use your problem in the simulation like the coordination with other problems and post processing won't work. More on this in the section How to develop your build_model! function below.\nImplement the required methods for your custom decision models. In some cases it will be possible to re-use some of the other methods that exist in PowerSimulations to make life easier for variable addition and constraint creation but this is not required.","category":"section"},{"location":"how_to/adding_new_problem_model/#Decision-Problem","page":"Adding an Operations Problem Model","title":"Decision Problem","text":"","category":"section"},{"location":"how_to/adding_new_problem_model/#Step-1:-Define-a-Custom-Decision-Problem","page":"Adding an Operations Problem Model","title":"Step 1: Define a Custom Decision Problem","text":"Define a decision problem struct as a subtype of PowerSimulations.DecisionProblem. This requirement will enable a lot of the underlying functionality that relies on multiple dispatch. DecisionProblems are used to parameterize the behavior of DecisionModel objects which are just containers for the parameters, references and the optimization problem.\n\nIt is possible to define a Custom Decision Problem that gives the user full control over the build, solve and execution process since it imposes less requirements on the developer. However, with less requirements there are also less checks and validations performed inside of PowerSimulations which might lead to unexpected errors\n\nstruct MyCustomDecisionProblem <: PSI.DecisionProblem end\n\nAlternatively, it is possible to define a Custom Decision Problem subtyping from DefaultDecisionProblem which imposes more requirements and structure onto the developer but employs more checks and validations in the process. Be aware that this route will decrease the flexibility of what can be done inside the custom model.\n\nstruct MyCustomDecisionProblem <: PSI.DefaultDecisionProblem end\n\nOnce the problem type is defined, initialize the decision model container with your custom decision problem passing the solver and some of the settings you need for the solution of the problem. For custom problems some of the settings need manual implementation by the developer. Settings availability is also dependent on wether  you choose to subtype from PSI.DecisionProblem or PSI.DefaultDecisionProblem\n\nmy_model = DecisionModel{MyCustomDecisionProblem}(\n    sys;\n    name = \"MyModel\",\n    optimizer = optimizer_with_attributes(HiGHS.Optimizer),\n    optimizer_solve_log_print = true,\n)","category":"section"},{"location":"how_to/adding_new_problem_model/#Mandatory-Method-Implementations","page":"Adding an Operations Problem Model","title":"Mandatory Method Implementations","text":"build_model!: This method build the JuMP optimization model.","category":"section"},{"location":"how_to/adding_new_problem_model/#Optional-Method-Overloads","page":"Adding an Operations Problem Model","title":"Optional Method Overloads","text":"These methods can be defined optionally for your problem. By default for problems subtyped from DecisionProblem these checks are not executed. If the problems are subtyped from DefaultDecisionProblem these checks are always conducted with PowerSimulations defaults and require compliance with those defaults to pass. In any case, these can be overloaded when necessary depending on the problem requirements.\n\nvalidate_template\nvalidate_time_series!\nreset!\nsolve_impl!","category":"section"},{"location":"how_to/adding_new_problem_model/#How-to-develop-your-build_model!-function","page":"Adding an Operations Problem Model","title":"How to develop your build_model! function","text":"","category":"section"},{"location":"how_to/adding_new_problem_model/#Registering-a-variable-in-the-model","page":"Adding an Operations Problem Model","title":"Registering a variable in the model","text":"To register a variable in the model, the developer must first allocate the container into the optimization container and then populate it. For example, it require start the build function as follows:\n\ninfo: Info\nWe recommend calling import PowerSimulations and defining the constant CONST PSI = PowerSimulations to make it easier to read the code and determine which package is responsible for defining the functions.\n\nfunction PSI.build_model!(model::PSI.DecisionModel{MyCustomDecisionProblem})\n    container = PSI.get_optimization_container(model)\n    time_steps = 1:24\n    PSI.set_time_steps!(container, time_steps)\n    system = PSI.get_system(model)\n\n    thermal_gens = PSY.get_components(PSY.ThermalStandard, system)\n    thermal_gens_names = PSY.get_name.(thermal_gens)\n\n    # Create the container for the variable\n    variable = PSI.add_variable_container!(\n        container,\n        PSI.ActivePowerVariable(), # <- This variable is defined in PowerSimulations but the user can define their own\n        PSY.ThermalGeneration, # <- Device type for the variable. Can be from PSY or custom defined\n        thermal_gens_names, # <- First container dimension\n        time_steps, # <- Second container dimension\n    )\n\n    # Iterate over the devices and time to store the JuMP variables into the container.\n    for t in time_steps, d in thermal_gens_names\n        name = PSY.get_name(d)\n        variable[name, t] = JuMP.@variable(get_jump_model(container))\n        # It is possible to use PSY getter functions to retrieve data from the generators\n        JuMP.set_upper_bound(variable[name, t], UB_DATA) # <- Optional\n        JuMP.set_lower_bound(variable[name, t], LB_DATA) # <- Optional\n    end\n\n    # Add More Variables.....\n\n    return\nend","category":"section"},{"location":"how_to/adding_new_problem_model/#Registering-a-constraint-in-the-model","page":"Adding an Operations Problem Model","title":"Registering a constraint in the model","text":"A similar pattern is used to add constraints to the model, in this example the field meta is used to avoid creating unnecessary duplicate constraint types. For instance to reflect upperbound and lowerbound or upwards and downwards constraints. Meta can take any string value except for the _ character.\n\nfunction PSI.build_model!(model::PSI.DecisionModel{MyCustomDecisionProblem})\n    container = PSI.get_optimization_container(model)\n    time_steps = 1:24\n    PSI.set_time_steps!(container, time_steps)\n    system = PSI.get_system(model)\n\n    # VARIABLE ADDITION CODE\n\n    # Constraint additions\n    con_ub = PSI.add_constraints_container!(\n        container,\n        PSI.RangeLimitConstraint(), # <- Constraint Type defined by PSI or your own\n        PSY.ThermalGeneration, # <- Device type for variable. Can be PSY or custom\n        thermal_gens_names, # <- First container dimension\n        time_steps; # <- Second container dimension\n        meta = \"ub\", # <- meta allows to reuse a constraint definition for similar constraints. It only requires to be a string\n    )\n\n    con_lb = PSI.add_constraints_container!(\n        container,\n        PSI.RangeLimitConstraint(),\n        PSY.ThermalGeneration,\n        thermal_gens_names, # <- First container dimension\n        time_steps; # <- Second container dimension\n        meta = \"lb\", # <- meta allows to reuse a constraint definition for similar constraints. It only requires to be a string\n    )\n\n    # Retrieve a relevant variable from the container if not defined in\n    variable = PSI.get_variable(container, PSI.ActivePowerVariable(), PSY.ThermalGeneration)\n    for device in devices, t in time_steps\n        ci_name = PSY.get_name(device)\n        limits = get_min_max_limits(device) # depends on constraint type and formulation type\n        con_ub[ci_name, t] =\n            JuMP.@constraint(get_jump_model(container), variable[ci_name, t] >= limits.min)\n        con_lb[ci_name, t] =\n            JuMP.@constraint(get_jump_model(container), variable[ci_name, t] >= limits.min)\n    end\n\n    return\nend","category":"section"},{"location":"how_to/logging/#Logging","page":"...configure logging","title":"Logging","text":"PowerSimulations.jl will output many log messages when building systems and running simulations. You may want to customize what gets logged to the console and, optionally, a file.\n\nBy default all log messages of level Logging.Info or higher will get displayed to the console.  When you run a simulation a simulation-specific logger will take over and log its messages to a file in the logs directory in the simulation output directory. When finished it will relinquish control back to the global logger.","category":"section"},{"location":"how_to/logging/#Configuring-the-global-logger","page":"...configure logging","title":"Configuring the global logger","text":"To configure the global logger in a Jupyter Notebook or REPL you may configure your own logger with the Julia Logging standard library or use the convenience function provided by PowerSimulations.  This example will log messages of level Logging.Error to console and Logging.Info and higher to the file power-simulations.log in the current directory.\n\nimport Logging\nusing PowerSimulations\nlogger = configure_logging(;\n    console_level = Logging.Error,\n    file_level = Logging.Info,\n    filename = \"power-simulations.log\",\n)","category":"section"},{"location":"how_to/logging/#Configuring-the-simulation-logger","page":"...configure logging","title":"Configuring the simulation logger","text":"You can configure the logging level used by the simulation logger when you call build!(simulation).  Here is an example that increases logging verbosity:\n\nimport Logging\nusing PowerSimulations\nsimulation = Simulation(...)\nbuild!(simulation; console_level = Logging.Info, file_level = Logging.Debug)\n\nThe log file will be located at <your-output-path>/<simulation-name>/<run-output-dir>/logs/simulation.log.","category":"section"},{"location":"how_to/logging/#Solver-logs","page":"...configure logging","title":"Solver logs","text":"You can configure logging for the solver you use.  Refer to the solver documentation.  PowerSimulations does not redirect or intercept prints to stdout or stderr from other libraries.","category":"section"},{"location":"how_to/logging/#Recorder-events","page":"...configure logging","title":"Recorder events","text":"PowerSimulations uses the InfrastructureSystems.Recorder to store simulation events in a log file.  Refer to this link for more information.","category":"section"},{"location":"how_to/register_variable/#Register-a-variable-in-a-custom-operation-model","page":"...register a variable in a custom operation model","title":"Register a variable in a custom operation model","text":"In most cases, operation problem models are optimization models. Although in PowerSimulations.jl it is possible to define arbitrary problems that can reflect heuristic decision rules, this is not the common case.\n\nThe first aspect to consider when thinking about developing a model compatible with PowerSimulations.jl is that although we support all of JuMP.jl objects, you need to employ anonymous constraints and variables in JuMP.jl and register the constraints, variables and other optimization objects into PowerSimulations.jl's optimization container. Otherwise the features to use your problem in the simulation like the coordination with other problems and post processing won't work.\n\ninfo: Info\nThe requirements for the simulation of Power Systems operations are more strict than solving an optimization problem once with just JuMP.jl. The requirements imposed by PowerSimulations.jl to integrate your models in a simulation are designed to help with other complex operations that go beyond JuMP.jl scope.\n\nTo register a variable in the model, the developer must first allocate the container into the optimization container and then populate it. For example, it require start the build function as follows:\n\nwarning: Warning\nAll the code in this page is considered \"pseudo-code\". Copy-paste will likely not work out of the box. You need to develop the internals of the functions correctly for the examples below to work.\n\nusing PowerSystems\nusing PowerSimulations\nimport PowerSystems as PSY\nimport PowerSimulations as PSI\n\nfunction PSI.build_model!(model::PSI.DecisionModel{MyCustomModel})\n    container = PSI.get_optimization_container(model)\n    PSI.set_time_steps!(container, 1:24)\n\n    # Create the container for the variable\n    variable = PSI.add_variable_container!(\n        container,\n        PSI.ActivePowerVariable(), # <- This variable is defined in PowerSimulations but the user can define their own\n        PSY.ThermalGeneration, # <- Device type for the variable. Can be from PSY or custom defined\n        devices_names, # <- First container dimension\n        time_steps, # <- Second container dimension\n    )\n\n    # Iterate over the devices and time to store the JuMP variables into the container.\n    for t in time_steps, d in devices\n        name = PSY.get_name(d)\n        variable[name, t] = JuMP.@variable(get_jump_model(container))\n        # It is possible to use PSY getter functions to retrieve data from the generators\n        # Any other variable property can be specified inside this loop.\n        JuMP.set_upper_bound(variable[name, t], UB_DATA) # <- Optional\n        JuMP.set_lower_bound(variable[name, t], LB_DATA) # <- Optional\n    end\n\n    return\nend","category":"section"},{"location":"formulation_library/Piecewise/#pwl_cost","page":"Piecewise Linear Cost","title":"Piecewise linear cost functions","text":"The choice for piecewise-linear (PWL) cost representation in  PowerSimulations.jl is equivalent to the so-called λ-model from the paper The Impacts of Convex Piecewise Linear Cost Formulations on AC Optimal Power Flow. The SOS constraints in each model are only implemented if the data for PWL is not convex.","category":"section"},{"location":"formulation_library/Piecewise/#Special-Ordered-Set-(SOS)-Constraints","page":"Piecewise Linear Cost","title":"Special Ordered Set (SOS) Constraints","text":"A special ordered set (SOS) is an ordered set of variables used as an additional way to specify integrality conditions in an optimization model.\n\nSpecial Ordered Sets of type 1 (SOS1) are a set of variables, at  most one of which can take a non-zero value, all others being at 0. They most frequently applications is in a a set of variables that are actually binary variables: in other words, we have to choose at most one from a set of possibilities.\nSpecial Ordered Sets of type 2 (SOS2) are an ordered set of non-negative variables, of which at most two can be non-zero, and if two are non-zero these must be consecutive in their ordering. Special Ordered Sets of type 2 are typically used to model non-linear functions of a variable in a linear model, such as non-convex quadratic functions using PWL functions.","category":"section"},{"location":"formulation_library/Piecewise/#Standard-representation-of-PWL-costs","page":"Piecewise Linear Cost","title":"Standard representation of PWL costs","text":"Piecewise-linear costs are defined by a sequence of points representing the line segments for each generator: (P_k^textmax C_k) on which we assume C_k is the cost of generating P_k^textmax power, and k in 1dots K are the number of segments each generator cost function has.\n\nnote: Note\nPowerSystems has more options to specify cost functions for each thermal unit. Independent of which form of the cost data is provided, PowerSimulations.jl will internally transform the data to use the λ-model formulation. See TODO: ADD PSY COST DOCS for more information.","category":"section"},{"location":"formulation_library/Piecewise/#Commitment-formulation","page":"Piecewise Linear Cost","title":"Commitment formulation","text":"With this the standard representation of PWL costs for a thermal unit commitment is given by:\n\nbeginalign*\n min_substackp_t delta_kt\n  sum_t in mathcalT left(sum_k in mathcalK C_kt delta_kt right) Delta t\n  sum_k in mathcalK P_k^textmax delta_kt = p_t  forall t in mathcalT\n  sum_k in mathcalK delta_kt = u_t  forall t in mathcalT\n  P^textmin u_t leq p_t leq P^textmax u_t  forall t in mathcalT\n left delta_1t dots delta_Kt right  in textSOS_2  forall t in mathcalT\nendalign*\n\non which delta_kt in 01 is the interpolation variable, p is the active power of the generator and u in 01 is the commitment variable of the generator. In the case of a PWL convex costs, i.e. increasing slopes, the SOS constraint is omitted.","category":"section"},{"location":"formulation_library/Piecewise/#Dispatch-formulation","page":"Piecewise Linear Cost","title":"Dispatch formulation","text":"beginalign*\n min_substackp_t delta_kt\n  sum_t in mathcalT left(sum_k in mathcalK C_kt delta_kt right) Delta t\n  sum_k in mathcalK P_k^textmax delta_kt = p_t  forall t in mathcalT\n  sum_k in mathcalK delta_kt = texton_t  forall t in mathcalT\n  P^textmin texton_t leq p_t leq P^textmax texton_t  forall t in mathcalT\n left delta_it dots delta_kt right  in textSOS_2  forall t in mathcalT\nendalign*\n\non which delta_kt in 01 is the interpolation variable, p is the active power of the generator and texton in 01 is the parameter that decides if the generator is available or not. In the case of a PWL convex costs, i.e. increasing slopes, the SOS constraint is omitted.","category":"section"},{"location":"formulation_library/Piecewise/#Compact-representation-of-PWL-costs","page":"Piecewise Linear Cost","title":"Compact representation of PWL costs","text":"","category":"section"},{"location":"formulation_library/Piecewise/#Commitment-Formulation","page":"Piecewise Linear Cost","title":"Commitment Formulation","text":"beginalign*\n min_substackp_t delta_kt\n  sum_t in mathcalT left(sum_k in mathcalK C_kt delta_kt right) Delta t\n  sum_k in mathcalK P_k^textmax delta_kt = P^textmin u_t + Delta p_t  forall t in mathcalT\n  sum_k in mathcalK delta_kt = u_t  forall t in mathcalT\n  0 leq Delta p_t leq left( P^textmax - P^textmin right)u_t   forall t in mathcalT\n left delta_it dots delta_kt right  in textSOS_2  forall t in mathcalT\nendalign*\n\non which delta_kt in 01 is the interpolation variable, Delta p is the active power of the generator above the minimum power and u in 01 is the commitment variable of the generator. In the case of a PWL convex costs, i.e. increasing slopes, the SOS constraint is omitted.","category":"section"},{"location":"formulation_library/Piecewise/#Dispatch-formulation-2","page":"Piecewise Linear Cost","title":"Dispatch formulation","text":"beginalign*\n min_substackp_t delta_kt\n  sum_t in mathcalT left(sum_k in mathcalK C_kt delta_kt right) Delta t\n  sum_k in mathcalK P_k^textmax delta_kt = P^textmin texton_t + Delta p_t  forall t in mathcalT\n  sum_k in mathcalK delta_kt = texton_t  forall t in mathcalT\n  0 leq Delta p_t leq left( P^textmax - P^textmin right)texton_t  forall t in mathcalT\n left delta_it dots delta_kt right  in textSOS_2  forall t in mathcalT\nendalign*\n\non which delta_kt in 01 is the interpolation variable,  Delta p is the active power of the generator above the minimum power and u in 01 is the commitment variable of the generator. In the case of a PWL convex costs, i.e. increasing slopes, the SOS constraint is omitted.","category":"section"},{"location":"formulation_library/Source/#Source-Formulations","page":"Source","title":"Source Formulations","text":"Source formulations define the optimization models that describe source or infinite bus units mathematical model in different operational settings, such as economic dispatch and unit commitment.\n\nnote: Note\nThe use of reactive power variables and constraints will depend on the network model used, i.e., whether it uses (or does not use) reactive power. If the network model is purely active power-based,  reactive power variables and related constraints are not created.\n\nnote: Note\nReserve variables for services are not included in the formulation, albeit their inclusion change the variables, expressions, constraints and objective functions created. A detailed description of the implications in the optimization models is described in the Service formulation section.","category":"section"},{"location":"formulation_library/Source/#Table-of-Contents","page":"Source","title":"Table of Contents","text":"ImportExportSourceModel\n\n","category":"section"},{"location":"formulation_library/Source/#ImportExportSourceModel","page":"Source","title":"ImportExportSourceModel","text":"TODO","category":"section"},{"location":"formulation_library/Source/#PowerSimulations.ImportExportSourceModel","page":"Source","title":"PowerSimulations.ImportExportSourceModel","text":"Formulation type to add import and export model for Source\n\n\n\n\n\n","category":"type"},{"location":"how_to/parallel_simulations/#Parallel-Simulations","page":"...run a parallel simulation","title":"Parallel Simulations","text":"This section contains instructions to:\n\nRun a Simulation in Parallel on a local computer\nRun a Simulation in Parallel on an HPC","category":"section"},{"location":"how_to/parallel_simulations/#Run-a-Simulation-in-Parallel-on-a-local-computer","page":"...run a parallel simulation","title":"Run a Simulation in Parallel on a local computer","text":"This page describes how to split a simulation into partitions, run each partition in parallel, and then join the results.","category":"section"},{"location":"how_to/parallel_simulations/#Setup","page":"...run a parallel simulation","title":"Setup","text":"Create a Julia script to build and run simulations. It must meet the requirements below. A full example is in the PowerSimulations repository in test/run_partitioned_simulation.jl.\n\nCall using PowerSimulations.\nImplement a build function that matches the signature below. It must construct a Simulation, call build!, and then return the Simulation instance. It must throw an exception if the build fails.\n\nfunction build_simulation(\n    output_dir::AbstractString,\n    simulation_name::AbstractString,\n    partitions::SimulationPartitions,\n    index::Union{Nothing, Integer}=nothing,\n)\n\nHere is example code to construct the Simulation with these parameters:\n\n    sim = Simulation(\n        name=simulation_name,\n        steps=partitions.num_steps,\n        models=models,\n        sequence=sequence,\n        simulation_folder=output_dir,\n    )\n    status = build!(sim; partitions=partitions, index=index, serialize=isnothing(index))\n    if status != PSI.SimulationBuildStatus.BUILT\n        error(\"Failed to build simulation: status=$status\")\n    end\n\nImplement an execute function that matches the signature below. It must throw an exception if the execute fails.\n\nfunction execute_simulation(sim, args...; kwargs...)\n    status = execute!(sim)\n    if status != PSI.RunStatus.SUCCESSFULLY_FINALIZED\n        error(\"Simulation failed to execute: status=$status\")\n    end\nend","category":"section"},{"location":"how_to/parallel_simulations/#Execution","page":"...run a parallel simulation","title":"Execution","text":"After loading your script, call the function run_parallel_simulation as shown below.\n\nThis example splits a year-long simulation into weekly partitions for a total of 53 individual jobs and then runs them four at a time.\n\njulia> include(\"my_simulation.jl\")\njulia> run_parallel_simulation(\n        build_simulation,\n        execute_simulation,\n        script=\"my_simulation.jl\",\n        output_dir=\"my_simulation_output\",\n        name=\"my_simulation\",\n        num_steps=365,\n        period=7,\n        num_overlap_steps=1,\n        num_parallel_processes=4,\n        exeflags=\"--project=<path-to-your-julia-environment>\",\n    )\n\nThe final results will be in ./my_simulation_otuput/my_simulation\n\nNote the log files and results for each partition are located in ./my_simulation_otuput/my_simulation/simulation_partitions","category":"section"},{"location":"how_to/parallel_simulations/#Run-a-Simulation-in-Parallel-on-an-HPC","page":"...run a parallel simulation","title":"Run a Simulation in Parallel on an HPC","text":"This page describes how to split a simulation into partitions, run each partition in parallel on HPC compute nodes, and then join the results.\n\nThese steps can be used on a local computer or any HPC supported by the submission software. Some steps may be specific to NREL's HPC Eagle cluster.\n\nNote: Some instructions are preliminary and will change if functionality is moved to a new Julia package.","category":"section"},{"location":"how_to/parallel_simulations/#Setup-2","page":"...run a parallel simulation","title":"Setup","text":"Create a conda environment and install the Python package NREL-jade: https://nrel.github.io/jade/installation.html. The rest of this page assumes that the environment is called jade.\nActivate the environment with conda activate jade.\nLocate the path to that conda environment. It will likely be ~/.conda-envs/jade or ~/.conda/envs/jade.\nLoad the Julia environment that you use to run simulations. Add the packages Conda and PyCall.\nSetup Conda to use the existing jade environment by running these commands:\n\njulia> run(`conda create -n conda_jl python conda`)\njulia> ENV[\"CONDA_JL_HOME\"] = joinpath(ENV[\"HOME\"], \".conda-envs\", \"jade\")  # change this to your path\npkg> build Conda\n\nCopy the code below into a Julia file called configure_parallel_simulation.jl. This is an interface to Jade through PyCall. It will be used to create a Jade configuration. (It may eventually be moved to a separate package.)\n\nfunction configure_parallel_simulation(\n    script::AbstractString,\n    num_steps::Integer,\n    num_period_steps::Integer;\n    num_overlap_steps::Integer=0,\n    project_path=nothing,\n    simulation_name=\"simulation\",\n    config_file=\"config.json\",\n    force=false,\n)\n    partitions = SimulationPartitions(num_steps, num_period_steps, num_overlap_steps)\n    jgc = pyimport(\"jade.extensions.generic_command\")\n    julia_cmd = isnothing(project_path) ? \"julia\" : \"julia --project=$project_path\"\n    setup_command = \"$julia_cmd $script setup --simulation-name=$simulation_name \" *\n    \"--num-steps=$num_steps --num-period-steps=$num_period_steps \" *\n    \"--num-overlap-steps=$num_overlap_steps\"\n    teardown_command = \"$julia_cmd $script join --simulation-name=$simulation_name\"\n    config = jgc.GenericCommandConfiguration(\n        setup_command=setup_command,\n        teardown_command=teardown_command,\n    )\n\n    for i in 1:get_num_partitions(partitions)\n        cmd = \"$julia_cmd $script execute --simulation-name=$simulation_name --index=$i\"\n        job = jgc.GenericCommandParameters(command=cmd, name=\"execute-$i\")\n        config.add_job(job)\n    end\n\n    config.dump(config_file, indent=2)\n    println(\"Created Jade configuration in $config_file. \" *\n            \"Run 'jade submit-jobs [options] $config_file' to execute them.\")\nend\n\nCreate a Julia script to build and run simulations. It must meet the requirements below. A full example is in the PowerSimulations repository in test/run_partitioned_simulation.jl.\n\nCall using PowerSimulations.\nImplement a build function that matches the signature below. It must construct a Simulation, call build!, and then return the Simulation instance. It must throw an exception if the build fails.\n\nfunction build_simulation(\n    output_dir::AbstractString,\n    simulation_name::AbstractString,\n    partitions::SimulationPartitions,\n    index::Union{Nothing, Integer}=nothing,\n)\n\nHere is example code to construct the Simulation with these parameters:\n\n    sim = Simulation(\n        name=simulation_name,\n        steps=partitions.num_steps,\n        models=models,\n        sequence=sequence,\n        simulation_folder=output_dir,\n    )\n    status = build!(sim; partitions=partitions, index=index, serialize=isnothing(index))\n    if status != PSI.SimulationBuildStatus.BUILT\n        error(\"Failed to build simulation: status=$status\")\n    end\n\nImplement an execute function that matches the signature below. It must throw an exception if the execute fails.\n\nfunction execute_simulation(sim, args...; kwargs...)\n    status = execute!(sim)\n    if status != PSI.RunStatus.SUCCESSFULLY_FINALIZED\n        error(\"Simulation failed to execute: status=$status\")\n    end\nend\n\nMake the script runnable as a CLI command by including the following code at the bottom of the file.\n\nfunction main()\n    process_simulation_partition_cli_args(build_simulation, execute_simulation, ARGS...)\nend\n\nif abspath(PROGRAM_FILE) == @__FILE__\n    main()\nend","category":"section"},{"location":"how_to/parallel_simulations/#Execution-2","page":"...run a parallel simulation","title":"Execution","text":"Create a Jade configuration that defines the partitioned simulation jobs. Load your Julia environment.\nThis example splits a year-long simulation into weekly partitions for a total of 53 individual jobs.\n\njulia> include(\"configure_parallel_simulation.jl\")\njulia> num_steps = 365\njulia> period = 7\njulia> num_overlap_steps = 1\njulia> configure_parallel_simulation(\n    \"my_simulation.jl\",  # this is your build/execute script\n    num_steps,\n    period,\n    num_overlap_steps=1,\n    project_path=\".\",  # This optionally specifies the Julia project environment to load.\n)\nCreated Jade configuration in config.json. Run 'jade submit-jobs [options] config.json' to execute them.\n\nExit Julia.\n\nView the configuration for accuracy.\n\n$ jade config show config.json\n\nStart an interactive session on a debug node. Do not submit the jobs on a login node! The submission step will run a full build of the simulation and that may consume too many CPU and memory resources for the login node.\n\n$ salloc -t 01:00:00 -N1 --account=<your-account> --partition=debug\n\nFollow the instructions at https://nrel.github.io/jade/tutorial.html to submit the jobs. The example below will configure Jade to run each partition on its own compute node. Depending on the compute and memory constraints of your simulation, you may be able to pack more jobs on each node.\nAdjust the walltime as necessary.\n\n$ jade config hpc -c hpc_config.toml -t slurm  --walltime=04:00:00 -a <your-account>\n$ jade submit-jobs config.json --per-node-batch-size=1 -o output\n\nIf you are unsure about how much memory and CPU resources your simulation consumes, add these options:\n\n$ jade submit-jobs config.json --per-node-batch-size=1 -o output --resource-monitor-type periodic --resource-monitor-interval 3\n\nJade will create HTML plots of the resource utilization in output/stats. You may be able to customize --per-node-batch-size and --num-processes to finish the simulations more quickly.\n\nJade will run a final command to join the simulation partitions into one unified file. You can load the results as you normally would.\n\njulia> results = SimulationResults(\"<output-dir>/job-outputs/<simulation-name>\")\n\nNote the log files and results for each partition are located in <output-dir>/job-outputs/<simulation-name>/simulation_partitions","category":"section"},{"location":"formulation_library/ThermalGen/#ThermalGen-Formulations","page":"Thermal Generation","title":"ThermalGen Formulations","text":"Thermal generation formulations define the optimization models that describe thermal units mathematical model in different operational settings, such as economic dispatch and unit commitment.\n\nnote: Note\nThermal units can include multiple terms added to the objective function, such as no-load cost, turn-on/off cost, fixed cost and variable cost. In addition, variable costs can be linear, quadratic or piecewise-linear formulations. These methods are properly described in the cost function page.\n\nnote: Note\nThe use of reactive power variables and constraints will depend on the network model used, i.e., whether it uses (or does not use) reactive power. If the network model is purely active power-based,  reactive power variables and related constraints are not created.\n\nnote: Note\nReserve variables for services are not included in the formulation, albeit their inclusion change the variables, expressions, constraints and objective functions created. A detailed description of the implications in the optimization models is described in the Service formulation section.","category":"section"},{"location":"formulation_library/ThermalGen/#Table-of-Contents","page":"Thermal Generation","title":"Table of Contents","text":"ThermalBasicDispatch\nThermalDispatchNoMin\nThermalCompactDispatch\nThermalStandardDispatch\nThermalBasicUnitCommitment\nThermalBasicCompactUnitCommitment\nThermalStandardUnitCommitment\nThermalMultiStartUnitCommitment\nValid configurations\n\n","category":"section"},{"location":"formulation_library/ThermalGen/#ThermalBasicDispatch","page":"Thermal Generation","title":"ThermalBasicDispatch","text":"Variables:\n\nActivePowerVariable:\nBounds: [0.0, ]\nSymbol: p^textth\nReactivePowerVariable:\nBounds: [0.0, ]\nSymbol: q^textth\n\nStatic Parameters:\n\nP^textthmin = PowerSystems.get_active_power_limits(device).min\nP^textthmax = PowerSystems.get_active_power_limits(device).max\nQ^textthmin = PowerSystems.get_reactive_power_limits(device).min\nQ^textthmax = PowerSystems.get_reactive_power_limits(device).max\n\nObjective:\n\nAdd a cost to the objective function depending on the defined cost structure of the thermal unit by adding it to its ProductionCostExpression.\n\nExpressions:\n\nAdds p^textth to the ActivePowerBalance expression and q^textth to the ReactivePowerBalance, to be used in the supply-balance constraint depending on the network model used.\n\nConstraints:\n\nFor each thermal unit creates the range constraints for its active and reactive power depending on its static parameters.\n\nbeginalign*\n  P^textthmin le p^textth_t le P^textthmax quad forall tin 1 dots T \n  Q^textthmin le q^textth_t le Q^textthmax quad forall tin 1 dots T \nendalign*\n\n","category":"section"},{"location":"formulation_library/ThermalGen/#ThermalDispatchNoMin","page":"Thermal Generation","title":"ThermalDispatchNoMin","text":"Variables:\n\nActivePowerVariable:\nBounds: [0.0, ]\nSymbol: p^textth\nReactivePowerVariable:\nBounds: [0.0, ]\nSymbol: q^textth\n\nStatic Parameters:\n\nP^textthmax = PowerSystems.get_active_power_limits(device).max\nQ^textthmin = PowerSystems.get_reactive_power_limits(device).min\nQ^textthmax = PowerSystems.get_reactive_power_limits(device).max\n\nObjective:\n\nAdd a cost to the objective function depending on the defined cost structure of the thermal unit by adding it to its ProductionCostExpression.\n\nExpressions:\n\nAdds p^textth to the ActivePowerBalance expression and q^textth to the ReactivePowerBalance, to be used in the supply-balance constraint depending on the network model used.\n\nConstraints:\n\nFor each thermal unit creates the range constraints for its active and reactive power depending on its static parameters.\n\nbeginalign\n  0 le p^textth_t le P^textthmax quad forall tin 1 dots T \n  Q^textthmin le q^textth_t le Q^textthmax quad forall tin 1 dots T \nendalign\n\n","category":"section"},{"location":"formulation_library/ThermalGen/#ThermalCompactDispatch","page":"Thermal Generation","title":"ThermalCompactDispatch","text":"Variables:\n\nPowerAboveMinimumVariable:\nBounds: [0.0, ]\nSymbol: Delta p^textth\nReactivePowerVariable:\nBounds: [0.0, ]\nSymbol: q^textth\n\nAuxiliary Variables:\n\nPowerOutput:\nSymbol: P^textth\nDefinition: P^textth = texton^textthP^textmin + Delta p^textth\n\nStatic Parameters:\n\nP^textthmin = PowerSystems.get_active_power_limits(device).min\nP^textthmax = PowerSystems.get_active_power_limits(device).max\nQ^textthmin = PowerSystems.get_reactive_power_limits(device).min\nQ^textthmax = PowerSystems.get_reactive_power_limits(device).max\nR^textthup = PowerSystems.get_ramp_limits(device).up\nR^textthdn = PowerSystems.get_ramp_limits(device).down\n\nVariable Value Parameters:\n\ntexton^textth: Used in feedforwards to define if the unit is on/off at each time-step from another problem. If no feedforward is used, the parameter takes a {0,1} value if the unit is available or not.\n\nObjective:\n\nAdd a cost to the objective function depending on the defined cost structure of the thermal unit by adding it to its ProductionCostExpression.\n\nExpressions:\n\nAdds texton^textthP^textthmin + Delta p^textth to the ActivePowerBalance expression and q^textth to the ReactivePowerBalance, to be used in the supply-balance constraint depending on the network model used.\n\nConstraints:\n\nFor each thermal unit creates the range constraints for its active and reactive power depending on its static parameters. It also implements ramp constraints for the active power variable.\n\nbeginalign*\n  0 le Delta p^textth_t le texton^textth_tleft(P^textthmax - P^textthminright) quad forall tin 1 dots T \n  texton^textth_t Q^textthmin le q^textth_t le texton^textth_t Q^textthmax quad forall tin 1 dots T  \n -R^textthdn le Delta p_1^textth - Delta p^textth init le R^textthup \n -R^textthdn le Delta p_t^textth - Delta p_t-1^textth le R^textthup quad forall  tin 2 dots T\nendalign*\n\n","category":"section"},{"location":"formulation_library/ThermalGen/#ThermalStandardDispatch","page":"Thermal Generation","title":"ThermalStandardDispatch","text":"Variables:\n\nActivePowerVariable:\nBounds: [0.0, ]\nSymbol: p^textth\nReactivePowerVariable:\nBounds: [0.0, ]\nSymbol: q^textth\n\nIf Slack variables are enabled (use_slacks = true):\n\nRateofChangeConstraintSlackUp:\nBounds: [0.0, ]\nDefault initial value: 0.0\nDefault proportional cost: 2e5\nSymbol: p^textslup\nRateofChangeConstraintSlackDown:\nBounds: [0.0, ]\nDefault initial value: 0.0\nDefault proportional cost: 2e5\nSymbol: p^textsldn\n\nStatic Parameters:\n\nP^textthmin = PowerSystems.get_active_power_limits(device).min\nP^textthmax = PowerSystems.get_active_power_limits(device).max\nQ^textthmin = PowerSystems.get_reactive_power_limits(device).min\nQ^textthmax = PowerSystems.get_reactive_power_limits(device).max\nR^textthup = PowerSystems.get_ramp_limits(device).up\nR^textthdn = PowerSystems.get_ramp_limits(device).down\n\nObjective:\n\nAdd a cost to the objective function depending on the defined cost structure of the thermal unit by adding it to its ProductionCostExpression.\n\nExpressions:\n\nAdds p^textth to the ActivePowerBalance expression and q^textth to the ReactivePowerBalance, to be used in the supply-balance constraint depending on the network model used.\n\nConstraints:\n\nFor each thermal unit creates the range constraints for its active and reactive power depending on its static parameters.\n\nbeginalign*\n  P^textthmin le p^textth_t le P^textthmax quad forall tin 1 dots T \n  Q^textthmin le q^textth_t le Q^textthmax quad forall tin 1 dots T \n p_1^textth - p^textth init - p_1^textslup le R^textthup \n p_t^textth - p_t-1^textth - p_t^textsluple R^textthup quad forall  tin 2 dots T \n -R^textthdn le  p_1^textth - p^textth init + p_1^textsldn \n  -R^textthdn le p_t^textth - p_t-1^textth + p_t^textsldn quad forall  tin 2 dots T \nendalign*\n\n","category":"section"},{"location":"formulation_library/ThermalGen/#ThermalBasicUnitCommitment","page":"Thermal Generation","title":"ThermalBasicUnitCommitment","text":"Variables:\n\nActivePowerVariable:\nBounds: [0.0, ]\nSymbol: p^textth\nReactivePowerVariable:\nBounds: [0.0, ]\nSymbol: q^textth\nOnVariable:\nBounds: 01\nSymbol: u_t^textth\nStartVariable:\nBounds: 01\nSymbol: v_t^textth\nStopVariable:\nBounds: 01\nSymbol: w_t^textth\n\nStatic Parameters:\n\nP^textthmin = PowerSystems.get_active_power_limits(device).min\nP^textthmax = PowerSystems.get_active_power_limits(device).max\nQ^textthmin = PowerSystems.get_reactive_power_limits(device).min\nQ^textthmax = PowerSystems.get_reactive_power_limits(device).max\n\nObjective:\n\nAdd a cost to the objective function depending on the defined cost structure of the thermal unit by adding it to its ProductionCostExpression.\n\nExpressions:\n\nAdds p^textth to the ActivePowerBalance expression and q^textth to the ReactivePowerBalance, to be used in the supply-balance constraint depending on the network model used.\n\nConstraints:\n\nFor each thermal unit creates the range constraints for its active and reactive power depending on its static parameters. In addition, it creates the commitment constraint to turn on/off the device.\n\nbeginalign*\n  u_t^textth P^textthmin le p^textth_t le u_t^textth P^textthmax quad forall tin 1 dots T \n  u_t^textth Q^textthmin le q^textth_t le u_t^textth Q^textthmax quad forall tin 1 dots T \n u_1^textth = u^textthinit + v_1^textth - w_1^textth \n u_t^textth = u_t-1^textth + v_t^textth - w_t^textth quad forall t in 2dotsT \n v_t^textth + w_t^textth le 1 quad forall t in 1dotsT\nendalign*\n\n","category":"section"},{"location":"formulation_library/ThermalGen/#ThermalBasicCompactUnitCommitment","page":"Thermal Generation","title":"ThermalBasicCompactUnitCommitment","text":"Variables:\n\nPowerAboveMinimumVariable:\nBounds: [0.0, ]\nSymbol: Delta p^textth\nReactivePowerVariable:\nBounds: [0.0, ]\nSymbol: q^textth\nOnVariable:\nBounds: 01\nSymbol: u_t^textth\nStartVariable:\nBounds: 01\nSymbol: v_t^textth\nStopVariable:\nBounds: 01\nSymbol: w_t^textth\n\nAuxiliary Variables:\n\nPowerOutput:\nSymbol: P^textth\nDefinition: P^textth = u^textthP^textmin + Delta p^textth\n\nStatic Parameters:\n\nP^textthmin = PowerSystems.get_active_power_limits(device).min\nP^textthmax = PowerSystems.get_active_power_limits(device).max\nQ^textthmin = PowerSystems.get_reactive_power_limits(device).min\nQ^textthmax = PowerSystems.get_reactive_power_limits(device).max\n\nObjective:\n\nAdd a cost to the objective function depending on the defined cost structure of the thermal unit by adding it to its ProductionCostExpression.\n\nExpressions:\n\nAdds u^textthP^textthmin + Delta p^textth to the ActivePowerBalance expression and q^textth to the ReactivePowerBalance, to be used in the supply-balance constraint depending on the network model used.\n\nConstraints:\n\nFor each thermal unit creates the range constraints for its active and reactive power depending on its static parameters. In addition, it creates the commitment constraint to turn on/off the device.\n\nbeginalign*\n  0 le Delta p^textth_t le u^textth_tleft(P^textthmax - P^textthminright) quad forall tin 1 dots T \n  u_t^textth Q^textthmin le q^textth_t le u_t^textth Q^textthmax quad forall tin 1 dots T \n u_1^textth = u^textthinit + v_1^textth - w_1^textth \n u_t^textth = u_t-1^textth + v_t^textth - w_t^textth quad forall t in 2dotsT \n v_t^textth + w_t^textth le 1 quad forall t in 1dotsT\nendalign*\n\n","category":"section"},{"location":"formulation_library/ThermalGen/#ThermalCompactUnitCommitment","page":"Thermal Generation","title":"ThermalCompactUnitCommitment","text":"Variables:\n\nPowerAboveMinimumVariable:\nBounds: [0.0, ]\nSymbol: Delta p^textth\nReactivePowerVariable:\nBounds: [0.0, ]\nSymbol: q^textth\nOnVariable:\nBounds: 01\nSymbol: u_t^textth\nStartVariable:\nBounds: 01\nSymbol: v_t^textth\nStopVariable:\nBounds: 01\nSymbol: w_t^textth\n\nAuxiliary Variables:\n\nPowerOutput:\nSymbol: P^textth\nDefinition: P^textth = u^textthP^textmin + Delta p^textth\nTimeDurationOn:\nSymbol: V_t^textth\nDefinition: Computed post optimization by adding consecutive turned on variable u_t^textth\nTimeDurationOff:\nSymbol: W_t^textth\nDefinition: Computed post optimization by adding consecutive turned off variable 1 - u_t^textth\n\nStatic Parameters:\n\nP^textthmin = PowerSystems.get_active_power_limits(device).min\nP^textthmax = PowerSystems.get_active_power_limits(device).max\nQ^textthmin = PowerSystems.get_reactive_power_limits(device).min\nQ^textthmax = PowerSystems.get_reactive_power_limits(device).max\nR^textthup = PowerSystems.get_ramp_limits(device).up\nR^textthdn = PowerSystems.get_ramp_limits(device).down\nD^textminup = PowerSystems.get_time_limits(device).up\nD^textmindn = PowerSystems.get_time_limits(device).down\n\nObjective:\n\nAdd a cost to the objective function depending on the defined cost structure of the thermal unit by adding it to its ProductionCostExpression.\n\nExpressions:\n\nAdds u^textthP^textthmin + Delta p^textth to the ActivePowerBalance expression and q^textth to the ReactivePowerBalance, to be used in the supply-balance constraint depending on the network model used.\n\nConstraints:\n\nFor each thermal unit creates the range constraints for its active and reactive power depending on its static parameters. It also creates the commitment constraint to turn on/off the device.\n\nbeginalign*\n  0 le Delta p^textth_t le u^textth_tleft(P^textthmax - P^textthminright) quad forall tin 1 dots T \n  u_t^textth Q^textthmin le q^textth_t le u_t^textth Q^textthmax quad forall tin 1 dots T \n -R^textthdn le Delta p_1^textth - Delta p^textth init le R^textthup \n -R^textthdn le Delta p_t^textth - Delta p_t-1^textth le R^textthup quad forall  tin 2 dots T \n u_1^textth = u^textthinit + v_1^textth - w_1^textth \n u_t^textth = u_t-1^textth + v_t^textth - w_t^textth quad forall t in 2dotsT \n v_t^textth + w_t^textth le 1 quad forall t in 1dotsT \nendalign*\n\nIn addition, this formulation adds duration constraints, i.e. minimum-up time and minimum-down time constraints.  The duration constraints are added over the start times looking backwards.\n\nThe duration times D^textminup and D^textmindn are processed to be used in multiple of the time-steps, given the resolution of the specific problem. In addition, parameters D^textinitup and D^textinitdn are used to identify how long the unit was on or off, respectively, before the simulation started.\n\nMinimum up-time constraint for t in 1dots T:\n\nbeginalign*\n  textIf  t leq D^textminup - D^textinitup text and  D^textinitup  0 \n 1 + sum_i=t-D^textminup + 1^t v_i^textth  leq u_t^textth quad text(for  i text in the set of time steps) \n textOtherwise  \n sum_i=t-D^textminup + 1^t v_i^textth leq  u_t^textth \nendalign*\n\nMinimum down-time constraint for t in 1dots T:\n\nbeginalign*\n  textIf  t leq D^textmindn - D^textinitdn text and  D^textinitup  0 \n 1 + sum_i=t-D^textmindn + 1^t w_i^textth leq 1 -  u_t^textth  quad text(for  i text in the set of time steps) \n textOtherwise  \n sum_i=t-D^textmindn + 1^t w_i^textth  leq 1 - u_t^textth\nendalign*\n\n","category":"section"},{"location":"formulation_library/ThermalGen/#ThermalStandardUnitCommitment","page":"Thermal Generation","title":"ThermalStandardUnitCommitment","text":"Variables:\n\nActivePowerVariable:\nBounds: [0.0, ]\nSymbol: p^textth\nReactivePowerVariable:\nBounds: [0.0, ]\nSymbol: q^textth\nOnVariable:\nBounds: 01\nSymbol: u_t^textth\nStartVariable:\nBounds: 01\nSymbol: v_t^textth\nStopVariable:\nBounds: 01\nSymbol: w_t^textth\n\nIf Slack variables are enabled (use_slacks = true):\n\nRateofChangeConstraintSlackUp:\nBounds: [0.0, ]\nDefault initial value: 0.0\nDefault proportional cost: 2e5\nSymbol: p^textslup\nRateofChangeConstraintSlackDown:\nBounds: [0.0, ]\nDefault initial value: 0.0\nDefault proportional cost: 2e5\nSymbol: p^textsldn\n\nAuxiliary Variables:\n\nTimeDurationOn:\nSymbol: V_t^textth\nDefinition: Computed post optimization by adding consecutive turned on variable u_t^textth\nTimeDurationOff:\nSymbol: W_t^textth\nDefinition: Computed post optimization by adding consecutive turned off variable 1 - u_t^textth\n\nStatic Parameters:\n\nP^textthmin = PowerSystems.get_active_power_limits(device).min\nP^textthmax = PowerSystems.get_active_power_limits(device).max\nQ^textthmin = PowerSystems.get_reactive_power_limits(device).min\nQ^textthmax = PowerSystems.get_reactive_power_limits(device).max\nR^textthup = PowerSystems.get_ramp_limits(device).up\nR^textthdn = PowerSystems.get_ramp_limits(device).down\nD^textminup = PowerSystems.get_time_limits(device).up\nD^textmindn = PowerSystems.get_time_limits(device).down\n\nObjective:\n\nAdd a cost to the objective function depending on the defined cost structure of the thermal unit by adding it to its ProductionCostExpression.\n\nExpressions:\n\nAdds p^textth to the ActivePowerBalance expression and q^textth to the ReactivePowerBalance, to be used in the supply-balance constraint depending on the network model used.\n\nConstraints:\n\nFor each thermal unit creates the range constraints for its active and reactive power depending on its static parameters. It also creates the commitment constraint to turn on/off the device.\n\nbeginalign*\n  u^textth_t P^textthmin le  p^textth_t le u^textth_t P^textthmax quad forall tin 1 dots T \n  u_t^textth Q^textthmin le q^textth_t le u_t^textth Q^textthmax quad forall tin 1 dots T \n p_1^textth -  p^textth init - p_1^textslup le R^textthup \n p_t^textth -  p_t-1^textth - p_t^textslup le R^textthup quad forall  tin 2 dots T \n -R^textthdn le p_1^textth -  p^textth init + p_1^textsldn \n -R^textthdn le  p_t^textth -  p_t-1^textth + p_t^textsldn quad forall  tin 2 dots T \n u_1^textth = u^textthinit + v_1^textth - w_1^textth \n u_t^textth = u_t-1^textth + v_t^textth - w_t^textth quad forall t in 2dotsT \n v_t^textth + w_t^textth le 1 quad forall t in 1dotsT \nendalign*\n\nIn addition, this formulation adds duration constraints, i.e. minimum-up time and minimum-down time constraints.  The duration constraints are added over the start times looking backwards.\n\nThe duration times D^textminup and D^textmindn are processed to be used in multiple of the time-steps, given the resolution of the specific problem. In addition, parameters D^textinitup and D^textinitdn are used to identify how long the unit was on or off, respectively, before the simulation started.\n\nMinimum up-time constraint for t in 1dots T:\n\nbeginalign*\n  textIf  t leq D^textminup - D^textinitup text and  D^textinitup  0 \n 1 + sum_i=t-D^textminup + 1^t v_i^textth  leq u_t^textth quad text(for  i text in the set of time steps) \n textOtherwise  \n sum_i=t-D^textminup + 1^t v_i^textth leq  u_t^textth \nendalign*\n\nMinimum down-time constraint for t in 1dots T:\n\nbeginalign*\n  textIf  t leq D^textmindn - D^textinitdn text and  D^textinitup  0 \n 1 + sum_i=t-D^textmindn + 1^t w_i^textth leq 1 -  u_t^textth  quad text(for  i text in the set of time steps) \n textOtherwise  \n sum_i=t-D^textmindn + 1^t w_i^textth  leq 1 - u_t^textth\nendalign*\n\n","category":"section"},{"location":"formulation_library/ThermalGen/#ThermalMultiStartUnitCommitment","page":"Thermal Generation","title":"ThermalMultiStartUnitCommitment","text":"Variables:\n\nPowerAboveMinimumVariable:\nBounds: [0.0, ]\nSymbol: Delta p^textth\nReactivePowerVariable:\nBounds: [0.0, ]\nSymbol: q^textth\nOnVariable:\nBounds: 01\nSymbol: u_t^textth\nStartVariable:\nBounds: 01\nSymbol: v_t^textth\nStopVariable:\nBounds: 01\nSymbol: w_t^textth\nColdStartVariable:\nBounds: 01\nSymbol: x_t^textth\nWarmStartVariable:\nBounds: 01\nSymbol: y_t^textth\nHotStartVariable:\nBounds: 01\nSymbol: z_t^textth\n\nAuxiliary Variables:\n\nPowerOutput:\nSymbol: P^textth\nDefinition: P^textth = u^textthP^textmin + Delta p^textth\nTimeDurationOn:\nSymbol: V_t^textth\nDefinition: Computed post optimization by adding consecutive turned on variable u_t^textth\nTimeDurationOff:\nSymbol: W_t^textth\nDefinition: Computed post optimization by adding consecutive turned off variable 1 - u_t^textth\n\nStatic Parameters:\n\nP^textthmin = PowerSystems.get_active_power_limits(device).min\nP^textthmax = PowerSystems.get_active_power_limits(device).max\nQ^textthmin = PowerSystems.get_reactive_power_limits(device).min\nQ^textthmax = PowerSystems.get_reactive_power_limits(device).max\nR^textthup = PowerSystems.get_ramp_limits(device).up\nR^textthdn = PowerSystems.get_ramp_limits(device).down\nD^textminup = PowerSystems.get_time_limits(device).up\nD^textmindn = PowerSystems.get_time_limits(device).down\nD^textcold = PowerSystems.get_start_time_limits(device).cold\nD^textwarm = PowerSystems.get_start_time_limits(device).warm\nD^texthot = PowerSystems.get_start_time_limits(device).hot\nP^textthstartup = PowerSystems.get_power_trajectory(device).startup\nP^textth shdown = PowerSystems.get_power_trajectory(device).shutdown\n\nObjective:\n\nAdd a cost to the objective function depending on the defined cost structure of the thermal unit by adding it to its ProductionCostExpression.\n\nExpressions:\n\nAdds u^textthP^textthmin + Delta p^textth to the ActivePowerBalance expression and q^textth to the ReactivePowerBalance, to be used in the supply-balance constraint depending on the network model used.\n\nConstraints:\n\nFor each thermal unit creates the range constraints for its active and reactive power depending on its static parameters. It also creates the commitment constraint to turn on/off the device.\n\nbeginalign*\n  0 le Delta p^textth_t le u^textth_tleft(P^textthmax - P^textthminright) quad forall tin 1 dots T \n  u_t^textth Q^textthmin le q^textth_t le u_t^textth Q^textthmax quad forall tin 1 dots T \n -R^textthdn le Delta p_1^textth - Delta p^textth init le R^textthup \n -R^textthdn le Delta p_t^textth - Delta p_t-1^textth le R^textthup quad forall  tin 2 dots T \n u_1^textth = u^textthinit + v_1^textth - w_1^textth \n u_t^textth = u_t-1^textth + v_t^textth - w_t^textth quad forall t in 2dotsT \n v_t^textth + w_t^textth le 1 quad forall t in 1dotsT \n maxP^textthmax - P^textthshdown 0 cdot w_1^textth le u^textthinit (P^textthmax - P^textthmin) - P^textthinit\nendalign*\n\nIn addition, this formulation adds duration constraints, i.e. minimum-up time and minimum-down time constraints.  The duration constraints are added over the start times looking backwards.\n\nThe duration times D^textminup and D^textmindn are processed to be used in multiple of the time-steps, given the resolution of the specific problem. In addition, parameters D^textinitup and D^textinitdn are used to identify how long the unit was on or off, respectively, before the simulation started.\n\nMinimum up-time constraint for t in 1dots T:\n\nbeginalign*\n  textIf  t leq D^textminup - D^textinitup text and  D^textinitup  0 \n 1 + sum_i=t-D^textminup + 1^t v_i^textth  leq u_t^textth quad text(for  i text in the set of time steps) \n textOtherwise  \n sum_i=t-D^textminup + 1^t v_i^textth leq  u_t^textth \nendalign*\n\nMinimum down-time constraint for t in 1dots T:\n\nbeginalign*\n  textIf  t leq D^textmindn - D^textinitdn text and  D^textinitup  0 \n 1 + sum_i=t-D^textmindn + 1^t w_i^textth leq 1 -  u_t^textth  quad text(for  i text in the set of time steps) \n textOtherwise  \n sum_i=t-D^textmindn + 1^t w_i^textth  leq 1 - u_t^textth\nendalign*\n\nFinally, multi temperature start/stop constraints are implemented using the following constraints:\n\nbeginalign*\n v_t^textth = x_t^textth + y_t^textth + z_t^textth quad forall t in 1 dots T \n z_t^textth le sum_i in D^texthot D^textwarm)w_t-i^textth quad forall t in D^textwarm dots T \n y_t^textth le sum_i in D^textwarm D^textcold)w_t-i^textth quad forall t in D^textcold dots T \n (D^textwarm - 1) z_t^textth + (1 - z_t^textth) M^textbig ge sum_i=1^t (1 - u_i^textth) + D^textinithot quad forall t in 1 dots T  \n D^texthot z_t^textth le sum_i=1^t (1 - u_i^textth) +  D^textinithot quad forall t in 1 dots T \n (D^textcold - 1) y_t^textth + (1 - y_t^textth) M^textbig ge sum_i=1^t (1 - u_i^textth) + D^textinitwarm quad forall t in 1 dots T  \n D^textwarm y_t^textth le sum_i=1^t (1 - u_i^textth) +  D^textinitwarm quad forall t in 1 dots T \nendalign*\n\n","category":"section"},{"location":"formulation_library/ThermalGen/#Valid-configurations","page":"Thermal Generation","title":"Valid configurations","text":"Valid DeviceModels for subtypes of ThermalGen include the following:\n\nusing PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.generate_device_formulation_combinations()\nfilter!(x -> x[\"device_type\"] <: ThermalGen, combos)\ncombo_table = DataFrame(\n    \"Valid DeviceModel\" =>\n        [\"`DeviceModel($(c[\"device_type\"]), $(c[\"formulation\"]))`\" for c in combos],\n    \"Device Type\" => [\n        \"[$(c[\"device_type\"])](https://nrel-Sienna.github.io/PowerSystems.jl/stable/model_library/generated_$(c[\"device_type\"])/)\"\n        for c in combos\n    ],\n    \"Formulation\" => [\"[$(c[\"formulation\"])](@ref)\" for c in combos],\n)\nmdtable(combo_table; latex = false)","category":"section"},{"location":"formulation_library/ThermalGen/#PowerSimulations.ThermalBasicDispatch","page":"Thermal Generation","title":"PowerSimulations.ThermalBasicDispatch","text":"Formulation type to enable basic dispatch without any intertemporal (ramp) constraints\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/ThermalGen/#PowerSimulations.ThermalDispatchNoMin","page":"Thermal Generation","title":"PowerSimulations.ThermalDispatchNoMin","text":"Formulation type to enable basic dispatch without any intertemporal constraints and relaxed minimum generation. May not work with non-convex PWL cost definitions\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/ThermalGen/#PowerSimulations.ThermalCompactDispatch","page":"Thermal Generation","title":"PowerSimulations.ThermalCompactDispatch","text":"Formulation type to enable thermal compact dispatch\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/ThermalGen/#PowerSimulations.ThermalStandardDispatch","page":"Thermal Generation","title":"PowerSimulations.ThermalStandardDispatch","text":"Formulation type to enable standard dispatch with a range and enforce intertemporal ramp constraints\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/ThermalGen/#PowerSimulations.ThermalBasicUnitCommitment","page":"Thermal Generation","title":"PowerSimulations.ThermalBasicUnitCommitment","text":"Formulation type to enable basic unit commitment representation without any intertemporal (ramp, min on/off time) constraints\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/ThermalGen/#PowerSimulations.ThermalBasicCompactUnitCommitment","page":"Thermal Generation","title":"PowerSimulations.ThermalBasicCompactUnitCommitment","text":"Formulation type to enable thermal compact commitment without intertemporal (ramp, min on/off time) constraints\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/ThermalGen/#PowerSimulations.ThermalCompactUnitCommitment","page":"Thermal Generation","title":"PowerSimulations.ThermalCompactUnitCommitment","text":"Formulation type to enable thermal compact commitment\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/ThermalGen/#PowerSimulations.ThermalStandardUnitCommitment","page":"Thermal Generation","title":"PowerSimulations.ThermalStandardUnitCommitment","text":"Formulation type to enable standard unit commitment with intertemporal constraints and simplified startup profiles\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/ThermalGen/#PowerSimulations.ThermalMultiStartUnitCommitment","page":"Thermal Generation","title":"PowerSimulations.ThermalMultiStartUnitCommitment","text":"Formulation type to enable pg-lib commitment formulation with startup/shutdown profiles\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/DCModels/#DC-Models-formulations","page":"DC Models formulations","title":"DC Models formulations","text":"note: Note\nMulti-terminal DC models are still in early stages of development and future versions will add a more comprehensive list of formulations\n\n","category":"section"},{"location":"formulation_library/DCModels/#LosslessLine","page":"DC Models formulations","title":"LosslessLine","text":"LosslessLine models are used with PSY.DCBranch models.\n\nVariables:\n\nFlowActivePowerVariable:\nBounds: (R^textminR^textmax)\nSymbol: f\n\nStatic Parameters\n\nR^textfrommin = PowerSystems.get_active_power_limits_from(branch).min\nR^textfrommax = PowerSystems.get_active_power_limits_from(branch).max\nR^texttomin = PowerSystems.get_active_power_limits_to(branch).min\nR^texttomax = PowerSystems.get_active_power_limits_to(branch).max\n\nThen, the minimum and maximum are computed as R^\\text{min} = \\min(R^\\text{from,min}, R^\\text{to,min}) and R^\\text{max} = \\min(R^\\text{from,max}, R^\\text{to,max})\n\nObjective:\n\nNo cost is added to the objective function.\n\nExpressions:\n\nThe variable FlowActivePowerVariable f is added to the nodal balance expression ActivePowerBalance for DC Buses, by adding the flow f in the receiving DC bus and subtracting it from the sending DC bus.\n\nConstraints:\n\nNo constraints are added to the function.\n\n","category":"section"},{"location":"formulation_library/DCModels/#LosslessConverter","page":"DC Models formulations","title":"LosslessConverter","text":"Converters are used to interface the AC Buses with DC Buses.\n\nVariables:\n\nActivePowerVariable:\nBounds: (P^textminP^textmax)\nSymbol: p\n\nStatic Parameters:\n\nP^textmin = PowerSystems.get_active_power_limits(device).min\nP^textmax = PowerSystems.get_active_power_limits(device).max\n\nObjective:\n\nNo cost is added to the objective function.\n\nExpressions:\n\nThe variable ActivePowerVariable p is added positive to the AC balance expression ActivePowerBalance for AC Buses, and added negative to ActivePowerBalance for DC Buses, balancing both sides.\n\nConstraints:\n\nNo constraints are added to the function.","category":"section"},{"location":"formulation_library/DCModels/#PowerSimulations.LosslessLine","page":"DC Models formulations","title":"PowerSimulations.LosslessLine","text":"Lossless Line struct formulation\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/DCModels/#PowerSimulations.LosslessConverter","page":"DC Models formulations","title":"PowerSimulations.LosslessConverter","text":"Lossless InterconnectingConverter Model\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Branch/#PowerSystems.Branch-Formulations","page":"Branch","title":"PowerSystems.Branch Formulations","text":"note: Note\nThe use of reactive power variables and constraints will depend on the network model used, i.e., whether it uses (or does not use) reactive power. If the network model is purely active power-based, reactive power variables and related constraints are not created.","category":"section"},{"location":"formulation_library/Branch/#Table-of-contents","page":"Branch","title":"Table of contents","text":"StaticBranch\nStaticBranchBounds\nStaticBranchUnbounded\nHVDCTwoTerminalUnbounded\nHVDCTwoTerminalLossless\nHVDCTwoTerminalDispatch\nPhaseAngleControl\nTwoTerminalLCCLine\nValid configurations","category":"section"},{"location":"formulation_library/Branch/#StaticBranch","page":"Branch","title":"StaticBranch","text":"Formulation valid for PTDFPowerModel Network model\n\nVariables:\n\nFlowActivePowerVariable:\nBounds: (-inftyinfty)\nSymbol: f If Slack variables are enabled:\nFlowActivePowerSlackUpperBound:\nBounds: [0.0, ]\nDefault proportional cost: 2e5\nSymbol: f^textslup\nFlowActivePowerSlackLowerBound:\nBounds: [0.0, ]\nDefault proportional cost: 2e5\nSymbol: f^textsllo\n\nStatic Parameters\n\nR^textmax = PowerSystems.get_rating(branch)\n\nObjective:\n\nAdd a large proportional cost to the objective function if rate constraint slack variables are used + (f^textslup + f^textsllo) cdot 2 cdot 10^5\n\nExpressions:\n\nNo expressions are used.\n\nConstraints:\n\nFor each branch b in 1dots B (in a system with N buses) the constraints are given by:\n\nbeginaligned\n  f_t = sum_i=1^N textPTDF_ib cdot textBal_it quad forall t in 1dots T\n  f_t - f_t^textslup le R^textmaxquad forall t in 1dots T \n  f_t + f_t^textsllo ge -R^textmaxquad forall t in 1dots T \nendaligned\n\non which textPTDF is the N times B system Power Transfer Distribution Factors (PTDF) matrix, and textBal_it is the active power bus balance expression (i.e. textGeneration_it - textDemand_it) at bus i at time-step t.\n\n","category":"section"},{"location":"formulation_library/Branch/#StaticBranchBounds","page":"Branch","title":"StaticBranchBounds","text":"Formulation valid for PTDFPowerModel Network model\n\nVariables:\n\nFlowActivePowerVariable:\nBounds: left-R^textmaxR^textmaxright\nSymbol: f\n\nStatic Parameters\n\nR^textmax = PowerSystems.get_rating(branch)\n\nObjective:\n\nNo cost is added to the objective function.\n\nExpressions:\n\nNo expressions are used.\n\nConstraints:\n\nFor each branch b in 1dots B (in a system with N buses) the constraints are given by:\n\nbeginaligned\n  f_t = sum_i=1^N textPTDF_ib cdot textBal_it quad forall t in 1dots T\nendaligned\n\non which textPTDF is the N times B system Power Transfer Distribution Factors (PTDF) matrix, and textBal_it is the active power bus balance expression (i.e. textGeneration_it - textDemand_it) at bus i at time-step t.\n\n","category":"section"},{"location":"formulation_library/Branch/#StaticBranchUnbounded","page":"Branch","title":"StaticBranchUnbounded","text":"Formulation valid for PTDFPowerModel Network model\n\nFlowActivePowerVariable:\nBounds: (-inftyinfty)\nSymbol: f\n\nObjective:\n\nNo cost is added to the objective function.\n\nExpressions:\n\nNo expressions are used.\n\nConstraints:\n\nFor each branch b in 1dots B (in a system with N buses) the constraints are given by:\n\nbeginaligned\n  f_t = sum_i=1^N textPTDF_ib cdot textBal_it quad forall t in 1dots T\nendaligned\n\non which textPTDF is the N times B system Power Transfer Distribution Factors (PTDF) matrix, and textBal_it is the active power bus balance expression (i.e. textGeneration_it - textDemand_it) at bus i at time-step t.\n\n","category":"section"},{"location":"formulation_library/Branch/#HVDCTwoTerminalUnbounded","page":"Branch","title":"HVDCTwoTerminalUnbounded","text":"Formulation valid for PTDFPowerModel Network model\n\nThis model assumes that it can transfer power from two AC buses without losses and no limits.\n\nVariables:\n\nFlowActivePowerVariable:\nBounds: left(-inftyinftyright)\nSymbol: f\n\nObjective:\n\nNo cost is added to the objective function.\n\nExpressions:\n\nThe variable FlowActivePowerVariable f is added to the nodal balance expression ActivePowerBalance, by adding the flow f in the receiving bus and subtracting it from the sending bus. This is used then to compute the AC flows using the PTDF equation.\n\nConstraints:\n\nNo constraints are added.\n\n","category":"section"},{"location":"formulation_library/Branch/#HVDCTwoTerminalLossless","page":"Branch","title":"HVDCTwoTerminalLossless","text":"Formulation valid for PTDFPowerModel Network model\n\nThis model assumes that it can transfer power from two AC buses without losses.\n\nVariables:\n\nFlowActivePowerVariable:\nBounds: left(-inftyinftyright)\nSymbol: f\n\nStatic Parameters\n\nR^textfrommin = PowerSystems.get_active_power_limits_from(branch).min\nR^textfrommax = PowerSystems.get_active_power_limits_from(branch).max\nR^texttomin = PowerSystems.get_active_power_limits_to(branch).min\nR^texttomax = PowerSystems.get_active_power_limits_to(branch).max\n\nObjective:\n\nNo cost is added to the objective function.\n\nExpressions:\n\nThe variable FlowActivePowerVariable f is added to the nodal balance expression ActivePowerBalance, by adding the flow f in the receiving bus and subtracting it from the sending bus. This is used then to compute the AC flows using the PTDF equation.\n\nConstraints:\n\nbeginalign*\n  R^textmin le f_t  le R^textmaxquad forall t in 1dots T \nendalign*\n\nwhere:\n\nbeginalign*\n  R^textmin = begincases\n\t\t\tminleft(R^textfrommin R^texttominright)  textif  R^textfrommin ge 0 text and  R^texttomin ge 0 \n      maxleft(R^textfrommin R^texttominright)  textif  R^textfrommin le 0 text and  R^texttomin le 0 \n      R^textfrommin textif  R^textfrommin le 0 text and  R^texttomin ge 0 \n      R^texttomin textif  R^textfrommin ge 0 text and  R^texttomin le 0\n\t\t endcases\nendalign*\n\nand\n\nbeginalign*\n  R^textmax = begincases\n\t\t\tminleft(R^textfrommax R^texttomaxright)  textif  R^textfrommax ge 0 text and  R^texttomax ge 0 \n      maxleft(R^textfrommax R^texttomaxright)  textif  R^textfrommax le 0 text and  R^texttomax le 0 \n      R^textfrommax textif  R^textfrommax le 0 text and  R^texttomax ge 0 \n      R^texttomax textif  R^textfrommax ge 0 text and  R^texttomax le 0\n\t\t endcases\nendalign*\n\n","category":"section"},{"location":"formulation_library/Branch/#HVDCTwoTerminalDispatch","page":"Branch","title":"HVDCTwoTerminalDispatch","text":"Formulation valid for PTDFPowerModel Network model\n\nVariables\n\nFlowActivePowerToFromVariable:\nSymbol: f^textto-from\nFlowActivePowerFromToVariable:\nSymbol: f^textfrom-to\nHVDCLosses:\nSymbol: ell\nHVDCFlowDirectionVariable\nBounds: 01\nSymbol: u^textdir\n\nStatic Parameters\n\nR^textfrommin = PowerSystems.get_active_power_limits_from(branch).min\nR^textfrommax = PowerSystems.get_active_power_limits_from(branch).max\nR^texttomin = PowerSystems.get_active_power_limits_to(branch).min\nR^texttomax = PowerSystems.get_active_power_limits_to(branch).max\nL_0 = PowerSystems.get_loss(branch).l0\nL_1 = PowerSystems.get_loss(branch).l1\n\nObjective:\n\nNo cost is added to the objective function.\n\nExpressions:\n\nEach FlowActivePowerToFromVariable f^textto-from and FlowActivePowerFromToVariable f^textfrom-to  is added to the nodal balance expression ActivePowerBalance, by adding the respective flow in the receiving bus and subtracting it from the sending bus. That is,  f^textto-from adds the flow to the from bus, and subtracts the flow from the to bus, while f^textfrom-to adds the flow to the to bus, and subtracts the flow from the from bus  This is used then to compute the AC flows using the PTDF equation.\n\nIn addition, the HVDCLosses are subtracted to the from bus in the ActivePowerBalance expression.\n\nConstraints:\n\nbeginalign*\n  R^textfrommin le f_t^textfrom-to  le R^textfrommax forall t in 1dots T \n  R^texttomin le f_t^textto-from  le R^texttomaxquad forall t in 1dots T \n f_t^textto-from - f_t^textfrom-to le L_1 cdot f_t^textto-from - L_0quad forall t in 1dots T \n f_t^textfrom-to - f_t^textto-from ge L_1 cdot f_t^textfrom-to + L_0quad forall t in 1dots T \n f_t^textfrom-to - f_t^textto-from ge - M^textbig (1 - u^textdir_t)quad forall t in 1dots T \n f_t^textto-from - f_t^textfrom-to ge - M^textbig u^textdir_tquad forall t in 1dots T \n f_t^textto-from - f_t^textfrom-to le ell_tquad forall t in 1dots T \n f_t^textfrom-to - f_t^textto-from le ell_tquad forall t in 1dots T \nendalign*\n\n","category":"section"},{"location":"formulation_library/Branch/#PhaseAngleControl","page":"Branch","title":"PhaseAngleControl","text":"Formulation valid for PTDFPowerModel Network model\n\nVariables:\n\nFlowActivePowerVariable:\nBounds: (-inftyinfty)\nSymbol: f\nPhaseShifterAngle:\nSymbol: theta^textshift\n\nStatic Parameters\n\nR^textmax = PowerSystems.get_rating(branch)\nTheta^textmin = PowerSystems.get_phase_angle_limits(branch).min\nTheta^textmax = PowerSystems.get_phase_angle_limits(branch).max\nX = PowerSystems.get_x(branch) (series reactance)\n\nObjective:\n\nNo changes to objective function\n\nExpressions:\n\nAdds to the ActivePowerBalance expression the term -theta^textshift X to the from bus and +theta^textshift X to the to bus, that the PhaseShiftingTransformer is connected.\n\nConstraints:\n\nFor each branch b in 1dots B (in a system with N buses) the constraints are given by:\n\nbeginaligned\n  f_t = sum_i=1^N textPTDF_ib cdot textBal_it + fractheta^textshift_tX quad forall t in 1dots T\n  -R^textmax le f_t  le R^textmaxquad forall t in 1dots T \nendaligned\n\non which textPTDF is the N times B system Power Transfer Distribution Factors (PTDF) matrix, and textBal_it is the active power bus balance expression (i.e. textGeneration_it - textDemand_it) at bus i at time-step t.\n\n","category":"section"},{"location":"formulation_library/Branch/#TwoTerminalLCCLine","page":"Branch","title":"TwoTerminalLCCLine","text":"Formulation valid for ACPPowerModel Network model\n\nVariables:\n\n[HVDCRectifierDelayAngleVariable]:\n+ Bounds: ``(-\\alpha_{r,t}^\\text{min},\\alpha_{r,t}^\\text{max})``\n+ Symbol: ``\\alpha_{r,t}``\n[HVDCInverterExtinctionAngleVariable]:\n+ Bounds: ``(-\\gamma_{i,t}^\\text{min},\\gamma_{i,t}^\\text{max})``\n+ Symbol: ``\\gamma_{i,t}``\n[HVDCRectifierPowerFactorAngleVariable]:\n+ Bounds: ``\\{0,1\\}``\n+ Symbol: ``\\phi_{r,t}``\n[HVDCInverterPowerFactorAngleVariable]:\n+ Bounds: ``\\{0,1\\}``\n+ Symbol: ``\\phi_{i,t}``\n[HVDCRectifierOverlapAngleVariable]:\n+ Bounds: [0.0, ]\n+ Symbol: ``\\mu_{r,t}``\n[HVDCInverterOverlapAngleVariable]:\n+ Bounds: [0.0, ]\n+ Symbol: ``\\mu_{i,t}``\n[HVDCRectifierTapSettingVariable]:\n+ Bounds: ``(t_{r,t}^\\text{min},t_{r,t}^\\text{max})``\n+ Symbol: ``t_{r,t}``\n[HVDCInverterTapSettingVariable]:\n+ Bounds: ``(t_{i,t}^\\text{min},t_{i,t}^\\text{max})``\n+ Symbol: ``t_{i,t}``\n[HVDCRectifierDCVoltageVariable]:\n+ Bounds: [0.0, ]\n+ Symbol: ``v_{r,t}^\\text{dc}``\n[HVDCInverterDCVoltageVariable]:\n+ Bounds: [0.0, ]\n+ Symbol: ``v_{i,t}^\\text{dc}``\n[HVDCRectifierACCurrentVariable]:\n+ Bounds: [0.0, ]\n+ Symbol: ``I_{r,t}^\\text{ac}``\n[HVDCInverterACCurrentVariable]:\n+ Bounds: [0.0, ]\n+ Symbol: ``I_{i,t}^\\text{ac}``\n[DCLineCurrentFlowVariable]:\n+ Bounds: [0.0, ]\n+ Symbol: ``I^\\text{dc}``\n[HVDCActivePowerReceivedFromVariable]:\n+ Bounds: [0.0, ]\n+ Symbol: ``p_{r,t}^\\text{ac}``\n[HVDCActivePowerReceivedToVariable]:\n+ Bounds: [0.0, ]\n+ Symbol: ``p_{i,t}^\\text{ac}``\n[HVDCReactivePowerReceivedFromVariable]:\n+ Bounds: [0.0, ]\n+ Symbol: ``q_{r,t}^\\text{ac}``\n[HVDCReactivePowerReceivedToVariable]:\n+ Bounds: [0.0, ]\n+ Symbol: ``q_{i,t}^\\text{ac}``\n\nStatic Parameters\n\nR^textdc = PowerSystems.get_r(lcc)\nN_r = PowerSystems.get_rectifier_bridges(lcc)\nN_i = PowerSystems.get_inverter_bridges(lcc)\nX_r = PowerSystems.get_rectifier_xc(lcc)\nX_i = PowerSystems.get_inverter_xc(lcc)\na_r = PowerSystems.get_rectifier_transformer_ratio(lcc)\na_i = PowerSystems.get_inverter_transformer_ratio(lcc)\nt_r = PowerSystems.get_rectifier_tap_setting(lcc)\nt_i = PowerSystems.get_inverter_tap_setting(lcc)\nt^textmin_r = PowerSystems.get_rectifier_tap_setting(lcc).min\nt^textmax_r = PowerSystems.get_rectifier_tap_setting(lcc).max\nt^textmin_i = PowerSystems.get_inverter_tap_setting(lcc).min\nt^textmax_i = PowerSystems.get_inverter_tap_setting(lcc).max\n\nObjective:\n\nNo changes to objective function\n\nExpressions:\n\nThe variable HVDCActivePowerReceivedFromVariable p_rt^textac is added to the nodal balance expression ActivePowerBalance as a negative load, since the rectifier takes power from the AC system and to injects it into the DC system. On the other hand, the variable HVDCActivePowerReceivedToVariable p_it^textac is added to the nodal balance expression ActivePowerBalance as a positive load, since it takes the power from the DC system and injects it  back into the AC system.\n\nThe variables HVDCReactivePowerReceivedFromVariable q_rt^textac and HVDCReactivePowerReceivedToVariable `q_{i,t}^\\text{ac}are added to the nodal balance expressionActivePowerBalance as positive loads, since they consume reactive power from the AC system to allow current transfer in converters during commutation.\n\nConstraints:\n\nRectifier:\n\nbeginaligned\n  v^textdc_rt = frac3piN_r left( sqrt2fraca_r v^textac_rtt_rtcosalpha_rt-X_r I^textdc_t right)\n mu_rt = arccos left( cosalpha_rt - fracsqrt2 I^textdc_t X_r t_rta_r v^textac_rt right) - alpha_rt\n phi_rt = arctan left( frac2mu_rt + sin(2alpha_rt) - sin(2mu_rt + 2alpha_rt)cos(2alpha_rt) - cos(2mu_rt + 2alpha_rt) right)\nendaligned\n\nWhich can be approximated as:\n\nbeginaligned\n phi_rt = arccos(frac12cosalpha_rt + frac12cos(alpha_rt + mu_rt))\nendaligned\n\nbeginaligned\n I^textac_rt = sqrt6 fracN_rpi I^textdc_t\n p^textac_rt = sqrt3 I^textac_rt fraca_r v^textac_rtt_rtcosphi_rt \n q^textac_rt = sqrt3 I^textac_rt fraca_r v^textac_rtt_rtsinphi_rt \nendaligned\n\nInverter:\n\nbeginaligned\n  v^textdc_it = frac3piN_i left( sqrt2fraca_i v^textac_itt_itcosgamma_it-X_i I^textdc_t right)\n mu_it = arccos left( cosgamma_it - fracsqrt2 I^textdc_t X_i t_ita_i v^textac_it right) - gamma_it\n phi_it = arctan left( frac2mu_it + sin(2gamma_it) - sin(2mu_it + 2gamma_it)cos(2gamma_it) - cos(2mu_rt + 2gamma_it) right)\nendaligned\n\nWhich can be approximated as:\n\nbeginaligned\n phi_it = arccos(frac12cosgamma_it + frac12cos(gamma_it + mu_it))\nendaligned\n\nbeginaligned\n I^textac_it = sqrt6 fracN_ipi I^textdc_t\n p^textac_it = sqrt3 I^textac_it fraca_i v^textac_itt_itcosphi_it \n q^textac_it = sqrt3 I^textac_it fraca_i v^textac_itt_itsinphi_it \nendaligned\n\nDC Transmission Line:\n\nbeginaligned\n  v^textdc_it = v^textdc_rt - R_textdcI^textdc_t\nendaligned\n\n","category":"section"},{"location":"formulation_library/Branch/#Valid-configurations","page":"Branch","title":"Valid configurations","text":"Valid DeviceModels for subtypes of Branch include the following:\n\nusing PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.generate_device_formulation_combinations()\nfilter!(x -> (x[\"device_type\"] <: Branch) && (x[\"device_type\"] != TModelHVDCLine), combos)\ncombo_table = DataFrame(\n    \"Valid DeviceModel\" =>\n        [\"`DeviceModel($(c[\"device_type\"]), $(c[\"formulation\"]))`\" for c in combos],\n    \"Device Type\" => [\n        \"[$(c[\"device_type\"])](https://nrel-Sienna.github.io/PowerSystems.jl/stable/model_library/generated_$(c[\"device_type\"])/)\"\n        for c in combos\n    ],\n    \"Formulation\" => [\"[$(c[\"formulation\"])](@ref)\" for c in combos],\n)\nmdtable(combo_table; latex = false)","category":"section"},{"location":"formulation_library/Branch/#PowerSimulations.StaticBranch","page":"Branch","title":"PowerSimulations.StaticBranch","text":"Branch type to add unbounded flow variables and use flow constraints\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Branch/#PowerSimulations.StaticBranchBounds","page":"Branch","title":"PowerSimulations.StaticBranchBounds","text":"Branch type to add bounded flow variables and use flow constraints\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Branch/#PowerSimulations.StaticBranchUnbounded","page":"Branch","title":"PowerSimulations.StaticBranchUnbounded","text":"Branch type to avoid flow constraints\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Branch/#PowerSimulations.HVDCTwoTerminalUnbounded","page":"Branch","title":"PowerSimulations.HVDCTwoTerminalUnbounded","text":"Branch type to avoid flow constraints\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Branch/#PowerSimulations.HVDCTwoTerminalLossless","page":"Branch","title":"PowerSimulations.HVDCTwoTerminalLossless","text":"Branch type to represent lossless power flow on DC lines\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Branch/#PowerSimulations.HVDCTwoTerminalDispatch","page":"Branch","title":"PowerSimulations.HVDCTwoTerminalDispatch","text":"Branch type to represent lossy power flow on DC lines\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Branch/#PowerSimulations.PhaseAngleControl","page":"Branch","title":"PowerSimulations.PhaseAngleControl","text":"Branch formulation for PhaseShiftingTransformer flow control\n\n\n\n\n\n","category":"type"},{"location":"how_to/problem_templates/#op_problem_template","page":"...create a problem template","title":"Operations ProblemTemplates","text":"Templates are used to specify the modeling properties of the devices and network that are going to he used to specify a problem. A ProblemTemplate is just a collection of DeviceModels that allows the user to specify the formulations of each set of devices (by device type) independently so that the modeler can adjust the level of detail according to the question of interest and the available data. For more information about valid [DeviceModel`](@ref)s and their mathematical representations, check out the Formulation Library.","category":"section"},{"location":"how_to/problem_templates/#Building-a-ProblemTemplate","page":"...create a problem template","title":"Building a ProblemTemplate","text":"You can build a ProblemTemplate by adding a NetworkModel, DeviceModels, and ServiceModels.\n\ntemplate = ProblemTemplate()\nset_network_model!(template, NetworkModel(CopperPlatePowerModel))\nset_device_model!(template, PowerLoad, StaticPowerLoad)\nset_device_model!(template, ThermalStandard, ThermalBasicUnitCommitment)\nset_service_model!(template, VariableReserve{ReserveUp}, RangeReserve)","category":"section"},{"location":"how_to/problem_templates/#Default-Templates","page":"...create a problem template","title":"Default Templates","text":"PowerSimulations.jl provides default templates for common operation problems. You can retrieve a default template and modify it according to your requirements. Currently supported default templates are:\n\nusing PowerSimulations #hide\ntemplate_economic_dispatch()\n\nusing PowerSimulations #hide\ntemplate_unit_commitment()","category":"section"},{"location":"how_to/problem_templates/#PowerSimulations.template_economic_dispatch-how_to-problem_templates","page":"...create a problem template","title":"PowerSimulations.template_economic_dispatch","text":"template_economic_dispatch(; kwargs...) -> ProblemTemplate\n\n\ntemplate_economic_dispatch(; kwargs...)\n\nCreates a ProblemTemplate with default DeviceModels for an Economic Dispatch problem.\n\nExample\n\ntemplate = templateeconomicdispatch()\n\n\n# Accepted Key Words\n- `network::Type{<:PM.AbstractPowerModel}` : override default network model settings\n- `devices::Vector{DeviceModel}` : override default `DeviceModel` settings\n- `services::Vector{ServiceModel}` : override default `ServiceModel` settings\n\n\n\n\n\n","category":"function"},{"location":"how_to/problem_templates/#PowerSimulations.template_unit_commitment-how_to-problem_templates","page":"...create a problem template","title":"PowerSimulations.template_unit_commitment","text":"template_unit_commitment(; kwargs...) -> ProblemTemplate\n\n\ntemplate_unit_commitment(; kwargs...)\n\nCreates a ProblemTemplate with default DeviceModels for a Unit Commitment problem.\n\nExample\n\ntemplate = templateunitcommitment()\n\n\n# Accepted Key Words\n- `network::Type{<:PM.AbstractPowerModel}` : override default network model settings\n- `devices::Vector{DeviceModel}` : override default `DeviceModel` settings\n- `services::Vector{ServiceModel}` : override default `ServiceModel` settings\n\n\n\n\n\n","category":"function"},{"location":"how_to/debugging_infeasible_models/#Debugging-infeasible-models","page":"...debug an infeasible model","title":"Debugging infeasible models","text":"Getting infeasible solutions to models is a common occurrence in operations simulations, there are multiple reasons why this can happen. PowerSimulations.jl has several tools to help debug this situation.","category":"section"},{"location":"how_to/debugging_infeasible_models/#Adding-slacks-to-the-model","page":"...debug an infeasible model","title":"Adding slacks to the model","text":"One of the most common infeasibility issues observed is due to not enough generation to supply demand, or conversely, excessive fixed (non-curtailable) generation in a low demand scenario.\n\nThe recommended solution for any of these cases is adding slack variables to the network model, for example:\n\ntemplate_uc = ProblemTemplate(\n    NetworkModel(\n        CopperPlatePowerModel;\n        use_slacks = true,\n    ),\n)\n\nwill add slack variables to the ActivePowerBalance expression.\n\nIn this case, if the problem is now feasible, the user can check the solution of the variables SystemBalanceSlackUp and SystemBalanceSlackDown, and if one value is greater than zero, it represents that not enough generation (for Slack Up) or not enough demand (for Slack Down) in the optimization problem.","category":"section"},{"location":"how_to/debugging_infeasible_models/#Services-cases","page":"...debug an infeasible model","title":"Services cases","text":"In many scenarios, certain units are also required to provide reserve requirements, e.g. thermal units mandated to provide up-regulation. In such scenarios, it is also possible to add slack variables, by specifying the service model (RangeReserve) for the specific service type (VariableReserve{ReserveUp}) as:\n\nset_service_model!(\n    template_uc,\n    ServiceModel(\n        VariableReserve{ReserveUp},\n        RangeReserve;\n        use_slacks = true,\n    ),\n)\n\nAgain, if the problem is now feasible, check the solution of ReserveRequirementSlack variable, and if it is larger than zero in a specific time-step, then it is evidence that there is not enough reserve available to satisfy the requirement.","category":"section"},{"location":"how_to/debugging_infeasible_models/#Getting-the-infeasibility-conflict","page":"...debug an infeasible model","title":"Getting the infeasibility conflict","text":"Some solvers allows to identify which constraints and variables are producing the infeasibility, by finding the irreducible infeasible set (IIS), that is the subset of constraints and variable bounds that will become feasible if any single constraint or variable bound is removed.\n\nTo enable this feature in PowerSimulations the keyword argument calculate_conflict must be set to true, when creating the DecisionModel. Note that not all solvers allow the computation of the IIS, but most commercial solvers have this capability. It is also recommended to enable the keyword argument store_variable_names=true to help understanding which variables are with infeasibility issues.\n\nThe following code creates a decision model with the Xpress optimizer, and enabling the calculate_conflict=true keyword argument.\n\nDecisionModel(\n    template_ed,\n    sys_rts_rt;\n    name = \"ED\",\n    optimizer = optimizer_with_attributes(Xpress.Optimizer, \"MIPRELSTOP\" => 1e-2),\n    optimizer_solve_log_print = true,\n    calculate_conflict = true,\n    store_variable_names = true,\n)\n\nHere is an example on how the IIS will be displayed as:\n\nError: Constraints participating in conflict basis (IIS) \n│ \n│ ┌──────────────────────────────────────┐\n│ │ CopperPlateBalanceConstraint__System │\n│ ├──────────────────────────────────────┤\n│ │                            (113, 26) │\n│ └──────────────────────────────────────┘\n│ ┌──────────────────────────────────┐\n│ │ EnergyAssetBalance__HybridSystem │\n│ ├──────────────────────────────────┤\n│ │               (\"317_Hybrid\", 26) │\n│ └──────────────────────────────────┘\n│ ┌─────────────────────────────────────────────┐\n│ │ PiecewiseLinearCostConstraint__HybridSystem │\n│ ├─────────────────────────────────────────────┤\n│ │                          (\"317_Hybrid\", 26) │\n│ └─────────────────────────────────────────────┘\n│ ┌────────────────────────────────────────────────┐\n│ │ PiecewiseLinearCostConstraint__ThermalStandard │\n│ ├────────────────────────────────────────────────┤\n│ │                            (\"202_STEAM_3\", 26) │\n│ │                            (\"101_STEAM_3\", 26) │\n│ │                               (\"118_CC_1\", 26) │\n│ │                            (\"202_STEAM_4\", 26) │\n│ │                               (\"315_CT_6\", 26) │\n│ │                            (\"201_STEAM_3\", 26) │\n│ │                            (\"102_STEAM_4\", 26) │\n│ └────────────────────────────────────────────────┘\n│ ┌──────────────────────────────────────────────────────────────────────┐\n│ │ ActivePowerVariableTimeSeriesLimitsConstraint__RenewableDispatch__ub │\n│ ├──────────────────────────────────────────────────────────────────────┤\n│ │                                                   (\"122_WIND_1\", 26) │\n│ │                                                     (\"324_PV_3\", 26) │\n│ │                                                     (\"312_PV_1\", 26) │\n│ │                                                     (\"102_PV_1\", 26) │\n│ │                                                     (\"101_PV_1\", 26) │\n│ │                                                     (\"324_PV_2\", 26) │\n│ │                                                     (\"313_PV_2\", 26) │\n│ │                                                     (\"104_PV_1\", 26) │\n│ │                                                     (\"101_PV_2\", 26) │\n│ │                                                   (\"309_WIND_1\", 26) │\n│ │                                                     (\"310_PV_2\", 26) │\n│ │                                                     (\"113_PV_1\", 26) │\n│ │                                                     (\"314_PV_1\", 26) │\n│ │                                                     (\"324_PV_1\", 26) │\n│ │                                                     (\"103_PV_1\", 26) │\n│ │                                                   (\"303_WIND_1\", 26) │\n│ │                                                     (\"314_PV_2\", 26) │\n│ │                                                     (\"102_PV_2\", 26) │\n│ │                                                     (\"314_PV_3\", 26) │\n│ │                                                     (\"320_PV_1\", 26) │\n│ │                                                     (\"101_PV_3\", 26) │\n│ │                                                     (\"319_PV_1\", 26) │\n│ │                                                     (\"314_PV_4\", 26) │\n│ │                                                     (\"310_PV_1\", 26) │\n│ │                                                     (\"215_PV_1\", 26) │\n│ │                                                     (\"313_PV_1\", 26) │\n│ │                                                     (\"101_PV_4\", 26) │\n│ │                                                     (\"119_PV_1\", 26) │\n│ └──────────────────────────────────────────────────────────────────────┘\n│ ┌─────────────────────────────────────────────────────────────────────────────┐\n│ │ FeedforwardSemiContinuousConstraint__ThermalStandard__ActivePowerVariable_ub │\n│ ├─────────────────────────────────────────────────────────────────────────────┤\n│ │                                                            (\"322_CT_6\", 26) │\n│ │                                                            (\"321_CC_1\", 26) │\n│ │                                                            (\"223_CT_4\", 26) │\n│ │                                                            (\"213_CT_1\", 26) │\n│ │                                                            (\"223_CT_6\", 26) │\n│ │                                                            (\"123_CT_1\", 26) │\n│ │                                                            (\"113_CT_3\", 26) │\n│ │                                                            (\"302_CT_3\", 26) │\n│ │                                                            (\"215_CT_4\", 26) │\n│ │                                                            (\"301_CT_4\", 26) │\n│ │                                                            (\"113_CT_2\", 26) │\n│ │                                                            (\"221_CC_1\", 26) │\n│ │                                                            (\"223_CT_5\", 26) │\n│ │                                                            (\"315_CT_7\", 26) │\n│ │                                                            (\"215_CT_5\", 26) │\n│ │                                                            (\"113_CT_1\", 26) │\n│ │                                                            (\"307_CT_2\", 26) │\n│ │                                                            (\"213_CT_2\", 26) │\n│ │                                                            (\"113_CT_4\", 26) │\n│ │                                                            (\"218_CC_1\", 26) │\n│ │                                                            (\"213_CC_3\", 26) │\n│ │                                                            (\"323_CC_2\", 26) │\n│ │                                                            (\"322_CT_5\", 26) │\n│ │                                                            (\"207_CT_2\", 26) │\n│ │                                                            (\"123_CT_5\", 26) │\n│ │                                                            (\"123_CT_4\", 26) │\n│ │                                                            (\"207_CT_1\", 26) │\n│ │                                                            (\"301_CT_3\", 26) │\n│ │                                                            (\"302_CT_4\", 26) │\n│ │                                                            (\"307_CT_1\", 26) │\n│ └─────────────────────────────────────────────────────────────────────────────┘\n│ ┌───────────────────────────────────────────────────────┐\n│ │ RenewableActivePowerLimitConstraint__HybridSystem__ub │\n│ ├───────────────────────────────────────────────────────┤\n│ │                                    (\"317_Hybrid\", 26) │\n│ └───────────────────────────────────────────────────────┘\n│ ┌───────────────────────────────────────┐\n│ │ ThermalOnVariableUb__HybridSystem__ub │\n│ ├───────────────────────────────────────┤\n│ │                    (\"317_Hybrid\", 26) │\n│ └───────────────────────────────────────┘\n\n Error: Serializing Infeasible Problem at /var/folders/1v/t69qyl0n5059n6c1nn7sp8zm7g8s6z/T/jl_jNSREb/compact_sim/problems/ED/infeasible_ED_2020-10-06T15:00:00.json\n\nNote that the IIS clearly identify that the issue is happening at time step 26, and constraints are related with the CopperPlateBalanceConstraint__System, with multiple upper bound constraints, for the hybrid system, renewable units and thermal units. This highlights that there may not be enough generation in the system. Indeed, by enabling system slacks, the problem become feasible.\n\nFinally, the infeasible model is exported in a json file that can be loaded directly in JuMP to be explored. More information about this is available here.","category":"section"},{"location":"api/PowerSimulations/#API-Reference","page":"Public API","title":"API Reference","text":"Pages = [\"PowerSimulations.md\"]\nDepth = 3\n\n&nbsp;\n&nbsp;","category":"section"},{"location":"api/PowerSimulations/#Device-Models","page":"Public API","title":"Device Models","text":"List of structures and methods for Device models","category":"section"},{"location":"api/PowerSimulations/#Formulations","page":"Public API","title":"Formulations","text":"Refer to the Formulations Page for each Abstract Device Formulation.\n\nHVDC formulations will be moved to its own section in future releases","category":"section"},{"location":"api/PowerSimulations/#HVDC-Formulations","page":"Public API","title":"HVDC Formulations","text":"","category":"section"},{"location":"api/PowerSimulations/#Converter-Formulations","page":"Public API","title":"Converter Formulations","text":"","category":"section"},{"location":"api/PowerSimulations/#DC-Lines-Formulations","page":"Public API","title":"DC Lines Formulations","text":"","category":"section"},{"location":"api/PowerSimulations/#Synchronous-Condenser-Formulations","page":"Public API","title":"Synchronous Condenser Formulations","text":"","category":"section"},{"location":"api/PowerSimulations/#Problem-Templates","page":"Public API","title":"Problem Templates","text":"&nbsp;\n&nbsp;\n\n","category":"section"},{"location":"api/PowerSimulations/#Decision-Models","page":"Public API","title":"Decision Models","text":"&nbsp;\n&nbsp;\n\n","category":"section"},{"location":"api/PowerSimulations/#Emulation-Models","page":"Public API","title":"Emulation Models","text":"&nbsp;\n&nbsp;\n\n","category":"section"},{"location":"api/PowerSimulations/#Service-Models","page":"Public API","title":"Service Models","text":"List of structures and methods for Service models\n\n&nbsp;\n&nbsp;\n\n","category":"section"},{"location":"api/PowerSimulations/#Simulation-Models","page":"Public API","title":"Simulation Models","text":"&nbsp;\n&nbsp;","category":"section"},{"location":"api/PowerSimulations/#Chronology-Models","page":"Public API","title":"Chronology Models","text":"","category":"section"},{"location":"api/PowerSimulations/#Variables","page":"Public API","title":"Variables","text":"For a list of variables for each device refer to its Formulations page.","category":"section"},{"location":"api/PowerSimulations/#Common-Variables","page":"Public API","title":"Common Variables","text":"","category":"section"},{"location":"api/PowerSimulations/#Thermal-Unit-Variables","page":"Public API","title":"Thermal Unit Variables","text":"","category":"section"},{"location":"api/PowerSimulations/#Storage-Unit-Variables","page":"Public API","title":"Storage Unit Variables","text":"","category":"section"},{"location":"api/PowerSimulations/#Branches-and-Network-Variables","page":"Public API","title":"Branches and Network Variables","text":"","category":"section"},{"location":"api/PowerSimulations/#Two-Terminal-and-Multi-Terminal-HVDC-Variables","page":"Public API","title":"Two Terminal and Multi-Terminal HVDC Variables","text":"","category":"section"},{"location":"api/PowerSimulations/#Services-Variables","page":"Public API","title":"Services Variables","text":"","category":"section"},{"location":"api/PowerSimulations/#Feedforward-Variables","page":"Public API","title":"Feedforward Variables","text":"&nbsp;\n&nbsp;\n\n","category":"section"},{"location":"api/PowerSimulations/#Auxiliary-Variables","page":"Public API","title":"Auxiliary Variables","text":"","category":"section"},{"location":"api/PowerSimulations/#Thermal-Unit-Auxiliary-Variables","page":"Public API","title":"Thermal Unit Auxiliary Variables","text":"","category":"section"},{"location":"api/PowerSimulations/#Bus-Auxiliary-Variables","page":"Public API","title":"Bus Auxiliary Variables","text":"","category":"section"},{"location":"api/PowerSimulations/#Branch-Auxiliary-Variables","page":"Public API","title":"Branch Auxiliary Variables","text":"&nbsp;\n&nbsp;\n\n","category":"section"},{"location":"api/PowerSimulations/#Constraints","page":"Public API","title":"Constraints","text":"","category":"section"},{"location":"api/PowerSimulations/#Common-Constraints","page":"Public API","title":"Common Constraints","text":"","category":"section"},{"location":"api/PowerSimulations/#Network-Constraints","page":"Public API","title":"Network Constraints","text":"","category":"section"},{"location":"api/PowerSimulations/#Power-Variable-Limit-Constraints","page":"Public API","title":"Power Variable Limit Constraints","text":"","category":"section"},{"location":"api/PowerSimulations/#Services-Constraints","page":"Public API","title":"Services Constraints","text":"","category":"section"},{"location":"api/PowerSimulations/#Thermal-Unit-Constraints","page":"Public API","title":"Thermal Unit Constraints","text":"","category":"section"},{"location":"api/PowerSimulations/#Renewable-Unit-Constraints","page":"Public API","title":"Renewable Unit Constraints","text":"","category":"section"},{"location":"api/PowerSimulations/#Source-Constraints","page":"Public API","title":"Source Constraints","text":"","category":"section"},{"location":"api/PowerSimulations/#Branches-Constraints","page":"Public API","title":"Branches Constraints","text":"","category":"section"},{"location":"api/PowerSimulations/#Two-Terminal-and-Multi-Terminal-HVDC-Constraints","page":"Public API","title":"Two Terminal and Multi-Terminal HVDC Constraints","text":"","category":"section"},{"location":"api/PowerSimulations/#Contingency-Constraints","page":"Public API","title":"Contingency Constraints","text":"","category":"section"},{"location":"api/PowerSimulations/#Market-Bid-Cost-Constraints","page":"Public API","title":"Market Bid Cost Constraints","text":"","category":"section"},{"location":"api/PowerSimulations/#Feedforward-Constraints","page":"Public API","title":"Feedforward Constraints","text":"&nbsp;\n&nbsp;\n\n","category":"section"},{"location":"api/PowerSimulations/#Parameters","page":"Public API","title":"Parameters","text":"","category":"section"},{"location":"api/PowerSimulations/#Time-Series-Parameters","page":"Public API","title":"Time Series Parameters","text":"","category":"section"},{"location":"api/PowerSimulations/#Variable-Value-Parameters","page":"Public API","title":"Variable Value Parameters","text":"","category":"section"},{"location":"api/PowerSimulations/#Objective-Function-Parameters","page":"Public API","title":"Objective Function Parameters","text":"","category":"section"},{"location":"api/PowerSimulations/#Events-Parameters","page":"Public API","title":"Events Parameters","text":"","category":"section"},{"location":"api/PowerSimulations/#Results","page":"Public API","title":"Results","text":"","category":"section"},{"location":"api/PowerSimulations/#Acessing-Optimization-Model","page":"Public API","title":"Acessing Optimization Model","text":"","category":"section"},{"location":"api/PowerSimulations/#Accessing-Problem-Results","page":"Public API","title":"Accessing Problem Results","text":"","category":"section"},{"location":"api/PowerSimulations/#Accessing-Simulation-Results","page":"Public API","title":"Accessing Simulation Results","text":"","category":"section"},{"location":"api/PowerSimulations/#Simulation-Recorder","page":"Public API","title":"Simulation Recorder","text":"","category":"section"},{"location":"api/PowerSimulations/#PowerSimulations.DeviceModel","page":"Public API","title":"PowerSimulations.DeviceModel","text":"DeviceModel(\n    ::Type{D},\n    ::Type{B},\n    feedforwards::Vector{<:AbstractAffectFeedforward}\n    use_slacks::Bool,\n    duals::Vector{DataType},\n    services::Vector{ServiceModel}\n    attributes::Dict{String, Any}\n)\n\nEstablishes the model for a particular device specified by type. Uses the keyword argument feedforward to enable passing values between operation model at simulation time\n\nArguments\n\n::Type{D} where D<:PSY.Device: Power System Device Type\n::Type{B} where B<:AbstractDeviceFormulation: Abstract Device Formulation\nfeedforward::Array{<:AbstractAffectFeedforward} = Vector{AbstractAffectFeedforward}() : use to pass parameters between models\nuse_slacks::Bool = false : Add slacks to the device model. Implementation is model dependent and not all models feature slacks\nduals::Vector{DataType} = Vector{DataType}(): use to pass constraint type to calculate the duals. The DataType needs to be a valid ConstraintType\ntime_series_names::Dict{Type{<:TimeSeriesParameter}, String} = get_default_time_series_names(D, B) : use to specify time series names associated to the device`\nattributes::Dict{String, Any} = get_default_attributes(D, B) : use to specify attributes to the device\n\nExample\n\nthermal_gens = DeviceModel(ThermalStandard, ThermalBasicUnitCommitment)\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.TransportHVDCNetworkModel","page":"Public API","title":"PowerSimulations.TransportHVDCNetworkModel","text":"Transport Lossless HVDC network model. No DC voltage variables are added and DC lines are modeled as lossless power transport elements\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.VoltageDispatchHVDCNetworkModel","page":"Public API","title":"PowerSimulations.VoltageDispatchHVDCNetworkModel","text":"DC Voltage HVDC network model, where currents are solved based on DC voltage difference between DC buses\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.HVDCTwoTerminalLCC","page":"Public API","title":"PowerSimulations.HVDCTwoTerminalLCC","text":"Branch type to represent non-linear LCC (line commutated converter) model on two-terminal DC lines\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.QuadraticLossConverter","page":"Public API","title":"PowerSimulations.QuadraticLossConverter","text":"Quadratic Loss InterconnectingConverter Model\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.DCLossyLine","page":"Public API","title":"PowerSimulations.DCLossyLine","text":"Lossy Line Abstract Model\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.SynchronousCondenserBasicDispatch","page":"Public API","title":"PowerSimulations.SynchronousCondenserBasicDispatch","text":"Formulation type to add reactive power dispatch variables for SynchronousCondenser\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ProblemTemplate","page":"Public API","title":"PowerSimulations.ProblemTemplate","text":"ProblemTemplate(::Type{T}) where {T<:PM.AbstractPowerFormulation}\n\nCreates a model reference of the PowerSimulations Optimization Problem.\n\nArguments\n\nmodel::Type{T<:PM.AbstractPowerFormulation}:\n\nExample\n\ntemplate = ProblemTemplate(CopperPlatePowerModel)\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.set_device_model!-Tuple{ProblemTemplate, DeviceModel}","page":"Public API","title":"PowerSimulations.set_device_model!","text":"set_device_model!(\n    template::ProblemTemplate,\n    model::DeviceModel\n)\n\n\nSets the device model in a template using a DeviceModel instance\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.set_device_model!-Tuple{ProblemTemplate, Type{<:Device}, Type{<:PowerSimulations.AbstractDeviceFormulation}}","page":"Public API","title":"PowerSimulations.set_device_model!","text":"set_device_model!(\n    template::ProblemTemplate,\n    component_type::Type{<:Device},\n    formulation::Type{<:PowerSimulations.AbstractDeviceFormulation}\n)\n\n\nSets the device model in a template using the component type and formulation. Builds a default DeviceModel\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.set_hvdc_network_model!-Tuple{ProblemTemplate, Union{Nothing, PowerSimulations.AbstractHVDCNetworkModel}}","page":"Public API","title":"PowerSimulations.set_hvdc_network_model!","text":"set_hvdc_network_model!(\n    template::ProblemTemplate,\n    model::Union{Nothing, PowerSimulations.AbstractHVDCNetworkModel}\n)\n\n\nSets the network model in a template.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.set_hvdc_network_model!-Union{Tuple{U}, Tuple{ProblemTemplate, Type{U}}} where U<:PowerSimulations.AbstractHVDCNetworkModel","page":"Public API","title":"PowerSimulations.set_hvdc_network_model!","text":"set_hvdc_network_model!(\n    template::ProblemTemplate,\n    model::Type{U<:PowerSimulations.AbstractHVDCNetworkModel}\n)\n\n\nSets the network model in a template.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.set_network_model!-Tuple{ProblemTemplate, NetworkModel}","page":"Public API","title":"PowerSimulations.set_network_model!","text":"set_network_model!(\n    template::ProblemTemplate,\n    model::NetworkModel\n)\n\n\nSets the network model in a template.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.set_service_model!-Tuple{ProblemTemplate, String, Type{<:Service}, Type{<:PowerSimulations.AbstractServiceFormulation}}","page":"Public API","title":"PowerSimulations.set_service_model!","text":"set_service_model!(\n    template::ProblemTemplate,\n    service_name::String,\n    service_type::Type{<:Service},\n    formulation::Type{<:PowerSimulations.AbstractServiceFormulation}\n)\n\n\nSets the service model in a template using a name and the service type and formulation. Builds a default ServiceModel with useservicename set to true.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.set_service_model!-Tuple{ProblemTemplate, Type{<:Service}, Type{<:PowerSimulations.AbstractServiceFormulation}}","page":"Public API","title":"PowerSimulations.set_service_model!","text":"set_service_model!(\n    template::ProblemTemplate,\n    service_type::Type{<:Service},\n    formulation::Type{<:PowerSimulations.AbstractServiceFormulation}\n)\n\n\nSets the service model in a template using a ServiceModel instance.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.template_economic_dispatch-Tuple{}","page":"Public API","title":"PowerSimulations.template_economic_dispatch","text":"template_economic_dispatch(; kwargs...) -> ProblemTemplate\n\n\ntemplate_economic_dispatch(; kwargs...)\n\nCreates a ProblemTemplate with default DeviceModels for an Economic Dispatch problem.\n\nExample\n\ntemplate = templateeconomicdispatch()\n\n\n# Accepted Key Words\n- `network::Type{<:PM.AbstractPowerModel}` : override default network model settings\n- `devices::Vector{DeviceModel}` : override default `DeviceModel` settings\n- `services::Vector{ServiceModel}` : override default `ServiceModel` settings\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.template_unit_commitment-Tuple{}","page":"Public API","title":"PowerSimulations.template_unit_commitment","text":"template_unit_commitment(; kwargs...) -> ProblemTemplate\n\n\ntemplate_unit_commitment(; kwargs...)\n\nCreates a ProblemTemplate with default DeviceModels for a Unit Commitment problem.\n\nExample\n\ntemplate = templateunitcommitment()\n\n\n# Accepted Key Words\n- `network::Type{<:PM.AbstractPowerModel}` : override default network model settings\n- `devices::Vector{DeviceModel}` : override default `DeviceModel` settings\n- `services::Vector{ServiceModel}` : override default `ServiceModel` settings\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.DecisionModel-Tuple{AbstractString, MathOptInterface.OptimizerWithAttributes}","page":"Public API","title":"PowerSimulations.DecisionModel","text":"DecisionModel(\n    directory::AbstractString,\n    optimizer::MathOptInterface.OptimizerWithAttributes;\n    jump_model,\n    system\n) -> Any\n\n\nConstruct an DecisionProblem from a serialized file.\n\nArguments\n\ndirectory::AbstractString: Directory containing a serialized model\njump_model::Union{Nothing, JuMP.Model} = nothing: The JuMP model does not get serialized. Callers should pass whatever they passed to the original problem.\noptimizer::Union{Nothing,MOI.OptimizerWithAttributes} = nothing: The optimizer does not get serialized. Callers should pass whatever they passed to the original problem.\nsystem::Union{Nothing, PSY.System}: Optionally, the system used for the model. If nothing and systofile was set to true when the model was created, the system will be deserialized from a file.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.DecisionModel-Union{Tuple{M}, Tuple{PowerSimulations.AbstractProblemTemplate, System, PowerSimulations.Settings}, Tuple{PowerSimulations.AbstractProblemTemplate, System, PowerSimulations.Settings, Union{Nothing, JuMP.Model}}} where M<:PowerSimulations.DecisionProblem","page":"Public API","title":"PowerSimulations.DecisionModel","text":"DecisionModel{M}(\n    template::AbstractProblemTemplate,\n    sys::PSY.System,\n    jump_model::Union{Nothing, JuMP.Model}=nothing;\n    kwargs...) where {M<:DecisionProblem}\n\nBuild the optimization problem of type M with the specific system and template.\n\nArguments\n\n::Type{M} where M<:DecisionProblem: The abstract operation model type\ntemplate::AbstractProblemTemplate: The model reference made up of transmission, devices, branches, and services.\nsys::PSY.System: the system created using Power Systems\njump_model::Union{Nothing, JuMP.Model}: Enables passing a custom JuMP model. Use with care\nname = nothing: name of model, string or symbol; defaults to the type of template converted to a symbol.\noptimizer::Union{Nothing,MOI.OptimizerWithAttributes} = nothing : The optimizer does not get serialized. Callers should pass whatever they passed to the original problem.\nhorizon::Dates.Period = UNSET_HORIZON: Manually specify the length of the forecast Horizon\nresolution::Dates.Period = UNSET_RESOLUTION: Manually specify the model's resolution\nwarm_start::Bool = true: True will use the current operation point in the system to initialize variable values. False initializes all variables to zero. Default is true\nsystem_to_file::Bool = true:: True to create a copy of the system used in the model.\ninitialize_model::Bool = true: Option to decide to initialize the model or not.\ninitialization_file::String = \"\": This allows to pass pre-existing initialization values to avoid the solution of an optimization problem to find feasible initial conditions.\ndeserialize_initial_conditions::Bool = false: Option to deserialize conditions\nexport_pwl_vars::Bool = false: True to export all the pwl intermediate variables. It can slow down significantly the build and solve time.\nallow_fails::Bool = false: True to allow the simulation to continue even if the optimization step fails. Use with care.\noptimizer_solve_log_print::Bool = false: Uses JuMP.unset_silent() to print the optimizer's log. By default all solvers are set to MOI.Silent()\ndetailed_optimizer_stats::Bool = false: True to save detailed optimizer stats log.\ncalculate_conflict::Bool = false: True to use solver to calculate conflicts for infeasible problems. Only specific solvers are able to calculate conflicts.\ndirect_mode_optimizer::Bool = false: True to use the solver in direct mode. Creates a JuMP.direct_model.\nstore_variable_names::Bool = false: to store variable names in optimization model. Decreases the build times.\nrebuild_model::Bool = false: It will force the rebuild of the underlying JuMP model with each call to update the model. It increases solution times, use only if the model can't be updated in memory.\ninitial_time::Dates.DateTime = UNSET_INI_TIME: Initial Time for the model solve.\ntime_series_cache_size::Int = IS.TIME_SERIES_CACHE_SIZE_BYTES: Size in bytes to cache for each time array. Default is 1 MiB. Set to 0 to disable.\n\nExample\n\ntemplate = ProblemTemplate(CopperPlatePowerModel, devices, branches, services)\nOpModel = DecisionModel(MockOperationProblem, template, system)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.DecisionModel-Union{Tuple{M}, Tuple{Type{M}, PowerSimulations.AbstractProblemTemplate, System}, Tuple{Type{M}, PowerSimulations.AbstractProblemTemplate, System, Union{Nothing, JuMP.Model}}} where M<:PowerSimulations.DecisionProblem","page":"Public API","title":"PowerSimulations.DecisionModel","text":"DecisionModel(\n    ::Type{M<:PowerSimulations.DecisionProblem},\n    template::PowerSimulations.AbstractProblemTemplate,\n    sys::System;\n    ...\n) -> DecisionModel\nDecisionModel(\n    ::Type{M<:PowerSimulations.DecisionProblem},\n    template::PowerSimulations.AbstractProblemTemplate,\n    sys::System,\n    jump_model::Union{Nothing, JuMP.Model};\n    kwargs...\n) -> DecisionModel\n\n\nBuild the optimization problem of type M with the specific system and template\n\nArguments\n\n::Type{M} where M<:DecisionProblem: The abstract operation model type\ntemplate::AbstractProblemTemplate: The model reference made up of transmission, devices, branches, and services.\nsys::PSY.System: the system created using Power Systems\njump_model::Union{Nothing, JuMP.Model} = nothing: Enables passing a custom JuMP model. Use with care.\n\nExample\n\ntemplate = ProblemTemplate(CopperPlatePowerModel, devices, branches, services)\nproblem = DecisionModel(MyOpProblemType, template, system, optimizer)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.DecisionModel-Union{Tuple{System}, Tuple{M}, Tuple{System, Union{Nothing, JuMP.Model}}} where M<:PowerSimulations.DecisionProblem","page":"Public API","title":"PowerSimulations.DecisionModel","text":"Builds an empty decision model. This constructor is used for the implementation of custom decision models that do not require a template.\n\nArguments\n\n::Type{M} where M<:DecisionProblem: The abstract operation model type\nsys::PSY.System: the system created using Power Systems\njump_model::Union{Nothing, JuMP.Model} = nothing: Enables passing a custom JuMP model. Use with care.\n\nExample\n\nproblem = DecisionModel(system, optimizer)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.GenericOpProblem","page":"Public API","title":"PowerSimulations.GenericOpProblem","text":"Generic PowerSimulations Operation Problem Type for unspecified models\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.build!-Tuple{DecisionModel}","page":"Public API","title":"PowerSimulations.build!","text":"build!(\n    model::DecisionModel;\n    output_dir,\n    recorders,\n    console_level,\n    file_level,\n    disable_timer_outputs\n)\n\n\nBuild the Decision Model based on the specified DecisionProblem.\n\nArguments\n\nmodel::DecisionModel{<:DecisionProblem}: DecisionModel object\noutput_dir::String: Output directory for results\nrecorders::Vector{Symbol} = []: recorder names to register\nconsole_level = Logging.Error:\nfile_level = Logging.Info:\ndisable_timer_outputs = false : Enable/Disable timing outputs\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.solve!-Tuple{DecisionModel}","page":"Public API","title":"PowerSimulations.solve!","text":"solve!(\n    model::DecisionModel;\n    export_problem_results,\n    console_level,\n    file_level,\n    disable_timer_outputs,\n    export_optimization_problem,\n    kwargs...\n) -> InfrastructureSystems.Simulation.RunStatusModule.RunStatus\n\n\nDefault solve method for models that conform to the requirements of DecisionModel{<: DecisionProblem}.\n\nThis will call build! on the model if it is not already built. It will forward all keyword arguments to that function.\n\nArguments\n\nmodel::OperationModel = model: operation model\nexport_problem_results::Bool = false: If true, export OptimizationProblemResults DataFrames to CSV files. Reduces solution times during simulation.\nconsole_level = Logging.Error:\nfile_level = Logging.Info:\ndisable_timer_outputs = false : Enable/Disable timing outputs\nexport_optimization_problem::Bool = true: If true, serialize the model to a file to allow re-execution later.\n\nExamples\n\nresults = solve!(OpModel)\nresults = solve!(OpModel, export_problem_results = true)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.solve!-Tuple{Int64, DecisionModel, Dates.DateTime, PowerSimulations.SimulationStore}","page":"Public API","title":"PowerSimulations.solve!","text":"solve!(\n    step::Int64,\n    model::DecisionModel,\n    start_time::Dates.DateTime,\n    store::PowerSimulations.SimulationStore;\n    exports\n) -> InfrastructureSystems.Simulation.RunStatusModule.RunStatus\n\n\nDefault solve method for a DecisionModel used inside of a Simulation. Solves problems that conform to the requirements of DecisionModel{<: DecisionProblem}\n\nArguments\n\nstep::Int: Simulation Step\nmodel::OperationModel: operation model\nstart_time::Dates.DateTime: Initial Time of the simulation step in Simulation time.\nstore::SimulationStore: Simulation output store\n\nAccepted Key Words\n\nexports: realtime export of output. Use wisely, it can have negative impacts in the simulation times\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.EmulationModel","page":"Public API","title":"PowerSimulations.EmulationModel","text":"EmulationModel{M}(\n    template::AbstractProblemTemplate,\n    sys::PSY.System,\n    jump_model::Union{Nothing, JuMP.Model}=nothing;\n    kwargs...) where {M<:EmulationProblem}\n\nBuild the optimization problem of type M with the specific system and template.\n\nArguments\n\n::Type{M} where M<:EmulationProblem: The abstract Emulation model type\ntemplate::AbstractProblemTemplate: The model reference made up of transmission, devices, branches, and services.\nsys::PSY.System: the system created using Power Systems\njump_model::Union{Nothing, JuMP.Model}: Enables passing a custom JuMP model. Use with care\nname = nothing: name of model, string or symbol; defaults to the type of template converted to a symbol.\noptimizer::Union{Nothing,MOI.OptimizerWithAttributes} = nothing : The optimizer does not get serialized. Callers should pass whatever they passed to the original problem.\nwarm_start::Bool = true: True will use the current operation point in the system to initialize variable values. False initializes all variables to zero. Default is true\nsystem_to_file::Bool = true:: True to create a copy of the system used in the model.\ninitialize_model::Bool = true: Option to decide to initialize the model or not.\ninitialization_file::String = \"\": This allows to pass pre-existing initialization values to avoid the solution of an optimization problem to find feasible initial conditions.\ndeserialize_initial_conditions::Bool = false: Option to deserialize conditions\nexport_pwl_vars::Bool = false: True to export all the pwl intermediate variables. It can slow down significantly the build and solve time.\nallow_fails::Bool = false: True to allow the simulation to continue even if the optimization step fails. Use with care.\ncalculate_conflict::Bool = false: True to use solver to calculate conflicts for infeasible problems. Only specific solvers are able to calculate conflicts.\noptimizer_solve_log_print::Bool = false: Uses JuMP.unset_silent() to print the optimizer's log. By default all solvers are set to MOI.Silent()\ndetailed_optimizer_stats::Bool = false: True to save detailed optimizer stats log.\ndirect_mode_optimizer::Bool = false: True to use the solver in direct mode. Creates a JuMP.direct_model.\nstore_variable_names::Bool = false: True to store variable names in optimization model.\nrebuild_model::Bool = false: It will force the rebuild of the underlying JuMP model with each call to update the model. It increases solution times, use only if the model can't be updated in memory.\ninitial_time::Dates.DateTime = UNSET_INI_TIME: Initial Time for the model solve.\ntime_series_cache_size::Int = IS.TIME_SERIES_CACHE_SIZE_BYTES: Size in bytes to cache for each time array. Default is 1 MiB. Set to 0 to disable.\n\nExample\n\ntemplate = ProblemTemplate(CopperPlatePowerModel, devices, branches, services)\nOpModel = EmulationModel(MockEmulationProblem, template, system)\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.EmulationModel-Tuple{Type{M} where M<:PowerSimulations.EmulationProblem, ProblemTemplate, System, Union{Nothing, JuMP.Model}}","page":"Public API","title":"PowerSimulations.EmulationModel","text":"EmulationModel(\n    ::Type{M<:PowerSimulations.EmulationProblem},\n    template::PowerSimulations.AbstractProblemTemplate,\n    sys::System;\n    ...\n) -> EmulationModel\nEmulationModel(\n    ::Type{M<:PowerSimulations.EmulationProblem},\n    template::PowerSimulations.AbstractProblemTemplate,\n    sys::System,\n    jump_model::Union{Nothing, JuMP.Model};\n    kwargs...\n) -> EmulationModel\n\n\nBuild the optimization problem of type M with the specific system and template\n\nArguments\n\n::Type{M} where M<:EmulationProblem: The abstract Emulation model type\ntemplate::AbstractProblemTemplate: The model reference made up of transmission, devices, branches, and services.\nsys::PSY.System: the system created using Power Systems\njump_model::Union{Nothing, JuMP.Model}: Enables passing a custom JuMP model. Use with care\n\nExample\n\ntemplate = ProblemTemplate(CopperPlatePowerModel, devices, branches, services)\nproblem = EmulationModel(MyEmProblemType, template, system, optimizer)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.EmulationModel-Tuple{AbstractString, MathOptInterface.OptimizerWithAttributes}","page":"Public API","title":"PowerSimulations.EmulationModel","text":"EmulationModel(\n    directory::AbstractString,\n    optimizer::MathOptInterface.OptimizerWithAttributes;\n    jump_model,\n    system,\n    kwargs...\n) -> Any\n\n\nConstruct an EmulationProblem from a serialized file.\n\nArguments\n\ndirectory::AbstractString: Directory containing a serialized model.\noptimizer::MOI.OptimizerWithAttributes: The optimizer does not get serialized. Callers should pass whatever they passed to the original problem.\njump_model::Union{Nothing, JuMP.Model} = nothing: The JuMP model does not get serialized. Callers should pass whatever they passed to the original problem.\nsystem::Union{Nothing, PSY.System}: Optionally, the system used for the model. If nothing and systofile was set to true when the model was created, the system will be deserialized from a file.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.build!-Tuple{EmulationModel}","page":"Public API","title":"PowerSimulations.build!","text":"build!(\n    model::EmulationModel;\n    executions,\n    output_dir,\n    recorders,\n    console_level,\n    file_level,\n    disable_timer_outputs\n)\n\n\nImplementation of build for any EmulationProblem\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.run!-Tuple{EmulationModel}","page":"Public API","title":"PowerSimulations.run!","text":"run!(\n    model::EmulationModel;\n    export_problem_results,\n    console_level,\n    file_level,\n    disable_timer_outputs,\n    export_optimization_model,\n    kwargs...\n) -> InfrastructureSystems.Simulation.RunStatusModule.RunStatus\n\n\nDefault run method for problems that conform to the requirements of EmulationModel{<: EmulationProblem}\n\nThis will call build! on the model if it is not already built. It will forward all keyword arguments to that function.\n\nArguments\n\nmodel::EmulationModel = model: Emulation model\noptimizer::MOI.OptimizerWithAttributes: The optimizer that is used to solve the model\nexecutions::Int: Number of executions for the emulator run\nexport_problem_results::Bool: If true, export OptimizationProblemResults DataFrames to CSV files.\noutput_dir::String: Required if the model is not already built, otherwise ignored\nenable_progress_bar::Bool: Enables/Disable progress bar printing\nexport_optimization_model::Bool: If true, serialize the model to a file to allow re-execution later.\n\nExamples\n\nstatus = run!(model; optimizer = HiGHS.Optimizer, executions = 10)\nstatus = run!(model; output_dir = ./model_output, optimizer = HiGHS.Optimizer, executions = 10)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.solve!-Tuple{Int64, EmulationModel, Dates.DateTime, PowerSimulations.SimulationStore}","page":"Public API","title":"PowerSimulations.solve!","text":"solve!(\n    step::Int64,\n    model::EmulationModel,\n    start_time::Dates.DateTime,\n    store::PowerSimulations.SimulationStore;\n    exports\n) -> InfrastructureSystems.Simulation.RunStatusModule.RunStatus\n\n\nDefault solve method for an EmulationModel used inside of a Simulation. Solves problems that conform to the requirements of DecisionModel{<: DecisionProblem}\n\nArguments\n\nstep::Int: Simulation Step\nmodel::OperationModel: operation model\nstart_time::Dates.DateTime: Initial Time of the simulation step in Simulation time.\nstore::SimulationStore: Simulation output store\nexports = nothing: realtime export of output. Use wisely, it can have negative impacts in the simulation times\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.ServiceModel","page":"Public API","title":"PowerSimulations.ServiceModel","text":"Establishes the model for a particular services specified by type. Uses the keyword argument use_service_name to assign the model to a service with the same name as the name in the template. Uses the keyword argument feedforward to enable passing values between operation model at simulation time\n\nArguments\n\n-::Type{D}: Power System Service Type -::Type{B}: Abstract Service Formulation\n\nAccepted Key Words\n\nfeedforward::Array{<:AbstractAffectFeedforward} : use to pass parameters between models\nuse_service_name::Bool : use the name as the name for the service\n\nExample\n\nreserves = ServiceModel(PSY.VariableReserve{PSY.ReserveUp}, RangeReserve)\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.InitialCondition","page":"Public API","title":"PowerSimulations.InitialCondition","text":"Container for the initial condition data\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.SimulationModels","page":"Public API","title":"PowerSimulations.SimulationModels","text":"SimulationModels(\n    decision_models::Vector{<:DecisionModel},\n    emulation_models::Union{Nothing, EmulationModel}\n)\n\nStores the OperationProblem definitions to be used in the simulation. When creating the SimulationModels, the order in which the models are created determines the order on which the simulation is executed.\n\nArguments\n\ndecision_models::Vector{<:DecisionModel}: Vector of decision models.\nemulation_models::Union{Nothing, EmulationModel}: Optional argument to include\n\nan EmulationModel in the Simulation\n\nExample\n\ntemplate_uc = template_unit_commitment()\ntemplate_ed = template_economic_dispatch()\nmy_decision_model_uc = DecisionModel(template_1, sys_uc, optimizer, name = \"UC\")\nmy_decision_model_ed = DecisionModel(template_ed, sys_ed, optimizer, name = \"ED\")\nmodels = SimulationModels(\n    decision_models = [\n        my_decision_model_uc,\n        my_decision_model_ed\n    ]\n)\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.SimulationSequence","page":"Public API","title":"PowerSimulations.SimulationSequence","text":"SimulationSequence(\n    models::SimulationModels,\n    feedforward::Dict{String, Vector{<:AbstractAffectFeedforward}}\n    ini_cond_chronology::InitialConditionChronology\n)\n\nConstruct the simulation sequence between decision and emulation models.\n\nArguments\n\nmodels::SimulationModels: Vector of decisions and emulation models.\nfeedforward = Dict{String, Vector{<:AbstractAffectFeedforward}}(): Optional dictionary to specify how information and variables are exchanged between decision and emulation models.\nini_cond_chronology::InitialConditionChronology =  InterProblemChronology(): Define information sharing model between stages with InterProblemChronology\n\nExample\n\ntemplate_uc = template_unit_commitment()\ntemplate_ed = template_economic_dispatch()\nmy_decision_model_uc = DecisionModel(template_1, sys_uc, optimizer, name = \"UC\")\nmy_decision_model_ed = DecisionModel(template_ed, sys_ed, optimizer, name = \"ED\")\nmodels = SimulationModels(\n    decision_models = [\n        my_decision_model_uc,\n        my_decision_model_ed\n    ]\n)\n# The following sequence set the commitment variables (`OnVariable`) for `ThermalStandard` units from UC to ED.\nsequence = SimulationSequence(;\n    models = models,\n    feedforwards = Dict(\n        \"ED\" => [\n            SemiContinuousFeedforward(;\n                component_type = ThermalStandard,\n                source = OnVariable,\n                affected_values = [ActivePowerVariable],\n            ),\n        ],\n    ),\n)\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.Simulation","page":"Public API","title":"PowerSimulations.Simulation","text":"Simulation(\n    sequence::SimulationSequence,\n    name::String,\n    steps::Int\n    models::SimulationModels,\n    simulation_folder::String,\n    initial_time::Union{Nothing, Dates.DateTime}\n)\n\nConstruct the Simulation structure to run the sequence of decision and emulation models specified.\n\nArguments\n\nsequence::SimulationSequence: Simulation sequence that specify how the decision and emulation models will be executed.\nname::String: Name of the Simulation\nsteps::Int: Number of steps on which the sequence of models will be executed\nmodels::SimulationModels: List of Decision and Emulation Models\nsimulation_folder::String: Folder on which results will be stored\ninitial_time::Union{Nothing, Dates.DateTime} = nothing: Initial time of which the simulation starts. If nothing it will default to the first timestamp of time series of the system.\n\nExample\n\ntemplate_uc = template_unit_commitment()\ntemplate_ed = template_economic_dispatch()\nmy_decision_model_uc = DecisionModel(template_1, sys_uc, optimizer, name = \"UC\")\nmy_decision_model_ed = DecisionModel(template_ed, sys_ed, optimizer, name = \"ED\")\nmodels = SimulationModels(\n    decision_models = [\n        my_decision_model_uc,\n        my_decision_model_ed\n    ]\n)\n# The following sequence set the commitment variables (`OnVariable`) for `ThermalStandard` units from UC to ED.\nsequence = SimulationSequence(;\n    models = models,\n    feedforwards = Dict(\n        \"ED\" => [\n            SemiContinuousFeedforward(;\n                component_type = ThermalStandard,\n                source = OnVariable,\n                affected_values = [ActivePowerVariable],\n            ),\n        ],\n    ),\n)\n\nsim = Simulation(\n    sequence = sequence,\n    name = \"Sim\",\n    steps = 5,\n    models = models,\n    simulation_folder = mktempdir(cleanup=true),\n)\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.Simulation-Tuple{AbstractString, Dict}","page":"Public API","title":"PowerSimulations.Simulation","text":"Simulation(directory::AbstractString, model_info::Dict)\n\n\nConstructs Simulation from a serialized directory. Callers should pass any kwargs here that they passed to the original Simulation.\n\nArguments\n\ndirectory::AbstractString: the directory returned from the call to serialize\nmodel_info::Dict: Two-level dictionary containing model parameters that cannot be serialized. The outer dict should be keyed by the problem name. The inner dict must contain 'optimizer' and may contain 'jump_model'. These should be the same values used for the original simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.build!-Tuple{Simulation}","page":"Public API","title":"PowerSimulations.build!","text":"build!(\n    sim::Simulation;\n    recorders,\n    console_level,\n    file_level,\n    serialize,\n    partitions,\n    index\n) -> InfrastructureSystems.Simulation.SimulationBuildStatusModule.SimulationBuildStatus\n\n\nBuild the Simulation, problems and the related folder structure.\n\nArguments\n\nsim::Simulation: simulation object\nrecorders::Vector{Symbol} = []: recorder names to register\nserialize::Bool = true: serializes the simulation objects in the simulation\nconsole_level = Logging.Error:\nfile_level = Logging.Info:\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.execute!-Tuple{Simulation}","page":"Public API","title":"PowerSimulations.execute!","text":"execute!(\n    sim::Simulation;\n    kwargs...\n) -> InfrastructureSystems.Simulation.RunStatusModule.RunStatus\n\n\nSolves the simulation model for sequential Simulations.\n\nArguments\n\nsim::Simulation=sim: simulation object created by Simulation()\n\nThe optional keyword argument exports controls exporting of results to CSV files as the simulation runs.\n\nExample\n\nsim = Simulation(\"Test\", 7, problems, \"/Users/folder\")\nexecute!(sim::Simulation; kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.SimulationPartitions","page":"Public API","title":"PowerSimulations.SimulationPartitions","text":"Defines how a simulation can be partition into partitions and run in parallel.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.get_num_partitions-Tuple{SimulationPartitions}","page":"Public API","title":"PowerSimulations.get_num_partitions","text":"get_num_partitions(x::SimulationPartitions) -> Int64\n\n\nReturn the number of partitions in the simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.run_parallel_simulation-Tuple{Any, Any}","page":"Public API","title":"PowerSimulations.run_parallel_simulation","text":"run_parallel_simulation(\n    build_function,\n    execute_function;\n    script,\n    output_dir,\n    name,\n    num_steps,\n    period,\n    num_overlap_steps,\n    num_parallel_processes,\n    exeflags,\n    force\n)\n\n\nRun a partitioned simulation in parallel on a local computer.\n\nArguments\n\nbuild_function: Function reference that returns a built Simulation.\nexecute_function: Function reference that executes a Simulation.\nscript::AbstractString: Path to script that includes build_function and execute_function.\noutput_dir::AbstractString: Path for simulation outputs\nname::AbstractString: Simulation name\nnum_steps::Integer: Total number of steps in the simulation\nperiod::Integer: Number of steps in each simulation partition\nnum_overlap_steps::Integer: Number of steps that each partition overlaps with the previous partition\nnum_parallel_processes: Number of partitions to run in parallel. If nothing, use the number of cores.\nexeflags: Path to Julia project. Forwarded to Distributed.addprocs.\nforce: Overwrite the output directory if it already exists.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.InterProblemChronology","page":"Public API","title":"PowerSimulations.InterProblemChronology","text":"InterProblemChronology()\n\nType struct to select an information sharing model between stages that uses results from the most recent stage executed to calculate the initial conditions. This model takes into account solutions from stages defined with finer temporal resolutions\n\nSee also: IntraProblemChronology\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.IntraProblemChronology","page":"Public API","title":"PowerSimulations.IntraProblemChronology","text":"IntraProblemChronology()\n\nType struct to select an information sharing model between stages that uses results from the same recent stage to calculate the initial conditions. This model ignores solutions from stages defined with finer temporal resolutions.\n\nSee also: InterProblemChronology\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ActivePowerVariable","page":"Public API","title":"PowerSimulations.ActivePowerVariable","text":"Struct to dispatch the creation of Active Power Variables\n\nDocs abbreviation: p\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ReactivePowerVariable","page":"Public API","title":"PowerSimulations.ReactivePowerVariable","text":"Struct to dispatch the creation of Reactive Power Variables\n\nDocs abbreviation: q\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.PiecewiseLinearCostVariable","page":"Public API","title":"PowerSimulations.PiecewiseLinearCostVariable","text":"Struct to dispatch the creation of piecewise linear cost variables for objective function\n\nDocs abbreviation: delta\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.RateofChangeConstraintSlackUp","page":"Public API","title":"PowerSimulations.RateofChangeConstraintSlackUp","text":"Struct to dispatch the creation of Slack variables for rate of change constraints up limits\n\nDocs abbreviation: p^textslup\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.RateofChangeConstraintSlackDown","page":"Public API","title":"PowerSimulations.RateofChangeConstraintSlackDown","text":"Struct to dispatch the creation of Slack variables for rate of change constraints down limits\n\nDocs abbreviation: p^textsldn\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.PostContingencyActivePowerChangeVariable","page":"Public API","title":"PowerSimulations.PostContingencyActivePowerChangeVariable","text":"Struct to dispatch the creation of Post-Contingency Active Power Change Variables.\n\nDocs abbreviation: Delta p_gc\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.OnVariable","page":"Public API","title":"PowerSimulations.OnVariable","text":"Struct to dispatch the creation of a binary commitment status variable\n\nDocs abbreviation: u\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.StartVariable","page":"Public API","title":"PowerSimulations.StartVariable","text":"Struct to dispatch the creation of Binary Start Variables\n\nDocs abbreviation: v\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.StopVariable","page":"Public API","title":"PowerSimulations.StopVariable","text":"Struct to dispatch the creation of Binary Stop Variables\n\nDocs abbreviation: w\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.HotStartVariable","page":"Public API","title":"PowerSimulations.HotStartVariable","text":"Struct to dispatch the creation of Hot Start Variable for Thermal units with temperature considerations\n\nDocs abbreviation: z^textth\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.WarmStartVariable","page":"Public API","title":"PowerSimulations.WarmStartVariable","text":"Struct to dispatch the creation of Warm Start Variable for Thermal units with temperature considerations\n\nDocs abbreviation: y^textth\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ColdStartVariable","page":"Public API","title":"PowerSimulations.ColdStartVariable","text":"Struct to dispatch the creation of Cold Start Variable for Thermal units with temperature considerations\n\nDocs abbreviation: x^textth\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.PowerAboveMinimumVariable","page":"Public API","title":"PowerSimulations.PowerAboveMinimumVariable","text":"Struct to dispatch the creation of Active Power Variables above minimum power for Thermal Compact formulations\n\nDocs abbreviation: Delta p\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ReservationVariable","page":"Public API","title":"PowerSimulations.ReservationVariable","text":"Struct to dispatch the creation of binary storage charge reservation variable\n\nDocs abbreviation: u^textst\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.EnergyVariable","page":"Public API","title":"PowerSimulations.EnergyVariable","text":"Struct to dispatch the creation of a variable for energy storage level (state of charge)\n\nDocs abbreviation: e\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ActivePowerOutVariable","page":"Public API","title":"PowerSimulations.ActivePowerOutVariable","text":"Struct to dispatch the creation of Active Power Output Variables for 2-directional devices. For instance storage or pump-hydro\n\nDocs abbreviation: p^textout\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ActivePowerInVariable","page":"Public API","title":"PowerSimulations.ActivePowerInVariable","text":"Struct to dispatch the creation of Active Power Input Variables for 2-directional devices. For instance storage or pump-hydro\n\nDocs abbreviation: p^textin\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.FlowActivePowerVariable","page":"Public API","title":"PowerSimulations.FlowActivePowerVariable","text":"Struct to dispatch the creation of bidirectional Active Power Flow Variables\n\nDocs abbreviation: f\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.FlowActivePowerSlackUpperBound","page":"Public API","title":"PowerSimulations.FlowActivePowerSlackUpperBound","text":"Struct to dispatch the creation of active power flow upper bound slack variables. Used when there is not enough flow through the branch in the forward direction.\n\nDocs abbreviation: f^textslup\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.FlowActivePowerSlackLowerBound","page":"Public API","title":"PowerSimulations.FlowActivePowerSlackLowerBound","text":"Struct to dispatch the creation of active power flow lower bound slack variables. Used when there is not enough flow through the branch in the reverse direction.\n\nDocs abbreviation: f^textsllo\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.FlowActivePowerFromToVariable","page":"Public API","title":"PowerSimulations.FlowActivePowerFromToVariable","text":"Struct to dispatch the creation of unidirectional Active Power Flow Variables\n\nDocs abbreviation: f^textfrom-to\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.FlowActivePowerToFromVariable","page":"Public API","title":"PowerSimulations.FlowActivePowerToFromVariable","text":"Struct to dispatch the creation of unidirectional Active Power Flow Variables\n\nDocs abbreviation: f^textto-from\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.FlowReactivePowerFromToVariable","page":"Public API","title":"PowerSimulations.FlowReactivePowerFromToVariable","text":"Struct to dispatch the creation of unidirectional Reactive Power Flow Variables\n\nDocs abbreviation: f^textqfrom-to\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.FlowReactivePowerToFromVariable","page":"Public API","title":"PowerSimulations.FlowReactivePowerToFromVariable","text":"Struct to dispatch the creation of unidirectional Reactive Power Flow Variables\n\nDocs abbreviation: f^textqto-from\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.PhaseShifterAngle","page":"Public API","title":"PowerSimulations.PhaseShifterAngle","text":"Struct to dispatch the creation of Phase Shifters Variables\n\nDocs abbreviation: theta^textshift\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.HVDCLosses","page":"Public API","title":"PowerSimulations.HVDCLosses","text":"Struct to dispatch the creation of HVDC Losses Auxiliary Variables\n\nDocs abbreviation: ell\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.HVDCFlowDirectionVariable","page":"Public API","title":"PowerSimulations.HVDCFlowDirectionVariable","text":"Struct to dispatch the creation of HVDC Flow Direction Auxiliary Variables\n\nDocs abbreviation: u^textdir\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.VoltageMagnitude","page":"Public API","title":"PowerSimulations.VoltageMagnitude","text":"Struct to dispatch the creation of Voltage Magnitude Variables for AC formulations\n\nDocs abbreviation: v\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.VoltageAngle","page":"Public API","title":"PowerSimulations.VoltageAngle","text":"Struct to dispatch the creation of Voltage Angle Variables for AC/DC formulations\n\nDocs abbreviation: theta\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.InterpolationBinarySquaredCurrentVariable","page":"Public API","title":"PowerSimulations.InterpolationBinarySquaredCurrentVariable","text":"Struct to dispatch the creation of Binary Interpolation Variable for Squared Converter Current\n\nDocs abbreviation: z_c^i\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.SquaredDCVoltage","page":"Public API","title":"PowerSimulations.SquaredDCVoltage","text":"Struct to dispatch the creation of Squared Voltage Variables for DC formulations Docs abbreviation: v^sqdc\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.DCLineCurrent","page":"Public API","title":"PowerSimulations.DCLineCurrent","text":"Struct to dispatch the variable of DC Current Variables for DC Lines formulations Docs abbreviation: i_l^dc\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.InterpolationSquaredVoltageVariable","page":"Public API","title":"PowerSimulations.InterpolationSquaredVoltageVariable","text":"Struct to dispatch the creation of Continuous Interpolation Variable for Squared Converter Voltage\n\nDocs abbreviation: delta_c^v\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.InterpolationBinarySquaredVoltageVariable","page":"Public API","title":"PowerSimulations.InterpolationBinarySquaredVoltageVariable","text":"Struct to dispatch the creation of Binary Interpolation Variable for Squared Converter Voltage\n\nDocs abbreviation: z_c^v\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.AuxBilinearConverterVariable","page":"Public API","title":"PowerSimulations.AuxBilinearConverterVariable","text":"Struct to dispatch the creation of Auxiliary Variable for Converter Bilinear term: v * i Docs abbreviation: gamma_c^dc\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.AuxBilinearSquaredConverterVariable","page":"Public API","title":"PowerSimulations.AuxBilinearSquaredConverterVariable","text":"Struct to dispatch the creation of Auxiliary Variable for Squared Converter Bilinear term: v * i\n\nDocs abbreviation: gamma_c^sqdc\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.InterpolationSquaredBilinearVariable","page":"Public API","title":"PowerSimulations.InterpolationSquaredBilinearVariable","text":"Struct to dispatch the creation of Continuous Interpolation Variable for Squared Converter AuxVar\n\nDocs abbreviation: delta_c^gamma\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.InterpolationBinarySquaredBilinearVariable","page":"Public API","title":"PowerSimulations.InterpolationBinarySquaredBilinearVariable","text":"Struct to dispatch the creation of Binary Interpolation Variable for Squared Converter AuxVar\n\nDocs abbreviation: z_c^gamma\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.InterpolationSquaredCurrentVariable","page":"Public API","title":"PowerSimulations.InterpolationSquaredCurrentVariable","text":"Struct to dispatch the creation of Continuous Interpolation Variable for Squared Converter Current\n\nDocs abbreviation: delta_c^i\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.DCVoltage","page":"Public API","title":"PowerSimulations.DCVoltage","text":"Struct to dispatch the creation of Voltage Variables for DC formulations Docs abbreviation: v^dc\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ConverterCurrent","page":"Public API","title":"PowerSimulations.ConverterCurrent","text":"Struct to dispatch the creation of DC Converter Current Variables for DC formulations Docs abbreviation: i_c^dc\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.SquaredConverterCurrent","page":"Public API","title":"PowerSimulations.SquaredConverterCurrent","text":"Struct to dispatch the creation of Squared DC Converter Current Variables for DC formulations Docs abbreviation: i_c^sqdc\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ConverterPositiveCurrent","page":"Public API","title":"PowerSimulations.ConverterPositiveCurrent","text":"Struct to dispatch the creation of DC Converter Positive Term Current Variables for DC formulations Docs abbreviation: i_c^+dc\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ConverterNegativeCurrent","page":"Public API","title":"PowerSimulations.ConverterNegativeCurrent","text":"Struct to dispatch the creation of DC Converter Negative Term Current Variables for DC formulations Docs abbreviation: i_c^-dc\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ConverterPowerDirection","page":"Public API","title":"PowerSimulations.ConverterPowerDirection","text":"Struct to dispatch the creation of Binary Variable for Converter Power Direction Docs abbreviation: kappa_c^dc\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ActivePowerReserveVariable","page":"Public API","title":"PowerSimulations.ActivePowerReserveVariable","text":"Struct to dispatch the creation of Active Power Reserve Variables\n\nDocs abbreviation: r\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ServiceRequirementVariable","page":"Public API","title":"PowerSimulations.ServiceRequirementVariable","text":"Struct to dispatch the creation of Service Requirement Variables\n\nDocs abbreviation: textreq\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.SystemBalanceSlackUp","page":"Public API","title":"PowerSimulations.SystemBalanceSlackUp","text":"Struct to dispatch the creation of System-wide slack up variables. Used when there is not enough generation.\n\nDocs abbreviation: p^textslup\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.SystemBalanceSlackDown","page":"Public API","title":"PowerSimulations.SystemBalanceSlackDown","text":"Struct to dispatch the creation of System-wide slack down variables. Used when there is not enough load curtailment.\n\nDocs abbreviation: p^textsldn\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ReserveRequirementSlack","page":"Public API","title":"PowerSimulations.ReserveRequirementSlack","text":"Struct to dispatch the creation of Reserve requirement slack variables. Used when there is not reserves in the system to satisfy the requirement.\n\nDocs abbreviation: r^textsl\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.InterfaceFlowSlackUp","page":"Public API","title":"PowerSimulations.InterfaceFlowSlackUp","text":"Struct to dispatch the creation of Interface Flow Slack Up variables\n\nDocs abbreviation: f^textslup\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.InterfaceFlowSlackDown","page":"Public API","title":"PowerSimulations.InterfaceFlowSlackDown","text":"Struct to dispatch the creation of Interface Flow Slack Down variables\n\nDocs abbreviation: f^textsldn\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.PostContingencyActivePowerReserveDeploymentVariable","page":"Public API","title":"PowerSimulations.PostContingencyActivePowerReserveDeploymentVariable","text":"Struct to dispatch the creation of Post-Contingency Active Power Deployment Variable for mapping reserves deployment under contingencies.\n\nDocs abbreviation: Delta rsv_rgc\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.UpperBoundFeedForwardSlack","page":"Public API","title":"PowerSimulations.UpperBoundFeedForwardSlack","text":"Struct to dispatch the creation of Slack variables for UpperBoundFeedforward\n\nDocs abbreviation: p^textffubsl\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.LowerBoundFeedForwardSlack","page":"Public API","title":"PowerSimulations.LowerBoundFeedForwardSlack","text":"Struct to dispatch the creation of Slack variables for LowerBoundFeedforward\n\nDocs abbreviation: p^textfflbsl\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.TimeDurationOn","page":"Public API","title":"PowerSimulations.TimeDurationOn","text":"Auxiliary Variable for Thermal Generation Models to keep track of time elapsed on\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.TimeDurationOff","page":"Public API","title":"PowerSimulations.TimeDurationOff","text":"Auxiliary Variable for Thermal Generation Models to keep track of time elapsed off\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.PowerOutput","page":"Public API","title":"PowerSimulations.PowerOutput","text":"Auxiliary Variable for Thermal Generation Models that solve for power above min\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.PowerFlowVoltageAngle","page":"Public API","title":"PowerSimulations.PowerFlowVoltageAngle","text":"Auxiliary Variable for the bus angle results from power flow evaluation\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.PowerFlowVoltageMagnitude","page":"Public API","title":"PowerSimulations.PowerFlowVoltageMagnitude","text":"Auxiliary Variable for the bus voltage magnitued results from power flow evaluation\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.PowerFlowLossFactors","page":"Public API","title":"PowerSimulations.PowerFlowLossFactors","text":"Auxiliary Variable for the loss factors from AC power flow evaluation that are calculated using the Jacobian matrix\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.PowerFlowVoltageStabilityFactors","page":"Public API","title":"PowerSimulations.PowerFlowVoltageStabilityFactors","text":"Auxiliary Variable for the voltage stability factors from AC power flow evaluation that are calculated using the Jacobian matrix\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.PowerFlowBranchReactivePowerFromTo","page":"Public API","title":"PowerSimulations.PowerFlowBranchReactivePowerFromTo","text":"Auxiliary Variable for the line reactive flow in the from -> to direction from power flow evaluation\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.PowerFlowBranchReactivePowerToFrom","page":"Public API","title":"PowerSimulations.PowerFlowBranchReactivePowerToFrom","text":"Auxiliary Variable for the line reactive flow in the to -> from direction from power flow evaluation\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.PowerFlowBranchActivePowerFromTo","page":"Public API","title":"PowerSimulations.PowerFlowBranchActivePowerFromTo","text":"Auxiliary Variable for the line active flow in the from -> to direction from power flow evaluation\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.PowerFlowBranchActivePowerToFrom","page":"Public API","title":"PowerSimulations.PowerFlowBranchActivePowerToFrom","text":"Auxiliary Variable for the line active flow in the to -> from direction from power flow evaluation\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.PiecewiseLinearCostConstraint","page":"Public API","title":"PowerSimulations.PiecewiseLinearCostConstraint","text":"Struct to create the PiecewiseLinearCostConstraint associated with a specified variable.\n\nSee Piecewise linear cost functions for more information.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.CopperPlateBalanceConstraint","page":"Public API","title":"PowerSimulations.CopperPlateBalanceConstraint","text":"Struct to create the constraint to balance power in the copperplate model. For more information check Network Formulations.\n\nThe specified constraint is generally formulated as:\n\nsum_c in textcomponents p_t^c = 0 quad forall t in 1 dots T\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.NodalBalanceActiveConstraint","page":"Public API","title":"PowerSimulations.NodalBalanceActiveConstraint","text":"Struct to create the constraint to balance active power in nodal formulation. For more information check Network Formulations.\n\nThe specified constraint depends on the network model chosen.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.NodalBalanceReactiveConstraint","page":"Public API","title":"PowerSimulations.NodalBalanceReactiveConstraint","text":"Struct to create the constraint to balance reactive power in nodal formulation. For more information check Network Formulations.\n\nThe specified constraint depends on the network model chosen.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.AreaParticipationAssignmentConstraint","page":"Public API","title":"PowerSimulations.AreaParticipationAssignmentConstraint","text":"Struct to create the constraint to balance power across specified areas. For more information check Network Formulations.\n\nThe specified constraint is generally formulated as:\n\nsum_c in textcomponents_a p_t^c = 0 quad forall ain 1dots A t in 1 dots T\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ActivePowerVariableLimitsConstraint","page":"Public API","title":"PowerSimulations.ActivePowerVariableLimitsConstraint","text":"Struct to create the constraint to limit active power expressions. For more information check Device Formulations.\n\nThe specified constraint depends on the UpperBound and LowerBound expressions, but in its most basic formulation is of the form:\n\nP^textmin le p_t le P^textmax quad forall t in 1dotsT\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ReactivePowerVariableLimitsConstraint","page":"Public API","title":"PowerSimulations.ReactivePowerVariableLimitsConstraint","text":"Struct to create the constraint to limit reactive power expressions. For more information check Device Formulations.\n\nThe specified constraint depends on the UpperBound and LowerBound expressions, but in its most basic formulation is of the form:\n\nQ^textmin le q_t le Q^textmax quad forall t in 1dotsT\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ActivePowerVariableTimeSeriesLimitsConstraint","page":"Public API","title":"PowerSimulations.ActivePowerVariableTimeSeriesLimitsConstraint","text":"Struct to create the constraint to limit active power expressions by a time series parameter. For more information check Device Formulations.\n\nThe specified constraint depends on the UpperBound expressions, but in its most basic formulation is of the form:\n\np_t le textActivePowerTimeSeriesParameter_t quad forall t in 1dotsT\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.InputActivePowerVariableLimitsConstraint","page":"Public API","title":"PowerSimulations.InputActivePowerVariableLimitsConstraint","text":"Struct to create the constraint to limit active power input expressions. For more information check Device Formulations.\n\nThe specified constraint depends on the UpperBound and LowerBound expressions, but in its most basic formulation is of the form:\n\nP^textmin le p_t^textin le P^textmax quad forall t in 1dotsT\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.OutputActivePowerVariableLimitsConstraint","page":"Public API","title":"PowerSimulations.OutputActivePowerVariableLimitsConstraint","text":"Struct to create the constraint to limit active power output expressions. For more information check Device Formulations.\n\nThe specified constraint depends on the UpperBound and LowerBound expressions, but in its most basic formulation is of the form:\n\nP^textmin le p_t^textout le P^textmax quad forall t in 1dotsT\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ActivePowerInVariableTimeSeriesLimitsConstraint","page":"Public API","title":"PowerSimulations.ActivePowerInVariableTimeSeriesLimitsConstraint","text":"Struct to create the constraint to limit active power expressions by a time series parameter. For more information check Device Formulations.\n\nThe specified constraint depends on the UpperBound expressions, but in its most basic formulation is of the form:\n\np_t^in le textActivePowerTimeSeriesParameter_t quad forall t in 1dotsT\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ActivePowerOutVariableTimeSeriesLimitsConstraint","page":"Public API","title":"PowerSimulations.ActivePowerOutVariableTimeSeriesLimitsConstraint","text":"Struct to create the constraint to limit active power expressions by a time series parameter. For more information check Device Formulations.\n\nThe specified constraint depends on the UpperBound expressions, but in its most basic formulation is of the form:\n\np_t^out le textActivePowerTimeSeriesParameter_t quad forall t in 1dotsT\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.RequirementConstraint","page":"Public API","title":"PowerSimulations.RequirementConstraint","text":"Struct to create the constraint for satisfying active power reserve requirements. For more information check Service Formulations.\n\nThe constraint is as follows:\n\nsum_dinmathcalD_s r_dt + r_t^textsl ge textReqquad forall tin 1dots T quad text(for a ConstantReserve) \nsum_dinmathcalD_s r_dt + r_t^textsl ge textRequirementTimeSeriesParameter_tquad forall tin 1dots T quad text(for a VariableReserve)\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ParticipationFractionConstraint","page":"Public API","title":"PowerSimulations.ParticipationFractionConstraint","text":"Struct to create the constraint to participation assignments limits in the active power reserves. For more information check Service Formulations.\n\nThe constraint is as follows:\n\nr_dt le textReq cdot textPF quad forall din mathcalD_s forall tin 1dots T quad text(for a ConstantReserve) \nr_dt le textRequirementTimeSeriesParameter_t cdot textPFquad  forall din mathcalD_s forall tin 1dots T quad text(for a VariableReserve)\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ReservePowerConstraint","page":"Public API","title":"PowerSimulations.ReservePowerConstraint","text":"Struct to create the constraint for ensuring that NonSpinning Reserve can be delivered from turn-off thermal units.\n\nFor more information check Service Formulations for NonSpinningReserve.\n\nThe constraint is as follows:\n\nr_dt le (1 - u_dt^textth) cdot R^textlimit_d quad forall d in mathcalD_s forall t in 1dots T\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ActiveRangeICConstraint","page":"Public API","title":"PowerSimulations.ActiveRangeICConstraint","text":"Struct to create the constraint for starting up ThermalMultiStart units. For more information check ThermalGen Formulations for ThermalMultiStartUnitCommitment.\n\nThe specified constraint is formulated as:\n\nmaxP^textthmax - P^textthshdown 0 cdot w_1^textth le u^textthinit (P^textthmax - P^textthmin) - P^textthinit\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.CommitmentConstraint","page":"Public API","title":"PowerSimulations.CommitmentConstraint","text":"Struct to create the commitment constraint between the on, start, and stop variables. For more information check ThermalGen Formulations.\n\nThe specified constraints are formulated as:\n\nu_1^textth = u^textthinit + v_1^textth - w_1^textth \nu_t^textth = u_t-1^textth + v_t^textth - w_t^textth quad forall t in 2dotsT \nv_t^textth + w_t^textth le 1 quad forall t in 1dotsT\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.DurationConstraint","page":"Public API","title":"PowerSimulations.DurationConstraint","text":"Struct to create the duration constraint for commitment formulations, i.e. min-up and min-down.\n\nFor more information check ThermalGen Formulations.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.RampConstraint","page":"Public API","title":"PowerSimulations.RampConstraint","text":"Struct to create the RampConstraint associated with a specified thermal device or reserve service.\n\nFor thermal units, see more information in Thermal Formulations. The constraint is as follows:\n\n-R^textthdn le p_t^textth - p_t-1^textth le R^textthup quad forall  tin 1 dots T\n\nFor Ramp Reserve, see more information in Service Formulations. The constraint is as follows:\n\nr_dt le R^textthup cdot textTFquad  forall din mathcalD_s forall tin 1dots T quad text(for ReserveUp) \nr_dt le R^textthdn cdot textTFquad  forall din mathcalD_s forall tin 1dots T quad text(for ReserveDown)\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.StartupInitialConditionConstraint","page":"Public API","title":"PowerSimulations.StartupInitialConditionConstraint","text":"Struct to create the start-up initial condition constraints for ThermalMultiStart.\n\nFor more information check ThermalGen Formulations for ThermalMultiStartUnitCommitment.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.StartupTimeLimitTemperatureConstraint","page":"Public API","title":"PowerSimulations.StartupTimeLimitTemperatureConstraint","text":"Struct to create the start-up time limit constraints for ThermalMultiStart.\n\nFor more information check ThermalGen Formulations for ThermalMultiStartUnitCommitment.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.EqualityConstraint","page":"Public API","title":"PowerSimulations.EqualityConstraint","text":"Struct to create the constraint that sets the reactive power to the power factor in the RenewableConstantPowerFactor formulation for renewable units.\n\nFor more information check RenewableGen Formulations.\n\nThe specified constraint is formulated as:\n\nq_t^textre = textpf cdot p_t^textre quad forall t in 1dots T\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ImportExportBudgetConstraint","page":"Public API","title":"PowerSimulations.ImportExportBudgetConstraint","text":"Struct to create the constraint to limit the import and exports in a determined period. For more information check Device Formulations.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.FlowLimitConstraint","page":"Public API","title":"PowerSimulations.FlowLimitConstraint","text":"Struct to create the constraint that set the flow limits through a PhaseShiftingTransformer.\n\nFor more information check Branch Formulations.\n\nThe specified constraint is formulated as:\n\n-R^textmax le f_t le R^textmax quad forall t in 1dotsT\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.FlowRateConstraint","page":"Public API","title":"PowerSimulations.FlowRateConstraint","text":"Struct to create the constraint that set the AC flow limits through AC branches and HVDC two-terminal branches.\n\nFor more information check Branch Formulations.\n\nThe specified constraint is formulated as:\n\nbeginalign*\n  f_t - f_t^textslup le R^textmaxquad forall t in 1dots T \n  f_t + f_t^textsllo ge -R^textmaxquad forall t in 1dots T\nendalign*\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.FlowRateConstraintFromTo","page":"Public API","title":"PowerSimulations.FlowRateConstraintFromTo","text":"Struct to create the constraint for branch flow rate limits from the 'from' bus to the 'to' bus. For more information check Branch Formulations.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.FlowRateConstraintToFrom","page":"Public API","title":"PowerSimulations.FlowRateConstraintToFrom","text":"Struct to create the constraint for branch flow rate limits from the 'to' bus to the 'from' bus. For more information check Branch Formulations.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.HVDCPowerBalance","page":"Public API","title":"PowerSimulations.HVDCPowerBalance","text":"Struct to create the constraints that set the power balance across a lossy HVDC two-terminal line.\n\nFor more information check Branch Formulations.\n\nThe specified constraints are formulated as:\n\nbeginalign*\n f_t^textto-from - f_t^textfrom-to le L_1 cdot f_t^textto-from - L_0quad forall t in 1dots T \n f_t^textfrom-to - f_t^textto-from ge L_1 cdot f_t^textfrom-to + L_0quad forall t in 1dots T \n f_t^textfrom-to - f_t^textto-from ge - M^textbig (1 - u^textdir_t)quad forall t in 1dots T \n f_t^textto-from - f_t^textfrom-to ge - M^textbig u^textdir_tquad forall t in 1dots T \nendalign*\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.NetworkFlowConstraint","page":"Public API","title":"PowerSimulations.NetworkFlowConstraint","text":"Struct to create the constraint the AC branch flows depending on the network model. For more information check Branch Formulations.\n\nThe specified constraint depends on the network model chosen. The most common application is the StaticBranch in a PTDF Network Model:\n\nf_t = sum_i=1^N textPTDF_ib cdot textBal_it quad forall t in 1dots T\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.PhaseAngleControlLimit","page":"Public API","title":"PowerSimulations.PhaseAngleControlLimit","text":"Struct to create the constraint that set the angle limits through a PhaseShiftingTransformer.\n\nFor more information check Branch Formulations.\n\nThe specified constraint is formulated as:\n\nTheta^textmin le theta^textshift_t le Theta^textmax quad forall t in 1dotsT\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ConverterLossConstraint","page":"Public API","title":"PowerSimulations.ConverterLossConstraint","text":"Struct to create the constraints that decide the balance of AC and DC power of the converter.\n\nThe specified constraints are formulated as:\n\nbeginalign*\n p_ac = p_dc - loss_t  quad forall t in 1dots T \n loss_t = a i_c^2 + b i_c + c \nendalign*\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.InterpolationVoltageConstraints","page":"Public API","title":"PowerSimulations.InterpolationVoltageConstraints","text":"Struct to create the Quadratic PWL interpolation constraints that decide square value of the voltage. In this case x = voltage and y = squared_voltage. The specified constraints are formulated as:\n\nbeginalign*\n x = x_0 + sum_k=1^K (x_k - x_k-1) delta_k  quad forall t in 1dots T \n y = y_0 + sum_k=1^K (x_k - x_k-1) delta_k  quad forall t in 1dots T \n z_k le delta_k  quad forall t in 1dots T forall k in 1dots K-1 \n z_k ge delta_k+1  quad forall t in 1dots T forall k in 1dots K-1 \nendalign*\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.InterpolationCurrentConstraints","page":"Public API","title":"PowerSimulations.InterpolationCurrentConstraints","text":"Struct to create the Quadratic PWL interpolation constraints that decide square value of the current. In this case x = current and y = squared_current. The specified constraints are formulated as:\n\nbeginalign*\n x = x_0 + sum_k=1^K (x_k - x_k-1) delta_k  quad forall t in 1dots T \n y = y_0 + sum_k=1^K (x_k - x_k-1) delta_k  quad forall t in 1dots T \n z_k le delta_k  quad forall t in 1dots T forall k in 1dots K-1 \n z_k ge delta_k+1  quad forall t in 1dots T forall k in 1dots K-1 \nendalign*\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.InterpolationBilinearConstraints","page":"Public API","title":"PowerSimulations.InterpolationBilinearConstraints","text":"Struct to create the Quadratic PWL interpolation constraints that decide square value of the bilinear variable γ. In this case x = γ and y = squared_γ. The specified constraints are formulated as:\n\nbeginalign*\n x = x_0 + sum_k=1^K (x_k - x_k-1) delta_k  quad forall t in 1dots T \n y = y_0 + sum_k=1^K (x_k - x_k-1) delta_k  quad forall t in 1dots T \n z_k le delta_k  quad forall t in 1dots T forall k in 1dots K-1 \n z_k ge delta_k+1  quad forall t in 1dots T forall k in 1dots K-1 \nendalign*\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.CurrentAbsoluteValueConstraint","page":"Public API","title":"PowerSimulations.CurrentAbsoluteValueConstraint","text":"Struct to create the constraints that set the absolute value for the current to use in losses through a lossy Interconnecting Power Converter. The specified constraint is formulated as:\n\nbeginalign*\n i_c^dc = i_c^+ - i_c^- quad forall t in 1dots T  \n i_c^+ le I_max cdot nu_c  quad forall t in 1dots T  \n i_c^+ le I_max cdot (1 - nu_c)  quad forall t in 1dots T  \nendalign*\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ConverterPowerCalculationConstraint","page":"Public API","title":"PowerSimulations.ConverterPowerCalculationConstraint","text":"Struct to create the constraints that compute the converter DC power based on current and voltage.\n\nThe specified constraints are formulated as:\n\nbeginalign*\n p_c = 05 * (γ^sq - v^sq - i^sq) quad forall t in 1dots T \n γ_c = v_c + i_c quad forall t in 1dots T \nendalign*\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ConverterMcCormickEnvelopes","page":"Public API","title":"PowerSimulations.ConverterMcCormickEnvelopes","text":"Struct to create the McCormick envelopes constraints that decide the bounds on the DC active power.\n\nThe specified constraints are formulated as:\n\nbeginalign*\n p_c = V^min i_c + v_c I^min - I^minV^min  quad forall t in 1dots T \n p_c = V^max i_c + v_c I^max - I^maxV^max  quad forall t in 1dots T \n p_c = V^max i_c + v_c I^min - I^minV^max  quad forall t in 1dots T \n p_c = V^min i_c + v_c I^max - I^maxV^min  quad forall t in 1dots T \nendalign*\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.DCLineCurrentConstraint","page":"Public API","title":"PowerSimulations.DCLineCurrentConstraint","text":"Struct to create the constraints that set the current flowing through a DC line.\n\nbeginalign*\n i_l^dc = frac1r_l (v_froml - v_tol) quad forall t in 1dots T \nendalign*\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.DCCurrentBalance","page":"Public API","title":"PowerSimulations.DCCurrentBalance","text":"Struct for DC current balance in multi-terminal DC networks\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.PostContingencyGenerationBalanceConstraint","page":"Public API","title":"PowerSimulations.PostContingencyGenerationBalanceConstraint","text":"Struct to create the constraint to balance active power. For more information check ThermalGen Formulations.\n\nThe specified constraint is generally formulated as:\n\nsum_g in mathcalG_c p_gt = sum_g in mathcalG Delta p_g c t quad forall c in mathcalC  forall t in 1 dots T\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.PostContingencyActivePowerVariableLimitsConstraint","page":"Public API","title":"PowerSimulations.PostContingencyActivePowerVariableLimitsConstraint","text":"Struct to create the constraint to limit post-contingency active power expressions. For more information check Device Formulations.\n\nThe specified constraint depends on the UpperBound and LowerBound expressions, but in its most basic formulation is of the form:\n\nP^textmin le p_t + Delta p_c t  le P^textmax quad forall c in mathcalC  forall t in 1dotsT\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.PostContingencyActivePowerReserveDeploymentVariableLimitsConstraint","page":"Public API","title":"PowerSimulations.PostContingencyActivePowerReserveDeploymentVariableLimitsConstraint","text":"Struct to create the constraint to limit post-contingency active power reserve deploymentexpressions. For more information check Device Formulations.\n\nThe specified constraint depends on the UpperBound and LowerBound expressions, but in its most basic formulation is of the form:\n\nDelta rsv_r c t  le rsv_r c t quad forall r in mathcalR  forall c in mathcalC  forall t in 1dotsT\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.PiecewiseLinearBlockIncrementalOfferConstraint","page":"Public API","title":"PowerSimulations.PiecewiseLinearBlockIncrementalOfferConstraint","text":"Struct to create the PiecewiseLinearBlockIncrementalOfferConstraint associated with a specified variable.\n\nSee Piecewise linear cost functions for more information.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.PiecewiseLinearBlockDecrementalOfferConstraint","page":"Public API","title":"PowerSimulations.PiecewiseLinearBlockDecrementalOfferConstraint","text":"Struct to create the PiecewiseLinearBlockDecrementalOfferConstraint associated with a specified variable.\n\nSee Piecewise linear cost functions for more information.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.FeedforwardSemiContinuousConstraint","page":"Public API","title":"PowerSimulations.FeedforwardSemiContinuousConstraint","text":"Struct to create the constraint for semicontinuous feedforward limits.\n\nFor more information check Feedforward Formulations.\n\nThe specified constraint is formulated as:\n\nbeginalign*\n  textActivePowerRangeExpressionUB_t = p_t^textth - texton_t^textthP^textthmax le 0 quad  forall tin 1 dots T  \n  textActivePowerRangeExpressionLB_t = p_t^textth - texton_t^textthP^textthmin ge 0 quad  forall tin 1 dots T\nendalign*\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.FeedforwardUpperBoundConstraint","page":"Public API","title":"PowerSimulations.FeedforwardUpperBoundConstraint","text":"Struct to create the constraint for upper bound feedforward limits.\n\nFor more information check Feedforward Formulations.\n\nThe specified constraint is formulated as:\n\nbeginalign*\n  textAffectedVariable_t - p_t^textffubsl le textSourceVariableParameter_t quad forall t in 1dots T\nendalign*\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.FeedforwardLowerBoundConstraint","page":"Public API","title":"PowerSimulations.FeedforwardLowerBoundConstraint","text":"Struct to create the constraint for lower bound feedforward limits.\n\nFor more information check Feedforward Formulations.\n\nThe specified constraint is formulated as:\n\nbeginalign*\n  textAffectedVariable_t + p_t^textfflbsl ge textSourceVariableParameter_t quad forall t in 1dots T\nendalign*\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ActivePowerTimeSeriesParameter","page":"Public API","title":"PowerSimulations.ActivePowerTimeSeriesParameter","text":"Parameter to define active power time series\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ReactivePowerTimeSeriesParameter","page":"Public API","title":"PowerSimulations.ReactivePowerTimeSeriesParameter","text":"Parameter to define reactive power time series\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.RequirementTimeSeriesParameter","page":"Public API","title":"PowerSimulations.RequirementTimeSeriesParameter","text":"Parameter to define requirement time series\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ReactivePowerOffsetParameter","page":"Public API","title":"PowerSimulations.ReactivePowerOffsetParameter","text":"Parameter to define reactive power offset during an event.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ActivePowerOutTimeSeriesParameter","page":"Public API","title":"PowerSimulations.ActivePowerOutTimeSeriesParameter","text":"Parameter to define active power out time series\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ActivePowerInTimeSeriesParameter","page":"Public API","title":"PowerSimulations.ActivePowerInTimeSeriesParameter","text":"Parameter to define active power in time series\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.FuelCostParameter","page":"Public API","title":"PowerSimulations.FuelCostParameter","text":"Parameter to define fuel cost time series\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.FromToFlowLimitParameter","page":"Public API","title":"PowerSimulations.FromToFlowLimitParameter","text":"Parameter to define Flow From_To limit time series\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ToFromFlowLimitParameter","page":"Public API","title":"PowerSimulations.ToFromFlowLimitParameter","text":"Parameter to define Flow To_From limit time series\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.UpperBoundValueParameter","page":"Public API","title":"PowerSimulations.UpperBoundValueParameter","text":"Parameter to define variable upper bound\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.LowerBoundValueParameter","page":"Public API","title":"PowerSimulations.LowerBoundValueParameter","text":"Parameter to define variable lower bound\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.OnStatusParameter","page":"Public API","title":"PowerSimulations.OnStatusParameter","text":"Parameter to define unit commitment status updated from the system state\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.FixValueParameter","page":"Public API","title":"PowerSimulations.FixValueParameter","text":"Parameter to FixValueParameter\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.CostFunctionParameter","page":"Public API","title":"PowerSimulations.CostFunctionParameter","text":"Parameter to define cost function coefficient\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.AvailableStatusChangeCountdownParameter","page":"Public API","title":"PowerSimulations.AvailableStatusChangeCountdownParameter","text":"Parameter to record that the component changed in the availability status\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.AvailableStatusParameter","page":"Public API","title":"PowerSimulations.AvailableStatusParameter","text":"Parameter to define component availability status updated from the system state\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ActivePowerOffsetParameter","page":"Public API","title":"PowerSimulations.ActivePowerOffsetParameter","text":"Parameter to define active power offset during an event.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.DynamicBranchRatingTimeSeriesParameter","page":"Public API","title":"PowerSimulations.DynamicBranchRatingTimeSeriesParameter","text":"Parameter to define the dynamic rating time series of a branch\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.PostContingencyDynamicBranchRatingTimeSeriesParameter","page":"Public API","title":"PowerSimulations.PostContingencyDynamicBranchRatingTimeSeriesParameter","text":"Parameter to define the dynamic ratings time series of an AC branch for post-contingency condition\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.serialize_optimization_model-Tuple{PowerSimulations.OptimizationContainer, String}","page":"Public API","title":"PowerSimulations.serialize_optimization_model","text":"serialize_optimization_model(\n    container::PowerSimulations.OptimizationContainer,\n    save_path::String\n)\n\n\nExports the OpModel JuMP object in MathOptFormat\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_all_constraint_index-Tuple{PowerSimulations.OperationModel}","page":"Public API","title":"PowerSimulations.get_all_constraint_index","text":"get_all_constraint_index(\n    model::PowerSimulations.OperationModel\n) -> Vector{Tuple{InfrastructureSystems.Optimization.ConstraintKey, Int64, Int64}}\n\n\nEach Tuple corresponds to (conname, internalindex, moi_index)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_all_variable_index-Tuple{PowerSimulations.OperationModel}","page":"Public API","title":"PowerSimulations.get_all_variable_index","text":"get_all_variable_index(\n    model::PowerSimulations.OperationModel\n) -> Vector{T} where T<:Tuple{Any, Int64, Int64}\n\n\nEach Tuple corresponds to (conname, internalindex, moi_index)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#InfrastructureSystems.Optimization.OptimizationProblemResults-Tuple{DecisionModel}","page":"Public API","title":"InfrastructureSystems.Optimization.OptimizationProblemResults","text":"OptimizationProblemResults(\n    model::DecisionModel\n) -> OptimizationProblemResults\n\n\nConstruct OptimizationProblemResults from a solved DecisionModel.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#InfrastructureSystems.Optimization.OptimizationProblemResults-Tuple{EmulationModel}","page":"Public API","title":"InfrastructureSystems.Optimization.OptimizationProblemResults","text":"OptimizationProblemResults(\n    model::EmulationModel\n) -> OptimizationProblemResults\n\n\nConstruct OptimizationProblemResults from a solved EmulationModel.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.SimulationResults","page":"Public API","title":"PowerSimulations.SimulationResults","text":"SimulationResults(\n    path::AbstractString,\n    name::AbstractString;\n    ...\n) -> SimulationResults\nSimulationResults(\n    path::AbstractString,\n    name::AbstractString,\n    execution;\n    ignore_status\n) -> SimulationResults\n\n\nConstruct SimulationResults from a simulation output directory.\n\nArguments\n\npath::AbstractString: Simulation output directory\nname::AbstractString: Simulation name\nexecution::AbstractString: Execution number. Default is the most recent.\nignore_status::Bool: If true, return results even if the simulation failed.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.SimulationResults-Tuple{Simulation}","page":"Public API","title":"PowerSimulations.SimulationResults","text":"SimulationResults(\n    sim::Simulation;\n    ignore_status,\n    kwargs...\n) -> SimulationResults\n\n\nConstruct SimulationResults from a simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#InfrastructureSystems.Optimization.export_results-Tuple{SimulationResults, Any}","page":"Public API","title":"InfrastructureSystems.Optimization.export_results","text":"export_results(results::SimulationResults, exports)\n\n\nExport results to files in the results directory.\n\nArguments\n\nresults::SimulationResults: simulation results\nexports: SimulationResultsExport or anything that can be passed to its constructor. (such as Dict or path to JSON file)\n\nAn example JSON file demonstrating possible options is below. Note that start_time, end_time, path, and format are optional.\n\n{\n  \"decision_models\": [\n    {\n      \"name\": \"ED\",\n      \"variables\": [\n        \"P__ThermalStandard\",\n      ],\n      \"parameters\": [\n        \"all\"\n      ]\n    },\n    {\n      \"name\": \"UC\",\n      \"variables\": [\n        \"On__ThermalStandard\"\n      ],\n      \"parameters\": [\n        \"all\"\n      ],\n      \"duals\": [\n        \"all\"\n      ]\n    }\n  ],\n  \"start_time\": \"2020-01-01T04:00:00\",\n  \"end_time\": null,\n  \"path\": null,\n  \"format\": \"csv\"\n}\n\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#InfrastructureSystems.Optimization.read_aux_variable-Tuple{PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults}, Vararg{Any}}","page":"Public API","title":"InfrastructureSystems.Optimization.read_aux_variable","text":"read_aux_variable(\n    res::PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults},\n    args...;\n    initial_time,\n    count,\n    store,\n    table_format\n) -> SortedDict{_A, _B, Base.Order.ForwardOrdering} where {_A, _B}\n\n\nReturn the values for the requested auxillary variables. It keeps requests when performing multiple retrievals.\n\nArguments\n\nargs: Can be a string returned from list_aux_variable_names or args that can be splatted into a AuxVarKey.\ninitial_time::Dates.DateTime : initial of the requested results\ncount::Int: Number of results\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#InfrastructureSystems.Optimization.read_dual-Tuple{PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults}, Vararg{Any}}","page":"Public API","title":"InfrastructureSystems.Optimization.read_dual","text":"read_dual(\n    res::PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults},\n    args...;\n    initial_time,\n    count,\n    store,\n    table_format\n) -> SortedDict{_A, _B, Base.Order.ForwardOrdering} where {_A, _B}\n\n\nReturn the values for the requested dual. It keeps requests when performing multiple retrievals.\n\nArguments\n\nargs: Can be a string returned from list_dual_names or args that can be splatted into a ConstraintKey.\ninitial_time::Dates.DateTime : initial of the requested results\ncount::Int: Number of results\nstore::SimulationStore: a store that has been opened for reading\ntable_format::TableFormat: Format of the table to be returned. Default is TableFormat.LONG where the columns are DateTime, name, and value when the data has two dimensions and DateTime, name, name2, and value when the data has three dimensions. Set to it TableFormat.WIDE to pivot the names as columns. Note: TableFormat.WIDE is not supported when the data has three dimensions.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#InfrastructureSystems.Optimization.read_expression-Tuple{PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults}, Vararg{Any}}","page":"Public API","title":"InfrastructureSystems.Optimization.read_expression","text":"read_expression(\n    res::PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults},\n    args...;\n    initial_time,\n    count,\n    store,\n    table_format\n) -> SortedDict{_A, _B, Base.Order.ForwardOrdering} where {_A, _B}\n\n\nReturn the values for the requested auxillary variables. It keeps requests when performing multiple retrievals.\n\nArguments\n\nargs: Can be a string returned from list_expression_names or args that can be splatted into a ExpressionKey.\ninitial_time::Dates.DateTime : initial of the requested results\ncount::Int: Number of results\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#InfrastructureSystems.Optimization.read_parameter-Tuple{PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults}, Vararg{Any}}","page":"Public API","title":"InfrastructureSystems.Optimization.read_parameter","text":"read_parameter(\n    res::PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults},\n    args...;\n    initial_time,\n    count,\n    store,\n    table_format\n) -> SortedDict{_A, _B, Base.Order.ForwardOrdering} where {_A, _B}\n\n\nReturn the values for the requested parameter. It keeps requests when performing multiple retrievals.\n\nArguments\n\nargs: Can be a string returned from list_parameter_names or args that can be splatted into a ParameterKey.\ninitial_time::Dates.DateTime : initial of the requested results\ncount::Int: Number of results\ntable_format::TableFormat: Format of the table to be returned. Default is TableFormat.LONG where the columns are DateTime, name, and value when the data has two dimensions and DateTime, name, name2, and value when the data has three dimensions. Set to it TableFormat.WIDE to pivot the names as columns. Note: TableFormat.WIDE is not supported when the data has three dimensions.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#InfrastructureSystems.Optimization.read_variable-Tuple{PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults}, Vararg{Any}}","page":"Public API","title":"InfrastructureSystems.Optimization.read_variable","text":"read_variable(\n    res::PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults},\n    args...;\n    initial_time,\n    count,\n    store,\n    table_format\n) -> SortedDict{_A, _B, Base.Order.ForwardOrdering} where {_A, _B}\n\n\nReturn the values for the requested variable. It keeps requests when performing multiple retrievals.\n\nArguments\n\nargs: Can be a string returned from list_variable_names or args that can be splatted into a VariableKey.\ninitial_time::Dates.DateTime : initial of the requested results\ncount::Int: Number of results\nstore::SimulationStore: a store that has been opened for reading\ntable_format::TableFormat: Format of the table to be returned. Default is TableFormat.LONG where the columns are DateTime, name, and value when the data has two dimensions and DateTime, name, name2, and value when the data has three dimensions. Set to it TableFormat.WIDE to pivot the names as columns. Note: TableFormat.WIDE is not supported when the data has three dimensions.\n\nExamples\n\nread_variable(results, ActivePowerVariable, ThermalStandard)\nread_variable(results, \"ActivePowerVariable__ThermalStandard\")\nread_variable(results, \"ActivePowerVariable__ThermalStandard\", table_format = TableFormat.WIDE)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_decision_problem_results-Tuple{SimulationResults, String}","page":"Public API","title":"PowerSimulations.get_decision_problem_results","text":"get_decision_problem_results(\n    results::SimulationResults,\n    problem::String;\n    populate_system,\n    populate_units\n) -> PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults}\n\n\nReturn SimulationProblemResults corresponding to a SimulationResults\n\nArguments\n\nsim_results::PSI.SimulationResults: the simulation results to read from\nproblem::String: the name of the problem (e.g., \"UC\", \"ED\")\npopulate_system::Bool = true: whether to set the results' system as if using get_system!\npopulate_units::Union{IS.UnitSystem, String, Nothing} = IS.UnitSystem.NATURAL_UNITS: the units system with which to populate the results' system, if any (requires populate_system=true)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_emulation_problem_results-Tuple{SimulationResults}","page":"Public API","title":"PowerSimulations.get_emulation_problem_results","text":"get_emulation_problem_results(\n    results::SimulationResults;\n    populate_system,\n    populate_units\n) -> PowerSimulations.SimulationProblemResults{PowerSimulations.EmulationModelSimulationResults}\n\n\nReturn SimulationProblemResults corresponding to a SimulationResults\n\nArguments\n\nsim_results::PSI.SimulationResults: the simulation results to read from\npopulate_system::Bool = true: whether to set the results' system as if using get_system!\npopulate_units::Union{IS.UnitSystem, String, Nothing} = IS.UnitSystem.NATURAL_UNITS: the units system with which to populate the results' system, if any (requires populate_system=true)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.list_decision_problems-Tuple{SimulationResults}","page":"Public API","title":"PowerSimulations.list_decision_problems","text":"list_decision_problems(\n    results::SimulationResults\n) -> Vector{String}\n\n\nReturn the problem names in the simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.load_results!-Tuple{PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults}, Int64}","page":"Public API","title":"PowerSimulations.load_results!","text":"load_results!(\n    res::PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults},\n    count::Int64;\n    initial_time,\n    variables,\n    duals,\n    parameters,\n    aux_variables,\n    expressions,\n    store\n)\n\n\nLoad the simulation results into memory for repeated reads. This is useful when loading results from remote locations over network connections, when reading the same data very many times, etc. Multiple calls augment the cache according to these rules, where \"variable\" means \"variable, expression, etc.\":\n\nRequests for an already cached variable at a lesser count than already cached do not decrease the count of the cached variable\nRequests for an already cached variable at a greater count than already cached do increase the count of the cached variable\nRequests for new variables are fulfilled without evicting existing variables\n\nNote that count is global across all variables, so increasing the count re-reads already cached variables. For each variable, each element must be the name encoded as a string, like \"ActivePowerVariable__ThermalStandard\" or a Tuple with its constituent types, like (ActivePowerVariable, ThermalStandard). To clear the cache, use Base.empty!.\n\nArguments\n\ncount::Int: Number of windows to load.\ninitial_time::Dates.DateTime : Initial time of first window to load. Defaults to first.\naux_variables::Vector{Union{String, Tuple}}: Optional list of aux variables to load.\nduals::Vector{Union{String, Tuple}}: Optional list of duals to load.\nexpressions::Vector{Union{String, Tuple}}: Optional list of expressions to load.\nparameters::Vector{Union{String, Tuple}}: Optional list of parameters to load.\nvariables::Vector{Union{String, Tuple}}: Optional list of variables to load.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.load_results!-Tuple{PowerSimulations.SimulationProblemResults{PowerSimulations.EmulationModelSimulationResults}}","page":"Public API","title":"PowerSimulations.load_results!","text":"load_results!(\n    res::PowerSimulations.SimulationProblemResults{PowerSimulations.EmulationModelSimulationResults};\n    aux_variables,\n    duals,\n    expressions,\n    parameters,\n    variables\n)\n\n\nLoad the simulation results into memory for repeated reads. This is useful when loading results from remote locations over network connections.\n\nFor each variable/parameter/dual, etc., each element must be the name encoded as a string, like \"ActivePowerVariable__ThermalStandard\"or a Tuple with its constituent types, like(ActivePowerVariable, ThermalStandard)`.\n\nArguments\n\naux_variables::Vector{Union{String, Tuple}}: Optional list of aux variables to load.\nduals::Vector{Union{String, Tuple}}: Optional list of duals to load.\nexpressions::Vector{Union{String, Tuple}}: Optional list of expressions to load.\nparameters::Vector{Union{String, Tuple}}: Optional list of parameters to load.\nvariables::Vector{Union{String, Tuple}}: Optional list of variables to load.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#InfrastructureSystems.Optimization.get_timestamps-Tuple{PowerSimulations.SimulationProblemResults}","page":"Public API","title":"InfrastructureSystems.Optimization.get_timestamps","text":"get_timestamps(\n    result::PowerSimulations.SimulationProblemResults\n) -> StepRange{Dates.DateTime, Dates.Millisecond}\n\n\nReturn a reference to a StepRange of available timestamps.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#InfrastructureSystems.Optimization.list_aux_variable_names-Tuple{PowerSimulations.SimulationProblemResults}","page":"Public API","title":"InfrastructureSystems.Optimization.list_aux_variable_names","text":"list_aux_variable_names(\n    res::PowerSimulations.SimulationProblemResults\n) -> Vector\n\n\nReturn an array of auxillary variable names (strings) that are available for reads.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#InfrastructureSystems.Optimization.list_dual_names-Tuple{PowerSimulations.SimulationProblemResults}","page":"Public API","title":"InfrastructureSystems.Optimization.list_dual_names","text":"list_dual_names(\n    res::PowerSimulations.SimulationProblemResults\n) -> Vector\n\n\nReturn an array of dual names (strings) that are available for reads.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#InfrastructureSystems.Optimization.list_expression_names-Tuple{PowerSimulations.SimulationProblemResults}","page":"Public API","title":"InfrastructureSystems.Optimization.list_expression_names","text":"list_expression_names(\n    res::PowerSimulations.SimulationProblemResults\n) -> Vector\n\n\nReturn an array of expression names (strings) that are available for reads.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#InfrastructureSystems.Optimization.list_parameter_names-Tuple{PowerSimulations.SimulationProblemResults}","page":"Public API","title":"InfrastructureSystems.Optimization.list_parameter_names","text":"list_parameter_names(\n    res::PowerSimulations.SimulationProblemResults\n) -> Vector\n\n\nReturn an array of parmater names (strings) that are available for reads.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#InfrastructureSystems.Optimization.list_variable_names-Tuple{PowerSimulations.SimulationProblemResults}","page":"Public API","title":"InfrastructureSystems.Optimization.list_variable_names","text":"list_variable_names(\n    res::PowerSimulations.SimulationProblemResults\n) -> Vector\n\n\nReturn an array of variable names (strings) that are available for reads.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#InfrastructureSystems.Optimization.read_optimizer_stats-Tuple{PowerSimulations.SimulationProblemResults}","page":"Public API","title":"InfrastructureSystems.Optimization.read_optimizer_stats","text":"read_optimizer_stats(\n    res::PowerSimulations.SimulationProblemResults;\n    store\n) -> Any\n\n\nReturn the optimizer stats for the problem as a DataFrame.\n\nAccepted keywords\n\nstore::SimulationStore: a store that has been opened for reading\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_system!-Tuple{Union{OptimizationProblemResults, PowerSimulations.SimulationProblemResults}}","page":"Public API","title":"PowerSimulations.get_system!","text":"get_system!(\n    results::Union{OptimizationProblemResults, PowerSimulations.SimulationProblemResults};\n    kwargs...\n) -> Union{Nothing, InfrastructureSystems.InfrastructureSystemsType}\n\n\nReturn the system used for the problem. If the system hasn't already been deserialized or set with set_system! then deserialize and store it.\n\nIf the simulation was configured to serialize all systems to file then the returned system will include all data. If that was not configured then the returned system will include all data except time series data.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_realized_aux_variable-Tuple{PowerSimulations.SimulationProblemResults, AbstractString}","page":"Public API","title":"PowerSimulations.read_realized_aux_variable","text":"read_realized_aux_variable(\n    res::PowerSimulations.SimulationProblemResults,\n    aux_variable::AbstractString;\n    kwargs...\n) -> Any\n\n\nReturn the final values for the requested auxiliary variable for each time step for a problem.\n\nRefer to read_realized_variable for help and examples.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_realized_aux_variables-Tuple{PowerSimulations.SimulationProblemResults}","page":"Public API","title":"PowerSimulations.read_realized_aux_variables","text":"read_realized_aux_variables(\n    res::PowerSimulations.SimulationProblemResults;\n    kwargs...\n) -> Dict\n\n\nReturn the final values for the requested auxiliary variables for each time step for a problem.\n\nRefer to read_realized_aux_variables for help and examples.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_realized_dual-Tuple{PowerSimulations.SimulationProblemResults, AbstractString}","page":"Public API","title":"PowerSimulations.read_realized_dual","text":"read_realized_dual(\n    res::PowerSimulations.SimulationProblemResults,\n    dual::AbstractString;\n    kwargs...\n) -> Any\n\n\nReturn the final values for the requested dual for each time step for a problem.\n\nRefer to read_realized_variable for help and examples.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_realized_duals-Tuple{PowerSimulations.SimulationProblemResults}","page":"Public API","title":"PowerSimulations.read_realized_duals","text":"read_realized_duals(\n    res::PowerSimulations.SimulationProblemResults;\n    kwargs...\n) -> Dict\n\n\nReturn the final values for the requested duals for each time step for a problem.\n\nRefer to read_realized_duals for help and examples.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_realized_expression-Tuple{PowerSimulations.SimulationProblemResults, AbstractString}","page":"Public API","title":"PowerSimulations.read_realized_expression","text":"read_realized_expression(\n    res::PowerSimulations.SimulationProblemResults,\n    expression::AbstractString;\n    kwargs...\n) -> Any\n\n\nReturn the final values for the requested expression for each time step for a problem.\n\nRefer to read_realized_variable for help and examples.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_realized_expressions-Tuple{PowerSimulations.SimulationProblemResults}","page":"Public API","title":"PowerSimulations.read_realized_expressions","text":"read_realized_expressions(\n    res::PowerSimulations.SimulationProblemResults;\n    kwargs...\n) -> Dict\n\n\nReturn the final values for the requested expressions for each time step for a problem.\n\nRefer to read_realized_expressions for help and examples.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_realized_parameter-Tuple{PowerSimulations.SimulationProblemResults, AbstractString}","page":"Public API","title":"PowerSimulations.read_realized_parameter","text":"read_realized_parameter(\n    res::PowerSimulations.SimulationProblemResults,\n    parameter::AbstractString;\n    kwargs...\n) -> Any\n\n\nReturn the final values for the requested parameter for each time step for a problem.\n\nRefer to read_realized_variable for help and examples.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_realized_parameters-Tuple{PowerSimulations.SimulationProblemResults}","page":"Public API","title":"PowerSimulations.read_realized_parameters","text":"read_realized_parameters(\n    res::PowerSimulations.SimulationProblemResults;\n    kwargs...\n) -> Dict\n\n\nReturn the final values for the requested parameters for each time step for a problem.\n\nRefer to read_realized_parameters for help and examples.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_realized_variable-Tuple{PowerSimulations.SimulationProblemResults, AbstractString}","page":"Public API","title":"PowerSimulations.read_realized_variable","text":"read_realized_variable(\n    res::PowerSimulations.SimulationProblemResults,\n    variable::AbstractString;\n    kwargs...\n) -> Any\n\n\nReturn the final values for the requested variable for each time step for a problem.\n\nDecision problem results are returned in a Dict{DateTime, DataFrame}.\n\nEmulation problem results are returned in a DataFrame.\n\nLimit the data sizes returned by specifying initial_time and count for decision problems or start_time and len for emulation problems.\n\nSee also load_results! to preload data into memory.\n\nArguments\n\nvariable::Union{String, Tuple}: Variable name as a string or a Tuple with variable type and device type.\ninitial_time::Dates.DateTime: Initial time of the requested results. Decision problems only.\ncount::Int: Number of results. Decision problems only.\nstart_time::Dates.DateTime: Start time of the requested results. Emulation problems only.\nlen::Int: Number of rows in each DataFrame. Emulation problems only.\ntable_format::TableFormat: Format of the table to be returned. Default is TableFormat.LONG where the columns are DateTime, name, and value when the data has two dimensions and DateTime, name, name2, and value when the data has three dimensions. Set to it TableFormat.WIDE to pivot the names as columns. Note: TableFormat.WIDE is not supported when the data has three dimensions.\n\nExamples\n\njulia > read_realized_variable(results, \"ActivePowerVariable__ThermalStandard\")\njulia > read_realized_variable(results, (ActivePowerVariable, ThermalStandard))\njulia > read_realized_variable(results, (ActivePowerVariable, ThermalStandard), table_format = TableFormat.WIDE)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_realized_variables-Tuple{PowerSimulations.SimulationProblemResults}","page":"Public API","title":"PowerSimulations.read_realized_variables","text":"read_realized_variables(\n    res::PowerSimulations.SimulationProblemResults;\n    kwargs...\n) -> Dict\n\n\nReturn the final values for the requested variables for each time step for a problem.\n\nDecision problem results are returned in a Dict{String, Dict{DateTime, DataFrame}}.\n\nEmulation problem results are returned in a Dict{String, DataFrame}.\n\nLimit the data sizes returned by specifying initial_time and count for decision problems or start_time and len for emulation problems.\n\nIf the Julia process is started with multiple threads, the code will read the variables in parallel.\n\nSee also load_results! to preload data into memory.\n\nArguments\n\nvariables::Vector{Union{String, Tuple}}: Variable name as a string or a Tuple with variable type and device type. If not provided then return all variables.\ninitial_time::Dates.DateTime: Initial time of the requested results. Decision problems only.\ncount::Int: Number of results. Decision problems only.\nstart_time::Dates.DateTime: Start time of the requested results. Emulation problems only.\nlen::Int: Number of rows in each DataFrame. Emulation problems only.\ntable_format::TableFormat: Format of the table to be returned. Default is TableFormat.LONG where the columns are DateTime, name, and value when the data has two dimensions and DateTime, name, name2, and value when the data has three dimensions. Set to it TableFormat.WIDE to pivot the names as columns, matching earlier versions of PowerSimulations.jl. Note: TableFormat.WIDE is not supported when the data has three dimensions.\n\nExamples\n\njulia> variables_as_strings =\n    [\"ActivePowerVariable__ThermalStandard\", \"ActivePowerVariable__RenewableDispatch\"]\njulia> variables_as_types =\n    [(ActivePowerVariable, ThermalStandard), (ActivePowerVariable, RenewableDispatch)]\njulia> df_long =read_realized_variables(results, variables_as_strings)\njulia> df_long = read_realized_variables(results, variables_as_types)\njulia> df_wide = read_realized_variables(results, variables_as_types, table_format = TableFormat.WIDE)\njulia> using DataFramesMeta\njulia> df_agg_generators = @chain df_long begin\n    @groupby(:DateTime)\n    @combine(:value = sum(:value))\nend\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.set_system!-Tuple{PowerSimulations.SimulationProblemResults, AbstractString}","page":"Public API","title":"PowerSimulations.set_system!","text":"set_system!(\n    results::PowerSimulations.SimulationProblemResults,\n    system::AbstractString\n)\n\n\nSet the system in the results instance.\n\nThrows InvalidValue if the system UUID is incorrect.\n\nArguments\n\nresults::SimulationProblemResults: Results object\nsystem::AbstractString: Path to the system json file\n\nExamples\n\njulia > set_system!(res, \"my_path/system_data.json\")\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.SimulationPartitionResults","page":"Public API","title":"PowerSimulations.SimulationPartitionResults","text":"Handles merging of simulation partitions\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#InfrastructureSystems.Optimization.read_optimizer_stats-Tuple{PowerSimulations.HdfSimulationStore, Any}","page":"Public API","title":"InfrastructureSystems.Optimization.read_optimizer_stats","text":"read_optimizer_stats(\n    store::PowerSimulations.HdfSimulationStore,\n    model_name\n) -> Any\n\n\nReturn the optimizer stats for a problem as a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#InfrastructureSystems.Optimization.read_optimizer_stats-Tuple{PowerSimulations.HdfSimulationStore, Int64, Symbol, Int64}","page":"Public API","title":"InfrastructureSystems.Optimization.read_optimizer_stats","text":"read_optimizer_stats(\n    store::PowerSimulations.HdfSimulationStore,\n    simulation_step::Int64,\n    model_name::Symbol,\n    execution_index::Int64\n) -> Any\n\n\nRead the optimizer stats for a problem execution.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.list_simulation_events-Union{Tuple{T}, Tuple{Type{T}, AbstractString}, Tuple{Type{T}, AbstractString, Union{Nothing, Function}}} where T<:InfrastructureSystems.AbstractRecorderEvent","page":"Public API","title":"PowerSimulations.list_simulation_events","text":"list_simulation_events(\n    ::Type{T<:InfrastructureSystems.AbstractRecorderEvent},\n    output_dir::AbstractString;\n    ...\n) -> Vector{T} where T<:PowerSimulations.AbstractSimulationStatusEvent\nlist_simulation_events(\n    ::Type{T<:InfrastructureSystems.AbstractRecorderEvent},\n    output_dir::AbstractString,\n    filter_func::Union{Nothing, Function};\n    step,\n    model_name\n) -> Vector{T} where T<:PowerSimulations.AbstractSimulationStatusEvent\n\n\nlist_simulation_events(\n    ::Type{T},\n    output_dir::AbstractString,\n    filter_func::Union{Nothing, Function} = nothing;\n    step = nothing,\n    model = nothing,\n) where {T <: IS.AbstractRecorderEvent}\n\nList simulation events of type T in a simulation output directory.\n\nArguments\n\noutput_dir::AbstractString: Simulation output directory\nfilter_func::Union{Nothing, Function} = nothing: Refer to show_simulation_events.\nstep::Int = nothing: Filter events by step. Required if model is passed.\nmodel::Int = nothing: Filter events by model.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.show_recorder_events-Union{Tuple{T}, Tuple{Type{T}, AbstractString}, Tuple{Type{T}, AbstractString, Union{Nothing, Function}}} where T<:InfrastructureSystems.AbstractRecorderEvent","page":"Public API","title":"PowerSimulations.show_recorder_events","text":"show_recorder_events(\n    ::Type{T<:InfrastructureSystems.AbstractRecorderEvent},\n    filename::AbstractString;\n    ...\n)\nshow_recorder_events(\n    ::Type{T<:InfrastructureSystems.AbstractRecorderEvent},\n    filename::AbstractString,\n    filter_func::Union{Nothing, Function};\n    wall_time,\n    kwargs...\n)\n\n\nshow_recorder_events(\n    ::Type{T},\n    filename::AbstractString,\n    filter_func::Union{Nothing, Function} = nothing;\n    wall_time = false,\n    kwargs...,\n) where {T <: IS.AbstractRecorderEvent}\n\nShow the events of type T in a recorder file.\n\nArguments\n\n::Type{T}: Recorder event type\nfilename::AbstractString: recorder filename\nfilter_func::Union{Nothing, Function} = nothing: Optional function that accepts an event of type T and returns a Bool. Apply this function to each event and only return events where the result is true.\nwall_time = false: If true, show the wall_time timestamp.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.show_simulation_events-Union{Tuple{T}, Tuple{Type{T}, AbstractString}, Tuple{Type{T}, AbstractString, Union{Nothing, Function}}} where T<:InfrastructureSystems.AbstractRecorderEvent","page":"Public API","title":"PowerSimulations.show_simulation_events","text":"show_simulation_events(\n    ::Type{T<:InfrastructureSystems.AbstractRecorderEvent},\n    output_dir::AbstractString;\n    ...\n)\nshow_simulation_events(\n    ::Type{T<:InfrastructureSystems.AbstractRecorderEvent},\n    output_dir::AbstractString,\n    filter_func::Union{Nothing, Function};\n    step,\n    model,\n    wall_time,\n    kwargs...\n)\n\n\nshow_simulation_events(\n    ::Type{T},\n    output_dir::AbstractString,\n    filter_func::Union{Nothing,Function} = nothing;\n    step = nothing,\n    model = nothing,\n    wall_time = false,\n    kwargs...,\n) where { T <: IS.AbstractRecorderEvent}\n\nShow all simulation events of type T in a simulation output directory.\n\nArguments\n\n::Type{T}: Recorder event type\noutput_dir::AbstractString: Simulation output directory\nfilter_func::Union{Nothing, Function} = nothing: Refer to show_recorder_events.\nstep::Int = nothing: Filter events by step. Required if model is passed.\nmodel::Int = nothing: Filter events by model.\nwall_time = false: If true, show the wall_time timestamp.\n\n\n\n\n\n","category":"method"},{"location":"how_to/read_results/#read_results","page":"...read the simulation results","title":"Read results","text":"Once a DecisionModel is solved via solve!(model) or a Simulation is executed (and solved) via execute!(simulation), the results are stored and can be accessed directly in the REPL for result exploration and plotting.","category":"section"},{"location":"how_to/read_results/#Read-results-of-a-Decision-Problem","page":"...read the simulation results","title":"Read results of a Decision Problem","text":"Once a DecisionModel is solved, results are accessed using OptimizationProblemResults(model) as follows:\n\n# The DecisionModel is already constructed\nbuild!(model; output_dir = mktempdir())\nsolve!(model)\n\nresults = OptimizationProblemResults(model)\n\nThe output will showcase the available expressions, parameters and variables to read. For example it will look like:\n\nStart: 2020-01-01T00:00:00\nEnd: 2020-01-03T23:00:00\nResolution: 60 minutes\n\nPowerSimulations Problem Auxiliary variables Results\n┌──────────────────────────────────────────┐\n│ CumulativeCyclingCharge__HybridSystem    │\n│ CumulativeCyclingDischarge__HybridSystem │\n└──────────────────────────────────────────┘\n\nPowerSimulations Problem Expressions Results\n┌─────────────────────────────────────────────┐\n│ ProductionCostExpression__RenewableDispatch │\n│ ProductionCostExpression__ThermalStandard   │\n└─────────────────────────────────────────────┘\n\nPowerSimulations Problem Duals Results\n┌──────────────────────────────────────┐\n│ CopperPlateBalanceConstraint__System │\n└──────────────────────────────────────┘\n\nPowerSimulations Problem Parameters Results\n┌────────────────────────────────────────────────────────────────────────┐\n│ ActivePowerTimeSeriesParameter__RenewableNonDispatch                           │\n│ RenewablePowerTimeSeries__HybridSystem                                 │\n│ RequirementTimeSeriesParameter__VariableReserve__ReserveUp__Spin_Up_R3 │\n│ RequirementTimeSeriesParameter__VariableReserve__ReserveUp__Reg_Up     │\n│ ActivePowerTimeSeriesParameter__PowerLoad                              │\n│ ActivePowerTimeSeriesParameter__RenewableDispatch                      │\n│ RequirementTimeSeriesParameter__VariableReserve__ReserveDown__Reg_Down │\n│ ActivePowerTimeSeriesParameter__HydroDispatch                          │\n│ RequirementTimeSeriesParameter__VariableReserve__ReserveUp__Spin_Up_R1 │\n│ RequirementTimeSeriesParameter__VariableReserve__ReserveUp__Spin_Up_R2 │\n└────────────────────────────────────────────────────────────────────────┘\n\nPowerSimulations Problem Variables Results\n┌────────────────────────────────────────────────────────────────────┐\n│ ActivePowerOutVariable__HybridSystem                               │\n│ ReservationVariable__HybridSystem                                  │\n│ RenewablePower__HybridSystem                                       │\n│ ActivePowerReserveVariable__VariableReserve__ReserveUp__Spin_Up_R1 │\n│ SystemBalanceSlackUp__System                                       │\n│ BatteryEnergyShortageVariable__HybridSystem                        │\n│ ActivePowerReserveVariable__VariableReserve__ReserveUp__Reg_Up     │\n│ StopVariable__ThermalStandard                                      │\n│ BatteryStatus__HybridSystem                                        │\n│ BatteryDischarge__HybridSystem                                     │\n│ ActivePowerInVariable__HybridSystem                                │\n│ DischargeRegularizationVariable__HybridSystem                      │\n│ BatteryCharge__HybridSystem                                        │\n│ ActivePowerVariable__RenewableDispatch                             │\n│ ActivePowerReserveVariable__VariableReserve__ReserveDown__Reg_Down │\n│ EnergyVariable__HybridSystem                                       │\n│ OnVariable__HybridSystem                                           │\n│ BatteryEnergySurplusVariable__HybridSystem                         │\n│ SystemBalanceSlackDown__System                                     │\n│ ActivePowerReserveVariable__VariableReserve__ReserveUp__Spin_Up_R2 │\n│ ThermalPower__HybridSystem                                         │\n│ ActivePowerVariable__ThermalStandard                               │\n│ StartVariable__ThermalStandard                                     │\n│ ActivePowerReserveVariable__VariableReserve__ReserveUp__Spin_Up_R3 │\n│ OnVariable__ThermalStandard                                        │\n│ ChargeRegularizationVariable__HybridSystem                         │\n└────────────────────────────────────────────────────────────────────┘\n\nThen the following code can be used to read results:\n\n# Read active power of Thermal Standard\nthermal_active_power = read_variable(results, \"ActivePowerVariable__ThermalStandard\")\n\n# Read max active power parameter of RenewableDispatch\nrenewable_param =\n    read_parameter(results, \"ActivePowerTimeSeriesParameter__RenewableDispatch\")\n\n# Read cost expressions of ThermalStandard units\ncost_thermal = read_expression(results, \"ProductionCostExpression__ThermalStandard\")\n\n# Read dual variables\ndual_balance_constraint = read_dual(results, \"CopperPlateBalanceConstraint__System\")\n\n# Read auxiliary variables\naux_var_result = read_aux_variable(results, \"CumulativeCyclingCharge__HybridSystem\")\n\nResults will be in the form of DataFrames that can be easily explored.","category":"section"},{"location":"how_to/read_results/#Read-results-of-a-Simulation","page":"...read the simulation results","title":"Read results of a Simulation","text":"# The Simulation is already constructed\nbuild!(sim)\nexecute!(sim; enable_progress_bar = true)\n\nresults_sim = SimulationResults(sim)\n\nAs an example, the SimulationResults printing will look like:\n\nDecision Problem Results\n┌──────────────┬─────────────────────┬──────────────┬─────────────────────────┐\n│ Problem Name │ Initial Time        │ Resolution   │ Last Solution Timestamp │\n├──────────────┼─────────────────────┼──────────────┼─────────────────────────┤\n│ ED           │ 2020-10-02T00:00:00 │ 60 minutes   │ 2020-10-09T23:00:00     │\n│ UC           │ 2020-10-02T00:00:00 │ 1440 minutes │ 2020-10-09T00:00:00     │\n└──────────────┴─────────────────────┴──────────────┴─────────────────────────┘\n\nEmulator Results\n┌─────────────────┬───────────┐\n│ Name            │ Emulator  │\n│ Resolution      │ 5 minutes │\n│ Number of steps │ 2304      │\n└─────────────────┴───────────┘\n\nWith this, it is possible to obtain results of each DecisionModel and EmulationModel as follows:\n\n# Use the Problem Name for Decision Problems\nresults_uc = get_decision_problem_results(results_sim, \"UC\")\nresults_ed = get_decision_problem_results(results_sim, \"ED\")\nresults_emulator = get_emulation_problem_results(results_sim)\n\nOnce we have each decision (or emulation) problem results, we can explore directly using the approach for Decision Models, mentioned in the previous section.","category":"section"},{"location":"how_to/read_results/#Reading-solutions-for-all-simulation-steps","page":"...read the simulation results","title":"Reading solutions for all simulation steps","text":"In this case, using read_variable (or read expression, parameter or dual), will return a dictionary of all steps (of that Decision Problem). For example, the following code:\n\nthermal_active_power = read_variable(results_uc, \"ActivePowerVariable__ThermalStandard\")\n\nwill return:\n\nDataStructures.SortedDict{Any, Any, Base.Order.ForwardOrdering} with 8 entries:\n  DateTime(\"2020-10-02T00:00:00\") => 72×54 DataFrame…\n  DateTime(\"2020-10-03T00:00:00\") => 72×54 DataFrame…\n  DateTime(\"2020-10-04T00:00:00\") => 72×54 DataFrame…\n  DateTime(\"2020-10-05T00:00:00\") => 72×54 DataFrame…\n  DateTime(\"2020-10-06T00:00:00\") => 72×54 DataFrame…\n  DateTime(\"2020-10-07T00:00:00\") => 72×54 DataFrame…\n  DateTime(\"2020-10-08T00:00:00\") => 72×54 DataFrame…\n  DateTime(\"2020-10-09T00:00:00\") => 72×54 DataFrame…\n\nThat is, a sorted dictionary for each simulation step, using as a key the initial timestamp for that specific simulation step.\n\nNote that in this case, each DataFrame, has a dimension of 72 times 54, since the horizon is 72 hours (number of rows), but the interval is only 24 hours. Indeed, note the initial timestamp of each simulation step is the beginning of each day, i.e. 24 hours. Finally, there 54 columns, since this example system has 53 ThermalStandard units (plus 1 column for the timestamps). The user is free to explore the solution of any simulation step as needed.","category":"section"},{"location":"how_to/read_results/#Reading-the-\"realized\"-solution-(i.e.-the-interval)","page":"...read the simulation results","title":"Reading the \"realized\" solution (i.e. the interval)","text":"Using read_realized_variable (or read realized expression, parameter or dual), will return the DataFrame of the realized solution of any specific variable. That is, it will concatenate the corresponding simulation step with the specified interval of that step, to construct a single DataFrame with the \"realized solution\" of the entire simulation.\n\nFor example, the code:\n\nth_realized_power =\n    read_realized_variable(results_uc, \"ActivePowerVariable__ThermalStandard\")\n\nwill return:\n\n92×54 DataFrame\n Row │ DateTime             322_CT_6      321_CC_1  202_STEAM_3   223_CT_4  123_STEAM_2    213_CT_1  223_CT_6  313_CC_1  101_STEAM_3  123_C ⋯\n     │ DateTime             Float64       Float64   Float64       Float64   Float64        Float64   Float64   Float64   Float64      Float ⋯\n─────┼───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n   1 │ 2020-10-02T00:00:00   0.0           293.333   0.0               0.0    0.0               0.0       0.0   231.667      76.0     0.0   ⋯\n   2 │ 2020-10-02T01:00:00   0.0           267.552   0.0               0.0    0.0               0.0       0.0   231.667      76.0     0.0\n   3 │ 2020-10-02T02:00:00   0.0           234.255   0.0               0.0   -4.97544e-11       0.0       0.0   231.667      76.0     0.0\n   4 │ 2020-10-02T03:00:00   0.0           249.099   0.0               0.0   -4.97544e-11       0.0       0.0   231.667      76.0     0.0\n   5 │ 2020-10-02T04:00:00   0.0           293.333   0.0               0.0   -4.97544e-11       0.0       0.0   231.667      76.0     0.0   ⋯\n   6 │ 2020-10-02T05:00:00   0.0           293.333   1.27578e-11       0.0   -4.97544e-11       0.0       0.0   293.333      76.0     0.0\n  ⋮  │          ⋮                ⋮           ⋮           ⋮           ⋮            ⋮           ⋮         ⋮         ⋮           ⋮             ⋱\n 187 │ 2020-10-09T18:00:00   0.0           293.333  76.0               0.0  155.0               0.0       0.0   318.843      76.0     0.0\n 188 │ 2020-10-09T19:00:00   0.0           293.333  76.0               0.0  124.0               0.0       0.0   293.333      76.0     0.0\n 189 │ 2020-10-09T20:00:00   0.0           293.333  60.6667            0.0  124.0               0.0       0.0     0.0        76.0     0.0   ⋯\n 190 │ 2020-10-09T21:00:00  -7.65965e-12   293.333  60.6667            0.0  124.0               0.0       0.0     0.0        76.0     0.0\n 191 │ 2020-10-09T22:00:00   0.0             0.0    60.6667            0.0  124.0               0.0       0.0     0.0        76.0     7.156\n 192 │ 2020-10-09T23:00:00   0.0             0.0    60.6667            0.0  117.81              0.0       0.0     0.0        76.0     0.0\n                                                                                                              44 columns and 180 rows omitted\n\nIn this case, the 8 simulation steps of 24 hours (192 hours), in a single DataFrame, to enable easy exploration of the realized results for the user.","category":"section"},{"location":"api/glossary/#Definitions","page":"Glossary and Acronyms","title":"Definitions","text":"","category":"section"},{"location":"api/glossary/#A","page":"Glossary and Acronyms","title":"A","text":"Attributes: Certain device formulations can be customized by specifying attributes that will include/remove certain variables, expressions and/or constraints. For example, in StorageSystemsSimulations.jl, the device formulation of StorageDispatchWithReserves can be specified with the following dictionary of attributes:\n\nset_device_model!(\n    template,\n    DeviceModel(\n        GenericBattery,\n        StorageDispatchWithReserves;\n        attributes = Dict{String, Any}(\n            \"reservation\" => false,\n            \"cycling_limits\" => false,\n            \"energy_target\" => false,\n            \"complete_coverage\" => false,\n            \"regularization\" => false,\n        ),\n    ),\n)\n\nChanging the attributes between true or false can enable/disable multiple aspects of the formulation.","category":"section"},{"location":"api/glossary/#C","page":"Glossary and Acronyms","title":"C","text":"Chronologies: In PowerSimulations.jl, chronologies define where information is flowing. There are two types of chronologies. 1) inter-stage chronologies (InterProblemChronology) that define how information flows between stages. e.g. day-ahead solutions are used to inform economic dispatch problems; and 2) intra-stage chronologies (IntraProblemChronology) that define how information flows between multiple executions of a single stage. e.g. the dispatch setpoints of the first period of an economic dispatch problem are constrained by the ramping limits from setpoints in the final period of the previous problem.","category":"section"},{"location":"api/glossary/#D","page":"Glossary and Acronyms","title":"D","text":"Decision Problem: A decision problem calculates the desired system operation based on forecasts of uncertain inputs and information about the state of the system. The output of a decision problem represents the policies used to drive the set-points of the system's devices, like generators or switches, and depends on the purpose of the problem. See the tutorial on Running a Simple-Step Problem to learn more about solving individual problems.\nDevice Formulation: The model of a device that is incorporated into a large system optimization models. For instance, the storage device model used inside of a Unit Commitment (UC) problem. A device model needs to follow some requirements to be integrated into operation problems. For more information about valid DeviceModels and their mathematical representations, check out the Formulation Library.","category":"section"},{"location":"api/glossary/#E","page":"Glossary and Acronyms","title":"E","text":"Emulation Problem: An emulation problem is used to mimic the system's behavior subject to an incoming decision and the realization of a forecasted inputs. The solution of the emulator produces outputs representative of the system performance when operating subject the policies resulting from the decision models.","category":"section"},{"location":"api/glossary/#F","page":"Glossary and Acronyms","title":"F","text":"FeedForward: The definition of exactly what information is passed using the defined chronologies is accomplished using FeedForwards. Specifically, a FeedForward is used to define what to do with information being passed with an inter-stage chronology in a Simulation. The most common FeedForward is the SemiContinuousFeedForward that affects the semi-continuous range constraints of thermal generators in the economic dispatch problems based on the value of the (already solved) unit-commitment variables.","category":"section"},{"location":"api/glossary/#H","page":"Glossary and Acronyms","title":"H","text":"Horizon: The number of steps in the look-ahead of a decision problem. For instance, a Day-Ahead problem usually has a 48 step horizon. Check the time Time Series Data Section in PowerSystems.jl","category":"section"},{"location":"api/glossary/#I","page":"Glossary and Acronyms","title":"I","text":"Interval: The amount of time between updates to the decision problem. For instance, Day-Ahead problems usually have a 24-hour intervals and Real-Time problems have 5-minute intervals. Check the time Time Series Data Section in PowerSystems.jl","category":"section"},{"location":"api/glossary/#R","page":"Glossary and Acronyms","title":"R","text":"Resolution: The amount of time between time steps in a simulation. For instance 1-hour or 5-minutes. In Julia these are defined using the syntax Hour(1) and Minute(5). Check the time Time Series Data Section in PowerSystems.jl\nResults vs Realized Results: In PowerSimulations.jl the term results is used to refer to the solution of all optimization problems in a Simulation. When using read_variable(results, Variable) in a DecisionModel of a simulation, the output is a dictionary with the values of such variable for every optimization problem solved, while read_realized_variable(results, Variable) will return the values of the specified interval and number of steps in the simulation. See the Read Results page for more details.","category":"section"},{"location":"api/glossary/#S","page":"Glossary and Acronyms","title":"S","text":"Service Formulation: The model of a service that is incorporated into a large system optimization models. Services (or ancillary services) are models used to ensure that there is necessary support to the power grid from generators to consumers, in order to ensure reliable operation of the system. The most common application for ancillary services are reserves, i.e., generation (or load) that is not currently being used, but can be quickly made available in case of unexpected changes of grid conditions, for example a sudden loss of load or generation. A service model needs to follow some requirements to be integrated into operation problems. For more information about valid ServiceModels and their mathematical representations, check out the Formulation Library.\nSimulation: A simulation is a pre-determined sequence of decision problems in a way that solving it, resembles the solution procedures commonly used by operators. The most common simulation model is the solution of a Unit Commitment and Economic Dispatch sequence of problems.\nSolver: A solver is a software package that incorporates algorithms for finding solutions to one or more classes of optimization problem. For example, FICO Xpress is a commercial optimization solver for linear programming (LP), convex quadratic programming (QP) problems, convex quadratically constrained quadratic programming (QCQP), second-order cone programming (SOCP) and their mixed integer counterparts. A solver is required to be specified in order to solve any computer optimization problem.","category":"section"},{"location":"api/glossary/#T","page":"Glossary and Acronyms","title":"T","text":"Template: A ProblemTemplate is just a collection of DeviceModels that allows the user to specify the formulations of each set of devices (by device type) independently so that the modeler can adjust the level of detail according to the question of interest and the available data. For more information about valid DeviceModels and their mathematical representations, check out the Formulation Library.","category":"section"},{"location":"api/developer/#Guidelines-for-Developers","page":"Developer Guidelines","title":"Guidelines for Developers","text":"In order to contribute to PowerSimulations.jl repository please read the following sections of InfrastructureSystems.jl documentation in detail:\n\nStyle Guide\nContributing Guidelines\n\nPull requests are always welcome to fix bugs or add additional modeling capabilities.\n\nAll the code contributions need to include tests with a minimum coverage of 70%","category":"section"},{"location":"explanation/feedforward/#feedforward","page":"Feedforward","title":"Feedforward","text":"The definition of exactly what information is passed using the defined chronologies is accomplished using FeedForwards.\n\nSpecifically, a FeedForward is used to define what to do with information being passed with an inter-stage chronology in a Simulation. The most common FeedForward is the SemiContinuousFeedForward that affects the semi-continuous range constraints of thermal generators in the economic dispatch problems based on the value of the (already solved) unit-commitment variables.\n\nThe creation of a FeedForward requires at least to specify the component_type on which the FeedForward will be applied. The source variable specify which variable will be taken from the problem solved, for example the commitment variable of the thermal unit in the unit commitment problem. Finally, the affected_values specify which variables will be affected in the problem to be solved, for example the next economic dispatch problem.","category":"section"},{"location":"formulation_library/Introduction/#formulation_intro","page":"Introduction","title":"Formulations Introduction","text":"PowerSimulations.jl enables modularity in its formulations by assigning a DeviceModel to each PowerSystems.jl component type existing in a defined system.\n\nPowerSimulations.jl has a multiple AbstractDeviceFormulation subtypes that can be applied to different PowerSystems.jl device types, each dispatching to different methods for populating the optimization problem variables, objective function, expressions and constraints.","category":"section"},{"location":"formulation_library/Introduction/#Example-Formulation","page":"Introduction","title":"Example Formulation","text":"For example a typical optimization problem in a DecisionModel in PowerSimulations.jl with three DeviceModel has the abstract form of:\n\nbeginalign*\n    min_boldsymbolx textObjective_DeviceModelA + textObjective_DeviceModelB + textObjective_DeviceModelC \n     textst \n     hspace09cm textConstraints_NetworkModel \n     hspace09cm textConstraints_DeviceModelA \n     hspace09cm textConstraints_DeviceModelB \n     hspace09cm textConstraints_DeviceModelC \nendalign*\n\nSuppose this is a system with the following characteristics:\n\nHorizon: 48 hours\nInterval: 24 hours\nResolution: 1 hour\nThree Buses: 1, 2 and 3\nOne ThermalStandard (device A) unit at bus 1\nOne RenewableDispatch (device B) unit at bus 2\nOne PowerLoad (device C) at bus 3\nThree Line that connects all the buses\n\nNow, we assign the following DeviceModel to each PowerSystems.jl with:\n\nType Formulation\nNetwork CopperPlatePowerModel\nThermalStandard ThermalDispatchNoMin\nRenewableDispatch RenewableFullDispatch\nPowerLoad StaticPowerLoad\n\nNote that we did not assign any DeviceModel to Line since the CopperPlatePowerModel used for the network assumes that everything is lumped in the same node (like a copper plate with infinite capacity), and hence there are no flows between buses that branches can limit.\n\nEach DeviceModel formulation is described in specific in their respective page, but the overall optimization problem will end-up as:\n\nbeginalign*\n    min_boldsymbolp^textth boldsymbolp^textre sum_t=1^48 C^textth p_t^textth - C^textre p_t^textre \n     textst \n     hspace09cm p_t^textth + p_t^textre = P_t^textload quad forall t in 1dots 48 \n     hspace09cm 0 le p_t^textth le P^textthmax \n     hspace09cm 0 le p_t^textre le textActivePowerTimeSeriesParameter_t \nendalign*\n\nNote that the StaticPowerLoad does not impose any cost to the objective function or constraint but adds its power demand to the supply-balance demand of the CopperPlatePowerModel used. Since we are using the ThermalDispatchNoMin formulation for the thermal generation, the lower bound for the power is 0, instead of P^textthmin. In addition, we are assuming a linear cost C^textth. Finally, the RenewableFullDispatch formulation allows the dispatch of the renewable unit between 0 and its maximum injection time series p_t^textreparam.","category":"section"},{"location":"formulation_library/Introduction/#Nomenclature","page":"Introduction","title":"Nomenclature","text":"In the formulations described in the other pages, the nomenclature is as follows:\n\nLowercase letters are used for variables, e.g., p for power.\nUppercase letters are used for parameters, e.g., C for costs.\nSubscripts are used for indexing, e.g., (cdot)_t for indexing at time t.\nSuperscripts are used for descriptions, e.g., (cdot)^textth to describe a thermal (th) variable/parameter.\nBold letters are used for vectors, e.g., boldsymbolp = p_1dots24.","category":"section"},{"location":"explanation/psi_structure/#psi_structure","page":"PowerSimulations.jl Modeling Structure","title":"PowerSimulations.jl Modeling Structure","text":"PowerSimulations enables the simulation of a sequence of power systems optimization problems and provides user control over each aspect of the simulation configuration. Specifically:\n\nmathematical formulations can be selected for each component with DeviceModel and ServiceModel\na problem can be defined by creating model entries in a Operations ProblemTemplates\nmodels (DecisionModel or EmulationModel) can be built by applying a ProblemTemplate to a System and can be executed/solved in isolation or as part of a Simulation\nSimulations can be defined and executed by sequencing one or more models and defining how and when data flows between models.\n\nquestion: What is the difference between a Model and a Problem?\nA \"Problem\" is an abstract mathematical description of how to represent power system behavior, whereas a \"Model\" is a concrete representation of a \"Problem\" applied to a dataset. I.e. once a Problem is populated with data describing all the loads, generators, lines, etc., it becomes a Model.","category":"section"},{"location":"how_to/simulation_recorder/#Simulation-Recorder","page":"...inspect simulation events using the recorder","title":"Simulation Recorder","text":"PowerSimulations.jl provides the ability to record structured data as events during a simulation. These events can be post-processed to help debug problems.\n\nBy default only SimulationStepEvent and ProblemExecutionEvent are recorded.  Here is an example.\n\nSuppose a simulation is run in the directory ./output.\n\nAssume that setup commands have been run:\n\nusing PowerSimulations\nimport PowerSimulations as PSI\n\nNote that for all functions below you can optionally specify a function to filter events. The function must accept the event type and return true or false.","category":"section"},{"location":"how_to/simulation_recorder/#Show-all-events-of-type-PSI.SimulationStepEvent","page":"...inspect simulation events using the recorder","title":"Show all events of type PSI.SimulationStepEvent","text":"julia> show_simulation_events(PSI.SimulationStepEvent, \"./output/aggregation/1\")\n┌─────────────────────┬─────────────────────┬──────┬────────┐\n│                name │     simulation_time │ step │ status │\n├─────────────────────┼─────────────────────┼──────┼────────┤\n│ SimulationStepEvent │ 2024-01-01T00:00:00 │    1 │  start │\n│ SimulationStepEvent │ 2024-01-01T23:00:00 │    1 │   done │\n│ SimulationStepEvent │ 2024-01-01T23:00:00 │    2 │  start │\n│ SimulationStepEvent │ 2024-01-02T23:00:00 │    2 │   done │\n└─────────────────────┴─────────────────────┴──────┴────────┘","category":"section"},{"location":"how_to/simulation_recorder/#Show-events-of-type-PSI.ProblemExecutionEvent-for-a-specific-step-and-stage.","page":"...inspect simulation events using the recorder","title":"Show events of type PSI.ProblemExecutionEvent for a specific step and stage.","text":"show_simulation_events(\n    PSI.ProblemExecutionEvent,\n    \"./output/aggregation/1\",\n    x -> x.step == 1 && x.stage == 2 && x.status == \"start\"\n)\n┌──────────────────────┬─────────────────────┬──────┬───────┬────────┐\n│                 name │     simulation_time │ step │ stage │ status │\n├──────────────────────┼─────────────────────┼──────┼───────┼────────┤\n│ ProblemExecutionEvent │ 2024-01-01T00:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T00:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T01:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T02:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T03:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T04:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T05:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T06:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T07:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T08:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T09:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T10:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T11:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T12:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T13:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T14:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T15:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T16:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T17:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T18:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T19:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T20:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T21:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T22:00:00 │    1 │     2 │  start │\n└──────────────────────┴─────────────────────┴──────┴───────┴────────┘","category":"section"},{"location":"explanation/sequencing/#sequencing","page":"Sequencing","title":"Sequencing","text":"In a typical simulation pipeline, we want to connect daily (24-hours) day-ahead unit commitment problems, with multiple economic dispatch problems. Usually, our day-ahead unit commitment problem will have an hourly (1-hour) resolution, while the economic dispatch will have a 5-minute resolution.\n\nDepending on your problem, it is common to use a 2-day look-ahead for unit commitment problems, so in this case, the Day-Ahead problem will have: resolution = Hour(1) with interval = Hour(24) and horizon = Hour(48). In the case of the economic dispatch problem, it is common to use a look-ahead of two hours. Thus, the Real-Time problem will have: resolution = Minute(5), with interval = Minute(5) (we only store the first operating point) and horizon = 24 (24 time steps of 5 minutes are 120 minutes, that is 2 hours).","category":"section"},{"location":"formulation_library/General/#formulation_library","page":"General","title":"Formulations","text":"Modeling formulations are created by dispatching on abstract subtypes of PowerSimulations.AbstractDeviceFormulation","category":"section"},{"location":"formulation_library/General/#FixedOutput","page":"General","title":"FixedOutput","text":"Variables:\n\nNo variables are created for DeviceModel(<:DeviceType, FixedOutput)\n\nStatic Parameters:\n\nThermalGen:\nP^textthmax = PowerSystems.get_max_active_power(device)\nQ^textthmax = PowerSystems.get_max_reactive_power(device)\nStorage:\nP^textstmax = PowerSystems.get_max_active_power(device)\nQ^textstmax = PowerSystems.get_max_reactive_power(device)\n\nTime Series Parameters:\n\nusing PowerSimulations\nusing HydroPowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombo_tables = []\nfor t in [RenewableGen, ThermalGen, HydroGen, ElectricLoad]\n    combos = PowerSimulations.get_default_time_series_names(t, FixedOutput)\n    combo_table = DataFrame(\n        \"Parameter\" => map(x -> \"[`$x`](@ref)\", collect(keys(combos))),\n        \"Default Time Series Name\" => map(x -> \"`$x`\", collect(values(combos))),\n    )\n    insertcols!(combo_table, 1, \"Device Type\" => fill(string(t), length(combos)))\n    push!(combo_tables, combo_table)\nend\nmdtable(vcat(combo_tables...); latex = false)\n\nObjective:\n\nNo objective terms are created for DeviceModel(<:DeviceType, FixedOutput)\n\nExpressions:\n\nAdds the active and reactive parameters listed for specific device types above to the respective active and reactive power balance expressions created by the selected Network Formulations.\n\nConstraints:\n\nNo constraints are created for DeviceModel(<:DeviceType, FixedOutput)\n\n","category":"section"},{"location":"formulation_library/General/#FunctionData-Options","page":"General","title":"FunctionData Options","text":"PowerSimulations can represent variable costs using a variety of different methods depending on the data available in each device. The following describes the objective function terms that are populated for each variable cost option.","category":"section"},{"location":"formulation_library/General/#LinearFunctionData","page":"General","title":"LinearFunctionData","text":"variable_cost = LinearFunctionData(c): creates a fixed marginal cost term in the objective function\n\nbeginaligned\n  textmin sum_t c * G_t\nendaligned","category":"section"},{"location":"formulation_library/General/#QuadraticFunctionData-and-PolynomialFunctionData","page":"General","title":"QuadraticFunctionData and PolynomialFunctionData","text":"variable_cost::QuadraticFunctionData and variable_cost::PolynomialFunctionData: create a polynomial cost term in the objective function\n\nbeginaligned\n  textmin sum_t sum_n C_n * G_t^n\nendaligned\n\nwhere\n\nFor QuadraticFunctionData:\nC_0 = get_constant_term(variable_cost)\nC_1 = get_proportional_term(variable_cost)\nC_2 = get_quadratic_term(variable_cost)\nFor PolynomialFunctionData:\nC_n = get_coefficients(variable_cost)[n]","category":"section"},{"location":"formulation_library/General/#andPiecewiseLinearSlopeData","page":"General","title":"`andPiecewiseLinearSlopeData`","text":"variable_cost::PiecewiseLinearData and variable_cost::PiecewiseLinearSlopeData: create a piecewise linear cost term in the objective function\n\nbeginaligned\n  textmin sum_t f(G_t)\nendaligned\n\nwhere\n\nFor variable_cost::PiecewiseLinearData, f(x) is the piecewise linear function obtained by connecting the (x, y) points get_points(variable_cost) in order.\nFor variable_cost = PiecewiseLinearSlopeData([x0, x1, x2, ...], y0, [s0, s1, s2, ...]), f(x) is the piecewise linear function obtained by starting at (x0, y0), drawing a segment at slope s0 to x=x1, drawing a segment at slope s1 to x=x2, etc.\n","category":"section"},{"location":"formulation_library/General/#StorageCost","page":"General","title":"StorageCost","text":"Adds an objective function cost term according to:\n\nbeginaligned\n  textmin sum_t quad E^surplus_t * C^penalty - E^shortage_t * C^value\nendaligned\n\nImpact of different cost configurations:\n\nThe following table describes all possible configurations of the StorageCost with the target constraint in hydro or storage device models. Cases 1(a) & 2(a) will not impact the model's operations, and the target constraint will be rendered useless. In most cases that have no energy target and a non-zero value for C^value, if this cost is too high (C^value  0) or too low (C^value 0) can result in either the model holding on to stored energy till the end of the model not storing any energy in the device. This is caused by the fact that when the energy target is zero, we have E_t = - E^shortage_t, and - E^shortage_t * C^value in the objective function is replaced by E_t * C^value, thus resulting in C^value to be seen as the cost of stored energy.\n\nCase Energy Target Energy Shortage Cost Energy Value / Energy Surplus cost Effect\nCase 1(a) hatE=0 C^penalty=0 C^value=0 no change\nCase 1(b) hatE=0 C^penalty=0 C^value0 penalty for storing energy\nCase 1(c) hatE=0 C^penalty0 C^value=0 no penalties or incentives applied\nCase 1(d) hatE=0 C^penalty=0 C^value0 incentive for storing energy\nCase 1(e) hatE=0 C^penalty0 C^value0 penalty for storing energy\nCase 1(f) hatE=0 C^penalty0 C^value0 incentive for storing energy\nCase 2(a) hatE0 C^penalty=0 C^value=0 no change\nCase 2(b) hatE0 C^penalty=0 C^value0 penalty on energy storage in excess of target\nCase 2(c) hatE0 C^penalty0 C^value=0 penalty on energy storage short of target\nCase 2(d) hatE0 C^penalty=0 C^value0 incentive on excess energy\nCase 2(e) hatE0 C^penalty0 C^value0 penalty on both excess/shortage of energy\nCase 2(f) hatE0 C^penalty0 C^value0 penalty for shortage, incentive for excess energy","category":"section"},{"location":"formulation_library/General/#PowerSimulations.FixedOutput","page":"General","title":"PowerSimulations.FixedOutput","text":"Formulation type to augment the power balance constraint expression with a time series parameter\n\n\n\n\n\n","category":"type"},{"location":"explanation/chronologies/#chronologies","page":"Chronologies","title":"Chronologies","text":"In PowerSimulations, chronologies define where information is flowing. There are two types of chronologies.\n\ninter-stage chronologies: Define how information flows between stages. e.g. day-ahead solutions are used to inform economic dispatch problems\nintra-stage chronologies: Define how information flows between multiple executions of a single stage. e.g. the dispatch setpoints of the first period of an economic dispatch problem are constrained by the ramping limits from setpoints in the final period of the previous problem.","category":"section"},{"location":"formulation_library/RenewableGen/#PowerSystems.RenewableGen-Formulations","page":"Renewable Generation","title":"PowerSystems.RenewableGen Formulations","text":"Renewable generation formulations define the optimization models that describe renewable units mathematical model in different operational settings, such as economic dispatch and unit commitment.\n\nnote: Note\nThe use of reactive power variables and constraints will depend on the network model used, i.e., whether it uses (or does not use) reactive power. If the network model is purely active power-based, reactive power variables and related constraints are not created.\n\nnote: Note\nReserve variables for services are not included in the formulation, albeit their inclusion change the variables, expressions, constraints and objective functions created. A detailed description of the implications in the optimization models is described in the Service formulation section.","category":"section"},{"location":"formulation_library/RenewableGen/#Table-of-contents","page":"Renewable Generation","title":"Table of contents","text":"RenewableFullDispatch\nRenewableConstantPowerFactor\nValid configurations\n\n","category":"section"},{"location":"formulation_library/RenewableGen/#RenewableFullDispatch","page":"Renewable Generation","title":"RenewableFullDispatch","text":"Variables:\n\nActivePowerVariable:\nBounds: [0.0, ]\nSymbol: p^textre\nReactivePowerVariable:\nBounds: [0.0, ]\nSymbol: q^textre\n\nStatic Parameters:\n\nP^textremin = PowerSystems.get_active_power_limits(device).min\nQ^textremin = PowerSystems.get_reactive_power_limits(device).min\nQ^textremax = PowerSystems.get_reactive_power_limits(device).max\n\nTime Series Parameters:\n\nUses the max_active_power timeseries parameter to limit the available active power at each time-step.\n\nusing PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.get_default_time_series_names(RenewableGen, RenewableFullDispatch)\ncombo_table = DataFrame(\n    \"Parameter\" => map(x -> \"[`$x`](@ref)\", collect(keys(combos))),\n    \"Default Time Series Name\" => map(x -> \"`$x`\", collect(values(combos))),\n)\nmdtable(combo_table; latex = false)\n\nObjective:\n\nCreates an objective function term based on the FunctionData Options where the quantity term is defined as - p^textre to incentivize generation from RenewableGen devices.\n\nExpressions:\n\nAdds p^textre and q^textre terms to the respective active and reactive power balance expressions created by the selected Network Formulations.\n\nConstraints:\n\nbeginaligned\n  P^textremin le p_t^textre le textActivePowerTimeSeriesParameter_t quad forall t in 1dots T \n  Q^textremin le q_t^textre le Q^textremax quad forall t in 1dots T\nendaligned\n\n","category":"section"},{"location":"formulation_library/RenewableGen/#RenewableConstantPowerFactor","page":"Renewable Generation","title":"RenewableConstantPowerFactor","text":"Variables:\n\nActivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_active_power(device)\nSymbol: p^textre\nReactivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_reactive_power(device)\nSymbol: q^textre\n\nStatic Parameters:\n\nP^textremin = PowerSystems.get_active_power_limits(device).min\nQ^textremin = PowerSystems.get_reactive_power_limits(device).min\nQ^textremax = PowerSystems.get_reactive_power_limits(device).max\ntextpf = PowerSystems.get_power_factor(device)\n\nTime Series Parameters:\n\nusing PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.get_default_time_series_names(\n    RenewableGen,\n    RenewableConstantPowerFactor,\n)\ncombo_table = DataFrame(\n    \"Parameter\" => map(x -> \"[`$x`](@ref)\", collect(keys(combos))),\n    \"Default Time Series Name\" => map(x -> \"`$x`\", collect(values(combos))),\n)\nmdtable(combo_table; latex = false)\n\nObjective:\n\nCreates an objective function term based on the FunctionData Options where the quantity term is defined as - p_t^textre to incentivize generation from RenewableGen devices.\n\nExpressions:\n\nAdds p^textre and q^textre terms to the respective active and reactive power balance expressions created by the selected Network Formulations\n\nConstraints:\n\nbeginaligned\n  P^textremin le p_t^textre le textActivePowerTimeSeriesParameter_t quad forall t in 1dots T \n  q_t^textre = textpf cdot p_t^textre quad forall t in 1dots T\nendaligned\n\n","category":"section"},{"location":"formulation_library/RenewableGen/#Valid-configurations","page":"Renewable Generation","title":"Valid configurations","text":"Valid DeviceModels for subtypes of RenewableGen include the following:\n\nusing PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.generate_device_formulation_combinations()\nfilter!(x -> x[\"device_type\"] <: RenewableGen, combos)\ncombo_table = DataFrame(\n    \"Valid DeviceModel\" =>\n        [\"`DeviceModel($(c[\"device_type\"]), $(c[\"formulation\"]))`\" for c in combos],\n    \"Device Type\" => [\n        \"[$(c[\"device_type\"])](https://nrel-Sienna.github.io/PowerSystems.jl/stable/model_library/generated_$(c[\"device_type\"])/)\"\n        for c in combos\n    ],\n    \"Formulation\" => [\"[$(c[\"formulation\"])](@ref)\" for c in combos],\n)\nmdtable(combo_table; latex = false)","category":"section"},{"location":"formulation_library/RenewableGen/#PowerSimulations.RenewableFullDispatch","page":"Renewable Generation","title":"PowerSimulations.RenewableFullDispatch","text":"Formulation type to add injection variables constrained by a maximum injection time series for RenewableGen\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/RenewableGen/#PowerSimulations.RenewableConstantPowerFactor","page":"Renewable Generation","title":"PowerSimulations.RenewableConstantPowerFactor","text":"Formulation type to add real and reactive injection variables with constant power factor with maximum real power injections constrained by a time series for RenewableGen\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Service/#service_formulations","page":"Services","title":"PowerSystems.Service Formulations","text":"Services (or ancillary services) are models used to ensure that there is necessary support to the power grid from generators to consumers, in order to ensure reliable operation of the system.\n\nThe most common application for ancillary services are reserves, i.e., generation (or load) that is not currently being used, but can be quickly made available in case of unexpected changes of grid conditions, for example a sudden loss of load or generation.\n\nA key challenge of adding services to a system, from a mathematical perspective, is specifying which units contribute to the specified requirement of a service, that implies the creation of new variables (such as reserve variables) and modification of constraints.\n\nIn this documentation, we first specify the available Services in the grid, and what requirements impose in the system, and later we discuss the implication on device formulations for specific units.","category":"section"},{"location":"formulation_library/Service/#Table-of-contents","page":"Services","title":"Table of contents","text":"RangeReserve\nStepwiseCostReserve\nGroupReserve\nRampReserve\nNonSpinningReserve\nConstantMaxInterfaceFlow\nVariableMaxInterfaceFlow\nChanges on Expressions\n\n","category":"section"},{"location":"formulation_library/Service/#RangeReserve","page":"Services","title":"RangeReserve","text":"For each service s of the model type RangeReserve the following variables are created:\n\nVariables:\n\nActivePowerReserveVariable:\nBounds: [0.0, ]\nDefault proportional cost: 10  textSystemBasePower\nSymbol: r_d for d in contributing devices to the service s If slacks are enabled:\nReserveRequirementSlack:\nBounds: [0.0, ]\nDefault proportional cost: 1e5\nSymbol: r^textsl\n\nDepending on the PowerSystems.jl type associated to the RangeReserve formulation model, the parameters are:\n\nStatic Parameters\n\ntextPF = PowerSystems.get_max_participation_factor(service)\n\nFor a ConstantReserve PowerSystems type:\n\ntextReq = PowerSystems.get_requirement(service)\n\nTime Series Parameters\n\nFor a VariableReserve PowerSystems type:\n\nusing PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.get_default_time_series_names(VariableReserve, RangeReserve)\ncombo_table = DataFrame(\n    \"Parameter\" => map(x -> \"[`$x`](@ref)\", collect(keys(combos))),\n    \"Default Time Series Name\" => map(x -> \"`$x`\", collect(values(combos))),\n)\nmdtable(combo_table; latex = false)\n\nRelevant Methods:\n\nmathcalD_s = PowerSystems.get_contributing_devices(system, service): Set (vector) of all contributing devices to the service s in the system.\n\nObjective:\n\nAdd a large proportional cost to the objective function if slack variables are used + r^textsl cdot 10^5. In addition adds the default cost for ActivePowerReserveVariables as a proportional cost.\n\nExpressions:\n\nAdds the ActivePowerReserveVariable for upper/lower bound expressions of contributing devices.\n\nFor ReserveUp types, the variable is added to ActivePowerRangeExpressionUB, such that this expression considers both the ActivePowerVariable and its reserve variable. Similarly, For ReserveDown types, the variable is added to ActivePowerRangeExpressionLB, such that this expression considers both the ActivePowerVariable and its reserve variable\n\nExample: for a thermal unit d contributing to two different ReserveUp s_1 s_2 services (e.g. Reg-Up and Spin):\n\ntextActivePowerRangeExpressionUB_t = p_t^textth + r_s_1t + r_s_2 t le P^textthmax\n\nsimilarly if s_3 is a ReserveDown service (e.g. Reg-Down):\n\ntextActivePowerRangeExpressionLB_t = p_t^textth - r_s_3t  ge P^textthmin\n\nConstraints:\n\nA RangeReserve implements two fundamental constraints. The first is that the sum of all reserves of contributing devices must be larger than the RangeReserve requirement. Thus, for a service s:\n\nsum_dinmathcalD_s r_dt + r_t^textsl ge textReqquad forall tin 1dots T quad text(for a ConstantReserve) \nsum_dinmathcalD_s r_dt + r_t^textsl ge textRequirementTimeSeriesParameter_tquad forall tin 1dots T quad text(for a VariableReserve)\n\nIn addition, there is a restriction on how much each contributing device d can contribute to the requirement, based on the max participation factor allowed.\n\nr_dt le textReq cdot textPF quad forall din mathcalD_s forall tin 1dots T quad text(for a ConstantReserve) \nr_dt le textRequirementTimeSeriesParameter_t cdot textPFquad  forall din mathcalD_s forall tin 1dots T quad text(for a VariableReserve)\n\n","category":"section"},{"location":"formulation_library/Service/#StepwiseCostReserve","page":"Services","title":"StepwiseCostReserve","text":"Service must be used with ReserveDemandCurve PowerSystems.jl type. This service model is used to model ORDC (Operating Reserve Demand Curve) in ERCOT.\n\nFor each service s of the model type ReserveDemandCurve the following variables are created:\n\nVariables:\n\nActivePowerReserveVariable:\nBounds: [0.0, ]\nSymbol: r_d for d in contributing devices to the service s\nServiceRequirementVariable:\nBounds: [0.0, ]\nSymbol: textreq\n\nTime Series Parameters\n\nFor a ReserveDemandCurve PowerSystems type:\n\nusing PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos =\n    PowerSimulations.get_default_time_series_names(ReserveDemandCurve, StepwiseCostReserve)\ncombo_table = DataFrame(\n    \"Parameter\" => map(x -> \"[`$x`](@ref)\", collect(keys(combos))),\n    \"Default Time Series Name\" => map(x -> \"`$x`\", collect(values(combos))),\n)\nmdtable(combo_table; latex = false)\n\nRelevant Methods:\n\nmathcalD_s = PowerSystems.get_contributing_devices(system, service): Set (vector) of all contributing devices to the service s in the system.\n\nObjective:\n\nThe ServiceRequirementVariable is added as a piecewise linear cost based on the decreasing offers listed in the variable_cost time series. These decreasing cost represent the scarcity prices of not having sufficient reserves. For example, if the variable textreq = 0, then a really high cost is paid for not having enough reserves, and if textreq is larger, then a lower cost (or even zero) is paid.\n\nExpressions:\n\nAdds the ActivePowerReserveVariable for upper/lower bound expressions of contributing devices.\n\nFor ReserveUp types, the variable is added to ActivePowerRangeExpressionUB, such that this expression considers both the ActivePowerVariable and its reserve variable. Similarly, For ReserveDown types, the variable is added to ActivePowerRangeExpressionLB, such that this expression considers both the ActivePowerVariable and its reserve variable\n\nExample: for a thermal unit d contributing to two different ReserveUp s_1 s_2 services (e.g. Reg-Up and Spin):\n\ntextActivePowerRangeExpressionUB_t = p_t^textth + r_s_1t + r_s_2 t le P^textthmax\n\nsimilarly if s_3 is a ReserveDown service (e.g. Reg-Down):\n\ntextActivePowerRangeExpressionLB_t = p_t^textth - r_s_3t  ge P^textthmin\n\nConstraints:\n\nA StepwiseCostReserve implements a single constraint, such that the sum of all reserves of contributing devices must be larger than the ServiceRequirementVariable variable. Thus, for a service s:\n\nsum_dinmathcalD_s r_dt  ge textreq_tquad forall tin 1dots T  ","category":"section"},{"location":"formulation_library/Service/#GroupReserve","page":"Services","title":"GroupReserve","text":"Service must be used with ConstantReserveGroup PowerSystems.jl type. This service model is used to model an aggregation of services.\n\nFor each service s of the model type GroupReserve the following variables are created:\n\nVariables:\n\nNo variables are created, but the services associated with the GroupReserve must have created variables.\n\nStatic Parameters\n\ntextReq = PowerSystems.get_requirement(service)\n\nRelevant Methods:\n\nmathcalS_s = PowerSystems.get_contributing_services(system, service): Set (vector) of all contributing services to the group service s in the system.\nmathcalD_s_i = PowerSystems.get_contributing_devices(system, service_aux): Set (vector) of all contributing devices to the service s_i in the system.\n\nObjective:\n\nDoes not modify the objective function, besides the changes to the objective function due to the other services associated to the group service.\n\nExpressions:\n\nNo changes, besides the changes to the expressions due to the other services associated to the group service.\n\nConstraints:\n\nA GroupReserve implements that the sum of all reserves of contributing devices, of all contributing services, must be larger than the GroupReserve requirement. Thus, for a GroupReserve service s:\n\nsum_dinmathcalD_s_i sum_i in mathcalS_s r_dt ge textReqquad forall tin 1dots T \n\n","category":"section"},{"location":"formulation_library/Service/#RampReserve","page":"Services","title":"RampReserve","text":"For each service s of the model type RampReserve the following variables are created:\n\nVariables:\n\nActivePowerReserveVariable:\nBounds: [0.0, ]\nDefault proportional cost: 10  textSystemBasePower\nSymbol: r_d for d in contributing devices to the service s If slacks are enabled:\nReserveRequirementSlack:\nBounds: [0.0, ]\nDefault proportional cost: 1e5\nSymbol: r^textsl\n\nRampReserve only accepts VariableReserve PowerSystems.jl type. With that, the parameters are:\n\nStatic Parameters\n\ntextTF = PowerSystems.get_time_frame(service)\nR^textthup = PowerSystems.get_ramp_limits(device).up for thermal contributing devices\nR^textthdn = PowerSystems.get_ramp_limits(device).down for thermal contributing devices\n\nTime Series Parameters\n\nFor a VariableReserve PowerSystems type:\n\nusing PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.get_default_time_series_names(VariableReserve, RampReserve)\ncombo_table = DataFrame(\n    \"Parameter\" => map(x -> \"[`$x`](@ref)\", collect(keys(combos))),\n    \"Default Time Series Name\" => map(x -> \"`$x`\", collect(values(combos))),\n)\nmdtable(combo_table; latex = false)\n\nRelevant Methods:\n\nmathcalD_s = PowerSystems.get_contributing_devices(system, service): Set (vector) of all contributing devices to the service s in the system.\n\nObjective:\n\nAdd a large proportional cost to the objective function if slack variables are used + r^textsl cdot 10^5. In addition adds the default cost for ActivePowerReserveVariables as a proportional cost.\n\nExpressions:\n\nAdds the ActivePowerReserveVariable for upper/lower bound expressions of contributing devices.\n\nFor ReserveUp types, the variable is added to ActivePowerRangeExpressionUB, such that this expression considers both the ActivePowerVariable and its reserve variable. Similarly, For ReserveDown types, the variable is added to ActivePowerRangeExpressionLB, such that this expression considers both the ActivePowerVariable and its reserve variable\n\nExample: for a thermal unit d contributing to two different ReserveUp s_1 s_2 services (e.g. Reg-Up and Spin):\n\ntextActivePowerRangeExpressionUB_t = p_t^textth + r_s_1t + r_s_2 t le P^textthmax\n\nsimilarly if s_3 is a ReserveDown service (e.g. Reg-Down):\n\ntextActivePowerRangeExpressionLB_t = p_t^textth - r_s_3t  ge P^textthmin\n\nConstraints:\n\nA RampReserve implements three fundamental constraints. The first is that the sum of all reserves of contributing devices must be larger than the RampReserve requirement. Thus, for a service s:\n\nsum_dinmathcalD_s r_dt + r_t^textsl ge textRequirementTimeSeriesParameter_tquad forall tin 1dots T\n\nFinally, there is a restriction based on the ramp limits of the contributing devices:\n\nr_dt le R^textthup cdot textTFquad  forall din mathcalD_s forall tin 1dots T quad text(for ReserveUp) \nr_dt le R^textthdn cdot textTFquad  forall din mathcalD_s forall tin 1dots T quad text(for ReserveDown)\n\n","category":"section"},{"location":"formulation_library/Service/#NonSpinningReserve","page":"Services","title":"NonSpinningReserve","text":"For each service s of the model type NonSpinningReserve, the following variables are created:\n\nVariables:\n\nActivePowerReserveVariable:\nBounds: [0.0, ]\nDefault proportional cost: 10  textSystemBasePower\nSymbol: r_d for d in contributing devices to the service s If slacks are enabled:\nReserveRequirementSlack:\nBounds: [0.0, ]\nDefault proportional cost: 1e5\nSymbol: r^textsl\n\nNonSpinningReserve only accepts VariableReserve PowerSystems.jl type. With that, the parameters are:\n\nStatic Parameters\n\ntextPF = PowerSystems.get_max_participation_factor(service)\ntextTF = PowerSystems.get_time_frame(service)\nP^textthmin = PowerSystems.get_active_power_limits(device).min for thermal contributing devices\nT^textstup = PowerSystems.get_time_limits(d).up for thermal contributing devices\nR^textthup = PowerSystems.get_ramp_limits(device).down for thermal contributing devices\n\nOther parameters:\n\nDelta T: Resolution of the problem in minutes.\n\nTime Series Parameters\n\nFor a VariableReserve PowerSystems type:\n\nusing PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.get_default_time_series_names(VariableReserve, NonSpinningReserve)\ncombo_table = DataFrame(\n    \"Parameter\" => map(x -> \"[`$x`](@ref)\", collect(keys(combos))),\n    \"Default Time Series Name\" => map(x -> \"`$x`\", collect(values(combos))),\n)\nmdtable(combo_table; latex = false)\n\nRelevant Methods:\n\nmathcalD_s = PowerSystems.get_contributing_devices(system, service): Set (vector) of all contributing devices to the service s in the system.\n\nObjective:\n\nAdd a large proportional cost to the objective function if slack variables are used + r^textsl cdot 10^5. In addition adds the default cost for ActivePowerReserveVariables as a proportional cost.\n\nExpressions:\n\nAdds the ActivePowerReserveVariable for upper/lower bound expressions of contributing devices.\n\nFor ReserveUp types, the variable is added to ActivePowerRangeExpressionUB, such that this expression considers both the ActivePowerVariable and its reserve variable. Similarly, For ReserveDown types, the variable is added to ActivePowerRangeExpressionLB, such that this expression considers both the ActivePowerVariable and its reserve variable\n\nExample: for a thermal unit d contributing to two different ReserveUp s_1 s_2 services (e.g. Reg-Up and Spin):\n\ntextActivePowerRangeExpressionUB_t = p_t^textth + r_s_1t + r_s_2 t le P^textthmax\n\nsimilarly if s_3 is a ReserveDown service (e.g. Reg-Down):\n\ntextActivePowerRangeExpressionLB_t = p_t^textth - r_s_3t  ge P^textthmin\n\nConstraints:\n\nA NonSpinningReserve implements three fundamental constraints. The first is that the sum of all reserves of contributing devices must be larger than the NonSpinningReserve requirement. Thus, for a service s:\n\nsum_dinmathcalD_s r_dt + r_t^textsl ge textRequirementTimeSeriesParameter_tquad forall tin 1dots T\n\nIn addition, there is a restriction on how much each contributing device d can contribute to the requirement, based on the max participation factor allowed.\n\nr_dt le textRequirementTimeSeriesParameter_t cdot textPFquad  forall din mathcalD_s forall tin 1dots T\n\nFinally, there is a restriction based on the reserve response time for the non-spinning reserve if the unit is off. To do so, compute R^textlimit_d as the reserve response limit as:\n\nR^textlimit_d = begincases\n0  text if TF  le T^textstup_d \nP^textthmin_d +  (textTF_s - T^textstup_d) cdot R^textthup_d Delta T cdot R^textthup_d  text if TF   T^textstup_d\nendcases quad forall din mathcalD_s\n\nThen, the constraint depends on the commitment variable u_t^textth as:\n\nr_dt le (1 - u_dt^textth) cdot R^textlimit_d quad forall d in mathcalD_s forall t in 1dots T\n\n","category":"section"},{"location":"formulation_library/Service/#ConstantMaxInterfaceFlow","page":"Services","title":"ConstantMaxInterfaceFlow","text":"This Service model only accepts the PowerSystems.jl TransmissionInterface type to properly function. It is used to model a collection of branches that make up an interface or corridor with a maximum transfer of power.\n\nVariables\n\nIf slacks are used:\n\nInterfaceFlowSlackUp:\nBounds: [0.0, ]\nSymbol: f^textslup\nInterfaceFlowSlackDown:\nBounds: [0.0, ]\nSymbol: f^textsldn\n\nStatic Parameters\n\nF^textmax = PowerSystems.get_active_power_flow_limits(service).max\nF^textmin = PowerSystems.get_active_power_flow_limits(service).min\nC^textflow = PowerSystems.get_violation_penalty(service)\nmathcalM_s = PowerSystems.get_direction_mapping(service). Dictionary of contributing branches with its specified direction (textDir_d = 1 or textDir_d = -1) with respect to the interface.\n\nRelevant Methods\n\nmathcalD_s = PowerSystems.get_contributing_devices(system, service): Set (vector) of all contributing branches to the service s in the system.\n\nObjective:\n\nAdd the violation penalty proportional cost to the objective function if slack variables are used + (f^textslup + f^textsldn) cdot C^textflow.\n\nExpressions:\n\nCreates the expression InterfaceTotalFlow to keep track of all FlowActivePowerVariable of contributing branches to the transmission interface.\n\nConstraints:\n\nIt adds the constraint to limit the InterfaceTotalFlow by the specified bounds of the service s:\n\nF^textmin le f^textslup_t - f^textsldn_t + sum_dinmathcalD_s textDir_d f_dt le F^textmax quad forall t in 1dotsT","category":"section"},{"location":"formulation_library/Service/#VariableMaxInterfaceFlow","page":"Services","title":"VariableMaxInterfaceFlow","text":"This Service model only accepts the PowerSystems.jl TransmissionInterface type to properly function. It is used to model a collection of branches that make up an interface or corridor with a maximum transfer of power.\n\nVariables\n\nIf slacks are used:\n\nInterfaceFlowSlackUp:\nBounds: [0.0, ]\nSymbol: f^textslup\nInterfaceFlowSlackDown:\nBounds: [0.0, ]\nSymbol: f^textsldn\n\nStatic Parameters\n\nF^textmax = PowerSystems.get_active_power_flow_limits(service).max\nF^textmin = PowerSystems.get_active_power_flow_limits(service).min\nC^textflow = PowerSystems.get_violation_penalty(service)\nmathcalM_s = PowerSystems.get_direction_mapping(service). Dictionary of contributing branches with its specified direction (textDir_d = 1 or textDir_d = -1) with respect to the interface.\n\nTime Series Parameters\n\nFor a TransmissionInterface PowerSystems type:\n\nusing PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.get_default_time_series_names(\n    TransmissionInterface,\n    VariableMaxInterfaceFlow,\n)\ncombo_table = DataFrame(\n    \"Parameter\" => map(x -> \"[`$x`](@ref)\", collect(keys(combos))),\n    \"Default Time Series Name\" => map(x -> \"`$x`\", collect(values(combos))),\n)\nmdtable(combo_table; latex = false)\n\nRelevant Methods\n\nmathcalD_s = PowerSystems.get_contributing_devices(system, service): Set (vector) of all contributing branches to the service s in the system.\n\nObjective:\n\nAdd the violation penalty proportional cost to the objective function if slack variables are used + (f^textslup + f^textsldn) cdot C^textflow.\n\nExpressions:\n\nCreates the expression InterfaceTotalFlow to keep track of all FlowActivePowerVariable of contributing branches to the transmission interface.\n\nConstraints:\n\nIt adds the constraint to limit the InterfaceTotalFlow by the specified bounds of the service s:\n\nF^textmin cdot textMinInterfaceFlowLimitParameter_t le f^textslup_t - f^textsldn_t + sum_dinmathcalD_s textDir_d f_dt le F^textmaxcdot textMaxInterfaceFlowLimitParameter_t quad forall t in 1dotsT","category":"section"},{"location":"formulation_library/Service/#Changes-on-Expressions-due-to-Service-models","page":"Services","title":"Changes on Expressions due to Service models","text":"It is important to note that by adding a service to a Optimization Problem, variables for each contributing device must be created. For example, for every contributing generator d in mathcalD that is participating in services s_1s_2s_3, it is required to create three set of ActivePowerReserveVariable variables:\n\nr_s_1dt r_s_2dt r_s_3dtquad forall d in mathcalD forall t in 1dots T","category":"section"},{"location":"formulation_library/Service/#Changes-on-UpperBound-(UB)-and-LowerBound-(LB)-limits","page":"Services","title":"Changes on UpperBound (UB) and LowerBound (LB) limits","text":"Each contributing generator d has active power limits that the reserve variables affect. In simple terms, the limits are implemented using expressions ActivePowerRangeExpressionUB and ActivePowerRangeExpressionLB as:\n\ntextActivePowerRangeExpressionUB_t le P^textmax \ntextActivePowerRangeExpressionLB_t ge P^textmin\n\nReserveUp type variables contribute to the upper bound expression, while ReserveDown variables contribute to the lower bound expressions. So if s_1s_2 are ReserveUp services, and s_3 is a ReserveDown service, then for a thermal generator d using a ThermalStandardDispatch:\n\nbeginalign*\n p_dt^textth + r_s_1dt + r_s_2dt le P^textthmaxquad forall din mathcalD^textth forall t in 1dotsT \n p_dt^textth - r_s_3dt ge P^textthminquad forall din mathcalD^textth forall t in 1dotsT\nendalign*\n\nwhile for a renewable generator d using a RenewableFullDispatch:\n\nbeginalign*\n p_dt^textre + r_s_1dt + r_s_2dt le textActivePowerTimeSeriesParameter_tquad forall din mathcalD^textre forall t in 1dotsT\n p_dt^textre - r_s_3dt ge 0quad forall din mathcalD^textre forall t in 1dotsT\nendalign*","category":"section"},{"location":"formulation_library/Service/#Changes-in-Ramp-limits","page":"Services","title":"Changes in Ramp limits","text":"For the case of Ramp Limits (of formulation that model these limits), the reserve variables only affect the current time, and not the previous time. Then, for the same example as before:\n\nbeginalign*\n p_dt^textth + r_s_1dt + r_s_2dt - p_dt-1^textthle R^textthupquad forall din mathcalD^textth forall t in 1dotsT\n p_dt^textth - r_s_3dt - p_dt-1^textth  ge -R^textthdnquad forall din mathcalD^textth forall t in 1dotsT\nendalign*","category":"section"},{"location":"formulation_library/Service/#PowerSimulations.RangeReserve","page":"Services","title":"PowerSimulations.RangeReserve","text":"Struct for to add reserves to be larger than a specified requirement\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Service/#PowerSimulations.StepwiseCostReserve","page":"Services","title":"PowerSimulations.StepwiseCostReserve","text":"Struct for to add reserves to be larger than a variable requirement depending of costs\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Service/#PowerSimulations.GroupReserve","page":"Services","title":"PowerSimulations.GroupReserve","text":"Struct to add reserves to be larger than a specified requirement for an aggregated collection of services\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Service/#PowerSimulations.RampReserve","page":"Services","title":"PowerSimulations.RampReserve","text":"Struct to add reserves to be larger than a specified requirement, with ramp constraints\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Service/#PowerSimulations.NonSpinningReserve","page":"Services","title":"PowerSimulations.NonSpinningReserve","text":"Struct to add non spinning reserve requirements larger than specified requirement\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Service/#PowerSimulations.ConstantMaxInterfaceFlow","page":"Services","title":"PowerSimulations.ConstantMaxInterfaceFlow","text":"Struct to add a constant maximum transmission flow for specified interface\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Service/#PowerSimulations.VariableMaxInterfaceFlow","page":"Services","title":"PowerSimulations.VariableMaxInterfaceFlow","text":"Struct to add a variable maximum transmission flow for specified interface\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/README/#Formulation-documentation-guide","page":"Formulation documentation guide","title":"Formulation documentation guide","text":"Formulation documentation should roughly follow the template established by RenewableGen.md","category":"section"},{"location":"formulation_library/README/#Auto-generated-items","page":"Formulation documentation guide","title":"Auto generated items","text":"Valid DeviceModel table: just change the device category in the filter function\nTime Series Parameters: just change the device category and formulation in the get_default_time_series_names method call","category":"section"},{"location":"formulation_library/README/#Linked-items","page":"Formulation documentation guide","title":"Linked items","text":"Formulations in the Valid DeviceModel table must have a docstring in src/core/formulations.jl\nThe Formulation in the @docs block must have a docstring in src/core/formulations.jl\nThe Variables must have docstrings in src/core/variables.jl \nThe Time Series Parameters must have docstrings in src/core/parameters.jl","category":"section"},{"location":"api/internal/#Internal-API","page":"Internals","title":"Internal API","text":"","category":"section"},{"location":"api/internal/#PowerSimulations.IGNORABLE_FILES","page":"Internals","title":"PowerSimulations.IGNORABLE_FILES","text":"If the name of an extraneous file that appears in simulation results matches one of these regexes, it is safe to ignore\n\n\n\n\n\n","category":"constant"},{"location":"api/internal/#PowerSimulations.AbstractCostAtMinParameter","page":"Internals","title":"PowerSimulations.AbstractCostAtMinParameter","text":"Parameters to define the cost at the minimum available power\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.AbstractDeviceFormulation","page":"Internals","title":"PowerSimulations.AbstractDeviceFormulation","text":"Abstract type for Device Formulations (a.k.a Models)\n\nExample\n\nimport PowerSimulations as PSI struct MyCustomDeviceFormulation <: PSI.AbstractDeviceFormulation\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.AbstractDynamicBranchRatingTimeSeriesParameter","page":"Internals","title":"PowerSimulations.AbstractDynamicBranchRatingTimeSeriesParameter","text":"Abstract type for dynamic ratings of AC branches\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.AbstractPiecewiseLinearBreakpointParameter","page":"Internals","title":"PowerSimulations.AbstractPiecewiseLinearBreakpointParameter","text":"Parameters to define the breakpoints of a piecewise linear function\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.AbstractPiecewiseLinearSlopeParameter","page":"Internals","title":"PowerSimulations.AbstractPiecewiseLinearSlopeParameter","text":"Parameters to define the slopes of a piecewise linear cost function\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.AbstractServiceFormulation","page":"Internals","title":"PowerSimulations.AbstractServiceFormulation","text":"Abstract type for Service Formulations (a.k.a Models)\n\nExample\n\nimport PowerSimulations as PSI struct MyServiceFormulation <: PSI.AbstractServiceFormulation\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.AbstractSimulationStatusEvent","page":"Internals","title":"PowerSimulations.AbstractSimulationStatusEvent","text":"All events subtyped from this need to be recorded under :simulation_status.\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.BranchFlowAuxVariableType","page":"Internals","title":"PowerSimulations.BranchFlowAuxVariableType","text":"Auxiliary Variable for line power flow results from power flow evaluation\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.CacheFlushRules","page":"Internals","title":"PowerSimulations.CacheFlushRules","text":"Informs the flusher on what data to keep in cache.\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.ContinuousCondition","page":"Internals","title":"PowerSimulations.ContinuousCondition","text":"ContinuousCondition()\n\nEstablishes an event condition that is triggered at all timesteps.  \n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.ConverterCurrentDirection","page":"Internals","title":"PowerSimulations.ConverterCurrentDirection","text":"Struct to dispatch the creation of DC Converter Binary for Absolute Value Current Variables for DC formulations Docs abbreviation: \\nu_c`\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.ConverterDCPower","page":"Internals","title":"PowerSimulations.ConverterDCPower","text":"Struct to dispatch the creation of DC Converter Power Variables for DC formulations Docs abbreviation: p_c^dc\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.DCLineCurrentFlowVariable","page":"Internals","title":"PowerSimulations.DCLineCurrentFlowVariable","text":"Struct to define the creation of HVDC DC Line Current Flow\n\nDocs abbreviation: i_d\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.DCLineLosses","page":"Internals","title":"PowerSimulations.DCLineLosses","text":"Auxiliary Variable of DC Current Variables for DC Lines formulations Docs abbreviation: p_l^loss\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.DCLosslessLine","page":"Internals","title":"PowerSimulations.DCLosslessLine","text":"Lossless Line Abstract Model\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.DecisionModelStore","page":"Internals","title":"PowerSimulations.DecisionModelStore","text":"Stores results data for one DecisionModel\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.DecisionProblem","page":"Internals","title":"PowerSimulations.DecisionProblem","text":"Abstract type for Decision Problems\n\nExample\n\nimport PowerSimulations as PSI struct MyCustomProblem <: PSI.DecisionProblem\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.DecrementalCostAtMinParameter","page":"Internals","title":"PowerSimulations.DecrementalCostAtMinParameter","text":"AbstractCostAtMinParameter for the decremental case (power sink)\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.DecrementalPiecewiseLinearBreakpointParameter","page":"Internals","title":"PowerSimulations.DecrementalPiecewiseLinearBreakpointParameter","text":"AbstractPiecewiseLinearBreakpointParameter for the decremental case (power sink)\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.DecrementalPiecewiseLinearSlopeParameter","page":"Internals","title":"PowerSimulations.DecrementalPiecewiseLinearSlopeParameter","text":"AbstractPiecewiseLinearSlopeParameter for the decremental case (power sink)\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.DefaultDecisionProblem","page":"Internals","title":"PowerSimulations.DefaultDecisionProblem","text":"Abstract type for models than employ PowerSimulations methods. For custom decision problems     use DecisionProblem as the super type.\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.DefaultEmulationProblem","page":"Internals","title":"PowerSimulations.DefaultEmulationProblem","text":"Abstract type for models than employ PowerSimulations methods. For custom emulation problems     use EmulationProblem as the super type.\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.DiscreteEventCondition","page":"Internals","title":"PowerSimulations.DiscreteEventCondition","text":"DiscreteEventCondition(condition_function::Function)\n\nEstablishes an event condition that is triggered if when a user defined function evaluates to true. The function should take SimulationState as its only arguement and return true when the event should be triggered and false otherwise.\n\nArguments\n\ncondition_function::Function: user defined function f(::SimulationState)to determine if event is triggered.\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.EmulationModelStore","page":"Internals","title":"PowerSimulations.EmulationModelStore","text":"Stores results data for one EmulationModel\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.EmulationProblem","page":"Internals","title":"PowerSimulations.EmulationProblem","text":"Abstract type for Emulation Problems\n\nExample\n\nimport PowerSimulations as PSI struct MyCustomEmulator <: PSI.EmulationProblem\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.GenericEmulationProblem","page":"Internals","title":"PowerSimulations.GenericEmulationProblem","text":"Default PowerSimulations Emulation Problem Type for unspecified problems\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.HVDCActivePowerReceivedFromVariable","page":"Internals","title":"PowerSimulations.HVDCActivePowerReceivedFromVariable","text":"Struct to dispatch the creation of HVDC Received Flow at From Bus Variables for PWL formulations\n\nDocs abbreviation: x\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.HVDCActivePowerReceivedToVariable","page":"Internals","title":"PowerSimulations.HVDCActivePowerReceivedToVariable","text":"Struct to dispatch the creation of HVDC Received Flow at To Bus Variables for PWL formulations\n\nDocs abbreviation: y\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.HVDCInverterACCurrentFlowConstraint","page":"Internals","title":"PowerSimulations.HVDCInverterACCurrentFlowConstraint","text":"Struct to create the constraint that calculates the AC Current flowing into the AC side of the inverter.\n\ni_\textac^i = sqrt6 fracN^ipiI_d\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.HVDCInverterACCurrentVariable","page":"Internals","title":"PowerSimulations.HVDCInverterACCurrentVariable","text":"Struct to define the creation of HVDC AC Line Current flowing into the AC side of Inverter\n\nDocs abbreviation: i_ac^i\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.HVDCInverterDCLineVoltageConstraint","page":"Internals","title":"PowerSimulations.HVDCInverterDCLineVoltageConstraint","text":"Struct to create the constraint that calculates the Inverter DC line voltage.\n\nv_d^i = frac3piN^i left( sqrt2\fraca^i v_textac^it^icosgamma^i-X^i I_d right)\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.HVDCInverterDCVoltageVariable","page":"Internals","title":"PowerSimulations.HVDCInverterDCVoltageVariable","text":"Struct to define the creation of HVDC DC Line Voltage at Inverter Side\n\nDocs abbreviation: v_d^i\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.HVDCInverterExtinctionAngleVariable","page":"Internals","title":"PowerSimulations.HVDCInverterExtinctionAngleVariable","text":"Struct to define the creation of HVDC Inverter Extinction Angle Variable\n\nDocs abbreviation: gamma^i\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.HVDCInverterOverlapAngleConstraint","page":"Internals","title":"PowerSimulations.HVDCInverterOverlapAngleConstraint","text":"Struct to create the constraint that calculates the Inverter Overlap Angle.\n\nmu^i = arccos left( cosgamma^i - fracsqrt2 I_d X^i t^ra^i v_textac^i right) - gamma^i\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.HVDCInverterOverlapAngleVariable","page":"Internals","title":"PowerSimulations.HVDCInverterOverlapAngleVariable","text":"Struct to define the creation of HVDC Inverter Overlap Angle Variable\n\nDocs abbreviation: mu^i\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.HVDCInverterPowerCalculationConstraint","page":"Internals","title":"PowerSimulations.HVDCInverterPowerCalculationConstraint","text":"Struct to create the constraint that calculates the AC Power injection at the AC side of the inverter.\n\nbeginalign*\np_textac^i = sqrt3 i_textac^i fraca^i v_textac^it^icosphi^i \nq_textac^i = sqrt3 i_textac^i fraca^i v_textac^it^isinphi^i \nendalign*\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.HVDCInverterPowerFactorAngleConstraint","page":"Internals","title":"PowerSimulations.HVDCInverterPowerFactorAngleConstraint","text":"Struct to create the constraint that calculates the Inverter Power Factor Angle.\n\nphi^i = arctan left( frac2mu^i + sin(2gamma^i) - sin(2(mu^i + gamma^i))cos(2gamma^i) - cos(2(mu^i + gamma^i)) right)\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.HVDCInverterPowerFactorAngleVariable","page":"Internals","title":"PowerSimulations.HVDCInverterPowerFactorAngleVariable","text":"Struct to define the creation of HVDC Inverter Power Factor Angle Variable\n\nDocs abbreviation: phi^i\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.HVDCInverterTapSettingVariable","page":"Internals","title":"PowerSimulations.HVDCInverterTapSettingVariable","text":"Struct to define the creation of HVDC Tap Setting at Inverter Transformer\n\nDocs abbreviation: t^i\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.HVDCPiecewiseBinaryLossVariable","page":"Internals","title":"PowerSimulations.HVDCPiecewiseBinaryLossVariable","text":"Struct to dispatch the creation of HVDC Piecewise Binary Loss Variables\n\nDocs abbreviation: z\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.HVDCPiecewiseLossVariable","page":"Internals","title":"PowerSimulations.HVDCPiecewiseLossVariable","text":"Struct to dispatch the creation of HVDC Piecewise Loss Variables\n\nDocs abbreviation: h or w\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.HVDCReactivePowerReceivedFromVariable","page":"Internals","title":"PowerSimulations.HVDCReactivePowerReceivedFromVariable","text":"Struct to dispatch the creation of HVDC Received Reactive Flow From Bus Variables\n\nDocs abbreviation: x^r\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.HVDCReactivePowerReceivedToVariable","page":"Internals","title":"PowerSimulations.HVDCReactivePowerReceivedToVariable","text":"Struct to dispatch the creation of HVDC Received Reactive Flow To Bus Variables\n\nDocs abbreviation: y^i\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.HVDCRectifierACCurrentFlowConstraint","page":"Internals","title":"PowerSimulations.HVDCRectifierACCurrentFlowConstraint","text":"Struct to create the constraint that calculates the AC Current flowing into the AC side of the rectifier.\n\ni_\textac^r = sqrt6 fracN^rpiI_d\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.HVDCRectifierACCurrentVariable","page":"Internals","title":"PowerSimulations.HVDCRectifierACCurrentVariable","text":"Struct to define the creation of HVDC AC Line Current flowing into the AC side of Rectifier\n\nDocs abbreviation: i_ac^r\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.HVDCRectifierDCLineVoltageConstraint","page":"Internals","title":"PowerSimulations.HVDCRectifierDCLineVoltageConstraint","text":"Struct to create the constraint that calculates the Rectifier DC line voltage.\n\nv_d^r = frac3piN^r left( sqrt2\fraca^r v_textac^rt^rcosalpha^r-X^r I_d right)\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.HVDCRectifierDCVoltageVariable","page":"Internals","title":"PowerSimulations.HVDCRectifierDCVoltageVariable","text":"Struct to define the creation of HVDC DC Line Voltage at Rectifier Side\n\nDocs abbreviation: v_d^r\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.HVDCRectifierDelayAngleVariable","page":"Internals","title":"PowerSimulations.HVDCRectifierDelayAngleVariable","text":"Struct to define the creation of HVDC Rectifier Delay Angle Variable\n\nDocs abbreviation: alpha^r\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.HVDCRectifierOverlapAngleConstraint","page":"Internals","title":"PowerSimulations.HVDCRectifierOverlapAngleConstraint","text":"Struct to create the constraint that calculates the Rectifier Overlap Angle.\n\nmu^r = arccos left( cosalpha^r - fracsqrt2 I_d X^r t^ra^r v_textac^r right) - alpha^r\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.HVDCRectifierOverlapAngleVariable","page":"Internals","title":"PowerSimulations.HVDCRectifierOverlapAngleVariable","text":"Struct to define the creation of HVDC Rectifier Overlap Angle Variable\n\nDocs abbreviation: mu^r\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.HVDCRectifierPowerCalculationConstraint","page":"Internals","title":"PowerSimulations.HVDCRectifierPowerCalculationConstraint","text":"Struct to create the constraint that calculates the AC Power injection at the AC side of the rectifier.\n\nbeginalign*\np_textac^r = sqrt3 i_textac^r fraca^r v_textac^rt^rcosphi^r \nq_textac^r = sqrt3 i_textac^r fraca^r v_textac^rt^rsinphi^r \nendalign*\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.HVDCRectifierPowerFactorAngleConstraint","page":"Internals","title":"PowerSimulations.HVDCRectifierPowerFactorAngleConstraint","text":"Struct to create the constraint that calculates the Rectifier Power Factor Angle.\n\nphi^r = arctan left( frac2mu^r + sin(2alpha^r) - sin(2(mu^r + alpha^r))cos(2lpha^r) - cos(2(mu^r + alpha^r)) right)\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.HVDCRectifierPowerFactorAngleVariable","page":"Internals","title":"PowerSimulations.HVDCRectifierPowerFactorAngleVariable","text":"Struct to define the creation of HVDC Rectifier Power Factor Angle Variable\n\nDocs abbreviation: phi^r\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.HVDCRectifierTapSettingVariable","page":"Internals","title":"PowerSimulations.HVDCRectifierTapSettingVariable","text":"Struct to define the creation of HVDC Tap Setting at Rectifier Transformer\n\nDocs abbreviation: t^r\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.HVDCTransmissionDCLineConstraint","page":"Internals","title":"PowerSimulations.HVDCTransmissionDCLineConstraint","text":"Struct to create the constraint that links the AC and DC side of the network.\n\nv_d^i = v_d^r - R_d I_d\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.HVDCTwoTerminalPiecewiseLoss","page":"Internals","title":"PowerSimulations.HVDCTwoTerminalPiecewiseLoss","text":"Branch type to represent piecewise lossy power flow on two terminal DC lines\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.HdfSimulationStore","page":"Internals","title":"PowerSimulations.HdfSimulationStore","text":"Stores simulation data in an HDF file.\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.InMemorySimulationStore","page":"Internals","title":"PowerSimulations.InMemorySimulationStore","text":"Stores simulation data in memory\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.IncrementalCostAtMinParameter","page":"Internals","title":"PowerSimulations.IncrementalCostAtMinParameter","text":"AbstractCostAtMinParameter for the incremental case (power source)\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.IncrementalPiecewiseLinearBreakpointParameter","page":"Internals","title":"PowerSimulations.IncrementalPiecewiseLinearBreakpointParameter","text":"AbstractPiecewiseLinearBreakpointParameter for the incremental case (power source)\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.IncrementalPiecewiseLinearSlopeParameter","page":"Internals","title":"PowerSimulations.IncrementalPiecewiseLinearSlopeParameter","text":"AbstractPiecewiseLinearSlopeParameter for the incremental case (power source)\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.InitialConditionChronology","page":"Internals","title":"PowerSimulations.InitialConditionChronology","text":"Supertype for initial condition chronologies \n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.InitialConditionsData","page":"Internals","title":"PowerSimulations.InitialConditionsData","text":"Stores data to populate initial conditions before the build call\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.LinearLossConverter","page":"Internals","title":"PowerSimulations.LinearLossConverter","text":"Linear Loss InterconnectingConverter Model\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.MaxInterfaceFlowLimitParameter","page":"Internals","title":"PowerSimulations.MaxInterfaceFlowLimitParameter","text":"Parameter to define Max Flow limit for interface time series\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.MinInterfaceFlowLimitParameter","page":"Internals","title":"PowerSimulations.MinInterfaceFlowLimitParameter","text":"Parameter to define Min Flow limit for interface time series\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.MultiStartVariable","page":"Internals","title":"PowerSimulations.MultiStartVariable","text":"Multi-start startup variables\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.OperationModel","page":"Internals","title":"PowerSimulations.OperationModel","text":"Abstract type for Decision Model and Emulation Model. OperationModel structs are parameterized with DecisionProblem or Emulation Problem structs\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.OptimizationOutputCache","page":"Internals","title":"PowerSimulations.OptimizationOutputCache","text":"Cache for a single parameter/variable/dual. Stores arrays chronologically by simulation timestamp.\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.OptimizationOutputCaches","page":"Internals","title":"PowerSimulations.OptimizationOutputCaches","text":"Cache for all model results\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.PiecewiseLinearBlockDecrementalOffer","page":"Internals","title":"PowerSimulations.PiecewiseLinearBlockDecrementalOffer","text":"Struct to dispatch the creation of piecewise linear block decremental offer variables for objective function\n\nDocs abbreviation: delta_d\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.PiecewiseLinearBlockIncrementalOffer","page":"Internals","title":"PowerSimulations.PiecewiseLinearBlockIncrementalOffer","text":"Struct to dispatch the creation of piecewise linear block incremental offer variables for objective function\n\nDocs abbreviation: delta\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.PiecewiseLinearUpperBoundConstraint","page":"Internals","title":"PowerSimulations.PiecewiseLinearUpperBoundConstraint","text":"Struct to create the PiecewiseLinearUpperBoundConstraint associated with a specified variable.\n\nSee Piecewise linear cost functions for more information.\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.PowerFlowAuxVariableType","page":"Internals","title":"PowerSimulations.PowerFlowAuxVariableType","text":"Auxiliary Variables that are calculated using a PowerFlowEvaluationModel\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.PresetTimeCondition","page":"Internals","title":"PowerSimulations.PresetTimeCondition","text":"PresetTimeCondition(time_stamps::Vector{Dates.DateTime})\n\nEstablishes an event condition that is triggered at pre-determined times.  \n\nArguments\n\ntime_stamps::Vector{Dates.DateTime}: times when event is triggered\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.ShutdownCostParameter","page":"Internals","title":"PowerSimulations.ShutdownCostParameter","text":"Parameter to define shutdown cost time series\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.SimulationProblemResults","page":"Internals","title":"PowerSimulations.SimulationProblemResults","text":"Holds the results of a simulation problem for plotting or exporting.\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.SimulationStore","page":"Internals","title":"PowerSimulations.SimulationStore","text":"Provides storage of simulation data\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.StartupCostParameter","page":"Internals","title":"PowerSimulations.StartupCostParameter","text":"Parameter to define startup cost time series\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulations.StateVariableValueCondition","page":"Internals","title":"PowerSimulations.StateVariableValueCondition","text":"StateVariableValueCondition(\n    variable_type::Type{<:VariableType}\n    device_type::Type{<:PSY.Device}\n    device_name::String\n    value::Float64\n)\n\nEstablishes an event condition that is triggered if a variable of type variable_type for a device of type device_type and name device_name is equal to value. and name \n\nArguments\n\nvariable_type::Type{<:VariableType}: variable to be monitored\ndevice_type::Type{<:PSY.Device}: device type to be monitored\ndevice_name::String: name of monitored device\nvalue::Float64: value to compare to in p.u.\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#Base.empty!-Tuple{PowerSimulations.EmulationModelStore}","page":"Internals","title":"Base.empty!","text":"empty!(store::PowerSimulations.EmulationModelStore)\n\n\nBase.empty!(store::EmulationModelStore)\n\nEmpty the EmulationModelStore\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.empty!-Tuple{PowerSimulations.OptimizationOutputCaches}","page":"Internals","title":"Base.empty!","text":"empty!(cache::PowerSimulations.OptimizationOutputCaches)\n\n\nBase.empty!(cache::OptimizationOutputCaches)\n\nEmpty the OptimizationOutputCaches\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.empty!-Tuple{PowerSimulations.OptimizationOutputCache}","page":"Internals","title":"Base.empty!","text":"empty!(cache::PowerSimulations.OptimizationOutputCache)\n\n\nBase.empty!(cache::OptimizationOutputCache)\n\nEmpty the OptimizationOutputCache\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#Base.empty!-Tuple{SimulationResults}","page":"Internals","title":"Base.empty!","text":"empty!(res::SimulationResults)\n\n\nBase.empty!(res::SimulationResults)\n\nEmpty the SimulationResults\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#InfrastructureSystems.Optimization.read_results_with_keys-Tuple{PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults}, Vector{<:InfrastructureSystems.Optimization.OptimizationContainerKey}}","page":"Internals","title":"InfrastructureSystems.Optimization.read_results_with_keys","text":"read_results_with_keys(\n    res::PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults},\n    result_keys::Vector{<:InfrastructureSystems.Optimization.OptimizationContainerKey};\n    start_time,\n    len,\n    cols,\n    table_format\n) -> Dict{InfrastructureSystems.Optimization.OptimizationContainerKey, DataFrame}\n\n\nHigh-level function to read a DataFrame of results.\n\nArguments\n\nres: the results to read.\nresult_keys::Vector{<:OptimizationContainerKey}: the keys to read. Output will be a Dict{OptimizationContainerKey, DataFrame} with these as the keys\nstart_time::Union{Nothing, Dates.DateTime} = nothing: the time at which the resulting time series should begin; nothing indicates the first time in the results\nlen::Union{Int, Nothing} = nothing: the number of steps in the resulting time series; nothing indicates up to the end of the results\ncols::Union{Colon, Vector{String}} = (:): which columns to fetch; defaults to :, i.e., all the columns\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#InfrastructureSystems.Optimization.to_matrix-Tuple{Vector}","page":"Internals","title":"InfrastructureSystems.Optimization.to_matrix","text":"to_matrix(vec::Vector) -> Matrix\n\n\nConvert Vectors, DenseAxisArrays, and SparkAxisArrays to a matrix.\n\nIf the input is a 1d array or DenseAxisArray, the returned matrix will have a number of rows equal to the length of the input and one column.\nIf the input is a 2d DenseAxisArray, the dimensions are transposed, due to the way we store outputs in JuMP.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations._add_category_to_map!-Tuple{Vector{DataType}, Vector{Pair{InfrastructureSystems.Optimization.OptimizationContainerKey, Any}}, Dict{DataType, <:Dict}, Dict{InfrastructureSystems.Optimization.OptimizationContainerKey, <:Dict}}","page":"Internals","title":"PowerSimulations._add_category_to_map!","text":"_add_category_to_map!(\n    precedence::Vector{DataType},\n    available_keys::Vector{Pair{InfrastructureSystems.Optimization.OptimizationContainerKey, Any}},\n    temp_component_map::Dict{DataType, <:Dict},\n    pf_data_opt_container_map::Dict{InfrastructureSystems.Optimization.OptimizationContainerKey, <:Dict}\n)\n\n\n_add_category_to_map!(\n    precedence::Vector{DataType},\n    available_keys::Vector{Pair{OptimizationContainerKey, Any}},\n    temp_component_map::Union{\n        Dict{DataType, Dict{String, Int}},\n        Dict{DataType, Dict{Union{Int64, String}, String}},\n    },\n    pf_data_opt_container_map::Union{\n        Dict{OptimizationContainerKey, Dict{String, Int}},\n        Dict{OptimizationContainerKey, Dict{Union{Int64, String}, String}},\n    },\n)\n\nHelper function that is used in makepfinputmap! and addtwoterminalelementsmap! to configure which variables from the optimization results get written to the PowerFlowData. For every results variable from the optimization, it finds the corresponding mapping between the optimization variable and the PowerFlowData variable. The mappings are added to the `pfdataoptcontainer_map` Dict. This step is executed during the build stage of the optimization. The results are written to the PowerFlowData in the solve stage, before the power flow is solved.\n\nArguments\n\nprecedence::Vector{DataType}: A vector of DataType objects that defines the order of precedence for the variables that correspond to the category of variables (e.g. :active_power - first look for ActivePowerVariable for the component type, if not available then PowerOutput, and finally ActivePowerTimeSeriesParameter).\navailable_keys::Vector{Pair{OptimizationContainerKey, Any}}: A vector of key-value pairs where the key is an OptimizationContainerKey and the value contains data associated with the key.\ntemp_component_map::Union{Dict{DataType, Dict{String, Int}}, Dict{DataType, Dict{Union{Int64, String}, String}}}: A mapping for component types to point the component-level results (e.g. as voltage value for bus \"A\") to the appropriate variable in PowerFlowData (e.g. row 27 in the bus-related matrices).\npf_data_opt_container_map::Union{Dict{OptimizationContainerKey, Dict{String, Int}}, Dict{OptimizationContainerKey, Dict{Union{Int64, String}, String}}}: The target Dict that contains mappings for all relevant component types.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations._add_generic_incremental_interpolation_constraint!-Union{Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{S}, Tuple{R}, Tuple{PowerSimulations.OptimizationContainer, R, S, T, U, V, InfrastructureSystems.FlattenIteratorWrapper{W}, Dict{String, Vector{Float64}}, Dict{String, Vector{Float64}}}} where {R<:InfrastructureSystems.Optimization.VariableType, S<:InfrastructureSystems.Optimization.VariableType, T<:InfrastructureSystems.Optimization.VariableType, U<:InfrastructureSystems.Optimization.VariableType, V<:InfrastructureSystems.Optimization.ConstraintType, W<:Component}","page":"Internals","title":"PowerSimulations._add_generic_incremental_interpolation_constraint!","text":"_add_generic_incremental_interpolation_constraint!(\n    container::PowerSimulations.OptimizationContainer,\n    ::InfrastructureSystems.Optimization.VariableType,\n    ::InfrastructureSystems.Optimization.VariableType,\n    ::InfrastructureSystems.Optimization.VariableType,\n    ::InfrastructureSystems.Optimization.VariableType,\n    ::InfrastructureSystems.Optimization.ConstraintType,\n    devices::InfrastructureSystems.FlattenIteratorWrapper{W<:Component},\n    dic_var_bkpts::Dict{String, Vector{Float64}},\n    dic_function_bkpts::Dict{String, Vector{Float64}};\n    meta\n)\n\n\n_add_generic_incremental_interpolation_constraint!(container, ::R, ::S, ::T, ::U, ::V, devices, dic_var_bkpts, dic_function_bkpts; meta)\n\nAdd incremental piecewise linear interpolation constraints to an optimization container.\n\nThis function implements the incremental method for piecewise linear approximation in optimization models. It creates constraints that relate the original variable (x) to its piecewise linear approximation (y = f(x)) using interpolation variables (δ) and binary variables (z) to ensure proper ordering.\n\nThe incremental method represents each segment of the PWL function as:\n\nx = x₁ + Σᵢ δᵢ(xᵢ₊₁ - xᵢ) where δᵢ ∈ [0,1]\ny = y₁ + Σᵢ δᵢ(yᵢ₊₁ - yᵢ) where yᵢ = f(xᵢ)\n\nBinary variables z ensure the incremental property: δᵢ₊₁ ≤ zᵢ ≤ δᵢ for adjacent segments.\n\nArguments\n\ncontainer::OptimizationContainer: The optimization container to add constraints to\n::R: Type parameter for the original variable (x)\n::S: Type parameter for the approximated variable (y = f(x))  \n::T: Type parameter for the interpolation variables (δ)\n::U: Type parameter for the binary interpolation variables (z)\n::V: Type parameter for the constraint type\ndevices::IS.FlattenIteratorWrapper{W}: Collection of devices to apply constraints to\ndic_var_bkpts::Dict{String, Vector{Float64}}: Breakpoints in the domain (x-coordinates) for each device\ndic_function_bkpts::Dict{String, Vector{Float64}}: Function values at breakpoints (y-coordinates) for each device\nmeta: Metadata for constraint naming (default: empty)\n\nType Parameters\n\nR <: VariableType: Original variable type\nS <: VariableType: Approximated variable type  \nT <: VariableType: Interpolation variable type\nU <: VariableType: Binary interpolation variable type\nV <: ConstraintType: Constraint type\nW <: PSY.Component: Component type for devices\n\nNotes\n\nCreates two types of constraints: variable interpolation and function interpolation\nAdds ordering constraints for binary variables to ensure incremental property\nAll constraints are applied for each device and time step\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations._add_pwl_constraint!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, U, Vector{Float64}, PowerSimulations.SOSStatusVariableModule.SOSStatusVariable, Int64}} where {T<:Component, U<:InfrastructureSystems.Optimization.VariableType}","page":"Internals","title":"PowerSimulations._add_pwl_constraint!","text":"_add_pwl_constraint!(\n    container::PowerSimulations.OptimizationContainer,\n    component::Component,\n    _::InfrastructureSystems.Optimization.VariableType,\n    break_points::Vector{Float64},\n    sos_status::PowerSimulations.SOSStatusVariableModule.SOSStatusVariable,\n    period::Int64\n)\n\n\nImplement the constraints for PWL variables. That is:\n\nsum_kinmathcalK P_k^max delta_kt = p_t \nsum_kinmathcalK delta_kt = on_t\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations._add_pwl_constraint!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, U, Vector{Float64}, PowerSimulations.SOSStatusVariableModule.SOSStatusVariable, Int64}} where {T<:Component, U<:PowerAboveMinimumVariable}","page":"Internals","title":"PowerSimulations._add_pwl_constraint!","text":"_add_pwl_constraint!(\n    container::PowerSimulations.OptimizationContainer,\n    component::Component,\n    _::PowerAboveMinimumVariable,\n    break_points::Vector{Float64},\n    sos_status::PowerSimulations.SOSStatusVariableModule.SOSStatusVariable,\n    period::Int64\n)\n\n\nImplement the constraints for PWL variables for Compact form. That is:\n\nsum_kinmathcalK P_k^max delta_kt = p_t + P_min * u_t \nsum_kinmathcalK delta_kt = on_t\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations._add_pwl_constraint!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, U, Vector{Float64}, PowerSimulations.SOSStatusVariableModule.SOSStatusVariable, Int64}} where {T<:ReserveDemandCurve, U<:ServiceRequirementVariable}","page":"Internals","title":"PowerSimulations._add_pwl_constraint!","text":"_add_pwl_constraint!(\n    container::PowerSimulations.OptimizationContainer,\n    component::ReserveDemandCurve,\n    _::ServiceRequirementVariable,\n    break_points::Vector{Float64},\n    sos_status::PowerSimulations.SOSStatusVariableModule.SOSStatusVariable,\n    period::Int64\n)\n\n\nImplement the constraints for PWL Block Offer variables for ORDC. That is:\n\nsum_kinmathcalK delta_kt = p_t \nsum_kinmathcalK delta_kt = P_k+1t^max - P_kt^max\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations._add_pwl_constraint!-Union{Tuple{W}, Tuple{V}, Tuple{D}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, U, D, Vector{<:Union{Float64, JuMP.AbstractJuMPScalar}}, Int64, Type{V}, Type{W}}} where {T<:Component, U<:InfrastructureSystems.Optimization.VariableType, D<:PowerSimulations.AbstractDeviceFormulation, V<:PowerSimulations.AbstractPiecewiseLinearBlockOffer, W<:PowerSimulations.AbstractPiecewiseLinearBlockOfferConstraint}","page":"Internals","title":"PowerSimulations._add_pwl_constraint!","text":"_add_pwl_constraint!(\n    container::PowerSimulations.OptimizationContainer,\n    component::Component,\n    _::InfrastructureSystems.Optimization.VariableType,\n    _::PowerSimulations.AbstractDeviceFormulation,\n    break_points::Vector{<:Union{Float64, JuMP.AbstractJuMPScalar}},\n    period::Int64,\n    _::Type{V<:PowerSimulations.AbstractPiecewiseLinearBlockOffer},\n    _::Type{W<:PowerSimulations.AbstractPiecewiseLinearBlockOfferConstraint}\n)\n\n\nImplement the constraints for PWL Block Offer variables. That is:\n\nsum_kinmathcalK delta_kt = p_t \nsum_kinmathcalK delta_kt = P_k+1t^max - P_kt^max\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations._add_pwl_sos_constraint!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, U, Vector{Float64}, PowerSimulations.SOSStatusVariableModule.SOSStatusVariable, Int64}} where {T<:Component, U<:InfrastructureSystems.Optimization.VariableType}","page":"Internals","title":"PowerSimulations._add_pwl_sos_constraint!","text":"_add_pwl_sos_constraint!(\n    container::PowerSimulations.OptimizationContainer,\n    component::Component,\n    _::InfrastructureSystems.Optimization.VariableType,\n    break_points::Vector{Float64},\n    sos_status::PowerSimulations.SOSStatusVariableModule.SOSStatusVariable,\n    period::Int64\n)\n\n\nImplement the SOS for PWL variables. That is:\n\ndelta_it  delta_kt in textSOS_2\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations._add_pwl_term!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Union{CostCurve{PiecewisePointCurve}, FuelCurve{PiecewisePointCurve}}, U, V}} where {T<:Component, U<:InfrastructureSystems.Optimization.VariableType, V<:PowerSimulations.AbstractDeviceFormulation}","page":"Internals","title":"PowerSimulations._add_pwl_term!","text":"_add_pwl_term!(\n    container::PowerSimulations.OptimizationContainer,\n    component::Component,\n    cost_function::Union{CostCurve{PiecewisePointCurve}, FuelCurve{PiecewisePointCurve}},\n    _::InfrastructureSystems.Optimization.VariableType,\n    _::PowerSimulations.AbstractDeviceFormulation\n) -> Vector{JuMP.AffExpr}\n\n\nAdd PWL cost terms for data coming from a PiecewisePointCurve\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations._add_pwl_term!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Union{CostCurve{PiecewisePointCurve}, FuelCurve{PiecewisePointCurve}}, U, V}} where {T<:ThermalGen, U<:InfrastructureSystems.Optimization.VariableType, V<:ThermalDispatchNoMin}","page":"Internals","title":"PowerSimulations._add_pwl_term!","text":"_add_pwl_term!(\n    container::PowerSimulations.OptimizationContainer,\n    component::ThermalGen,\n    cost_function::Union{CostCurve{PiecewisePointCurve}, FuelCurve{PiecewisePointCurve}},\n    _::InfrastructureSystems.Optimization.VariableType,\n    _::ThermalDispatchNoMin\n) -> Vector{JuMP.AffExpr}\n\n\nAdd PWL cost terms for data coming from a PiecewisePointCurve for ThermalDispatchNoMin formulation\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations._add_two_terminal_elements_map!-Tuple{System, PowerFlows.PowerFlowData, Vector{Pair{InfrastructureSystems.Optimization.OptimizationContainerKey, Any}}, Dict{Symbol, <:Dict{InfrastructureSystems.Optimization.OptimizationContainerKey, <:Dict}}}","page":"Internals","title":"PowerSimulations._add_two_terminal_elements_map!","text":"_add_two_terminal_elements_map!(\n    sys::System,\n    pf_data::PowerFlows.PowerFlowData,\n    available_keys::Vector{Pair{InfrastructureSystems.Optimization.OptimizationContainerKey, Any}},\n    input_key_map::Dict{Symbol, <:Dict{InfrastructureSystems.Optimization.OptimizationContainerKey, <:Dict}}\n)\n\n\n_add_two_terminal_elements_map!(\n    sys::PSY.System,\n    pf_data::PFS.PowerFlowData,\n    available_keys::Vector{Pair{OptimizationContainerKey, Any}},\n    input_key_map::Dict{Symbol, Dict{OptimizationContainerKey, Dict{String, Int64}}}\n)\n\nAdds mappings for two-terminal elements (HVDC components) that connect the power flow results (from -> to, to -> from) to be added to the mappings for all component types. The results for these elements are added as bus injections in the PowerFlowData as a simplified representation of these components.\n\nArguments\n\nsys::PSY.System: System instance representing the power system model.\npf_data::PFS.PowerFlowData: The power flow data used internally for power flow calculations.\navailable_keys::Vector{Pair{OptimizationContainerKey, Any}}: A vector of available optimization container keys and their associated values.\ninput_key_map::Dict{Symbol, Dict{OptimizationContainerKey, Dict{String, Int64}}}: A dictionary mapping categories to optimization container keys and their associated mappings. To be extended in this function by the mappings for the two-terminal elements to the respective buses in the PowerFlowData instance.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, CostCurve{LinearCurve}, U}} where {T<:InfrastructureSystems.Optimization.VariableType, U<:PowerSimulations.AbstractDeviceFormulation}","page":"Internals","title":"PowerSimulations._add_variable_cost_to_objective!","text":"_add_variable_cost_to_objective!(\n    container::PowerSimulations.OptimizationContainer,\n    _::InfrastructureSystems.Optimization.VariableType,\n    component::Component,\n    cost_function::CostCurve{LinearCurve},\n    _::PowerSimulations.AbstractDeviceFormulation\n)\n\n\nAdds to the cost function cost terms for sum of variables with common factor to be used for cost expression for optimization_container model.\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nvar_key::VariableKey: The variable name\ncomponentname::String: The componentname of the variable container\ncost_component::PSY.CostCurve{PSY.LinearCurve} : container for cost to be associated with variable\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, CostCurve{PiecewisePointCurve}, U}} where {T<:InfrastructureSystems.Optimization.VariableType, U<:PowerSimulations.AbstractDeviceFormulation}","page":"Internals","title":"PowerSimulations._add_variable_cost_to_objective!","text":"_add_variable_cost_to_objective!(\n    container::PowerSimulations.OptimizationContainer,\n    _::InfrastructureSystems.Optimization.VariableType,\n    component::Component,\n    cost_function::CostCurve{PiecewisePointCurve},\n    _::PowerSimulations.AbstractDeviceFormulation\n)\n\n\nCreates piecewise linear cost function using a sum of variables and expression with sign and time step included.\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nvar_key::VariableKey: The variable name\ncomponentname::String: The componentname of the variable container\ncost_function::PSY.CostCurve{PSY.PiecewisePointCurve}: container for piecewise linear cost\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, CostCurve{QuadraticCurve}, U}} where {T<:InfrastructureSystems.Optimization.VariableType, U<:PowerSimulations.AbstractDeviceFormulation}","page":"Internals","title":"PowerSimulations._add_variable_cost_to_objective!","text":"_add_variable_cost_to_objective!(\n    container::PowerSimulations.OptimizationContainer,\n    _::InfrastructureSystems.Optimization.VariableType,\n    component::Component,\n    cost_function::CostCurve{QuadraticCurve},\n    _::PowerSimulations.AbstractDeviceFormulation\n)\n\n\nAdds to the cost function cost terms for sum of variables with common factor to be used for cost expression for optimization_container model.\n\nEquation\n\ngen_cost = dt*sign*(sum(variable.^2)*cost_data[1] + sum(variable)*cost_data[2])\n\nLaTeX\n\ncost = dttimes sign (sum_iin I c_1 v_i^2 + sum_iin I c_2 v_i )\n\nfor quadratic factor large enough. If the first term of the quadratic objective is 0.0, adds a linear cost term sum(variable)*cost_data[2]\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nvar_key::VariableKey: The variable name\ncomponentname::String: The componentname of the variable container\ncost_component::PSY.CostCurve{PSY.QuadraticCurve} : container for quadratic factors\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, FuelCurve{LinearCurve}, U}} where {T<:InfrastructureSystems.Optimization.VariableType, U<:PowerSimulations.AbstractDeviceFormulation}","page":"Internals","title":"PowerSimulations._add_variable_cost_to_objective!","text":"_add_variable_cost_to_objective!(\n    container::PowerSimulations.OptimizationContainer,\n    _::InfrastructureSystems.Optimization.VariableType,\n    component::Component,\n    cost_function::FuelCurve{LinearCurve},\n    _::PowerSimulations.AbstractDeviceFormulation\n)\n\n\nAdds to the cost function cost terms for sum of variables with common factor to be used for cost expression for optimization_container model.\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nvar_key::VariableKey: The variable name\ncomponentname::String: The componentname of the variable container\ncost_component::PSY.FuelCurve{PSY.LinearCurve} : container for cost to be associated with variable\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, FuelCurve{PiecewisePointCurve}, U}} where {T<:InfrastructureSystems.Optimization.VariableType, U<:PowerSimulations.AbstractDeviceFormulation}","page":"Internals","title":"PowerSimulations._add_variable_cost_to_objective!","text":"_add_variable_cost_to_objective!(\n    container::PowerSimulations.OptimizationContainer,\n    _::InfrastructureSystems.Optimization.VariableType,\n    component::Component,\n    cost_function::FuelCurve{PiecewisePointCurve},\n    _::PowerSimulations.AbstractDeviceFormulation\n)\n\n\nCreates piecewise linear cost function using a sum of variables and expression with sign and time step included.\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nvar_key::VariableKey: The variable name\ncomponentname::String: The componentname of the variable container\ncost_function::PSY.CostCurve{PSY.PiecewisePointCurve}: container for piecewise linear cost\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, FuelCurve{QuadraticCurve}, U}} where {T<:InfrastructureSystems.Optimization.VariableType, U<:PowerSimulations.AbstractDeviceFormulation}","page":"Internals","title":"PowerSimulations._add_variable_cost_to_objective!","text":"_add_variable_cost_to_objective!(\n    container::PowerSimulations.OptimizationContainer,\n    _::InfrastructureSystems.Optimization.VariableType,\n    component::Component,\n    cost_function::FuelCurve{QuadraticCurve},\n    _::PowerSimulations.AbstractDeviceFormulation\n)\n\n\nAdds to the cost function cost terms for sum of variables with common factor to be used for cost expression for optimization_container model.\n\nEquation\n\ngen_cost = dt*(sum(variable.^2)*cost_data[1]*fuel_cost + sum(variable)*cost_data[2]*fuel_cost)\n\nLaTeX\n\ncost = dttimes  (sum_iin I c_f c_1 v_i^2 + sum_iin I c_f c_2 v_i )\n\nfor quadratic factor large enough. If the first term of the quadratic objective is 0.0, adds a linear cost term sum(variable)*cost_data[2]\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nvar_key::VariableKey: The variable name\ncomponentname::String: The componentname of the variable container\ncost_component::PSY.FuelCurve{PSY.QuadraticCurve} : container for quadratic factors\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, OfferCurveCost, U}} where {T<:InfrastructureSystems.Optimization.VariableType, U<:PowerSimulations.AbstractDeviceFormulation}","page":"Internals","title":"PowerSimulations._add_variable_cost_to_objective!","text":"_add_variable_cost_to_objective!(\n    container::PowerSimulations.OptimizationContainer,\n    _::InfrastructureSystems.Optimization.VariableType,\n    component::Component,\n    cost_function::OfferCurveCost,\n    _::PowerSimulations.AbstractDeviceFormulation\n)\n\n\nCreates piecewise linear market bid function using a sum of variables and expression for market participants. Decremental offers are not accepted for most components, except Storage systems and loads.\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nvar_key::VariableKey: The variable name\ncomponentname::String: The componentname of the variable container\ncost_function::MarketBidCost : container for market bid cost\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{V}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, V, U}} where {T<:InfrastructureSystems.Optimization.VariableType, V<:Union{CostCurve{PiecewiseAverageCurve}, CostCurve{PiecewiseIncrementalCurve}}, U<:PowerSimulations.AbstractDeviceFormulation}","page":"Internals","title":"PowerSimulations._add_variable_cost_to_objective!","text":"_add_variable_cost_to_objective!(\n    container::PowerSimulations.OptimizationContainer,\n    _::InfrastructureSystems.Optimization.VariableType,\n    component::Component,\n    cost_function::Union{CostCurve{PiecewiseAverageCurve}, CostCurve{PiecewiseIncrementalCurve}},\n    _::PowerSimulations.AbstractDeviceFormulation\n)\n\n\nCreates piecewise linear cost function using a sum of variables and expression with sign and time step included.\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nvar_key::VariableKey: The variable name\ncomponentname::String: The componentname of the variable container\ncost_function::PSY.Union{PSY.CostCurve{PSY.PiecewiseIncrementalCurve}, PSY.CostCurve{PSY.PiecewiseAverageCurve}}: container for piecewise linear cost\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{V}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, V, U}} where {T<:InfrastructureSystems.Optimization.VariableType, V<:Union{FuelCurve{PiecewiseAverageCurve}, FuelCurve{PiecewiseIncrementalCurve}}, U<:PowerSimulations.AbstractDeviceFormulation}","page":"Internals","title":"PowerSimulations._add_variable_cost_to_objective!","text":"_add_variable_cost_to_objective!(\n    container::PowerSimulations.OptimizationContainer,\n    _::InfrastructureSystems.Optimization.VariableType,\n    component::Component,\n    cost_function::Union{FuelCurve{PiecewiseAverageCurve}, FuelCurve{PiecewiseIncrementalCurve}},\n    _::PowerSimulations.AbstractDeviceFormulation\n)\n\n\nCreates piecewise linear fuel cost function using a sum of variables and expression with sign and time step included.\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nvar_key::VariableKey: The variable name\ncomponentname::String: The componentname of the variable container\ncost_function::PSY.Union{PSY.FuelCurve{PSY.PiecewiseIncrementalCurve}, PSY.FuelCurve{PSY.PiecewiseAverageCurve}}: container for piecewise linear cost\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations._allocate_execution_order-Tuple{Vector{Int64}}","page":"Internals","title":"PowerSimulations._allocate_execution_order","text":"_allocate_execution_order(\n    interval_run_counts::Vector{Int64}\n) -> Vector{Int64}\n\n\nFunction calculates the total number of problem executions in the simulation and allocates the appropiate vector\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations._calculate_interval_inner_counts-Tuple{OrderedDict{Symbol, Dates.Millisecond}}","page":"Internals","title":"PowerSimulations._calculate_interval_inner_counts","text":"_calculate_interval_inner_counts(\n    intervals::OrderedDict{Symbol, Dates.Millisecond}\n) -> Vector{Int64}\n\n\ncalculateintervalinnercounts(intervals::OrderedDict{String,<:Dates.TimePeriod})\n\nCalculates how many times a problem is executed for every interval of the previous problem\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations._get_breakpoints_for_pwl_function-Tuple{Float64, Float64, Any}","page":"Internals","title":"PowerSimulations._get_breakpoints_for_pwl_function","text":"_get_breakpoints_for_pwl_function(\n    min_val::Float64,\n    max_val::Float64,\n    f;\n    num_segments\n) -> Tuple{Vector{Float64}, Vector{Float64}}\n\n\n_get_breakpoints_for_pwl_function(min_val, max_val, f; num_segments = DEFAULT_INTERPOLATION_LENGTH)\n\nGenerate breakpoints for piecewise linear (PWL) approximation of a nonlinear function.\n\nThis function creates equally-spaced breakpoints over the specified domain [minval, maxval] and evaluates the given function at each breakpoint to construct a piecewise linear approximation. The breakpoints are used in optimization problems to linearize nonlinear constraints or objectives.\n\nArguments\n\nmin_val::Float64: Minimum value of the domain for the PWL approximation\nmax_val::Float64: Maximum value of the domain for the PWL approximation  \nf: Function to be approximated (must be callable with Float64 input)\nnum_segments::Int: Number of linear segments in the PWL approximation (default: DEFAULTINTERPOLATIONLENGTH)\n\nReturns\n\nTuple{Vector{Float64}, Vector{Float64}}: A tuple containing:\nx_bkpts: Vector of x-coordinates (breakpoints) in the domain\ny_bkpts: Vector of y-coordinates (function values at breakpoints)\n\nNotes\n\nThe number of breakpoints is num_segments + 1\nBreakpoints are equally spaced across the domain\nThe first breakpoint is always at min_val and the last at max_val\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations._get_data_for_tdc-Union{Tuple{U}, Tuple{T}, Tuple{Vector{T}, Vector{U}, Dates.TimePeriod}} where {T<:InitialCondition, U<:InitialCondition}","page":"Internals","title":"PowerSimulations._get_data_for_tdc","text":"_get_data_for_tdc(\n    initial_conditions_on::Array{T<:InitialCondition, 1},\n    initial_conditions_off::Array{U<:InitialCondition, 1},\n    resolution::Dates.TimePeriod\n) -> Tuple{Matrix{InitialCondition}, Vector{@NamedTuple{up::Float64, down::Float64}}}\n\n\nIf the fraction of hours that a generator has a duration constraint is less than the fraction of hours that a single time_step represents then it is not binding.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations._get_initial_condition_type-Tuple{Type{RampConstraint}, Type{<:ThermalGen}, Type{<:PowerSimulations.AbstractThermalFormulation}}","page":"Internals","title":"PowerSimulations._get_initial_condition_type","text":"_get_initial_condition_type(\n    _::Type{RampConstraint},\n    _::Type{<:ThermalGen},\n    _::Type{<:PowerSimulations.AbstractThermalFormulation}\n) -> Type{PowerSimulations.DeviceAboveMinPower}\n\n\nThis function gets the data for the generators for ramping constraints of thermal generators\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations._get_pwl_cost_expression-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Int64, Vector{Float64}, Float64}} where T<:ReserveDemandCurve","page":"Internals","title":"PowerSimulations._get_pwl_cost_expression","text":"_get_pwl_cost_expression(\n    container::PowerSimulations.OptimizationContainer,\n    component::ReserveDemandCurve,\n    time_period::Int64,\n    slopes_normalized::Vector{Float64},\n    multiplier::Float64\n) -> JuMP.AffExpr\n\n\nGet cost expression for StepwiseCostReserve\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations._lookup_maybe_time_variant_param-Union{Tuple{U}, Tuple{F}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Int64, Val{false}, F, U}} where {T<:Component, F<:Function, U<:InfrastructureSystems.Optimization.ParameterType}","page":"Internals","title":"PowerSimulations._lookup_maybe_time_variant_param","text":"_lookup_maybe_time_variant_param(\n    _::PowerSimulations.OptimizationContainer,\n    component::Component,\n    _::Int64,\n    _::Val{false},\n    getter_func::Function,\n    _::InfrastructureSystems.Optimization.ParameterType\n) -> Any\n\n\nEither looks up a value in the component using getter_func or fetches the value from the parameter U(), depending on whether we are in the time-variant case or not\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations._summary_to_dict!-Tuple{OptimizerStats, JuMP.Model}","page":"Internals","title":"PowerSimulations._summary_to_dict!","text":"_summary_to_dict!(\n    optimizer_stats::OptimizerStats,\n    jump_model::JuMP.Model\n)\n\n\nRun this function only when getting detailed solver stats\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations._validate_eltype-Union{Tuple{T}, Tuple{Type{T}, Component, TimeSeriesKey}, Tuple{Type{T}, Component, TimeSeriesKey, Any}} where T","page":"Internals","title":"PowerSimulations._validate_eltype","text":"_validate_eltype(\n    ::Type{T},\n    component::Component,\n    ts_key::TimeSeriesKey\n) -> Any\n_validate_eltype(\n    ::Type{T},\n    component::Component,\n    ts_key::TimeSeriesKey,\n    msg\n) -> Any\n\n\nValidate that the eltype of the time series, or the field itself if it's not a time series, is of the type given\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_constraints!-Union{Tuple{SR}, Tuple{PowerSimulations.OptimizationContainer, Type{RequirementConstraint}, SR, Vector{<:Service}, ServiceModel{SR, GroupReserve}}} where SR<:ConstantReserveGroup","page":"Internals","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{RequirementConstraint},\n    service::ConstantReserveGroup,\n    contributing_services::Vector{<:Service},\n    model::ServiceModel{SR<:ConstantReserveGroup, GroupReserve}\n)\n\n\nThis function creates the requirement constraint that will be attained by the appropriate services\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{B}, Tuple{PowerSimulations.OptimizationContainer, Type{FlowRateConstraintFromTo}, InfrastructureSystems.FlattenIteratorWrapper{B}, DeviceModel{B, <:PowerSimulations.AbstractBranchFormulation}, NetworkModel{T}}} where {B<:ACTransmission, T<:PowerModels.AbstractPowerModel}","page":"Internals","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    cons_type::Type{FlowRateConstraintFromTo},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{B<:ACTransmission},\n    device_model::DeviceModel{B<:ACTransmission, <:PowerSimulations.AbstractBranchFormulation},\n    network_model::NetworkModel{T<:PowerModels.AbstractPowerModel}\n)\n\n\nAdd rate limit from to constraints for ACBranch with AbstractPowerModel\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{B}, Tuple{PowerSimulations.OptimizationContainer, Type{FlowRateConstraintToFrom}, InfrastructureSystems.FlattenIteratorWrapper{B}, DeviceModel{B, <:PowerSimulations.AbstractBranchFormulation}, NetworkModel{T}}} where {B<:ACTransmission, T<:PowerModels.AbstractPowerModel}","page":"Internals","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    cons_type::Type{FlowRateConstraintToFrom},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{B<:ACTransmission},\n    device_model::DeviceModel{B<:ACTransmission, <:PowerSimulations.AbstractBranchFormulation},\n    network_model::NetworkModel{T<:PowerModels.AbstractPowerModel}\n)\n\n\nAdd rate limit to from constraints for ACBranch with AbstractPowerModel\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{FlowLimitConstraint}, InfrastructureSystems.FlattenIteratorWrapper{AreaInterchange}, DeviceModel{AreaInterchange, StaticBranch}, NetworkModel{T}}} where T<:PowerModels.AbstractActivePowerModel","page":"Internals","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{FlowLimitConstraint},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{AreaInterchange},\n    model::DeviceModel{AreaInterchange, StaticBranch},\n    _::NetworkModel{T<:PowerModels.AbstractActivePowerModel}\n)\n\n\nAdd flow constraints for area interchanges\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{NetworkFlowConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, PhaseAngleControl}, NetworkModel{<:PowerSimulations.AbstractPTDFModel}}} where T<:PhaseShiftingTransformer","page":"Internals","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{NetworkFlowConstraint},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{T<:PhaseShiftingTransformer},\n    model::DeviceModel{T<:PhaseShiftingTransformer, PhaseAngleControl},\n    network_model::NetworkModel{<:PowerSimulations.AbstractPTDFModel}\n)\n\n\nAdd network flow constraints for PhaseShiftingTransformer and NetworkModel with <: AbstractPTDFModel\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{NetworkFlowConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, PhaseAngleControl}, NetworkModel{DCPPowerModel}}} where T<:PhaseShiftingTransformer","page":"Internals","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{NetworkFlowConstraint},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{T<:PhaseShiftingTransformer},\n    model::DeviceModel{T<:PhaseShiftingTransformer, PhaseAngleControl},\n    _::NetworkModel{DCPPowerModel}\n)\n\n\nAdd network flow constraints for PhaseShiftingTransformer and NetworkModel with PM.DCPPowerModel\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{NetworkFlowConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, StaticBranchBounds}, NetworkModel{<:PowerSimulations.AbstractPTDFModel}}} where T<:ACTransmission","page":"Internals","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    cons_type::Type{NetworkFlowConstraint},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{T<:ACTransmission},\n    device_model::DeviceModel{T<:ACTransmission, StaticBranchBounds},\n    network_model::NetworkModel{<:PowerSimulations.AbstractPTDFModel}\n)\n\n\nAdd network flow constraints for ACBranch and NetworkModel with <: AbstractPTDFModel\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{StartTypeConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, ThermalMultiStartUnitCommitment}, NetworkModel}} where T<:ThermalMultiStart","page":"Internals","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{StartTypeConstraint},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{T<:ThermalMultiStart},\n    model::DeviceModel{T<:ThermalMultiStart, ThermalMultiStartUnitCommitment},\n    _::NetworkModel\n)\n\n\nConstructs contraints that restricts devices to one type of start at a time\n\nEquations\n\nsum(var_starts[name, s, t] for s in starts) = var_start[name, t]\n\nLaTeX\n\nsum^S_g_s=1 δ^s(t)  eq  x^start(t)\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{StartupInitialConditionConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, ThermalMultiStartUnitCommitment}, NetworkModel}} where T<:ThermalMultiStart","page":"Internals","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{StartupInitialConditionConstraint},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{T<:ThermalMultiStart},\n    model::DeviceModel{T<:ThermalMultiStart, ThermalMultiStartUnitCommitment},\n    _::NetworkModel\n)\n\n\nConstructs contraints that restricts devices to one type of start at a time\n\nEquations\n\nub: (time_limits[st+1]-1)*δ^{s}(t) + (1 - δ^{s}(t)) * M_VALUE >= sum(1-varbin[name, i]) for i in 1:t) + initial_condition_offtime lb: (time_limits[st]-1)*δ^{s}(t) =< sum(1-varbin[name, i]) for i in 1:t) + initial_condition_offtime\n\nLaTeX\n\nTS^s+1_g δ^s(t) + (1-δ^s(t)) M_VALUE   geq  sum^t_i=1 x^status(i)  +  DT_g^0  forall t in 1 ldots  TS^s+1_g\n\nTS^s_g δ^s(t) leq  sum^t_i=1 x^status(i)  +  DT_g^0  forall t in 1 ldots  TS^s+1_g\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{StartupTimeLimitTemperatureConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, ThermalMultiStartUnitCommitment}, NetworkModel}} where T<:ThermalMultiStart","page":"Internals","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{StartupTimeLimitTemperatureConstraint},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{T<:ThermalMultiStart},\n    model::DeviceModel{T<:ThermalMultiStart, ThermalMultiStartUnitCommitment},\n    _::NetworkModel\n)\n\n\nConstructs contraints for different types of starts based on generator down-time\n\nEquations\n\nfor t in time_limits[s+1]:T\n\nvar_starts[name, s, t] <= sum( var_stop[name, t-i] for i in time_limits[s]:(time_limits[s+1]-1)\n\nLaTeX\n\nδ^s(t)  leq sum_i=TS^s_g^TS^s+1_g x^stop(t-i)\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_constraints!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{PhaseAngleControlLimit}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, PhaseAngleControl}, NetworkModel{U}}} where {T<:PhaseShiftingTransformer, U<:PowerModels.AbstractActivePowerModel}","page":"Internals","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{PhaseAngleControlLimit},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{T<:PhaseShiftingTransformer},\n    model::DeviceModel{T<:PhaseShiftingTransformer, PhaseAngleControl},\n    _::NetworkModel{U<:PowerModels.AbstractActivePowerModel}\n)\n\n\nAdd phase angle limits for phase shifters\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_constraints!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{FlowLimitConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, U}, NetworkModel{V}}} where {T<:Union{MonitoredLine, PhaseShiftingTransformer}, U<:PowerSimulations.AbstractBranchFormulation, V<:PowerModels.AbstractDCPModel}","page":"Internals","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{FlowLimitConstraint},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{T<:Union{MonitoredLine, PhaseShiftingTransformer}},\n    model::DeviceModel{T<:Union{MonitoredLine, PhaseShiftingTransformer}, U<:PowerSimulations.AbstractBranchFormulation},\n    _::NetworkModel{V<:PowerModels.AbstractDCPModel}\n)\n\n\nAdd branch flow constraints for monitored lines with DC Power Model\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_constraints!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{FlowLimitToFromConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, U}, NetworkModel{V}}} where {T<:MonitoredLine, U<:StaticBranchUnbounded, V<:PowerModels.AbstractActivePowerModel}","page":"Internals","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    _::PowerSimulations.OptimizationContainer,\n    _::Type{FlowLimitToFromConstraint},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{T<:MonitoredLine},\n    model::DeviceModel{T<:MonitoredLine, U<:StaticBranchUnbounded},\n    _::NetworkModel{V<:PowerModels.AbstractActivePowerModel}\n)\n\n\nDon't add branch flow constraints for monitored lines if formulation is StaticBranchUnbounded\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_constraints!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{FlowRateConstraintFromTo}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, U}, NetworkModel{V}}} where {T<:MonitoredLine, U<:StaticBranchUnbounded, V<:PowerModels.AbstractActivePowerModel}","page":"Internals","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    _::PowerSimulations.OptimizationContainer,\n    _::Type{FlowRateConstraintFromTo},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{T<:MonitoredLine},\n    model::DeviceModel{T<:MonitoredLine, U<:StaticBranchUnbounded},\n    _::NetworkModel{V<:PowerModels.AbstractActivePowerModel}\n)\n\n\nDon't add branch flow constraints for monitored lines if formulation is StaticBranchUnbounded\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_constraints!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{FlowRateConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, U}, NetworkModel{V}}} where {T<:ACTransmission, U<:PowerSimulations.AbstractBranchFormulation, V<:PowerModels.AbstractActivePowerModel}","page":"Internals","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    cons_type::Type{FlowRateConstraint},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{T<:ACTransmission},\n    device_model::DeviceModel{T<:ACTransmission, U<:PowerSimulations.AbstractBranchFormulation},\n    network_model::NetworkModel{V<:PowerModels.AbstractActivePowerModel}\n)\n\n\nAdd branch rate limit constraints for ACBranch with AbstractActivePowerModel\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{U}, Tuple{PowerSimulations.OptimizationContainer, Type{RampConstraint}, InfrastructureSystems.FlattenIteratorWrapper{U}, DeviceModel{U, V}, NetworkModel{W}}} where {U<:ThermalGen, V<:PowerSimulations.AbstractThermalUnitCommitment, W<:PowerModels.AbstractPowerModel}","page":"Internals","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    T::Type{RampConstraint},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{U<:ThermalGen},\n    model::DeviceModel{U<:ThermalGen, V<:PowerSimulations.AbstractThermalUnitCommitment},\n    _::NetworkModel{W<:PowerModels.AbstractPowerModel}\n)\n\n\nThis function adds the ramping limits of generators when there are CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{<:ActivePowerVariableLimitsConstraint}, Type{<:InfrastructureSystems.Optimization.VariableType}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {V<:ThermalMultiStart, W<:ThermalMultiStartUnitCommitment, X<:PowerModels.AbstractPowerModel}","page":"Internals","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    T::Type{<:ActivePowerVariableLimitsConstraint},\n    U::Type{<:InfrastructureSystems.Optimization.VariableType},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:ThermalMultiStart},\n    _::DeviceModel{V<:ThermalMultiStart, W<:ThermalMultiStartUnitCommitment},\n    _::NetworkModel{X<:PowerModels.AbstractPowerModel}\n)\n\n\nThis function adds range constraint for the first time period. Constraint (10) from PGLIB formulation\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{<:PowerSimulations.PowerVariableLimitsConstraint}, Type{<:Union{InfrastructureSystems.Optimization.ExpressionType, InfrastructureSystems.Optimization.VariableType}}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {V<:ThermalGen, W<:PowerSimulations.AbstractThermalDispatchFormulation, X<:PowerModels.AbstractPowerModel}","page":"Internals","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    T::Type{<:PowerSimulations.PowerVariableLimitsConstraint},\n    U::Type{<:Union{InfrastructureSystems.Optimization.ExpressionType, InfrastructureSystems.Optimization.VariableType}},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:ThermalGen},\n    model::DeviceModel{V<:ThermalGen, W<:PowerSimulations.AbstractThermalDispatchFormulation},\n    _::NetworkModel{X<:PowerModels.AbstractPowerModel}\n)\n\n\nSemicontinuous range constraints for thermal dispatch formulations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{<:PowerSimulations.PowerVariableLimitsConstraint}, Type{<:Union{InfrastructureSystems.Optimization.ExpressionType, InfrastructureSystems.Optimization.VariableType}}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {V<:ThermalGen, W<:PowerSimulations.AbstractThermalUnitCommitment, X<:PowerModels.AbstractPowerModel}","page":"Internals","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    T::Type{<:PowerSimulations.PowerVariableLimitsConstraint},\n    U::Type{<:Union{InfrastructureSystems.Optimization.ExpressionType, InfrastructureSystems.Optimization.VariableType}},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:ThermalGen},\n    model::DeviceModel{V<:ThermalGen, W<:PowerSimulations.AbstractThermalUnitCommitment},\n    _::NetworkModel{X<:PowerModels.AbstractPowerModel}\n)\n\n\nSemicontinuous range constraints for unit commitment formulations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{<:PowerSimulations.PowerVariableLimitsConstraint}, Type{<:Union{PowerAboveMinimumVariable, InfrastructureSystems.Optimization.ExpressionType}}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {V<:ThermalGen, W<:ThermalCompactDispatch, X<:PowerModels.AbstractPowerModel}","page":"Internals","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    T::Type{<:PowerSimulations.PowerVariableLimitsConstraint},\n    U::Type{<:Union{PowerAboveMinimumVariable, InfrastructureSystems.Optimization.ExpressionType}},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:ThermalGen},\n    model::DeviceModel{V<:ThermalGen, W<:ThermalCompactDispatch},\n    network_model::NetworkModel{X<:PowerModels.AbstractPowerModel}\n)\n\n\nRange constraints for thermal compact dispatch\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{<:ReactivePowerVariableLimitsConstraint}, Type{<:ReactivePowerVariable}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {V<:ElectricLoad, W<:PowerSimulations.AbstractControllablePowerLoadFormulation, X<:PowerModels.AbstractPowerModel}","page":"Internals","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    T::Type{<:ReactivePowerVariableLimitsConstraint},\n    U::Type{<:ReactivePowerVariable},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:ElectricLoad},\n    _::DeviceModel{V<:ElectricLoad, W<:PowerSimulations.AbstractControllablePowerLoadFormulation},\n    network_model::NetworkModel{X<:PowerModels.AbstractPowerModel}\n)\n\n\nReactive Power Constraints on Controllable Loads Assume Constant power_factor\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{<:ReactivePowerVariableLimitsConstraint}, Type{<:ReactivePowerVariable}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {V<:RenewableGen, W<:RenewableConstantPowerFactor, X<:PowerModels.AbstractPowerModel}","page":"Internals","title":"PowerSimulations.add_constraints!","text":"add_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{<:ReactivePowerVariableLimitsConstraint},\n    _::Type{<:ReactivePowerVariable},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:RenewableGen},\n    _::DeviceModel{V<:RenewableGen, W<:RenewableConstantPowerFactor},\n    _::NetworkModel{X<:PowerModels.AbstractPowerModel}\n)\n\n\nReactive Power Constraints on Renewable Gen Constant power_factor\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_feedforward_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, DeviceModel, InfrastructureSystems.FlattenIteratorWrapper{T}, UpperBoundFeedforward}} where T<:Component","page":"Internals","title":"PowerSimulations.add_feedforward_constraints!","text":"add_feedforward_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::DeviceModel,\n    devices::InfrastructureSystems.FlattenIteratorWrapper{T<:Component},\n    ff::UpperBoundFeedforward\n)\n\n\n    ub_ff(container::OptimizationContainer,\n          cons_name::Symbol,\n          constraint_infos,\n          param_reference,\n          var_key::VariableKey)\n\nConstructs a parameterized upper bound constraint to implement feedforward from other models. The Parameters are initialized using the uppper boundary values of the provided variables.\n\nvariable[var_name, t] <= param_reference[var_name]\n\nLaTeX\n\nx leq param^max\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\ncons_name::Symbol : name of the constraint\nparam_reference : Reference to the JuMP.VariableRef used to determine the upperbound\nvar_key::VariableKey : the name of the continuous variable\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_feedforward_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, DeviceModel, Union{InfrastructureSystems.FlattenIteratorWrapper{T}, Vector{T}}, FixValueFeedforward}} where T<:Component","page":"Internals","title":"PowerSimulations.add_feedforward_constraints!","text":"add_feedforward_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::DeviceModel,\n    devices::Union{Array{T<:Component, 1}, InfrastructureSystems.FlattenIteratorWrapper{T<:Component}},\n    ff::FixValueFeedforward\n)\n\n\n    add_feedforward_constraints(\n        container::OptimizationContainer,\n        ::DeviceModel,\n        devices::IS.FlattenIteratorWrapper{T},\n        ff::FixValueFeedforward,\n    ) where {T <: PSY.Component}\n\nConstructs a equality constraint to a fix a variable in one model using the variable value from other model results.\n\nvariable[var_name, t] == param[var_name, t]\n\nLaTeX\n\nx == param\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nmodel::DeviceModel : the device model\ndevices::IS.FlattenIteratorWrapper{T} : list of devices\nff::FixValueFeedforward : a instance of the FixValue Feedforward\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_feedforward_constraints!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, DeviceModel{T, U}, InfrastructureSystems.FlattenIteratorWrapper{T}, LowerBoundFeedforward}} where {T<:Component, U<:PowerSimulations.AbstractDeviceFormulation}","page":"Internals","title":"PowerSimulations.add_feedforward_constraints!","text":"add_feedforward_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::DeviceModel{T<:Component, U<:PowerSimulations.AbstractDeviceFormulation},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{T<:Component},\n    ff::LowerBoundFeedforward\n)\n\n\n    lb_ff(container::OptimizationContainer,\n          cons_name::Symbol,\n          constraint_infos,\n          param_reference,\n          var_key::VariableKey)\n\nConstructs a parameterized upper bound constraint to implement feedforward from other models. The Parameters are initialized using the uppper boundary values of the provided variables.\n\nvariable[var_name, t] <= param_reference[var_name]\n\nLaTeX\n\nx leq param^max\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\ncons_name::Symbol : name of the constraint\nparam_reference : Reference to the JuMP.VariableRef used to determine the upperbound\nvar_key::VariableKey : the name of the continuous variable\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_linear_ramp_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, Type{<:InfrastructureSystems.Optimization.ConstraintType}, Type{S}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{<:PowerModels.AbstractPowerModel}}} where {S<:Union{ActivePowerVariable, PowerAboveMinimumVariable}, V<:Component, W<:PowerSimulations.AbstractDeviceFormulation}","page":"Internals","title":"PowerSimulations.add_linear_ramp_constraints!","text":"add_linear_ramp_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    T::Type{<:InfrastructureSystems.Optimization.ConstraintType},\n    U::Type{S<:Union{ActivePowerVariable, PowerAboveMinimumVariable}},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:Component},\n    model::DeviceModel{V<:Component, W<:PowerSimulations.AbstractDeviceFormulation},\n    _::Type{<:PowerModels.AbstractPowerModel}\n)\n\n\nConstructs allowed rate-of-change constraints from variables, initial condtions, and rate data.\n\nIf t = 1:\n\nvariable[name, 1] - initial_conditions[ix].value <= rate_data[1][ix].up\n\ninitial_conditions[ix].value - variable[name, 1] <= rate_data[1][ix].down\n\nIf t > 1:\n\nvariable[name, t] - variable[name, t-1] <= rate_data[1][ix].up\n\nvariable[name, t-1] - variable[name, t] <= rate_data[1][ix].down\n\nLaTeX\n\nr^down leq x_1 - x_init leq r^up text for  t = 1\n\nr^down leq x_t - x_t-1 leq r^up forall t geq 2\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_pwl_term!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{Bool, PowerSimulations.OptimizationContainer, T, OfferCurveCost, U, V}} where {T<:Component, U<:InfrastructureSystems.Optimization.VariableType, V<:PowerSimulations.AbstractDeviceFormulation}","page":"Internals","title":"PowerSimulations.add_pwl_term!","text":"add_pwl_term!(\n    is_decremental::Bool,\n    container::PowerSimulations.OptimizationContainer,\n    component::Component,\n    _::OfferCurveCost,\n    _::InfrastructureSystems.Optimization.VariableType,\n    _::PowerSimulations.AbstractDeviceFormulation\n)\n\n\nAdd PWL cost terms for data coming from the MarketBidCost with a fixed incremental offer curve\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_range_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {T<:InfrastructureSystems.Optimization.ConstraintType, U<:InfrastructureSystems.Optimization.VariableType, V<:Component, W<:PowerSimulations.AbstractDeviceFormulation, X<:PowerModels.AbstractPowerModel}","page":"Internals","title":"PowerSimulations.add_range_constraints!","text":"add_range_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:InfrastructureSystems.Optimization.ConstraintType},\n    _::Type{U<:InfrastructureSystems.Optimization.VariableType},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:Component},\n    model::DeviceModel{V<:Component, W<:PowerSimulations.AbstractDeviceFormulation},\n    _::Type{X<:PowerModels.AbstractPowerModel}\n)\n\n\nConstructs min/max range constraint from device variable.\n\nIf min and max within an epsilon width:\n\nvariable[name, t] == limits.max\n\nOtherwise:\n\nlimits.min <= variable[name, t] <= limits.max\n\nwhere limits in constraint_infos.\n\nLaTeX\n\nx = limits^max text for  limits^max - limits^min  varepsilon\n\nlimits^min leq x leq limits^max text otherwise \n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_reserve_range_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {T<:InputActivePowerVariableLimitsConstraint, U<:InfrastructureSystems.Optimization.VariableType, V<:Component, W<:PowerSimulations.AbstractDeviceFormulation, X<:PowerModels.AbstractPowerModel}","page":"Internals","title":"PowerSimulations.add_reserve_range_constraints!","text":"add_reserve_range_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:InputActivePowerVariableLimitsConstraint},\n    _::Type{U<:InfrastructureSystems.Optimization.VariableType},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:Component},\n    model::DeviceModel{V<:Component, W<:PowerSimulations.AbstractDeviceFormulation},\n    _::Type{X<:PowerModels.AbstractPowerModel}\n)\n\n\nConstructs min/max range constraint from device variable and reservation decision variable.\n\nvarcts[name, t] <= limits.max * (1 - varbin[name, t])\n\nvarcts[name, t] >= limits.min * (1 - varbin[name, t])\n\nwhere limits in constraint_infos.\n\nLaTeX\n\n0 leq x^cts leq limits^max (1 - x^bin) text for  limits^min = 0\n\nlimits^min (1 - x^bin) leq x^cts leq limits^max (1 - x^bin) text otherwise \n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_reserve_range_constraints!-Union{Tuple{Y}, Tuple{X}, Tuple{W}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{W}, DeviceModel{W, X}, Type{Y}}} where {T<:Union{ActivePowerVariableLimitsConstraint, OutputActivePowerVariableLimitsConstraint, ReactivePowerVariableLimitsConstraint}, U<:InfrastructureSystems.Optimization.ExpressionType, W<:Component, X<:PowerSimulations.AbstractDeviceFormulation, Y<:PowerModels.AbstractPowerModel}","page":"Internals","title":"PowerSimulations.add_reserve_range_constraints!","text":"add_reserve_range_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:Union{ActivePowerVariableLimitsConstraint, OutputActivePowerVariableLimitsConstraint, ReactivePowerVariableLimitsConstraint}},\n    _::Type{U<:InfrastructureSystems.Optimization.ExpressionType},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{W<:Component},\n    model::DeviceModel{W<:Component, X<:PowerSimulations.AbstractDeviceFormulation},\n    _::Type{Y<:PowerModels.AbstractPowerModel}\n)\n\n\nConstructs min/max range constraint from device variable and reservation decision variable.\n\nvarcts[name, t] <= limits.max * varbin[name, t]\n\nvarcts[name, t] >= limits.min * varbin[name, t]\n\nwhere limits in constraint_infos.\n\nLaTeX\n\nlimits^min x^bin leq x^cts leq limits^max x^bin\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_reserve_range_constraints!-Union{Tuple{Y}, Tuple{X}, Tuple{W}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{W}, DeviceModel{W, X}, Type{Y}}} where {T<:Union{ActivePowerVariableLimitsConstraint, OutputActivePowerVariableLimitsConstraint, ReactivePowerVariableLimitsConstraint}, U<:InfrastructureSystems.Optimization.VariableType, W<:Component, X<:PowerSimulations.AbstractDeviceFormulation, Y<:PowerModels.AbstractPowerModel}","page":"Internals","title":"PowerSimulations.add_reserve_range_constraints!","text":"add_reserve_range_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:Union{ActivePowerVariableLimitsConstraint, OutputActivePowerVariableLimitsConstraint, ReactivePowerVariableLimitsConstraint}},\n    _::Type{U<:InfrastructureSystems.Optimization.VariableType},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{W<:Component},\n    model::DeviceModel{W<:Component, X<:PowerSimulations.AbstractDeviceFormulation},\n    _::Type{Y<:PowerModels.AbstractPowerModel}\n)\n\n\nConstructs min/max range constraint from device variable and reservation decision variable.\n\nvarcts[name, t] <= limits.max * varbin[name, t]\n\nvarcts[name, t] >= limits.min * varbin[name, t]\n\nwhere limits in constraint_infos.\n\nLaTeX\n\nlimits^min x^bin leq x^cts leq limits^max x^bin\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_result!-Tuple{PowerSimulations.OptimizationOutputCache, Dates.DateTime, Array{Float64}, Bool}","page":"Internals","title":"PowerSimulations.add_result!","text":"add_result!(\n    cache::PowerSimulations.OptimizationOutputCache,\n    timestamp::Dates.DateTime,\n    array::Array{Float64},\n    system_cache_is_full::Bool\n) -> Int64\n\n\nAdd result to the cache.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_semicontinuous_ramp_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, Type{<:InfrastructureSystems.Optimization.ConstraintType}, Type{S}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{<:PowerModels.AbstractPowerModel}}} where {S<:Union{ActivePowerVariable, PowerAboveMinimumVariable}, V<:Component, W<:PowerSimulations.AbstractDeviceFormulation}","page":"Internals","title":"PowerSimulations.add_semicontinuous_ramp_constraints!","text":"add_semicontinuous_ramp_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    T::Type{<:InfrastructureSystems.Optimization.ConstraintType},\n    U::Type{S<:Union{ActivePowerVariable, PowerAboveMinimumVariable}},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:Component},\n    model::DeviceModel{V<:Component, W<:PowerSimulations.AbstractDeviceFormulation},\n    _::Type{<:PowerModels.AbstractPowerModel}\n)\n\n\nConstructs allowed rate-of-change constraints from variables, initial condtions, start/stop status, and rate data\n\nEquations\n\nIf t = 1:\n\nvariable[name, 1] - initial_conditions[ix].value <= rate_data[1][ix].up + rate_data[2][ix].max*varstart[name, 1]\n\ninitial_conditions[ix].value - variable[name, 1] <= rate_data[1][ix].down + rate_data[2][ix].min*varstop[name, 1]\n\nIf t > 1:\n\nvariable[name, t] - variable[name, t-1] <= rate_data[1][ix].up + rate_data[2][ix].max*varstart[name, t]\n\nvariable[name, t-1] - variable[name, t] <= rate_data[1][ix].down + rate_data[2][ix].min*varstop[name, t]\n\nLaTeX\n\nr^down + r^min x^stop_1 leq x_1 - x_init leq r^up + r^max x^start_1 text for  t = 1\n\nr^down + r^min x^stop_t leq x_t - x_t-1 leq r^up + r^max x^start_t forall t geq 2\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_semicontinuous_range_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {T<:InfrastructureSystems.Optimization.ConstraintType, U<:InfrastructureSystems.Optimization.VariableType, V<:Component, W<:PowerSimulations.AbstractDeviceFormulation, X<:PowerModels.AbstractPowerModel}","page":"Internals","title":"PowerSimulations.add_semicontinuous_range_constraints!","text":"add_semicontinuous_range_constraints!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:InfrastructureSystems.Optimization.ConstraintType},\n    _::Type{U<:InfrastructureSystems.Optimization.VariableType},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:Component},\n    model::DeviceModel{V<:Component, W<:PowerSimulations.AbstractDeviceFormulation},\n    _::Type{X<:PowerModels.AbstractPowerModel}\n)\n\n\nConstructs min/max range constraint from device variable and on/off decision variable.\n\nIf device min = 0:\n\nvarcts[name, t] <= limits.max*varbin[name, t])\n\nvarcts[name, t] >= 0.0\n\nOtherwise:\n\nvarcts[name, t] <= limits.max*varbin[name, t]\n\nvarcts[name, t] >= limits.min*varbin[name, t]\n\nwhere limits in constraint_infos.\n\nLaTeX\n\n0 leq x^cts leq limits^max x^bin text for  limits^min = 0\n\nlimits^min x^bin leq x^cts leq limits^max x^bin text otherwise \n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_sparse_pwl_interpolation_variables!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Any, DeviceModel{U, V}}, Tuple{PowerSimulations.OptimizationContainer, T, Any, DeviceModel{U, V}, Any}} where {T<:Union{PowerSimulations.BinaryInterpolationVariableType, PowerSimulations.InterpolationVariableType}, U<:Component, V<:PowerSimulations.AbstractDeviceFormulation}","page":"Internals","title":"PowerSimulations.add_sparse_pwl_interpolation_variables!","text":"add_sparse_pwl_interpolation_variables!(\n    container::PowerSimulations.OptimizationContainer,\n    ::Union{PowerSimulations.BinaryInterpolationVariableType, PowerSimulations.InterpolationVariableType},\n    devices,\n    model::DeviceModel{U<:Component, V<:PowerSimulations.AbstractDeviceFormulation}\n)\nadd_sparse_pwl_interpolation_variables!(\n    container::PowerSimulations.OptimizationContainer,\n    ::Union{PowerSimulations.BinaryInterpolationVariableType, PowerSimulations.InterpolationVariableType},\n    devices,\n    model::DeviceModel{U<:Component, V<:PowerSimulations.AbstractDeviceFormulation},\n    num_segments\n)\n\n\nadd_sparse_pwl_interpolation_variables!(container, devices, ::T, model, num_segments = DEFAULT_INTERPOLATION_LENGTH)\n\nAdd piecewise linear interpolation variables to an optimization container.\n\nThis function creates the necessary variables for piecewise linear (PWL) approximation in optimization models. It adds either continuous interpolation variables (δ) or binary interpolation variables (z) depending on the variable type T. These variables are used in the incremental method for PWL approximation where:\n\nInterpolation variables (δ): Continuous variables ∈ [0,1] that represent weights for each segment\nBinary interpolation variables (z): Binary variables that enforce ordering constraints in incremental method\n\nThe function creates a 3-dimensional variable structure indexed by (devicename, segmentindex, time_step). For binary variables, the number of variables is one less than for continuous variables since they control transitions between segments.\n\nArguments\n\ncontainer::OptimizationContainer: The optimization container to add variables to\ndevices: Collection of devices for which to create PWL variables\n::T: Type parameter specifying the variable type (InterpolationVariableType or BinaryInterpolationVariableType)\nmodel::DeviceModel{U, V}: Device model containing formulation information for bounds\nnum_segments::Int: Number of linear segments in the PWL approximation (default: DEFAULTINTERPOLATIONLENGTH)\n\nType Parameters\n\nT <: Union{InterpolationVariableType, BinaryInterpolationVariableType}: Variable type to create\nU <: PSY.Component: Component type for devices\nV <: AbstractDeviceFormulation: Device formulation type for bounds\n\nNotes\n\nBinary variables have num_segments - 1 variables (control transitions between segments)\nContinuous variables have num_segments variables (one per segment)\nVariable bounds are set based on the device formulation if available\nVariables are created for all devices and time steps in the optimization horizon\n\nSee Also\n\n_add_generic_incremental_interpolation_constraint!: Function that uses these variables in constraints\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{PhaseShiftingTransformer}, DeviceModel{PhaseShiftingTransformer, V}, NetworkModel{<:PowerSimulations.AbstractPTDFModel}}} where {T<:ActivePowerBalance, U<:PhaseShifterAngle, V<:PhaseAngleControl}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:ActivePowerBalance},\n    _::Type{U<:PhaseShifterAngle},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{PhaseShiftingTransformer},\n    _::DeviceModel{PhaseShiftingTransformer, V<:PhaseAngleControl},\n    network_model::NetworkModel{<:PowerSimulations.AbstractPTDFModel}\n)\n\n\nImplementation of addtoexpression! for lossless branch/network models\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{AreaBalancePowerModel}}} where {T<:ActivePowerBalance, U<:ActivePowerTimeSeriesParameter, V<:MotorLoad, W<:StaticPowerLoad}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:ActivePowerBalance},\n    _::Type{U<:ActivePowerTimeSeriesParameter},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:MotorLoad},\n    model::DeviceModel{V<:MotorLoad, W<:StaticPowerLoad},\n    network_model::NetworkModel{AreaBalancePowerModel}\n)\n\n\nMotor load implementation to add constant power to ActivePowerBalance expression for AreaBalancePowerModel\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{CopperPlatePowerModel}}} where {T<:ActivePowerBalance, U<:ActivePowerTimeSeriesParameter, V<:MotorLoad, W<:StaticPowerLoad}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:ActivePowerBalance},\n    _::Type{U<:ActivePowerTimeSeriesParameter},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:MotorLoad},\n    device_model::DeviceModel{V<:MotorLoad, W<:StaticPowerLoad},\n    network_model::NetworkModel{CopperPlatePowerModel}\n)\n\n\nMotor load implementation to add parameters to SystemBalanceExpressions CopperPlate\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{CopperPlatePowerModel}}} where {T<:ActivePowerBalance, U<:FlowActivePowerVariable, V<:ACBranch, W<:PowerSimulations.AbstractBranchFormulation}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:ActivePowerBalance},\n    _::Type{U<:FlowActivePowerVariable},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:ACBranch},\n    _::DeviceModel{V<:ACBranch, W<:PowerSimulations.AbstractBranchFormulation},\n    network_model::NetworkModel{CopperPlatePowerModel}\n)\n\n\nImplementation of addtoexpression! for lossless branch/network models\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{CopperPlatePowerModel}}} where {T<:ActivePowerBalance, U<:InfrastructureSystems.Optimization.VariableType, V<:StaticInjection, W<:PowerSimulations.AbstractDeviceFormulation}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:ActivePowerBalance},\n    _::Type{U<:InfrastructureSystems.Optimization.VariableType},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:StaticInjection},\n    device_model::DeviceModel{V<:StaticInjection, W<:PowerSimulations.AbstractDeviceFormulation},\n    network_model::NetworkModel{CopperPlatePowerModel}\n)\n\n\nDefault implementation to add variables to SystemBalanceExpressions\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{CopperPlatePowerModel}}} where {T<:SystemBalanceExpressions, U<:InfrastructureSystems.Optimization.TimeSeriesParameter, V<:ElectricLoad, W<:PowerSimulations.AbstractLoadFormulation}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:SystemBalanceExpressions},\n    _::Type{U<:InfrastructureSystems.Optimization.TimeSeriesParameter},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:ElectricLoad},\n    device_model::DeviceModel{V<:ElectricLoad, W<:PowerSimulations.AbstractLoadFormulation},\n    network_model::NetworkModel{CopperPlatePowerModel}\n)\n\n\nElectric Load implementation to add parameters to Copperplate SystemBalanceExpressions\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{CopperPlatePowerModel}}} where {T<:SystemBalanceExpressions, U<:InfrastructureSystems.Optimization.TimeSeriesParameter, V<:StaticInjection, W<:PowerSimulations.AbstractDeviceFormulation}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:SystemBalanceExpressions},\n    _::Type{U<:InfrastructureSystems.Optimization.TimeSeriesParameter},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:StaticInjection},\n    device_model::DeviceModel{V<:StaticInjection, W<:PowerSimulations.AbstractDeviceFormulation},\n    network_model::NetworkModel{CopperPlatePowerModel}\n)\n\n\nDefault implementation to add parameters to Copperplate SystemBalanceExpressions\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{PTDFPowerModel}}} where {T<:ActivePowerBalance, U<:FlowActivePowerToFromVariable, V<:TwoTerminalHVDC, W<:PowerSimulations.AbstractTwoTerminalDCLineFormulation}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:ActivePowerBalance},\n    _::Type{U<:FlowActivePowerToFromVariable},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:TwoTerminalHVDC},\n    _::DeviceModel{V<:TwoTerminalHVDC, W<:PowerSimulations.AbstractTwoTerminalDCLineFormulation},\n    network_model::NetworkModel{PTDFPowerModel}\n)\n\n\nDefault implementation to add branch variables to SystemBalanceExpressions\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T<:ActivePowerBalance, U<:ActivePowerTimeSeriesParameter, V<:MotorLoad, W<:StaticPowerLoad, X<:PowerModels.AbstractPowerModel}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:ActivePowerBalance},\n    _::Type{U<:ActivePowerTimeSeriesParameter},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:MotorLoad},\n    model::DeviceModel{V<:MotorLoad, W<:StaticPowerLoad},\n    network_model::NetworkModel{X<:PowerModels.AbstractPowerModel}\n)\n\n\nMotor load implementation to add constant power to ActivePowerBalance expression\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T<:ActivePowerBalance, U<:ActivePowerTimeSeriesParameter, V<:MotorLoad, W<:StaticPowerLoad, X<:PowerSimulations.AbstractPTDFModel}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:ActivePowerBalance},\n    _::Type{U<:ActivePowerTimeSeriesParameter},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:MotorLoad},\n    device_model::DeviceModel{V<:MotorLoad, W<:StaticPowerLoad},\n    network_model::NetworkModel{X<:PowerSimulations.AbstractPTDFModel}\n)\n\n\nMotor Load implementation to add constant motor power to PTDF SystemBalanceExpressions\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T<:ActivePowerBalance, U<:FlowActivePowerFromToVariable, V<:Branch, W<:PowerSimulations.AbstractDeviceFormulation, X<:PowerModels.AbstractPowerModel}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:ActivePowerBalance},\n    _::Type{U<:FlowActivePowerFromToVariable},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:Branch},\n    _::DeviceModel{V<:Branch, W<:PowerSimulations.AbstractDeviceFormulation},\n    network_model::NetworkModel{X<:PowerModels.AbstractPowerModel}\n)\n\n\nDefault implementation to add branch variables to SystemBalanceExpressions\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T<:ActivePowerBalance, U<:FlowActivePowerFromToVariable, V<:TwoTerminalHVDC, W<:PowerSimulations.AbstractTwoTerminalDCLineFormulation, X<:CopperPlatePowerModel}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:ActivePowerBalance},\n    _::Type{U<:FlowActivePowerFromToVariable},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:TwoTerminalHVDC},\n    _::DeviceModel{V<:TwoTerminalHVDC, W<:PowerSimulations.AbstractTwoTerminalDCLineFormulation},\n    network_model::NetworkModel{X<:CopperPlatePowerModel}\n)\n\n\nDefault implementation to add branch variables to SystemBalanceExpressions\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T<:ActivePowerBalance, U<:FlowActivePowerFromToVariable, V<:TwoTerminalHVDC, W<:PowerSimulations.AbstractTwoTerminalDCLineFormulation, X<:PowerSimulations.AbstractPTDFModel}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:ActivePowerBalance},\n    _::Type{U<:FlowActivePowerFromToVariable},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:TwoTerminalHVDC},\n    _::DeviceModel{V<:TwoTerminalHVDC, W<:PowerSimulations.AbstractTwoTerminalDCLineFormulation},\n    network_model::NetworkModel{X<:PowerSimulations.AbstractPTDFModel}\n)\n\n\nDefault implementation to add branch variables to SystemBalanceExpressions\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T<:ActivePowerBalance, U<:FlowActivePowerToFromVariable, V<:ACBranch, W<:PowerSimulations.AbstractDeviceFormulation, X<:PowerModels.AbstractPowerModel}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:ActivePowerBalance},\n    _::Type{U<:FlowActivePowerToFromVariable},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:ACBranch},\n    _::DeviceModel{V<:ACBranch, W<:PowerSimulations.AbstractDeviceFormulation},\n    network_model::NetworkModel{X<:PowerModels.AbstractPowerModel}\n)\n\n\nDefault implementation to add branch variables to SystemBalanceExpressions\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T<:ActivePowerBalance, U<:FlowActivePowerToFromVariable, V<:TwoTerminalHVDC, W<:PowerSimulations.AbstractTwoTerminalDCLineFormulation, X<:CopperPlatePowerModel}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:ActivePowerBalance},\n    _::Type{U<:FlowActivePowerToFromVariable},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:TwoTerminalHVDC},\n    _::DeviceModel{V<:TwoTerminalHVDC, W<:PowerSimulations.AbstractTwoTerminalDCLineFormulation},\n    network_model::NetworkModel{X<:CopperPlatePowerModel}\n)\n\n\nDefault implementation to add branch variables to SystemBalanceExpressions\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T<:ActivePowerBalance, U<:FlowActivePowerVariable, V<:ACBranch, W<:PowerSimulations.AbstractBranchFormulation, X<:PowerModels.AbstractActivePowerModel}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:ActivePowerBalance},\n    _::Type{U<:FlowActivePowerVariable},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:ACBranch},\n    _::DeviceModel{V<:ACBranch, W<:PowerSimulations.AbstractBranchFormulation},\n    network_model::NetworkModel{X<:PowerModels.AbstractActivePowerModel}\n)\n\n\nImplementation of addtoexpression! for lossless branch/network models\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T<:ActivePowerBalance, U<:FlowActivePowerVariable, V<:TwoTerminalHVDC, W<:PowerSimulations.AbstractBranchFormulation, X<:PTDFPowerModel}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:ActivePowerBalance},\n    _::Type{U<:FlowActivePowerVariable},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:TwoTerminalHVDC},\n    _::DeviceModel{V<:TwoTerminalHVDC, W<:PowerSimulations.AbstractBranchFormulation},\n    network_model::NetworkModel{X<:PTDFPowerModel}\n)\n\n\nImplementation of addtoexpression! for lossless branch/network models\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T<:ActivePowerBalance, U<:HVDCLosses, V<:TwoTerminalHVDC, W<:HVDCTwoTerminalDispatch, X<:Union{CopperPlatePowerModel, PTDFPowerModel}}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:ActivePowerBalance},\n    _::Type{U<:HVDCLosses},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:TwoTerminalHVDC},\n    _::DeviceModel{V<:TwoTerminalHVDC, W<:HVDCTwoTerminalDispatch},\n    network_model::NetworkModel{X<:Union{CopperPlatePowerModel, PTDFPowerModel}}\n)\n\n\nDefault implementation to add branch variables to SystemBalanceExpressions\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T<:ActivePowerBalance, U<:InfrastructureSystems.Optimization.VariableType, V<:StaticInjection, W<:PowerSimulations.AbstractDeviceFormulation, X<:PTDFPowerModel}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:ActivePowerBalance},\n    _::Type{U<:InfrastructureSystems.Optimization.VariableType},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:StaticInjection},\n    device_model::DeviceModel{V<:StaticInjection, W<:PowerSimulations.AbstractDeviceFormulation},\n    network_model::NetworkModel{X<:PTDFPowerModel}\n)\n\n\nDefault implementation to add variables to SystemBalanceExpressions\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T<:ActivePowerBalance, U<:PowerSimulations.HVDCActivePowerReceivedFromVariable, V<:TwoTerminalHVDC, W<:HVDCTwoTerminalLCC, X<:ACPPowerModel}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:ActivePowerBalance},\n    _::Type{U<:PowerSimulations.HVDCActivePowerReceivedFromVariable},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:TwoTerminalHVDC},\n    _::DeviceModel{V<:TwoTerminalHVDC, W<:HVDCTwoTerminalLCC},\n    network_model::NetworkModel{X<:ACPPowerModel}\n)\n\n\nHVDC LCC implementation to add ActivePowerBalance expression for HVDCActivePowerReceivedFromVariable variable\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T<:ActivePowerBalance, U<:PowerSimulations.HVDCActivePowerReceivedFromVariable, V<:TwoTerminalHVDC, W<:PowerSimulations.HVDCTwoTerminalPiecewiseLoss, X<:PowerSimulations.AbstractPTDFModel}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:ActivePowerBalance},\n    _::Type{U<:PowerSimulations.HVDCActivePowerReceivedFromVariable},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:TwoTerminalHVDC},\n    _::DeviceModel{V<:TwoTerminalHVDC, W<:PowerSimulations.HVDCTwoTerminalPiecewiseLoss},\n    network_model::NetworkModel{X<:PowerSimulations.AbstractPTDFModel}\n)\n\n\nPWL implementation to add FromTo branch variables to SystemBalanceExpressions\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T<:ActivePowerBalance, U<:PowerSimulations.HVDCActivePowerReceivedToVariable, V<:TwoTerminalHVDC, W<:HVDCTwoTerminalLCC, X<:ACPPowerModel}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:ActivePowerBalance},\n    _::Type{U<:PowerSimulations.HVDCActivePowerReceivedToVariable},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:TwoTerminalHVDC},\n    _::DeviceModel{V<:TwoTerminalHVDC, W<:HVDCTwoTerminalLCC},\n    network_model::NetworkModel{X<:ACPPowerModel}\n)\n\n\nHVDC LCC implementation to add ActivePowerBalance expression for HVDCActivePowerReceivedToVariable variable\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T<:ActivePowerBalance, U<:PowerSimulations.HVDCActivePowerReceivedToVariable, V<:TwoTerminalHVDC, W<:PowerSimulations.HVDCTwoTerminalPiecewiseLoss, X<:PowerSimulations.AbstractPTDFModel}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:ActivePowerBalance},\n    _::Type{U<:PowerSimulations.HVDCActivePowerReceivedToVariable},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:TwoTerminalHVDC},\n    _::DeviceModel{V<:TwoTerminalHVDC, W<:PowerSimulations.HVDCTwoTerminalPiecewiseLoss},\n    network_model::NetworkModel{X<:PowerSimulations.AbstractPTDFModel}\n)\n\n\nPWL implementation to add FromTo branch variables to SystemBalanceExpressions\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T<:ReactivePowerBalance, U<:PowerSimulations.HVDCReactivePowerReceivedFromVariable, V<:TwoTerminalHVDC, W<:HVDCTwoTerminalLCC, X<:ACPPowerModel}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:ReactivePowerBalance},\n    _::Type{U<:PowerSimulations.HVDCReactivePowerReceivedFromVariable},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:TwoTerminalHVDC},\n    _::DeviceModel{V<:TwoTerminalHVDC, W<:HVDCTwoTerminalLCC},\n    network_model::NetworkModel{X<:ACPPowerModel}\n)\n\n\nHVDC LCC implementation to add ReactivePowerBalance expression for HVDCReactivePowerReceivedFromVariable variable\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T<:ReactivePowerBalance, U<:PowerSimulations.HVDCReactivePowerReceivedToVariable, V<:TwoTerminalHVDC, W<:HVDCTwoTerminalLCC, X<:ACPPowerModel}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:ReactivePowerBalance},\n    _::Type{U<:PowerSimulations.HVDCReactivePowerReceivedToVariable},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:TwoTerminalHVDC},\n    _::DeviceModel{V<:TwoTerminalHVDC, W<:HVDCTwoTerminalLCC},\n    network_model::NetworkModel{X<:ACPPowerModel}\n)\n\n\nHVDC LCC implementation to add ReactivePowerBalance expression for HVDCReactivePowerReceivedToVariable variable\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T<:ReactivePowerBalance, U<:ReactivePowerTimeSeriesParameter, V<:MotorLoad, W<:StaticPowerLoad, X<:ACPPowerModel}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:ReactivePowerBalance},\n    _::Type{U<:ReactivePowerTimeSeriesParameter},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:MotorLoad},\n    model::DeviceModel{V<:MotorLoad, W<:StaticPowerLoad},\n    network_model::NetworkModel{X<:ACPPowerModel}\n)\n\n\nMotor load implementation to add constant power to ActivePowerBalance expression\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T<:SystemBalanceExpressions, U<:InfrastructureSystems.Optimization.TimeSeriesParameter, V<:Device, W<:PowerSimulations.AbstractDeviceFormulation, X<:PowerModels.AbstractPowerModel}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:SystemBalanceExpressions},\n    _::Type{U<:InfrastructureSystems.Optimization.TimeSeriesParameter},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:Device},\n    model::DeviceModel{V<:Device, W<:PowerSimulations.AbstractDeviceFormulation},\n    network_model::NetworkModel{X<:PowerModels.AbstractPowerModel}\n)\n\n\nDefault implementation to add parameters to SystemBalanceExpressions\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T<:SystemBalanceExpressions, U<:InfrastructureSystems.Optimization.TimeSeriesParameter, V<:ElectricLoad, W<:PowerSimulations.AbstractLoadFormulation, X<:PowerModels.AbstractPowerModel}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:SystemBalanceExpressions},\n    _::Type{U<:InfrastructureSystems.Optimization.TimeSeriesParameter},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:ElectricLoad},\n    model::DeviceModel{V<:ElectricLoad, W<:PowerSimulations.AbstractLoadFormulation},\n    network_model::NetworkModel{X<:PowerModels.AbstractPowerModel}\n)\n\n\nGeneric electric load implementation to add parameters to SystemBalanceExpressions\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T<:SystemBalanceExpressions, U<:InfrastructureSystems.Optimization.TimeSeriesParameter, V<:ElectricLoad, W<:PowerSimulations.AbstractLoadFormulation, X<:PowerSimulations.AbstractPTDFModel}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:SystemBalanceExpressions},\n    _::Type{U<:InfrastructureSystems.Optimization.TimeSeriesParameter},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:ElectricLoad},\n    device_model::DeviceModel{V<:ElectricLoad, W<:PowerSimulations.AbstractLoadFormulation},\n    network_model::NetworkModel{X<:PowerSimulations.AbstractPTDFModel}\n)\n\n\nElectric Load implementation to add parameters to PTDF SystemBalanceExpressions\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T<:SystemBalanceExpressions, U<:InfrastructureSystems.Optimization.TimeSeriesParameter, V<:StaticInjection, W<:PowerSimulations.AbstractDeviceFormulation, X<:PowerSimulations.AbstractPTDFModel}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:SystemBalanceExpressions},\n    _::Type{U<:InfrastructureSystems.Optimization.TimeSeriesParameter},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:StaticInjection},\n    device_model::DeviceModel{V<:StaticInjection, W<:PowerSimulations.AbstractDeviceFormulation},\n    network_model::NetworkModel{X<:PowerSimulations.AbstractPTDFModel}\n)\n\n\nDefault implementation to add parameters to PTDF SystemBalanceExpressions\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, NetworkModel{X}}} where {T<:SystemBalanceExpressions, U<:InfrastructureSystems.Optimization.VariableType, V<:StaticInjection, W<:PowerSimulations.AbstractDeviceFormulation, X<:PowerModels.AbstractPowerModel}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:SystemBalanceExpressions},\n    _::Type{U<:InfrastructureSystems.Optimization.VariableType},\n    devices::InfrastructureSystems.FlattenIteratorWrapper{V<:StaticInjection},\n    _::DeviceModel{V<:StaticInjection, W<:PowerSimulations.AbstractDeviceFormulation},\n    network_model::NetworkModel{X<:PowerModels.AbstractPowerModel}\n)\n\n\nDefault implementation to add device variables to SystemBalanceExpressions\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, Union{InfrastructureSystems.FlattenIteratorWrapper{V}, Vector{V}}, DeviceModel{V, W}, NetworkModel{X}}} where {T<:SystemBalanceExpressions, U<:PowerSimulations.EventParameter, V<:Device, W<:PowerSimulations.AbstractDeviceFormulation, X<:PowerModels.AbstractPowerModel}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:SystemBalanceExpressions},\n    _::Type{U<:PowerSimulations.EventParameter},\n    devices::Union{Array{V<:Device, 1}, InfrastructureSystems.FlattenIteratorWrapper{V<:Device}},\n    model::DeviceModel{V<:Device, W<:PowerSimulations.AbstractDeviceFormulation},\n    network_model::NetworkModel{X<:PowerModels.AbstractPowerModel}\n)\n\n\nDefault implementation to add parameters to SystemBalanceExpressions\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, Union{InfrastructureSystems.FlattenIteratorWrapper{V}, Vector{V}}, DeviceModel{V, W}, NetworkModel{X}}} where {T<:SystemBalanceExpressions, U<:PowerSimulations.EventParameter, V<:StaticInjection, W<:PowerSimulations.AbstractDeviceFormulation, X<:CopperPlatePowerModel}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:SystemBalanceExpressions},\n    _::Type{U<:PowerSimulations.EventParameter},\n    devices::Union{Array{V<:StaticInjection, 1}, InfrastructureSystems.FlattenIteratorWrapper{V<:StaticInjection}},\n    device_model::DeviceModel{V<:StaticInjection, W<:PowerSimulations.AbstractDeviceFormulation},\n    network_model::NetworkModel{X<:CopperPlatePowerModel}\n)\n\n\nDefault implementation to add parameters to SystemBalanceExpressions\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, Union{InfrastructureSystems.FlattenIteratorWrapper{V}, Vector{V}}, DeviceModel{V, W}, NetworkModel{X}}} where {T<:SystemBalanceExpressions, U<:PowerSimulations.EventParameter, V<:StaticInjection, W<:PowerSimulations.AbstractDeviceFormulation, X<:PowerSimulations.AbstractPTDFModel}","page":"Internals","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:SystemBalanceExpressions},\n    _::Type{U<:PowerSimulations.EventParameter},\n    devices::Union{Array{V<:StaticInjection, 1}, InfrastructureSystems.FlattenIteratorWrapper{V<:StaticInjection}},\n    device_model::DeviceModel{V<:StaticInjection, W<:PowerSimulations.AbstractDeviceFormulation},\n    network_model::NetworkModel{X<:PowerSimulations.AbstractPTDFModel}\n)\n\n\nDefault implementation to add parameters to SystemBalanceExpressions\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_variable!-Union{Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, D, Any}} where {T<:ServiceRequirementVariable, D<:ReserveDemandCurve}","page":"Internals","title":"PowerSimulations.add_variable!","text":"add_variable!(\n    container::PowerSimulations.OptimizationContainer,\n    variable_type::ServiceRequirementVariable,\n    service::ReserveDemandCurve,\n    formulation\n)\n\n\nAdd variables for ServiceRequirementVariable for StepWiseCostReserve\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_variable!-Union{Tuple{U}, Tuple{D}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.Optimization.AuxVariableType, U, Any}} where {D<:Component, U<:Union{InfrastructureSystems.FlattenIteratorWrapper{D}, Vector{D}}}","page":"Internals","title":"PowerSimulations.add_variable!","text":"add_variable!(\n    container::PowerSimulations.OptimizationContainer,\n    var_type::InfrastructureSystems.Optimization.AuxVariableType,\n    devices::Union{Array{D<:Component, 1}, InfrastructureSystems.FlattenIteratorWrapper{D<:Component}},\n    formulation\n)\n\n\nDefault implementation of adding auxiliary variable to the model.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_variable!-Union{Tuple{U}, Tuple{T}, Tuple{D}, Tuple{PowerSimulations.OptimizationContainer, T, U, Any}} where {D<:Component, T<:InfrastructureSystems.Optimization.VariableType, U<:Union{InfrastructureSystems.FlattenIteratorWrapper{D}, Vector{D}}}","page":"Internals","title":"PowerSimulations.add_variable!","text":"add_variable!(\n    container::PowerSimulations.OptimizationContainer,\n    variable_type::InfrastructureSystems.Optimization.VariableType,\n    devices::Union{Array{D<:Component, 1}, InfrastructureSystems.FlattenIteratorWrapper{D<:Component}},\n    formulation\n)\n\n\nAdds a variable to the optimization model and to the affine expressions contained in the optimization_container model according to the specified sign. Based on the inputs, the variable can be specified as binary.\n\nBounds\n\nlb_value_function <= varstart[name, t] <= ub_value_function\n\nIf binary = true:\n\nvarstart[name, t] in {0,1}\n\nLaTeX\n\nlb ge x^device_t le ub forall t\n\nx^device_t in 01 forall t iff textbinary = true\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\ndevices : Vector or Iterator with the devices\nvar_key::VariableKey : Base Name for the variable\nbinary::Bool : Select if the variable is binary\nexpressionname::Symbol : Expressionname name stored in container.expressions to add the variable\nsign::Float64 : sign of the addition of the variable to the expression_name. Default Value is 1.0\n\nAccepted Keyword Arguments\n\nubvalue : Provides the function over device to obtain the value for a upperbound\nlbvalue : Provides the function over device to obtain the value for a lowerbound. If the variable is meant to be positive define lb = x -> 0.0\ninitial_value : Provides the function over device to obtain the warm start value\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_variable!-Union{Tuple{U}, Tuple{T}, Tuple{D}, Tuple{PowerSimulations.OptimizationContainer, T, U, PowerSimulations.AbstractThermalFormulation}} where {D<:ThermalGen, T<:Union{OnVariable, StartVariable, StopVariable}, U<:Union{InfrastructureSystems.FlattenIteratorWrapper{D}, Vector{D}}}","page":"Internals","title":"PowerSimulations.add_variable!","text":"add_variable!(\n    container::PowerSimulations.OptimizationContainer,\n    variable_type::Union{OnVariable, StartVariable, StopVariable},\n    devices::Union{Array{D<:ThermalGen, 1}, InfrastructureSystems.FlattenIteratorWrapper{D<:ThermalGen}},\n    formulation::PowerSimulations.AbstractThermalFormulation\n)\n\n\nAdds a variable to the optimization model for the OnVariable of Thermal Units\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_variables!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Union{InfrastructureSystems.FlattenIteratorWrapper{U}, Vector{U}}, Union{PowerSimulations.AbstractDeviceFormulation, PowerSimulations.AbstractServiceFormulation}}} where {T<:InfrastructureSystems.Optimization.AuxVariableType, U<:Component}","page":"Internals","title":"PowerSimulations.add_variables!","text":"add_variables!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:InfrastructureSystems.Optimization.AuxVariableType},\n    devices::Union{Array{U<:Component, 1}, InfrastructureSystems.FlattenIteratorWrapper{U<:Component}},\n    formulation::Union{PowerSimulations.AbstractDeviceFormulation, PowerSimulations.AbstractServiceFormulation}\n)\n\n\nAdd variables to the OptimizationContainer for any component.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_variables!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Union{InfrastructureSystems.FlattenIteratorWrapper{U}, Vector{U}}, Union{PowerSimulations.AbstractDeviceFormulation, PowerSimulations.AbstractServiceFormulation}}} where {T<:InfrastructureSystems.Optimization.VariableType, U<:Component}","page":"Internals","title":"PowerSimulations.add_variables!","text":"add_variables!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:InfrastructureSystems.Optimization.VariableType},\n    devices::Union{Array{U<:Component, 1}, InfrastructureSystems.FlattenIteratorWrapper{U<:Component}},\n    formulation::Union{PowerSimulations.AbstractDeviceFormulation, PowerSimulations.AbstractServiceFormulation}\n)\n\n\nAdd variables to the OptimizationContainer for any component.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.add_variables!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, U, Union{InfrastructureSystems.FlattenIteratorWrapper{V}, Vector{V}}, PowerSimulations.AbstractReservesFormulation}} where {T<:InfrastructureSystems.Optimization.VariableType, U<:AbstractReserve, V<:Component}","page":"Internals","title":"PowerSimulations.add_variables!","text":"add_variables!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{T<:InfrastructureSystems.Optimization.VariableType},\n    service::AbstractReserve,\n    contributing_devices::Union{Array{V<:Component, 1}, InfrastructureSystems.FlattenIteratorWrapper{V<:Component}},\n    formulation::PowerSimulations.AbstractReservesFormulation\n)\n\n\nAdd variables to the OptimizationContainer for a service.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.apply_maybe_across_time_series-Tuple{Function, Component, TimeSeriesKey}","page":"Internals","title":"PowerSimulations.apply_maybe_across_time_series","text":"apply_maybe_across_time_series(\n    fn::Function,\n    component::Component,\n    ts_key::TimeSeriesKey\n) -> Any\n\n\nHelper function to look up a time series if necessary then apply a function (typically a validation routine in a do block) to every element in it\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.build_model!-Tuple{DecisionModel{<:PowerSimulations.DefaultDecisionProblem}}","page":"Internals","title":"PowerSimulations.build_model!","text":"build_model!(\n    model::DecisionModel{<:PowerSimulations.DefaultDecisionProblem}\n)\n\n\nDefault implementation of build method for Operational Problems for models conforming with DecisionProblem specification. Overload this function to implement a custom build method\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.build_model!-Tuple{EmulationModel}","page":"Internals","title":"PowerSimulations.build_model!","text":"build_model!(model::EmulationModel)\n\n\nDefault implementation of build method for Emulation Problems for models conforming with  DecisionProblem specification. Overload this function to implement a custom build method\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.check_activeservice_variables-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Vector{T}}} where T<:Service","page":"Internals","title":"PowerSimulations.check_activeservice_variables","text":"check_activeservice_variables(\n    container::PowerSimulations.OptimizationContainer,\n    contributing_services::Array{T<:Service, 1}\n)\n\n\nThis function checks if the variables for reserves were created\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.check_file_integrity-Tuple{String}","page":"Internals","title":"PowerSimulations.check_file_integrity","text":"check_file_integrity(path::String)\n\n\ncheck_file_integrity(path::String)\n\nChecks the hash value for each file made with the file is written with the new hash_value to verify the file hasn't been tampered with since written\n\nArguments\n\npath::String: this is the folder path that contains the results and the check.sha256 file\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.construct_device!-Union{Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ArgumentConstructStage, DeviceModel{T, D}, NetworkModel{<:PowerModels.AbstractActivePowerModel}}} where {T<:Source, D<:ImportExportSourceModel}","page":"Internals","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::InfrastructureSystems.Optimization.ArgumentConstructStage,\n    model::DeviceModel{T<:Source, D<:ImportExportSourceModel},\n    network_model::NetworkModel{<:PowerModels.AbstractActivePowerModel}\n)\n\n\nThis function creates the arguments for the model for an import/export formulation for Source devices\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.construct_device!-Union{Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ArgumentConstructStage, DeviceModel{T, D}, NetworkModel{<:PowerModels.AbstractActivePowerModel}}} where {T<:ThermalGen, D<:PowerSimulations.AbstractStandardUnitCommitment}","page":"Internals","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::InfrastructureSystems.Optimization.ArgumentConstructStage,\n    device_model::DeviceModel{T<:ThermalGen, D<:PowerSimulations.AbstractStandardUnitCommitment},\n    network_model::NetworkModel{<:PowerModels.AbstractActivePowerModel}\n)\n\n\nThis function creates the arguments model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.construct_device!-Union{Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ArgumentConstructStage, DeviceModel{T, D}, NetworkModel}} where {T<:Source, D<:ImportExportSourceModel}","page":"Internals","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::InfrastructureSystems.Optimization.ArgumentConstructStage,\n    model::DeviceModel{T<:Source, D<:ImportExportSourceModel},\n    network_model::NetworkModel\n)\n\n\nThis function creates the arguments for the model for an import/export formulation for Source devices\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.construct_device!-Union{Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ArgumentConstructStage, DeviceModel{T, D}, NetworkModel}} where {T<:ThermalGen, D<:PowerSimulations.AbstractStandardUnitCommitment}","page":"Internals","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::InfrastructureSystems.Optimization.ArgumentConstructStage,\n    device_model::DeviceModel{T<:ThermalGen, D<:PowerSimulations.AbstractStandardUnitCommitment},\n    network_model::NetworkModel\n)\n\n\nThis function creates the arguments for the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.construct_device!-Union{Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ModelConstructStage, DeviceModel{T, D}, NetworkModel{<:PowerModels.AbstractActivePowerModel}}} where {T<:Source, D<:ImportExportSourceModel}","page":"Internals","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::InfrastructureSystems.Optimization.ModelConstructStage,\n    model::DeviceModel{T<:Source, D<:ImportExportSourceModel},\n    network_model::NetworkModel{<:PowerModels.AbstractActivePowerModel}\n)\n\n\nThis function creates the constraints for the model for an import/export formulation for Source devices\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.construct_device!-Union{Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ModelConstructStage, DeviceModel{T, D}, NetworkModel}} where {T<:Source, D<:ImportExportSourceModel}","page":"Internals","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::InfrastructureSystems.Optimization.ModelConstructStage,\n    model::DeviceModel{T<:Source, D<:ImportExportSourceModel},\n    network_model::NetworkModel\n)\n\n\nThis function creates the constraints for the model for an import/export formulation for Source devices\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.construct_device!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ArgumentConstructStage, DeviceModel{T, ThermalBasicUnitCommitment}, NetworkModel{<:PowerModels.AbstractActivePowerModel}}} where T<:ThermalGen","page":"Internals","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::InfrastructureSystems.Optimization.ArgumentConstructStage,\n    device_model::DeviceModel{T<:ThermalGen, ThermalBasicUnitCommitment},\n    network_model::NetworkModel{<:PowerModels.AbstractActivePowerModel}\n)\n\n\nThis function creates the arguments for the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.construct_device!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ArgumentConstructStage, DeviceModel{T, ThermalBasicUnitCommitment}, NetworkModel}} where T<:ThermalGen","page":"Internals","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::InfrastructureSystems.Optimization.ArgumentConstructStage,\n    device_model::DeviceModel{T<:ThermalGen, ThermalBasicUnitCommitment},\n    network_model::NetworkModel\n)\n\n\nThis function creates the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.construct_device!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ArgumentConstructStage, DeviceModel{T, ThermalStandardDispatch}, NetworkModel{<:PowerModels.AbstractActivePowerModel}}} where T<:ThermalGen","page":"Internals","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::InfrastructureSystems.Optimization.ArgumentConstructStage,\n    device_model::DeviceModel{T<:ThermalGen, ThermalStandardDispatch},\n    network_model::NetworkModel{<:PowerModels.AbstractActivePowerModel}\n)\n\n\nThis function creates the arguments for the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.construct_device!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ArgumentConstructStage, DeviceModel{T, ThermalStandardDispatch}, NetworkModel}} where T<:ThermalGen","page":"Internals","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::InfrastructureSystems.Optimization.ArgumentConstructStage,\n    device_model::DeviceModel{T<:ThermalGen, ThermalStandardDispatch},\n    network_model::NetworkModel\n)\n\n\nThis function creates the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.construct_device!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ModelConstructStage, DeviceModel{T, <:PowerSimulations.AbstractStandardUnitCommitment}, NetworkModel{<:PowerModels.AbstractActivePowerModel}}} where T<:ThermalGen","page":"Internals","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::InfrastructureSystems.Optimization.ModelConstructStage,\n    device_model::DeviceModel{T<:ThermalGen, <:PowerSimulations.AbstractStandardUnitCommitment},\n    network_model::NetworkModel{<:PowerModels.AbstractActivePowerModel}\n)\n\n\nThis function creates the constraints for the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.construct_device!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ModelConstructStage, DeviceModel{T, ThermalBasicUnitCommitment}, NetworkModel{<:PowerModels.AbstractActivePowerModel}}} where T<:ThermalGen","page":"Internals","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::InfrastructureSystems.Optimization.ModelConstructStage,\n    device_model::DeviceModel{T<:ThermalGen, ThermalBasicUnitCommitment},\n    network_model::NetworkModel{<:PowerModels.AbstractActivePowerModel}\n)\n\n\nThis function creates the constraints for the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.construct_device!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ModelConstructStage, DeviceModel{T, ThermalBasicUnitCommitment}, NetworkModel}} where T<:ThermalGen","page":"Internals","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::InfrastructureSystems.Optimization.ModelConstructStage,\n    device_model::DeviceModel{T<:ThermalGen, ThermalBasicUnitCommitment},\n    network_model::NetworkModel\n)\n\n\nThis function creates the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.construct_device!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ModelConstructStage, DeviceModel{T, ThermalStandardDispatch}, NetworkModel{<:PowerModels.AbstractActivePowerModel}}} where T<:ThermalGen","page":"Internals","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::InfrastructureSystems.Optimization.ModelConstructStage,\n    device_model::DeviceModel{T<:ThermalGen, ThermalStandardDispatch},\n    network_model::NetworkModel{<:PowerModels.AbstractActivePowerModel}\n)\n\n\nThis function creates the constraints for the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.construct_device!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ModelConstructStage, DeviceModel{T, ThermalStandardDispatch}, NetworkModel}} where T<:ThermalGen","page":"Internals","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::InfrastructureSystems.Optimization.ModelConstructStage,\n    device_model::DeviceModel{T<:ThermalGen, ThermalStandardDispatch},\n    network_model::NetworkModel\n)\n\n\nThis function creates the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.construct_device!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ModelConstructStage, DeviceModel{T, U}, NetworkModel}} where {T<:ThermalGen, U<:PowerSimulations.AbstractStandardUnitCommitment}","page":"Internals","title":"PowerSimulations.construct_device!","text":"construct_device!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::InfrastructureSystems.Optimization.ModelConstructStage,\n    device_model::DeviceModel{T<:ThermalGen, U<:PowerSimulations.AbstractStandardUnitCommitment},\n    network_model::NetworkModel\n)\n\n\nThis function creates the constraints for the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.construct_service!-Union{Tuple{SR}, Tuple{PowerSimulations.OptimizationContainer, System, InfrastructureSystems.Optimization.ArgumentConstructStage, ServiceModel{SR, GroupReserve}, Dict{Symbol, DeviceModel}, Set{<:DataType}, NetworkModel}} where SR<:ConstantReserveGroup","page":"Internals","title":"PowerSimulations.construct_service!","text":"construct_service!(\n    container::PowerSimulations.OptimizationContainer,\n    sys::System,\n    _::InfrastructureSystems.Optimization.ArgumentConstructStage,\n    model::ServiceModel{SR<:ConstantReserveGroup, GroupReserve},\n    _::Dict{Symbol, DeviceModel},\n    _::Set{<:DataType},\n    _::NetworkModel\n)\n\n\nConstructs a service for ConstantReserveGroup.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.container_spec-Tuple{Type{Float64}, Vararg{Any}}","page":"Internals","title":"PowerSimulations.container_spec","text":"container_spec(\n    _::Type{Float64},\n    axs...\n) -> JuMP.Containers.DenseAxisArray\n\n\nReturns the correct container specification for the selected type of JuMP Model\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.container_spec-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any}}} where T","page":"Internals","title":"PowerSimulations.container_spec","text":"container_spec(\n    _::Type{T},\n    axs...\n) -> JuMP.Containers.DenseAxisArray\n\n\nReturns the correct container specification for the selected type of JuMP Model\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.device_duration_compact_retrospective!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Vector{@NamedTuple{up::Float64, down::Float64}}, Matrix{InitialCondition}, InfrastructureSystems.Optimization.ConstraintType, Tuple{InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType}, Type{T}}} where T<:Component","page":"Internals","title":"PowerSimulations.device_duration_compact_retrospective!","text":"device_duration_compact_retrospective!(\n    container::PowerSimulations.OptimizationContainer,\n    duration_data::Vector{@NamedTuple{up::Float64, down::Float64}},\n    initial_duration::Matrix{InitialCondition},\n    cons_type::InfrastructureSystems.Optimization.ConstraintType,\n    var_types::Tuple{InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType},\n    _::Type{T<:Component}\n)\n\n\nThis formulation of the duration constraints adds over the start times looking backwards.\n\nLaTeX\n\nMinimum up-time constraint:\n\nsum_i=t-min(d_min^up T)+ 1^t x_i^start - x_t^on leq 0\n\nfor i in the set of time steps.\n\nMinimum down-time constraint:\n\nsum_i=t-min(d_min^down T) + 1^t x_i^stop + x_t^on leq 1\n\nfor i in the set of time steps.\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nduration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down\ninitial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)\ncons_name::Symbol : name of the constraint\nvar_keys::Tuple{VariableKey, VariableKey, VariableKey}) : names of the variables\n: var_keys[1] : varon\n: var_keys[2] : varstart\n: var_keys[3] : varstop\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.device_duration_look_ahead!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Vector{@NamedTuple{up::Float64, down::Float64}}, Matrix{InitialCondition}, InfrastructureSystems.Optimization.ConstraintType, InfrastructureSystems.Optimization.ConstraintType, Tuple{InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType}, Type{T}}} where T<:Component","page":"Internals","title":"PowerSimulations.device_duration_look_ahead!","text":"device_duration_look_ahead!(\n    container::PowerSimulations.OptimizationContainer,\n    duration_data::Vector{@NamedTuple{up::Float64, down::Float64}},\n    initial_duration::Matrix{InitialCondition},\n    cons_type_up::InfrastructureSystems.Optimization.ConstraintType,\n    cons_type_down::InfrastructureSystems.Optimization.ConstraintType,\n    var_types::Tuple{InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType},\n    _::Type{T<:Component}\n)\n\n\nThis formulation of the duration constraints looks ahead in the time frame of the model.\n\nLaTeX\n\nMinimum up-time constraint:\n\nIf t leq d_min^up\n\nd_min^downx_t^stop - sum_i=t-d_min^up + 1^t x_i^on - x_init^up leq 0\n\nfor i in the set of time steps. Otherwise:\n\nd_min^downx_t^stop - sum_i=t-d_min^up + 1^t x_i^on leq 0\n\nfor i in the set of time steps.\n\nMinimum down-time constraint:\n\nIf t leq d_min^down\n\nd_min^upx_t^start - sum_i=t-d_min^down + 1^t (1 - x_i^on) - x_init^down leq 0\n\nfor i in the set of time steps. Otherwise:\n\nd_min^upx_t^start - sum_i=t-d_min^down + 1^t (1 - x_i^on) leq 0\n\nfor i in the set of time steps.\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nduration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down\ninitial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)\ncons_name::Symbol : name of the constraint\nvar_keys::Tuple{VariableKey, VariableKey, VariableKey}) : names of the variables\n: var_keys[1] : varon\n: var_keys[2] : varstart\n: var_keys[3] : varstop\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.device_duration_parameters!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Vector{@NamedTuple{up::Float64, down::Float64}}, Matrix{InitialCondition}, InfrastructureSystems.Optimization.ConstraintType, Tuple{InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType}, Type{T}}} where T<:Component","page":"Internals","title":"PowerSimulations.device_duration_parameters!","text":"device_duration_parameters!(\n    container::PowerSimulations.OptimizationContainer,\n    duration_data::Vector{@NamedTuple{up::Float64, down::Float64}},\n    initial_duration::Matrix{InitialCondition},\n    cons_type::InfrastructureSystems.Optimization.ConstraintType,\n    var_types::Tuple{InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType},\n    _::Type{T<:Component}\n)\n\n\nThis formulation of the duration constraints considers parameters.\n\nLaTeX\n\nMinimum up-time constraint:\n\nIf t leq d_min^up\n\nd_min^downx_t^stop - sum_i=t-d_min^up + 1^t x_i^on - x_init^up leq 0\n\nfor i in the set of time steps. Otherwise:\n\nsum_i=t-d_min^up + 1^t x_i^start - x_t^on leq 0\n\nfor i in the set of time steps.\n\nMinimum down-time constraint:\n\nIf t leq d_min^down\n\nd_min^upx_t^start - sum_i=t-d_min^down + 1^t (1 - x_i^on) - x_init^down leq 0\n\nfor i in the set of time steps. Otherwise:\n\nsum_i=t-d_min^down + 1^t x_i^stop + x_t^on leq 1\n\nfor i in the set of time steps.\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nduration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down\ninitialdurationon::Vector{InitialCondition} : gives initial number of time steps variable is up\ninitialdurationoff::Vector{InitialCondition} : gives initial number of time steps variable is down\ncons_name::Symbol : name of the constraint\nvar_keys::Tuple{VariableKey, VariableKey, VariableKey}) : names of the variables\n: var_keys[1] : varon\n: var_keys[2] : varstart\n: var_keys[3] : varstop\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.device_duration_retrospective!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Vector{@NamedTuple{up::Float64, down::Float64}}, Matrix{InitialCondition}, InfrastructureSystems.Optimization.ConstraintType, Tuple{InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType}, Type{T}}} where T<:Component","page":"Internals","title":"PowerSimulations.device_duration_retrospective!","text":"device_duration_retrospective!(\n    container::PowerSimulations.OptimizationContainer,\n    duration_data::Vector{@NamedTuple{up::Float64, down::Float64}},\n    initial_duration::Matrix{InitialCondition},\n    cons_type::InfrastructureSystems.Optimization.ConstraintType,\n    var_types::Tuple{InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType, InfrastructureSystems.Optimization.VariableType},\n    _::Type{T<:Component}\n)\n\n\nThis formulation of the duration constraints adds over the start times looking backwards.\n\nLaTeX\n\nMinimum up-time constraint:\n\nIf t leq d_min^up - d_init^up and d_init^up  0\n\n1 + sum_i=t-d_min^up + 1^t x_i^start - x_t^on leq 0\n\nfor i in the set of time steps. Otherwise:\n\nsum_i=t-d_min^up + 1^t x_i^start - x_t^on leq 0\n\nfor i in the set of time steps.\n\nMinimum down-time constraint:\n\nIf t leq d_min^down - d_init^down and d_init^down  0\n\n1 + sum_i=t-d_min^down + 1^t x_i^stop + x_t^on leq 1\n\nfor i in the set of time steps. Otherwise:\n\nsum_i=t-d_min^down + 1^t x_i^stop + x_t^on leq 1\n\nfor i in the set of time steps.\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nduration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down\ninitial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)\ncons_name::Symbol : name of the constraint\nvar_keys::Tuple{VariableKey, VariableKey, VariableKey}) : names of the variables\n: var_keys[1] : varon\n: var_keys[2] : varstart\n: var_keys[3] : varstop\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.find_key_with_value-Tuple{Any, Any}","page":"Internals","title":"PowerSimulations.find_key_with_value","text":"find_key_with_value(d, value) -> Any\n\n\nReturn the key for the given value\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.find_timestamp_index-Tuple{Union{StepRange{Dates.DateTime, Dates.Millisecond}, Vector{Dates.DateTime}}, Dates.DateTime}","page":"Internals","title":"PowerSimulations.find_timestamp_index","text":"find_timestamp_index(\n    dates::Union{StepRange{Dates.DateTime, Dates.Millisecond}, Vector{Dates.DateTime}},\n    date::Dates.DateTime\n) -> Int64\n\n\ncalculates the index in the time series corresponding to the data. Assumes that the dates vector is sorted.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.generate_formulation_combinations","page":"Internals","title":"PowerSimulations.generate_formulation_combinations","text":"generate_formulation_combinations(\n\n) -> Dict{String, Vector{Any}}\ngenerate_formulation_combinations(\n    sys\n) -> Dict{String, Vector{Any}}\n\n\nGenerate valid combinations of devicetype/formulation and servicetype/formulation. Return vectors of dictionaries with Julia types.\n\nArguments\n\nsys::Union{Nothing, System}: If set, only include component types present in the system.\n\n\n\n\n\n","category":"function"},{"location":"api/internal/#PowerSimulations.get_absolute_step_range-Tuple{SimulationPartitions, Int64}","page":"Internals","title":"PowerSimulations.get_absolute_step_range","text":"get_absolute_step_range(\n    partitions::SimulationPartitions,\n    index::Int64\n) -> UnitRange{Int64}\n\n\nReturn a UnitRange for the steps in the partition with the given index. Includes overlap.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_column_names-Tuple{PowerSimulations.OptimizationContainer, Symbol, Any, InfrastructureSystems.Optimization.OptimizationContainerKey}","page":"Internals","title":"PowerSimulations.get_column_names","text":"get_column_names(\n    _::PowerSimulations.OptimizationContainer,\n    field::Symbol,\n    subcontainer,\n    key::InfrastructureSystems.Optimization.OptimizationContainerKey\n) -> Any\n\n\nGet the column names for the specified container in the OptimizationContainer.\n\nArguments\n\ncontainer::OptimizationContainer: The optimization container.\nfield::Symbol: The field for which to retrieve the column names.\nkey::OptimizationContainerKey: The key for which to retrieve the column names.\n\nReturns\n\nTuple: Tuple of Vector{String}.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_column_names_from_key-Tuple{InfrastructureSystems.Optimization.OptimizationContainerKey}","page":"Internals","title":"PowerSimulations.get_column_names_from_key","text":"get_column_names_from_key(\n    key::InfrastructureSystems.Optimization.OptimizationContainerKey\n) -> Tuple{Vector}\n\n\nReturn the column names from a key as a tuple of vector of strings. Only useful for 1d DenseAxisArrays.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_dirty_data_to_flush!-Tuple{PowerSimulations.OptimizationOutputCache}","page":"Internals","title":"PowerSimulations.get_dirty_data_to_flush!","text":"get_dirty_data_to_flush!(\n    cache::PowerSimulations.OptimizationOutputCache\n) -> Tuple{Vector{Dates.DateTime}, Any}\n\n\nReturn all dirty data from the cache. Mark the timestamps as clean.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_enum_value-Tuple{Any, String}","page":"Internals","title":"PowerSimulations.get_enum_value","text":"get_enum_value(enum, value::String) -> Any\n\n\nGet the enum value for the string. Case insensitive.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_last_updated_timestamp-Tuple{PowerSimulations.DatasetContainer, InfrastructureSystems.Optimization.OptimizationContainerKey}","page":"Internals","title":"PowerSimulations.get_last_updated_timestamp","text":"get_last_updated_timestamp(\n    container::PowerSimulations.DatasetContainer,\n    key::InfrastructureSystems.Optimization.OptimizationContainerKey\n) -> Dates.DateTime\n\n\nReturn the timestamp from most recent data row updated in the dataset. This value may not be the same as the result from get_update_timestamp\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_last_updated_timestamp-Tuple{PowerSimulations.HDF5Dataset}","page":"Internals","title":"PowerSimulations.get_last_updated_timestamp","text":"get_last_updated_timestamp(\n    s::PowerSimulations.HDF5Dataset\n) -> Dates.DateTime\n\n\nReturn the timestamp from most recent data row updated in the dataset. This value may not be the same as the result from get_update_timestamp\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_last_updated_timestamp-Tuple{PowerSimulations.InMemoryDataset}","page":"Internals","title":"PowerSimulations.get_last_updated_timestamp","text":"get_last_updated_timestamp(\n    s::PowerSimulations.InMemoryDataset\n) -> Dates.DateTime\n\n\nReturn the timestamp from most recent data row updated in the dataset. This value may not be the same as the result from get_update_timestamp\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_min_max_limits-Tuple{ACTransmission, Type{<:InfrastructureSystems.Optimization.ConstraintType}, Type{<:PowerSimulations.AbstractBranchFormulation}}","page":"Internals","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    device::ACTransmission,\n    _::Type{<:InfrastructureSystems.Optimization.ConstraintType},\n    _::Type{<:PowerSimulations.AbstractBranchFormulation}\n) -> @NamedTuple{min::Float64, max::Float64}\n\n\nMin and max limits for Abstract Branch Formulation\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_min_max_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{<:PowerSimulations.AbstractCompactUnitCommitment}}","page":"Internals","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    device,\n    _::Type{ActivePowerVariableLimitsConstraint},\n    _::Type{<:PowerSimulations.AbstractCompactUnitCommitment}\n) -> NamedTuple{(:min, :max), <:Tuple{Float64, Any}}\n\n\nMin and Max active power limits for Compact Unit Commitment\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_min_max_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{<:PowerSimulations.AbstractThermalDispatchFormulation}}","page":"Internals","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    device,\n    _::Type{ActivePowerVariableLimitsConstraint},\n    _::Type{<:PowerSimulations.AbstractThermalDispatchFormulation}\n) -> NamedTuple{(:min, :max), <:Tuple{Float64, Any}}\n\n\nMin and max active power limits of generators for thermal dispatch formulations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_min_max_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{<:PowerSimulations.AbstractThermalUnitCommitment}}","page":"Internals","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    device,\n    _::Type{ActivePowerVariableLimitsConstraint},\n    _::Type{<:PowerSimulations.AbstractThermalUnitCommitment}\n) -> NamedTuple{(:min, :max), <:Tuple{Float64, Any}}\n\n\nMin and max active power limits of generators for thermal unit commitment formulations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_min_max_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{ThermalCompactDispatch}}","page":"Internals","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    device,\n    _::Type{ActivePowerVariableLimitsConstraint},\n    _::Type{ThermalCompactDispatch}\n) -> NamedTuple{(:min, :max), <:Tuple{Float64, Any}}\n\n\nMin and max active power limits of generators for thermal dispatch compact formulations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_min_max_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{ThermalDispatchNoMin}}","page":"Internals","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    device,\n    _::Type{ActivePowerVariableLimitsConstraint},\n    _::Type{ThermalDispatchNoMin}\n) -> NamedTuple{(:min, :max), <:Tuple{Float64, Any}}\n\n\nMin and max active power limits of generators for thermal dispatch no minimum formulations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_min_max_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{ThermalMultiStartUnitCommitment}}","page":"Internals","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    device,\n    _::Type{ActivePowerVariableLimitsConstraint},\n    _::Type{ThermalMultiStartUnitCommitment}\n) -> NamedTuple{(:min, :max), <:Tuple{Float64, Any}}\n\n\nMin and max active power limits for multi-start unit commitment formulations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_min_max_limits-Tuple{Any, Type{ReactivePowerVariableLimitsConstraint}, Type{<:PowerSimulations.AbstractThermalDispatchFormulation}}","page":"Internals","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    device,\n    _::Type{ReactivePowerVariableLimitsConstraint},\n    _::Type{<:PowerSimulations.AbstractThermalDispatchFormulation}\n) -> Any\n\n\nReactive power limits of generators for all dispatch formulations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_min_max_limits-Tuple{Any, Type{ReactivePowerVariableLimitsConstraint}, Type{<:PowerSimulations.AbstractThermalUnitCommitment}}","page":"Internals","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    device,\n    _::Type{ReactivePowerVariableLimitsConstraint},\n    _::Type{<:PowerSimulations.AbstractThermalUnitCommitment}\n) -> Any\n\n\nReactive power limits of generators when there CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_min_max_limits-Tuple{MonitoredLine, Type{<:InfrastructureSystems.Optimization.ConstraintType}, Type{<:PowerSimulations.AbstractBranchFormulation}}","page":"Internals","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    device::MonitoredLine,\n    _::Type{<:InfrastructureSystems.Optimization.ConstraintType},\n    _::Type{<:PowerSimulations.AbstractBranchFormulation}\n) -> @NamedTuple{min::Float64, max::Float64}\n\n\nMin and max limits for monitored line\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_min_max_limits-Tuple{MonitoredLine, Type{FlowLimitFromToConstraint}, Type{<:PowerSimulations.AbstractBranchFormulation}}","page":"Internals","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    device::MonitoredLine,\n    _::Type{FlowLimitFromToConstraint},\n    _::Type{<:PowerSimulations.AbstractBranchFormulation}\n) -> @NamedTuple{min::Float64, max::Float64}\n\n\nMin and max limits for flow limit from-to constraint\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_min_max_limits-Tuple{MonitoredLine, Type{FlowLimitToFromConstraint}, Type{<:PowerSimulations.AbstractBranchFormulation}}","page":"Internals","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    device::MonitoredLine,\n    _::Type{FlowLimitToFromConstraint},\n    _::Type{<:PowerSimulations.AbstractBranchFormulation}\n) -> @NamedTuple{min::Float64, max::Float64}\n\n\nMin and max limits for flow limit to-from constraint\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_min_max_limits-Tuple{PhaseShiftingTransformer, Type{PhaseAngleControlLimit}, Type{PhaseAngleControl}}","page":"Internals","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    _::PhaseShiftingTransformer,\n    _::Type{PhaseAngleControlLimit},\n    _::Type{PhaseAngleControl}\n) -> @NamedTuple{min::Float64, max::Float64}\n\n\nMin and max limits for Abstract Branch Formulation\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_min_max_limits-Tuple{PowerNetworkMatrices.BranchesParallel, Type{<:InfrastructureSystems.Optimization.ConstraintType}, Type{<:PowerSimulations.AbstractBranchFormulation}}","page":"Internals","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    double_circuit::PowerNetworkMatrices.BranchesParallel,\n    constraint_type::Type{<:InfrastructureSystems.Optimization.ConstraintType},\n    branch_formulation::Type{<:PowerSimulations.AbstractBranchFormulation}\n) -> NamedTuple{(:min, :max), <:Tuple{Any, Any}}\n\n\nMin and max limits for Abstract Branch Formulation\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_min_max_limits-Tuple{PowerNetworkMatrices.BranchesSeries, Type{<:InfrastructureSystems.Optimization.ConstraintType}, Type{<:PowerSimulations.AbstractBranchFormulation}}","page":"Internals","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    series_chain::PowerNetworkMatrices.BranchesSeries,\n    constraint_type::Type{<:InfrastructureSystems.Optimization.ConstraintType},\n    branch_formulation::Type{<:PowerSimulations.AbstractBranchFormulation}\n) -> NamedTuple{(:min, :max), <:Tuple{Any, Any}}\n\n\nMin and max limits for Abstract Branch Formulation\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_min_max_limits-Tuple{PowerNetworkMatrices.ThreeWindingTransformerWinding, Type{<:InfrastructureSystems.Optimization.ConstraintType}, Type{<:PowerSimulations.AbstractBranchFormulation}}","page":"Internals","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(\n    transformer_entry::PowerNetworkMatrices.ThreeWindingTransformerWinding,\n    constraint_type::Type{<:InfrastructureSystems.Optimization.ConstraintType},\n    branch_formulation::Type{<:PowerSimulations.AbstractBranchFormulation}\n) -> @NamedTuple{min::Float64, max::Float64}\n\n\nMin and max limits for Abstract Branch Formulation\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_piecewise_curve_per_system_unit-Tuple{PiecewiseStepData, UnitSystem, Float64, Float64}","page":"Internals","title":"PowerSimulations.get_piecewise_curve_per_system_unit","text":"get_piecewise_curve_per_system_unit(\n    cost_component::PiecewiseStepData,\n    unit_system::UnitSystem,\n    system_base_power::Float64,\n    device_base_power::Float64\n) -> PiecewiseStepData\n\n\nObtain the normalized PiecewiseStepData in system base per unit depending on the specified power units.\n\nNote that the costs (y-axis) are in /MWh, /(sys pu h) or /(device pu h), so they also require transformation.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_piecewise_pointcurve_per_system_unit-Tuple{PiecewiseLinearData, UnitSystem, Float64, Float64}","page":"Internals","title":"PowerSimulations.get_piecewise_pointcurve_per_system_unit","text":"get_piecewise_pointcurve_per_system_unit(\n    cost_component::PiecewiseLinearData,\n    unit_system::UnitSystem,\n    system_base_power::Float64,\n    device_base_power::Float64\n) -> PiecewiseLinearData\n\n\nObtain the normalized PiecewiseLinear cost data in system base per unit depending on the specified power units.\n\nNote that the costs (y-axis) are always in /h so they do not require transformation\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_proportional_cost_per_system_unit-Tuple{Float64, UnitSystem, Float64, Float64}","page":"Internals","title":"PowerSimulations.get_proportional_cost_per_system_unit","text":"get_proportional_cost_per_system_unit(\n    cost_term::Float64,\n    unit_system::UnitSystem,\n    system_base_power::Float64,\n    device_base_power::Float64\n) -> Float64\n\n\nObtain proportional (marginal or slope) cost data in system base per unit depending on the specified power units\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_quadratic_cost_per_system_unit-Tuple{Float64, UnitSystem, Float64, Float64}","page":"Internals","title":"PowerSimulations.get_quadratic_cost_per_system_unit","text":"get_quadratic_cost_per_system_unit(\n    cost_term::Float64,\n    unit_system::UnitSystem,\n    system_base_power::Float64,\n    device_base_power::Float64\n) -> Float64\n\n\nObtain quadratic cost data in system base per unit depending on the specified power units\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_startup_shutdown_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{<:PowerSimulations.AbstractCompactUnitCommitment}}","page":"Internals","title":"PowerSimulations.get_startup_shutdown_limits","text":"get_startup_shutdown_limits(\n    device,\n    _::Type{ActivePowerVariableLimitsConstraint},\n    _::Type{<:PowerSimulations.AbstractCompactUnitCommitment}\n) -> @NamedTuple{startup::Float64, shutdown::Float64}\n\n\nStartup shutdown limits for Compact Unit Commitment\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_startup_shutdown_limits-Tuple{ThermalMultiStart, Type{ActivePowerVariableLimitsConstraint}, Type{ThermalMultiStartUnitCommitment}}","page":"Internals","title":"PowerSimulations.get_startup_shutdown_limits","text":"get_startup_shutdown_limits(\n    device::ThermalMultiStart,\n    _::Type{ActivePowerVariableLimitsConstraint},\n    _::Type{ThermalMultiStartUnitCommitment}\n) -> @NamedTuple{startup::Float64, shutdown::Float64}\n\n\nStartup and shutdown active power limits for Compact Unit Commitment\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_update_timestamp-Tuple{PowerSimulations.AbstractDataset}","page":"Internals","title":"PowerSimulations.get_update_timestamp","text":"get_update_timestamp(\n    s::PowerSimulations.AbstractDataset\n) -> Any\n\n\nReturn the timestamp from the data used in the last update\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_update_timestamp-Tuple{PowerSimulations.DatasetContainer, InfrastructureSystems.Optimization.OptimizationContainerKey}","page":"Internals","title":"PowerSimulations.get_update_timestamp","text":"get_update_timestamp(\n    container::PowerSimulations.DatasetContainer,\n    key::InfrastructureSystems.Optimization.OptimizationContainerKey\n) -> Any\n\n\nReturn the timestamp from the data used in the last update\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_valid_step_length-Tuple{SimulationPartitions, Int64}","page":"Internals","title":"PowerSimulations.get_valid_step_length","text":"get_valid_step_length(\n    partitions::SimulationPartitions,\n    index::Int64\n) -> Int64\n\n\nReturn the length of valid data at the given index.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.get_valid_step_offset-Tuple{SimulationPartitions, Int64}","page":"Internals","title":"PowerSimulations.get_valid_step_offset","text":"get_valid_step_offset(\n    partitions::SimulationPartitions,\n    index::Int64\n) -> Int64\n\n\nReturn the step offset for valid data at the given index.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.has_dirty-Tuple{PowerSimulations.OptimizationOutputCaches}","page":"Internals","title":"PowerSimulations.has_dirty","text":"has_dirty(\n    cache::PowerSimulations.OptimizationOutputCaches\n) -> Bool\n\n\nReturn true if the cache has data that has not been flushed to storage.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.is_cached-Tuple{PowerSimulations.OptimizationOutputCaches, Any, Any, Any}","page":"Internals","title":"PowerSimulations.is_cached","text":"is_cached(\n    cache::PowerSimulations.OptimizationOutputCaches,\n    model_name,\n    key,\n    index\n) -> Bool\n\n\nReturn true if the data for timestamp is stored in cache.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.is_from_power_flow-Tuple{Type{<:InfrastructureSystems.Optimization.AuxVariableType}}","page":"Internals","title":"PowerSimulations.is_from_power_flow","text":"is_from_power_flow(\n    _::Type{<:InfrastructureSystems.Optimization.AuxVariableType}\n) -> Bool\n\n\nWhether the auxiliary variable is calculated using a PowerFlowEvaluationModel\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.join_simulation-Tuple{AbstractString}","page":"Internals","title":"PowerSimulations.join_simulation","text":"join_simulation(path::AbstractString)\n\n\nCombine all partition simulation files.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.latest_solved_power_flow_evaluation_data-Tuple{PowerSimulations.OptimizationContainer}","page":"Internals","title":"PowerSimulations.latest_solved_power_flow_evaluation_data","text":"latest_solved_power_flow_evaluation_data(\n    container::PowerSimulations.OptimizationContainer\n) -> PowerSimulations.PowerFlowEvaluationData\n\n\nFetch the most recently solved PowerFlowEvaluationData\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.list_decision_model_keys-Tuple{PowerSimulations.HdfSimulationStore, Symbol, Symbol}","page":"Internals","title":"PowerSimulations.list_decision_model_keys","text":"list_decision_model_keys(\n    store::PowerSimulations.HdfSimulationStore,\n    model::Symbol,\n    container_type::Symbol\n) -> Vector\n\n\nReturn the fields stored for the problem and container_type (duals/parameters/variables).\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.list_decision_models-Tuple{PowerSimulations.HdfSimulationStore}","page":"Internals","title":"PowerSimulations.list_decision_models","text":"list_decision_models(\n    store::PowerSimulations.HdfSimulationStore\n) -> Base.KeySet{Symbol, OrderedDict{Symbol, PowerSimulations.DatasetContainer{PowerSimulations.HDF5Dataset}}}\n\n\nReturn the problem names in order of execution.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.log_cache_hit_percentages-Tuple{PowerSimulations.OptimizationOutputCaches}","page":"Internals","title":"PowerSimulations.log_cache_hit_percentages","text":"log_cache_hit_percentages(\n    cache::PowerSimulations.OptimizationOutputCaches\n)\n\n\nLog the cache hit percentages for all caches.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.lookup_additional_axes-Tuple{Any}","page":"Internals","title":"PowerSimulations.lookup_additional_axes","text":"lookup_additional_axes(parameter_array) -> Any\n\n\nGiven a parameter array, get any additional axes, i.e., those that aren't the first (component) or the last (time)\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.onvar_cost-Tuple{PowerSimulations.OptimizationContainer, ThermalGenerationCost, OnVariable, ThermalGen, PowerSimulations.AbstractThermalFormulation, Int64}","page":"Internals","title":"PowerSimulations.onvar_cost","text":"onvar_cost(\n    container::PowerSimulations.OptimizationContainer,\n    cost::ThermalGenerationCost,\n    _::OnVariable,\n    d::ThermalGen,\n    _::PowerSimulations.AbstractThermalFormulation,\n    t::Int64\n) -> Any\n\n\nTheoretical Cost at power output zero. Mathematically is the intercept with the y-axis\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.open_store","page":"Internals","title":"PowerSimulations.open_store","text":"open_store(\n    ::Type{PowerSimulations.HdfSimulationStore},\n    directory::AbstractString;\n    ...\n) -> PowerSimulations.HdfSimulationStore\nopen_store(\n    ::Type{PowerSimulations.HdfSimulationStore},\n    directory::AbstractString,\n    mode;\n    filename\n) -> PowerSimulations.HdfSimulationStore\n\n\nConstruct and open an HdfSimulationStore.\n\nWhen reading or writing results in a program you should use the method that accepts a function in order to guarantee that the file handle gets closed.\n\nArguments\n\ndirectory::AbstractString: Directory containing the store file\nmode::AbstractString: Mode to use to open the store file\nfilename::AbstractString: Base name of the store file\n\nExamples\n\n# Assumes a simulation has been executed in the './rts' directory with these parameters.\npath = \"./rts\"\nproblem = :ED\nvar_name = :P__ThermalStandard\ntimestamp = DateTime(\"2020-01-01T05:00:00\")\nstore = open_store(HdfSimulationStore, path)\ndf = PowerSimulations.read_result(DataFrame, store, model, :variables, var_name, timestamp)\n\n\n\n\n\n","category":"function"},{"location":"api/internal/#PowerSimulations.process_market_bid_parameters!","page":"Internals","title":"PowerSimulations.process_market_bid_parameters!","text":"process_market_bid_parameters!(\n    container::PowerSimulations.OptimizationContainer,\n    devices_in,\n    model::DeviceModel\n)\nprocess_market_bid_parameters!(\n    container::PowerSimulations.OptimizationContainer,\n    devices_in,\n    model::DeviceModel,\n    incremental::Bool\n)\nprocess_market_bid_parameters!(\n    container::PowerSimulations.OptimizationContainer,\n    devices_in,\n    model::DeviceModel,\n    incremental::Bool,\n    decremental::Bool\n)\n\n\nValidate MarketBidCosts and add the appropriate parameters\n\n\n\n\n\n","category":"function"},{"location":"api/internal/#PowerSimulations.read_dataframe-Tuple{AbstractString}","page":"Internals","title":"PowerSimulations.read_dataframe","text":"read_dataframe(filename::AbstractString) -> DataFrame\n\n\nReturn a DataFrame from a CSV file.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.read_json-Tuple{AbstractString}","page":"Internals","title":"PowerSimulations.read_json","text":"read_json(\n    filename::AbstractString\n) -> Union{Nothing, Bool, Float64, Int64, String, JSON3.Array, JSON3.Object}\n\n\nReturn a decoded JSON file.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.read_result-Tuple{PowerSimulations.OptimizationOutputCaches, Any, Any, Any}","page":"Internals","title":"PowerSimulations.read_result","text":"read_result(\n    cache::PowerSimulations.OptimizationOutputCaches,\n    model_name,\n    key,\n    timestamp\n) -> Array\n\n\nRead the result from cache. Callers must first call is_cached to check if the timestamp is present.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.read_result-Tuple{Type{DataFrame}, PowerSimulations.HdfSimulationStore, Symbol, InfrastructureSystems.Optimization.OptimizationContainerKey, Union{Int64, Dates.DateTime}}","page":"Internals","title":"PowerSimulations.read_result","text":"read_result(\n    _::Type{DataFrame},\n    store::PowerSimulations.HdfSimulationStore,\n    model_name::Symbol,\n    key::InfrastructureSystems.Optimization.OptimizationContainerKey,\n    index::Union{Int64, Dates.DateTime}\n) -> DataFrame\n\n\nReturn DataFrame, DenseAxisArray, or Array for a model result at a timestamp.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.serialize_formulation_combinations","page":"Internals","title":"PowerSimulations.serialize_formulation_combinations","text":"serialize_formulation_combinations(\n\n) -> Dict{String, Vector{Any}}\nserialize_formulation_combinations(\n    sys\n) -> Dict{String, Vector{Any}}\n\n\nGenerate valid combinations of devicetype/formulation and servicetype/formulation. Return vectors of dictionaries with Julia types encoded as strings.\n\nArguments\n\nsys::Union{Nothing, System}: If set, only include component types present in the system.\n\n\n\n\n\n","category":"function"},{"location":"api/internal/#PowerSimulations.serialize_jump_optimization_model-Tuple{JuMP.Model, String}","page":"Internals","title":"PowerSimulations.serialize_jump_optimization_model","text":"serialize_jump_optimization_model(\n    jump_model::JuMP.Model,\n    save_path::String\n)\n\n\nExports the JuMP object in MathOptFormat\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.serialize_simulation-Tuple{Simulation}","page":"Internals","title":"PowerSimulations.serialize_simulation","text":"serialize_simulation(sim::Simulation; path, force) -> String\n\n\nserialize_simulation(sim::Simulation, path = \".\")\n\nSerialize the simulation to a directory in path.\n\nReturn the serialized simulation directory name that is created.\n\nArguments\n\nsim::Simulation: simulation to serialize\npath = \".\": path in which to create the serialzed directory\nforce = false: If true, delete the directory if it already exists. Otherwise, it will throw an exception.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.set_expression!-Union{Tuple{T}, Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, Type{S}, JuMP.AbstractJuMPScalar, T, Int64}} where {S<:CostExpressions, T<:Component}","page":"Internals","title":"PowerSimulations.set_expression!","text":"set_expression!(\n    container::PowerSimulations.OptimizationContainer,\n    _::Type{S<:CostExpressions},\n    cost_expression::JuMP.AbstractJuMPScalar,\n    component::Component,\n    time_period::Int64\n)\n\n\nReplaces an expression value in the expression container if the key exists\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.set_ic_quantity!-Union{Tuple{T}, Tuple{InitialCondition{T, Float64}, Float64}} where T<:InfrastructureSystems.Optimization.InitialConditionType","page":"Internals","title":"PowerSimulations.set_ic_quantity!","text":"set_ic_quantity!(\n    ic::InitialCondition{T<:InfrastructureSystems.Optimization.InitialConditionType, Float64},\n    var_value::Float64\n)\n\n\nDefault implementation of setinitialcondition_value\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.set_ic_quantity!-Union{Tuple{T}, Tuple{InitialCondition{T, JuMP.VariableRef}, Float64}} where T<:InfrastructureSystems.Optimization.InitialConditionType","page":"Internals","title":"PowerSimulations.set_ic_quantity!","text":"set_ic_quantity!(\n    ic::InitialCondition{T<:InfrastructureSystems.Optimization.InitialConditionType, JuMP.VariableRef},\n    var_value::Float64\n)\n\n\nDefault implementation of setinitialcondition_value\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.solve_impl!-Tuple{PowerSimulations.OptimizationContainer, System}","page":"Internals","title":"PowerSimulations.solve_impl!","text":"solve_impl!(\n    container::PowerSimulations.OptimizationContainer,\n    system::System\n) -> Any\n\n\nDefault solve method for OptimizationContainer\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.sparse_container_spec-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any}}} where T<:JuMP.AbstractJuMPScalar","page":"Internals","title":"PowerSimulations.sparse_container_spec","text":"sparse_container_spec(\n    _::Type{T<:JuMP.AbstractJuMPScalar},\n    axs...\n) -> JuMP.Containers.SparseAxisArray\n\n\nReturns the correct container specification for the selected type of JuMP Model\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.to_dataframe-Union{Tuple{T}, Tuple{JuMP.Containers.DenseAxisArray{T, 2, Ax, L} where {Ax, L<:Tuple{JuMP.Containers._AxisLookup, JuMP.Containers._AxisLookup}}, InfrastructureSystems.Optimization.OptimizationContainerKey}} where T<:Union{Number, Tuple{Vararg{Number}}, Vector{<:Tuple{Number, Number}}}","page":"Internals","title":"PowerSimulations.to_dataframe","text":"to_dataframe(\n    array::JuMP.Containers.DenseAxisArray{T<:Union{Number, Tuple{Vararg{Number}}, Vector{<:Tuple{Number, Number}}}, 2, Ax, L} where {Ax, L<:Tuple{JuMP.Containers._AxisLookup, JuMP.Containers._AxisLookup}},\n    key::InfrastructureSystems.Optimization.OptimizationContainerKey\n) -> DataFrame\n\n\nCreate a DataFrame from a JuMP DenseAxisArray or SparseAxisArray.\n\nArguments\n\narray: JuMP DenseAxisArray or SparseAxisArray to convert\nkey::OptimizationContainerKey:\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.to_results_dataframe-Tuple{JuMP.Containers.DenseAxisArray, Any}","page":"Internals","title":"PowerSimulations.to_results_dataframe","text":"to_results_dataframe(\n    array::JuMP.Containers.DenseAxisArray,\n    timestamps\n) -> Any\n\n\nConvert a DenseAxisArray containing components to a results DataFrame consumable by users.\n\nArguments\n\narray: DenseAxisArray: JuMP DenseAxisArray to convert\ntimestamps: Iterable of timestamps for each component or nothing if time is not known. The resulting DataFrame will have the column \"DateTime\" if timestamps is not nothing. Otherwise, it will have the column \"time_index\", representing the index of the time dimension.\n::Val{TableFormat}: Format of the table to create. If it is TableFormat.LONG, the DataFrame will have the column \"name\", and, if the data has three dimensions, \"name2.\" If it is TableFormat.WIDE, the DataFrame will have columns for each component. Wide format does not support arrays with more than two dimensions.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.update_container_parameter_values!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.OperationModel, InfrastructureSystems.Optimization.ParameterKey{T, U}, PowerSimulations.DatasetContainer{PowerSimulations.InMemoryDataset}}} where {T<:InfrastructureSystems.Optimization.ParameterType, U<:Component}","page":"Internals","title":"PowerSimulations.update_container_parameter_values!","text":"update_container_parameter_values!(\n    optimization_container::PowerSimulations.OptimizationContainer,\n    model::PowerSimulations.OperationModel,\n    key::InfrastructureSystems.Optimization.ParameterKey{T<:InfrastructureSystems.Optimization.ParameterType, U<:Component},\n    input::PowerSimulations.DatasetContainer{PowerSimulations.InMemoryDataset}\n)\n\n\nUpdate parameter function an OperationModel\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.update_model!-Tuple{PowerSimulations.OperationModel, Simulation}","page":"Internals","title":"PowerSimulations.update_model!","text":"update_model!(\n    model::PowerSimulations.OperationModel,\n    sim::Simulation\n)\n\n\nDefault problem update function for most problems with no customization\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.update_parameter_values!-Union{Tuple{U}, Tuple{T}, Tuple{EmulationModel, InfrastructureSystems.Optimization.ParameterKey{T, U}, PowerSimulations.DatasetContainer{PowerSimulations.InMemoryDataset}}} where {T<:InfrastructureSystems.Optimization.ParameterType, U<:Component}","page":"Internals","title":"PowerSimulations.update_parameter_values!","text":"update_parameter_values!(\n    model::EmulationModel,\n    key::InfrastructureSystems.Optimization.ParameterKey{T<:InfrastructureSystems.Optimization.ParameterType, U<:Component},\n    input::PowerSimulations.DatasetContainer{PowerSimulations.InMemoryDataset}\n)\n\n\nUpdate parameter function an OperationModel\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.update_parameter_values!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OperationModel, InfrastructureSystems.Optimization.ParameterKey{T, U}, PowerSimulations.SimulationState}} where {T<:InfrastructureSystems.Optimization.ParameterType, U<:Component}","page":"Internals","title":"PowerSimulations.update_parameter_values!","text":"update_parameter_values!(\n    model::PowerSimulations.OperationModel,\n    key::InfrastructureSystems.Optimization.ParameterKey{T<:InfrastructureSystems.Optimization.ParameterType, U<:Component},\n    simulation_state::PowerSimulations.SimulationState\n)\n\n\nUpdate parameter function an OperationModel\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.update_pf_data!-Tuple{PowerSimulations.PowerFlowEvaluationData{PowerFlows.PSSEExporter}, PowerSimulations.OptimizationContainer, Int64}","page":"Internals","title":"PowerSimulations.update_pf_data!","text":"update_pf_data!(\n    pf_e_data::PowerSimulations.PowerFlowEvaluationData{PowerFlows.PSSEExporter},\n    container::PowerSimulations.OptimizationContainer,\n    time_step::Int64\n)\n\n\nUpdate a PowerFlowEvaluationData containing a PowerFlowContainer that does not supports_multi_period using a single time_step of the OptimizationContainer. To properly keep track of outer step number, time steps must be passed in sequentially, starting with 1.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.variable_reactive_net_injection-Tuple{PowerModels.AbstractActivePowerModel}","page":"Internals","title":"PowerSimulations.variable_reactive_net_injection","text":"variable_reactive_net_injection(\n    pm::PowerModels.AbstractActivePowerModel;\n    kwargs...\n)\n\n\nactive power only models ignore reactive power variables\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.write_formulation_combinations","page":"Internals","title":"PowerSimulations.write_formulation_combinations","text":"write_formulation_combinations(filename::AbstractString)\nwrite_formulation_combinations(\n    filename::AbstractString,\n    sys\n)\n\n\nGenerate valid combinations of devicetype/formulation and servicetype/formulation and write the result to a JSON file.\n\nArguments\n\nsys::Union{Nothing, System}: If set, only include component types present in the system.\n\n\n\n\n\n","category":"function"},{"location":"api/internal/#PowerSimulations.write_result!-Tuple{PowerSimulations.HdfSimulationStore, Symbol, InfrastructureSystems.Optimization.OptimizationContainerKey, Dates.DateTime, Dates.DateTime, JuMP.Containers.DenseAxisArray{Float64, 3, var\"#s244\", L} where {var\"#s244\"<:Tuple{Any, Any, Any}, L<:Tuple{JuMP.Containers._AxisLookup, JuMP.Containers._AxisLookup, JuMP.Containers._AxisLookup}}}","page":"Internals","title":"PowerSimulations.write_result!","text":"write_result!(\n    store::PowerSimulations.HdfSimulationStore,\n    model_name::Symbol,\n    key::InfrastructureSystems.Optimization.OptimizationContainerKey,\n    index::Dates.DateTime,\n    _::Dates.DateTime,\n    data::JuMP.Containers.DenseAxisArray{Float64, 3, var\"#s244\", L} where {var\"#s244\"<:Tuple{Any, Any, Any}, L<:Tuple{JuMP.Containers._AxisLookup, JuMP.Containers._AxisLookup, JuMP.Containers._AxisLookup}}\n)\n\n\nWrite a decision model result for a timestamp to the store.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.write_result!-Tuple{PowerSimulations.HdfSimulationStore, Symbol, InfrastructureSystems.Optimization.OptimizationContainerKey, Int64, Dates.DateTime, JuMP.Containers.DenseAxisArray{Float64, 2, Ax, L} where {Ax, L<:Tuple{JuMP.Containers._AxisLookup, JuMP.Containers._AxisLookup}}}","page":"Internals","title":"PowerSimulations.write_result!","text":"write_result!(\n    store::PowerSimulations.HdfSimulationStore,\n    _::Symbol,\n    key::InfrastructureSystems.Optimization.OptimizationContainerKey,\n    index::Int64,\n    simulation_time::Dates.DateTime,\n    array::JuMP.Containers.DenseAxisArray{Float64, 2, Ax, L} where {Ax, L<:Tuple{JuMP.Containers._AxisLookup, JuMP.Containers._AxisLookup}}\n)\n\n\nWrite an emulation model result for an execution index value and the timestamp of the update\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulations.write_result!-Union{Tuple{N}, Tuple{PowerSimulations.HdfSimulationStore, Symbol, InfrastructureSystems.Optimization.OptimizationContainerKey, Dates.DateTime, Dates.DateTime, JuMP.Containers.DenseAxisArray{Float64, N, var\"#s244\", L} where {var\"#s244\"<:NTuple{N, Any}, L<:NTuple{N, JuMP.Containers._AxisLookup}}}} where N","page":"Internals","title":"PowerSimulations.write_result!","text":"write_result!(\n    store::PowerSimulations.HdfSimulationStore,\n    model_name::Symbol,\n    key::InfrastructureSystems.Optimization.OptimizationContainerKey,\n    index::Dates.DateTime,\n    _::Dates.DateTime,\n    data::JuMP.Containers.DenseAxisArray{Float64, N, var\"#s244\", L} where {var\"#s244\"<:NTuple{N, Any}, L<:NTuple{N, JuMP.Containers._AxisLookup}}\n)\n\n\nWrite a decision model result for a timestamp to the store.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSystems.get_component-Tuple{InfrastructureSystems.Results, Base.UUID}","page":"Internals","title":"PowerSystems.get_component","text":"get_component(\n    res::InfrastructureSystems.Results,\n    uuid::Base.UUID\n) -> Union{Nothing, InfrastructureSystems.InfrastructureSystemsComponent}\n\n\nCalling get_component on a Results is the same as calling [get_available_component] on the system attached to the results.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSystems.get_components-Union{Tuple{T}, Tuple{Type{T}, InfrastructureSystems.Results}} where T<:InfrastructureSystems.InfrastructureSystemsComponent","page":"Internals","title":"PowerSystems.get_components","text":"get_components(\n    ::Type{T<:InfrastructureSystems.InfrastructureSystemsComponent},\n    res::InfrastructureSystems.Results;\n    subsystem_name\n) -> InfrastructureSystems.FlattenIteratorWrapper{T, I} where {T<:InfrastructureSystems.InfrastructureSystemsComponent, I<:(Vector)}\n\n\nCalling get_components on a Results is the same as calling [get_available_components] on the system attached to the results.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSystems.get_groups-Tuple{Union{Nothing, Function}, ComponentSelector, InfrastructureSystems.Results}","page":"Internals","title":"PowerSystems.get_groups","text":"get_groups(\n    scope_limiter::Union{Nothing, Function},\n    selector::ComponentSelector,\n    res::InfrastructureSystems.Results\n) -> Any\n\n\nCalling get_groups on a Results is the same as calling [get_available_groups] on the system attached to the results.\n\n\n\n\n\n","category":"method"},{"location":"formulation_library/Feedforward/#ff_formulations","page":"Feedforwards","title":"FeedForward Formulations","text":"FeedForwards are the mechanism to define how information is shared between models. Specifically, a FeedForward defines what to do with information passed with an inter-stage chronology in a Simulation. The most common FeedForward is the SemiContinuousFeedForward that affects the semi-continuous range constraints of thermal generators in the economic dispatch problems based on the value of the (already solved) unit-commitment variables.\n\nThe creation of a FeedForward requires at least specifying the component_type on which the FeedForward will be applied. The source variable specifies which variable will be taken from the problem solved, for example, the commitment variable of the thermal unit in the unit commitment problem. Finally, the affected_values specify which variables will be affected in the problem to be solved, for example, the next economic dispatch problem.","category":"section"},{"location":"formulation_library/Feedforward/#Table-of-contents","page":"Feedforwards","title":"Table of contents","text":"SemiContinuousFeedforward\nFixValueFeedforward\nUpperBoundFeedforward\nLowerBoundFeedforward\n\n","category":"section"},{"location":"formulation_library/Feedforward/#SemiContinuousFeedforward","page":"Feedforwards","title":"SemiContinuousFeedforward","text":"Variables:\n\nNo variables are created\n\nParameters:\n\ntexton^textth = OnStatusParameter obtained from the source variable, typically the commitment variable of the unit commitment problem u^textth.\n\nObjective:\n\nNo changes to the objective function.\n\nExpressions:\n\nAdds -texton^textthP^textthmax to the ActivePowerRangeExpressionUB expression and -texton^textthP^textthmin to the ActivePowerRangeExpressionLB expression.\n\nConstraints:\n\nLimits the ActivePowerRangeExpressionUB and ActivePowerRangeExpressionLB by zero as:\n\nbeginalign*\n  textActivePowerRangeExpressionUB_t = p_t^textth - texton_t^textthP^textthmax le 0 quad  forall tin 1 dots T  \n  textActivePowerRangeExpressionLB_t = p_t^textth - texton_t^textthP^textthmin ge 0 quad  forall tin 1 dots T \nendalign*\n\nThus, if the commitment parameter is zero, the dispatch is limited to zero, forcing to turn off the generator without introducing binary variables in the economic dispatch problem.\n\n","category":"section"},{"location":"formulation_library/Feedforward/#FixValueFeedforward","page":"Feedforwards","title":"FixValueFeedforward","text":"Variables:\n\nNo variables are created\n\nParameters:\n\nThe parameter FixValueParameter is used to match the result obtained from the source variable (from the simulation state).\n\nObjective:\n\nNo changes to the objective function.\n\nExpressions:\n\nNo changes on expressions.\n\nConstraints:\n\nSet the VariableType from the affected_values to be equal to the source parameter store in FixValueParameter\n\nbeginalign*\n  textAffectedVariable_t = textSourceVariableParameter_t quad forall t in 1dots T\nendalign*\n\n","category":"section"},{"location":"formulation_library/Feedforward/#UpperBoundFeedforward","page":"Feedforwards","title":"UpperBoundFeedforward","text":"Variables:\n\nIf slack variables are enabled:\n\nUpperBoundFeedForwardSlack\nBounds: [0.0, ]\nDefault proportional cost: 1e6\nSymbol: p^textffubsl\n\nParameters:\n\nThe parameter UpperBoundValueParameter stores the result obtained from the source variable (from the simulation state) that will be used as an upper bound to the affected variable.\n\nObjective:\n\nThe slack variable is added to the objective function using its large default cost + p^textffubsl cdot 10^6\n\nExpressions:\n\nNo changes on expressions.\n\nConstraints:\n\nSet the VariableType from the affected_values to be lower than the source parameter store in UpperBoundValueParameter.\n\nbeginalign*\n   textAffectedVariable_t - p_t^textffubsl le textSourceVariableParameter_t quad forall t in 1dots T\nendalign*\n\n","category":"section"},{"location":"formulation_library/Feedforward/#LowerBoundFeedforward","page":"Feedforwards","title":"LowerBoundFeedforward","text":"Variables:\n\nIf slack variables are enabled:\n\nLowerBoundFeedForwardSlack\nBounds: [0.0, ]\nDefault proportional cost: 1e6\nSymbol: p^textfflbsl\n\nParameters:\n\nThe parameter LowerBoundValueParameter stores the result obtained from the source variable (from the simulation state) that will be used as a lower bound to the affected variable.\n\nObjective:\n\nThe slack variable is added to the objective function using its large default cost + p^textfflbsl cdot 10^6\n\nExpressions:\n\nNo changes on expressions.\n\nConstraints:\n\nSet the VariableType from the affected_values to be greater than the source parameter store in LowerBoundValueParameter.\n\nbeginalign*\n   textAffectedVariable_t + p_t^textfflbsl ge textSourceVariableParameter_t quad forall t in 1dots T\nendalign*","category":"section"},{"location":"formulation_library/Feedforward/#PowerSimulations.SemiContinuousFeedforward","page":"Feedforwards","title":"PowerSimulations.SemiContinuousFeedforward","text":"SemiContinuousFeedforward(\n    component_type::Type{<:PSY.Component},\n    source::Type{T},\n    affected_values::Vector{DataType},\n    meta = CONTAINER_KEY_EMPTY_META\n) where {T}\n\nIt allows to enable/disable bounds to 0.0 for a specified variable. Commonly used to limit the ActivePowerVariable in an Economic Dispatch problem by the commitment decision taken in an another problem (typically a Unit Commitment problem).\n\nArguments:\n\ncomponent_type::Type{<:PSY.Component} : Specify the type of component on which the Feedforward will be applied\nsource::Type{T} : Specify the VariableType, ParameterType or AuxVariableType as the source of values for the Feedforward\naffected_values::Vector{DataType} : Specify the variable on which the semicontinuous limit will be applied using the source values\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Feedforward/#PowerSimulations.FixValueFeedforward","page":"Feedforwards","title":"PowerSimulations.FixValueFeedforward","text":"FixValueFeedforward(\n    component_type::Type{<:PSY.Component},\n    source::Type{T},\n    affected_values::Vector{DataType},\n    meta = CONTAINER_KEY_EMPTY_META\n) where {T}\n\nFixes a Variable or Parameter Value in the model from another problem. Is the only Feed Forward that can be used with a Parameter or a Variable as the affected value.\n\nArguments:\n\ncomponent_type::Type{<:PSY.Component} : Specify the type of component on which the Feedforward will be applied\nsource::Type{T} : Specify the VariableType, ParameterType or AuxVariableType as the source of values for the Feedforward\naffected_values::Vector{DataType} : Specify the variable on which the fix value will be applied using the source values\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Feedforward/#PowerSimulations.UpperBoundFeedforward","page":"Feedforwards","title":"PowerSimulations.UpperBoundFeedforward","text":"UpperBoundFeedforward(\n    component_type::Type{<:PSY.Component},\n    source::Type{T},\n    affected_values::Vector{DataType},\n    add_slacks::Bool = false,\n    meta = CONTAINER_KEY_EMPTY_META\n) where {T}\n\nConstructs a parameterized upper bound constraint to implement feedforward from other models.\n\nArguments:\n\ncomponent_type::Type{<:PSY.Component} : Specify the type of component on which the Feedforward will be applied\nsource::Type{T} : Specify the VariableType, ParameterType or AuxVariableType as the source of values for the Feedforward\naffected_values::Vector{DataType} : Specify the variable on which the upper bound will be applied using the source values\nadd_slacks::Bool = false : Add slacks variables to relax the upper bound constraint.\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Feedforward/#PowerSimulations.LowerBoundFeedforward","page":"Feedforwards","title":"PowerSimulations.LowerBoundFeedforward","text":"LowerBoundFeedforward(\n    component_type::Type{<:PSY.Component},\n    source::Type{T},\n    affected_values::Vector{DataType},\n    add_slacks::Bool = false,\n    meta = CONTAINER_KEY_EMPTY_META\n) where {T}\n\nConstructs a parameterized lower bound constraint to implement feedforward from other models.\n\nArguments:\n\ncomponent_type::Type{<:PSY.Component} : Specify the type of component on which the Feedforward will be applied\nsource::Type{T} : Specify the VariableType, ParameterType or AuxVariableType as the source of values for the Feedforward\naffected_values::Vector{DataType} : Specify the variable on which the lower bound will be applied using the source values\nadd_slacks::Bool = false : Add slacks variables to relax the lower bound constraint.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/generated_decision_problem/#Running-a-Simple-Step-Problem","page":"Single-step Problem","title":"Running a Simple-Step Problem","text":"To follow along, you can download this tutorial as a Julia script (.jl) or Jupyter notebook (.ipynb).","category":"section"},{"location":"tutorials/generated_decision_problem/#Introduction","page":"Single-step Problem","title":"Introduction","text":"PowerSimulations.jl supports the construction and solution of optimal power system scheduling problems (Operations Problems). Operations problems form the fundamental building blocks for sequential simulations. This example shows how to specify and customize the mathematics that will be applied to the data with a ProblemTemplate, build and execute a DecisionModel, and access the results.\n\nusing PowerSystems\nusing PowerSimulations\nusing HydroPowerSimulations\nusing PowerSystemCaseBuilder\nusing HiGHS # solver\nusing Dates","category":"section"},{"location":"tutorials/generated_decision_problem/#Data","page":"Single-step Problem","title":"Data","text":"note: Note\nPowerSystemCaseBuilder.jl is a helper library that makes it easier to reproduce examples in the documentation and tutorials. Normally you would pass your local files to create the system data instead of calling the function build_system. For more details visit PowerSystemCaseBuilder Documentation\n\nsys = build_system(PSISystems, \"modified_RTS_GMLC_DA_sys\")","category":"section"},{"location":"tutorials/generated_decision_problem/#Define-a-problem-specification-with-a-ProblemTemplate","page":"Single-step Problem","title":"Define a problem specification with a ProblemTemplate","text":"You can create an empty template with:\n\ntemplate_uc = ProblemTemplate()\n\nNow, you can add a DeviceModel for each device type to create an assignment between PowerSystems device types and the subtypes of AbstractDeviceFormulation. PowerSimulations has a variety of different AbstractDeviceFormulation subtypes that can be applied to different PowerSystems device types, each dispatching to different methods for populating optimization problem objectives, variables, and constraints. Documentation on the formulation options for various devices can be found in the formulation library docs","category":"section"},{"location":"tutorials/generated_decision_problem/#Branch-Formulations","page":"Single-step Problem","title":"Branch Formulations","text":"Here is an example of relatively standard branch formulations. Other formulations allow for selective enforcement of transmission limits and greater control on transformer settings.\n\nset_device_model!(template_uc, Line, StaticBranch)\nset_device_model!(template_uc, Transformer2W, StaticBranch)\nset_device_model!(template_uc, TapTransformer, StaticBranch)","category":"section"},{"location":"tutorials/generated_decision_problem/#Injection-Device-Formulations","page":"Single-step Problem","title":"Injection Device Formulations","text":"Here we define template entries for all devices that inject or withdraw power on the network. For each device type, we can define a distinct AbstractDeviceFormulation. In this case, we're defining a basic unit commitment model for thermal generators, curtailable renewable generators, and fixed dispatch (net-load reduction) formulations for HydroDispatch and RenewableNonDispatch devices.\n\nset_device_model!(template_uc, ThermalStandard, ThermalStandardUnitCommitment)\nset_device_model!(template_uc, RenewableDispatch, RenewableFullDispatch)\nset_device_model!(template_uc, PowerLoad, StaticPowerLoad)\nset_device_model!(template_uc, HydroDispatch, HydroDispatchRunOfRiver)\nset_device_model!(template_uc, RenewableNonDispatch, FixedOutput)","category":"section"},{"location":"tutorials/generated_decision_problem/#Service-Formulations","page":"Single-step Problem","title":"Service Formulations","text":"We have two VariableReserve types, parameterized by their direction. So, similar to creating DeviceModels, we can create ServiceModels. The primary difference being that DeviceModel objects define how constraints get created, while ServiceModel objects define how constraints get modified.\n\nset_service_model!(template_uc, VariableReserve{ReserveUp}, RangeReserve)\nset_service_model!(template_uc, VariableReserve{ReserveDown}, RangeReserve)","category":"section"},{"location":"tutorials/generated_decision_problem/#Network-Formulations","page":"Single-step Problem","title":"Network Formulations","text":"Finally, we can define the transmission network specification that we'd like to model. For simplicity, we'll choose a copper plate formulation. But there are dozens of specifications available through an integration with PowerModels.jl.\n\nNote that many formulations will require appropriate data and may be computationally intractable\n\nset_network_model!(template_uc, NetworkModel(CopperPlatePowerModel))","category":"section"},{"location":"tutorials/generated_decision_problem/#DecisionModel","page":"Single-step Problem","title":"DecisionModel","text":"Now that we have a System and a ProblemTemplate, we can put the two together to create a DecisionModel that we solve.","category":"section"},{"location":"tutorials/generated_decision_problem/#Optimizer","page":"Single-step Problem","title":"Optimizer","text":"It's most convenient to define an optimizer instance upfront and pass it into the DecisionModel constructor. For this example, we can use the free HiGHS solver with a relatively relaxed MIP gap (ratioGap) setting to improve speed.\n\nsolver = optimizer_with_attributes(HiGHS.Optimizer, \"mip_rel_gap\" => 0.5)","category":"section"},{"location":"tutorials/generated_decision_problem/#Build-a-DecisionModel","page":"Single-step Problem","title":"Build a DecisionModel","text":"The construction of a DecisionModel essentially applies a ProblemTemplate to System data to create a JuMP model.\n\nproblem = DecisionModel(template_uc, sys; optimizer = solver, horizon = Hour(24))\nbuild!(problem; output_dir = mktempdir())\n\ntip: Tip\nThe principal component of the DecisionModel is the JuMP model. But you can serialize to a file using the following command:serialize_optimization_model(problem, save_path)Keep in mind that if the setting \"store_variable_names\" is set to False then the file won't show the model's names.","category":"section"},{"location":"tutorials/generated_decision_problem/#Solve-a-DecisionModel","page":"Single-step Problem","title":"Solve a DecisionModel","text":"solve!(problem)","category":"section"},{"location":"tutorials/generated_decision_problem/#Results-Inspection","page":"Single-step Problem","title":"Results Inspection","text":"PowerSimulations collects the DecisionModel results into a OptimizationProblemResults struct:\n\nres = OptimizationProblemResults(problem)","category":"section"},{"location":"tutorials/generated_decision_problem/#Optimizer-Stats","page":"Single-step Problem","title":"Optimizer Stats","text":"The optimizer summary is included\n\nget_optimizer_stats(res)","category":"section"},{"location":"tutorials/generated_decision_problem/#Objective-Function-Value","page":"Single-step Problem","title":"Objective Function Value","text":"get_objective_value(res)","category":"section"},{"location":"tutorials/generated_decision_problem/#Variable,-Parameter,-Auxiliary-Variable,-Dual,-and-Expression-Values","page":"Single-step Problem","title":"Variable, Parameter, Auxiliary Variable, Dual, and Expression Values","text":"The solution value data frames for variables, parameters, auxiliary variables, duals, and expressions can be accessed using the read_ methods:\n\nread_variables(res)\n\nOr, you can read a single parameter value for parameters that exist in the results.\n\nlist_parameter_names(res)\nread_parameter(res, \"ActivePowerTimeSeriesParameter__RenewableDispatch\")","category":"section"},{"location":"tutorials/generated_decision_problem/#Plotting","page":"Single-step Problem","title":"Plotting","text":"Take a look at the plotting capabilities in PowerGraphics.jl","category":"section"},{"location":"tutorials/generated_pcm_simulation/#Running-a-Multi-Stage-Production-Cost-Simulation","page":"Multi-stage Production Cost Simulation","title":"Running a Multi-Stage Production Cost Simulation","text":"To follow along, you can download this tutorial as a Julia script (.jl) or Jupyter notebook (.ipynb).","category":"section"},{"location":"tutorials/generated_pcm_simulation/#Introduction","page":"Multi-stage Production Cost Simulation","title":"Introduction","text":"PowerSimulations.jl supports simulations that consist of sequential optimization problems where results from previous problems inform subsequent problems in a variety of ways. This example demonstrates some of these capabilities to represent electricity market clearing. This example is intended to be an extension of the tutorial on Running a Simple-Step Problem.","category":"section"},{"location":"tutorials/generated_pcm_simulation/#Load-Packages","page":"Multi-stage Production Cost Simulation","title":"Load Packages","text":"using PowerSystems\nusing PowerSimulations\nusing HydroPowerSimulations\nimport PowerSimulations as PSI\nusing PowerSystemCaseBuilder\nusing Dates\nusing HiGHS #solver","category":"section"},{"location":"tutorials/generated_pcm_simulation/#Optimizer","page":"Multi-stage Production Cost Simulation","title":"Optimizer","text":"It's most convenient to define an optimizer instance upfront and pass it into the DecisionModel constructor. For this example, we can use the free HiGHS solver with a relatively relaxed MIP gap (ratioGap) setting to improve speed.\n\nsolver = optimizer_with_attributes(HiGHS.Optimizer, \"mip_rel_gap\" => 0.5)\n\nnote: Note\nDefining a solver upfront ensures that only one license is requested when using a license-limited solver, such as Gurobi. We can create a environment variable and pass it to the optimizer constructor for shared license use if using such a solverusing Gurobi\n\ngurobi_env = Gurobi.Env()\n\nsolver = optimizer_with_attributes(() -> Gurobi.Optimizer(gurobi_env),\"MIPGap\" => 0.01)Conversely, if a unique optimizer constructor is defined within the SimulationModels for each stage, a separate license will be obtained for each stage.","category":"section"},{"location":"tutorials/generated_pcm_simulation/#Hourly-day-ahead-system","page":"Multi-stage Production Cost Simulation","title":"Hourly day-ahead system","text":"First, we'll create a System with hourly data to represent day-ahead forecasted wind, solar, and load profiles:\n\nsys_DA = build_system(PSISystems, \"modified_RTS_GMLC_DA_sys\"; skip_serialization = true)","category":"section"},{"location":"tutorials/generated_pcm_simulation/#5-Minute-system","page":"Multi-stage Production Cost Simulation","title":"5-Minute system","text":"The RTS data also includes 5-minute resolution time series data. So, we can create another System to represent 15 minute ahead forecasted data for a \"real-time\" market:\n\nsys_RT = build_system(PSISystems, \"modified_RTS_GMLC_RT_sys\"; skip_serialization = true)","category":"section"},{"location":"tutorials/generated_pcm_simulation/#ProblemTemplates-define-stages","page":"Multi-stage Production Cost Simulation","title":"ProblemTemplates define stages","text":"Sequential simulations in PowerSimulations are created by defining OperationsProblems that represent stages, and how information flows between executions of a stage and between different stages.\n\nLet's start by defining a two stage simulation that might look like a typical day-Ahead and real-time electricity market clearing process.","category":"section"},{"location":"tutorials/generated_pcm_simulation/#Day-ahead-unit-commitment-stage","page":"Multi-stage Production Cost Simulation","title":"Day-ahead unit commitment stage","text":"First, we can define a unit commitment template for the day ahead problem. We can use the included UC template, but in this example, we'll replace the ThermalBasicUnitCommitment with the slightly more complex ThermalStandardUnitCommitment for the thermal generators.\n\ntemplate_uc = template_unit_commitment()\nset_device_model!(template_uc, ThermalStandard, ThermalStandardUnitCommitment)\nset_device_model!(template_uc, HydroDispatch, HydroDispatchRunOfRiver)","category":"section"},{"location":"tutorials/generated_pcm_simulation/#Define-the-reference-model-for-the-real-time-economic-dispatch","page":"Multi-stage Production Cost Simulation","title":"Define the reference model for the real-time economic dispatch","text":"In addition to the manual specification process demonstrated in the OperationsProblem example, PSI also provides pre-specified templates for some standard problems:\n\ntemplate_ed = template_economic_dispatch(;\n    network = NetworkModel(PTDFPowerModel; use_slacks = true),\n)","category":"section"},{"location":"tutorials/generated_pcm_simulation/#Define-the-SimulationModels","page":"Multi-stage Production Cost Simulation","title":"Define the SimulationModels","text":"DecisionModels define the problems that are executed in the simulation. The actual problem will change as the stage gets updated to represent different time periods, but the formulations applied to the components is constant within a stage. In this case, we want to define two stages with theProblemTemplates and theSystem`s that we've already created.\n\nmodels = SimulationModels(;\n    decision_models = [\n        DecisionModel(template_uc, sys_DA; optimizer = solver, name = \"UC\"),\n        DecisionModel(template_ed, sys_RT; optimizer = solver, name = \"ED\"),\n    ],\n)","category":"section"},{"location":"tutorials/generated_pcm_simulation/#SimulationSequence","page":"Multi-stage Production Cost Simulation","title":"SimulationSequence","text":"Similar to a ProblemTemplate, the SimulationSequence provides a template of how to execute a sequential set of operations problems.\n\nLet's review some of the SimulationSequence arguments.","category":"section"},{"location":"tutorials/generated_pcm_simulation/#Chronologies","page":"Multi-stage Production Cost Simulation","title":"Chronologies","text":"In PowerSimulations, chronologies define where information is flowing. There are two types of chronologies.\n\ninter-stage chronologies: Define how information flows between stages. e.g. day-ahead solutions are used to inform economic dispatch problems\nintra-stage chronologies: Define how information flows between multiple executions of a single stage. e.g. the dispatch setpoints of the first period of an economic dispatch problem are constrained by the ramping limits from setpoints in the final period of the previous problem.","category":"section"},{"location":"tutorials/generated_pcm_simulation/#FeedForward","page":"Multi-stage Production Cost Simulation","title":"FeedForward","text":"The definition of exactly what information is passed using the defined chronologies is accomplished with FeedForward. Specifically, FeedForward is used to define what to do with information being passed with an inter-stage chronology. Let's define a FeedForward that affects the semi-continuous range constraints of thermal generators in the economic dispatch problems based on the value of the unit-commitment variables.\n\nfeedforward = Dict(\n    \"ED\" => [\n        SemiContinuousFeedforward(;\n            component_type = ThermalStandard,\n            source = OnVariable,\n            affected_values = [ActivePowerVariable],\n        ),\n    ],\n)","category":"section"},{"location":"tutorials/generated_pcm_simulation/#Sequencing","page":"Multi-stage Production Cost Simulation","title":"Sequencing","text":"The stage problem length, look-ahead, and other details surrounding the temporal Sequencing of stages are controlled using the structure of the time series data in the Systems. So, to define a typical day-ahead - real-time sequence:\n\nDay ahead problems should represent 48 hours, advancing 24 hours after each execution (24-hour look-ahead)\nReal time problems should represent 1 hour (12 5-minute periods), advancing 15 min after each execution (15 min look-ahead)\n\nWe can adjust the time series data to reflect this structure in each System:\n\ntransform_single_time_series!(sys_DA, Hour(48), Hour(24))\ntransform_single_time_series!(sys_RT, Minute(60), Minute(15))\n\nNow we can put it all together to define a SimulationSequence\n\nDA_RT_sequence = SimulationSequence(;\n    models = models,\n    ini_cond_chronology = InterProblemChronology(),\n    feedforwards = feedforward,\n)","category":"section"},{"location":"tutorials/generated_pcm_simulation/#Simulation","page":"Multi-stage Production Cost Simulation","title":"Simulation","text":"Now, we can build and execute a simulation using the SimulationSequence and Stages that we've defined.\n\npath = mkdir(joinpath(\".\", \"rts-store\")) #hide\nsim = Simulation(;\n    name = \"rts-test\",\n    steps = 2,\n    models = models,\n    sequence = DA_RT_sequence,\n    simulation_folder = joinpath(\".\", \"rts-store\"),\n)","category":"section"},{"location":"tutorials/generated_pcm_simulation/#Build-simulation","page":"Multi-stage Production Cost Simulation","title":"Build simulation","text":"build!(sim)","category":"section"},{"location":"tutorials/generated_pcm_simulation/#Execute-simulation","page":"Multi-stage Production Cost Simulation","title":"Execute simulation","text":"the following command returns the status of the simulation (0: is proper execution) and stores the results in a set of HDF5 files on disk.\n\nexecute!(sim; enable_progress_bar = false)","category":"section"},{"location":"tutorials/generated_pcm_simulation/#Results","page":"Multi-stage Production Cost Simulation","title":"Results","text":"To access the results, we need to load the simulation result metadata and then make requests to the specific data of interest. This allows you to efficiently access the results of interest without overloading resources.\n\nresults = SimulationResults(sim);\nuc_results = get_decision_problem_results(results, \"UC\"); # UC stage result metadata\ned_results = get_decision_problem_results(results, \"ED\"); # ED stage result metadata\nnothing #hide\n\nWe can read all the result variables\n\nread_variables(uc_results)\n\nor all the parameters\n\nread_parameters(uc_results)\n\nWe can just list the variable names contained in uc_results:\n\nlist_variable_names(uc_results)\n\nand a number of parameters (this pattern also works for aux_variables, expressions, and duals)\n\nlist_parameter_names(uc_results)\n\nNow we can read the specific results of interest for a specific problem, time window (optional), and set of variables, duals, or parameters (optional)\n\nDict([\n    v => read_variable(uc_results, v) for v in [\n        \"ActivePowerVariable__RenewableDispatch\",\n        \"ActivePowerVariable__HydroDispatch\",\n        \"StopVariable__ThermalStandard\",\n    ]\n])\n\nOr if we want the result of just one variable, parameter, or dual (must be defined in the problem definition), we can use:\n\nread_parameter(\n    ed_results,\n    \"ActivePowerTimeSeriesParameter__RenewableNonDispatch\";\n    initial_time = DateTime(\"2020-01-01T06:00:00\"),\n    count = 5,\n)\n\ninfo: Info\n\n\nnote that this returns the results of each execution step in a separate dataframe If you want the realized results (without lookahead periods), you can call read_realized_*:\n\nread_realized_variables(\n    uc_results,\n    [\"ActivePowerVariable__ThermalStandard\", \"ActivePowerVariable__RenewableDispatch\"],\n)\nrm(path; force = true, recursive = true) #hide","category":"section"},{"location":"tutorials/generated_pcm_simulation/#Plotting","page":"Multi-stage Production Cost Simulation","title":"Plotting","text":"Take a look at the plotting capabilities in PowerGraphics.jl","category":"section"},{"location":"#PowerSimulations.jl","page":"Welcome Page","title":"PowerSimulations.jl","text":"","category":"section"},{"location":"#Overview","page":"Welcome Page","title":"Overview","text":"PowerSimulations.jl is a power system operations simulation tool developed as a flexible and open source software for quasi-static power systems simulations including Production Cost Models. PowerSimulations.jl tackles the issues of developing a simulation model in a modular way providing tools for the formulation of decision models and emulation models that can be solved independently or in an interconnected fashion.\n\nPowerSimulations.jl supports the workflows to develop simulations by separating the development of operations models and simulation models.\n\nOperation Models: Optimization model used to find the solution of an operation problem.\nSimulations Models: Defined the requirements to find solutions to a sequence of operation problems in a way that resembles the procedures followed by operators.\n\nThe most common Simulation Model is the solution of a Unit Commitment and Economic Dispatch sequence of problems. This model is used in commercial Production Cost Modeling tools, but it has a limited scope of analysis.\n\nPowerSimulations.jl is an active project under development, and we welcome your feedback, suggestions, and bug reports.","category":"section"},{"location":"#About-Sienna","page":"Welcome Page","title":"About Sienna","text":"PowerSimulations.jl is part of the National Renewable Energy Laboratory's Sienna ecosystem, an open source framework for power system modeling, simulation, and optimization. The Sienna ecosystem can be found on Github. It contains three applications:\n\nSienna\\Data enables efficient data input, analysis, and transformation\nSienna\\Ops enables enables system scheduling simulations by formulating and solving optimization problems\nSienna\\Dyn enables system transient analysis including small signal stability and full system dynamic simulations\n\nEach application uses multiple packages in the Julia programming language.","category":"section"},{"location":"#Installation-and-Quick-Links","page":"Welcome Page","title":"Installation and Quick Links","text":"Sienna installation page: Instructions to install PowerSimulations.jl and other Sienna\\Ops packages\nJuMP.jl solver's page: An appropriate optimization solver is required for running PowerSimulations.jl models. Refer to this page to select and install a solver for your application.\nSienna Documentation Hub: Links to other Sienna packages' documentation","category":"section"},{"location":"#How-To-Use-This-Documentation","page":"Welcome Page","title":"How To Use This Documentation","text":"There are five main sections containing different information:\n\nTutorials - Detailed walk-throughs to help you learn how to use PowerSimulations.jl\nHow to... - Directions to help guide your work for a particular task\nExplanation - Additional details and background information to help you understand PowerSimulations.jl, its structure, and how it works behind the scenes\nReference - Technical references and API for a quick look-up during your work\nFormulation Library - Technical reference for the variables, parameters, and\n\nequations that PowerSimulations.jl uses to define device behavior\n\nPowerSimulations.jl strives to follow the Diataxis documentation framework.","category":"section"},{"location":"formulation_library/Load/#PowerSystems.ElectricLoad-Formulations","page":"Load","title":"PowerSystems.ElectricLoad Formulations","text":"Electric load formulations define the optimization models that describe load units (demand) mathematical model in different operational settings, such as economic dispatch and unit commitment.\n\nnote: Note\nThe use of reactive power variables and constraints will depend on the network model used, i.e., whether it uses (or does not use) reactive power. If the network model is purely active power-based, reactive power variables and related constraints are not created.","category":"section"},{"location":"formulation_library/Load/#Table-of-contents","page":"Load","title":"Table of contents","text":"StaticPowerLoad\nPowerLoadInterruption\nPowerLoadDispatch\nValid configurations\n\n","category":"section"},{"location":"formulation_library/Load/#StaticPowerLoad","page":"Load","title":"StaticPowerLoad","text":"Variables:\n\nNo variables are created\n\nTime Series Parameters:\n\nUses the max_active_power  timeseries parameter to determine the demand value at each time-step\n\nusing PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.get_default_time_series_names(ElectricLoad, StaticPowerLoad)\ncombo_table = DataFrame(\n    \"Parameter\" => map(x -> \"[`$x`](@ref)\", collect(keys(combos))),\n    \"Default Time Series Name\" => map(x -> \"`$x`\", collect(values(combos))),\n)\nmdtable(combo_table; latex = false)\n\nExpressions:\n\nSubtracts the parameters listed above from the respective active and reactive power balance expressions created by the selected Network Formulations.\n\nConstraints:\n\nNo constraints are created\n\n","category":"section"},{"location":"formulation_library/Load/#PowerLoadInterruption","page":"Load","title":"PowerLoadInterruption","text":"Variables:\n\nActivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: 0.0\nSymbol: p^textld\nReactivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: 0.0\nSymbol: q^textld\nOnVariable:\nBounds: 01\nDefault initial value: 1\nSymbol: u^textld\n\nStatic Parameters:\n\nP^textldmax = PowerSystems.get_max_active_power(device)\nQ^textldmax = PowerSystems.get_max_reactive_power(device)\n\nTime Series Parameters:\n\nusing PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.get_default_time_series_names(ElectricLoad, PowerLoadInterruption)\ncombo_table = DataFrame(\n    \"Parameter\" => map(x -> \"[`$x`](@ref)\", collect(keys(combos))),\n    \"Default Time Series Name\" => map(x -> \"`$x`\", collect(values(combos))),\n)\nmdtable(combo_table; latex = false)\n\nObjective:\n\nCreates an objective function term based on the FunctionData Options where the quantity term is defined as p^textld.\n\nExpressions:\n\nSubtractp^textld and q^textld terms and to the respective active and reactive power balance expressions created by the selected Network Formulations\n\nConstraints:\n\nbeginaligned\n  p_t^textld le u_t^textld cdot textActivePowerTimeSeriesParameter_t quad forall t in 1dots T \n  q_t^textre = textpf cdot p_t^textre quad forall t in 1dots T\nendaligned\n\non which textpf = sin(arctan(Q^textldmaxP^textldmax)).\n\n","category":"section"},{"location":"formulation_library/Load/#PowerLoadDispatch","page":"Load","title":"PowerLoadDispatch","text":"Variables:\n\nActivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_active_power(device)\nSymbol: p^textld\nReactivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_reactive_power(device)\nSymbol: q^textld\n\nStatic Parameters:\n\nP^textldmax = PowerSystems.get_max_active_power(device)\nQ^textldmax = PowerSystems.get_max_reactive_power(device)\n\nTime Series Parameters:\n\nusing PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.get_default_time_series_names(ElectricLoad, PowerLoadDispatch)\ncombo_table = DataFrame(\n    \"Parameter\" => map(x -> \"[`$x`](@ref)\", collect(keys(combos))),\n    \"Default Time Series Name\" => map(x -> \"`$x`\", collect(values(combos))),\n)\nmdtable(combo_table; latex = false)\n\nObjective:\n\nCreates an objective function term based on the FunctionData Options where the quantity term is defined as p^textld.\n\nExpressions:\n\nSubtractp^textld and q^textld terms and to the respective active and reactive power balance expressions created by the selected Network Formulations\n\nConstraints:\n\nbeginaligned\n  p_t^textld le textActivePowerTimeSeriesParameter_t quad forall t in 1dots T\n  q_t^textld = textpf cdot p_t^textld quad forall t in 1dots T\nendaligned\n\non which textpf = sin(arctan(Q^textldmaxP^textldmax)).","category":"section"},{"location":"formulation_library/Load/#Valid-configurations","page":"Load","title":"Valid configurations","text":"Valid DeviceModels for subtypes of ElectricLoad include the following:\n\nusing PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.generate_device_formulation_combinations()\nfilter!(x -> x[\"device_type\"] <: ElectricLoad, combos)\ncombo_table = DataFrame(\n    \"Valid DeviceModel\" =>\n        [\"`DeviceModel($(c[\"device_type\"]), $(c[\"formulation\"]))`\" for c in combos],\n    \"Device Type\" => [\n        \"[$(c[\"device_type\"])](https://nrel-Sienna.github.io/PowerSystems.jl/stable/model_library/generated_$(c[\"device_type\"])/)\"\n        for c in combos\n    ],\n    \"Formulation\" => [\"[$(c[\"formulation\"])](@ref)\" for c in combos],\n)\nmdtable(combo_table; latex = false)","category":"section"},{"location":"formulation_library/Load/#PowerSimulations.StaticPowerLoad","page":"Load","title":"PowerSimulations.StaticPowerLoad","text":"Formulation type to add a time series parameter for non-dispatchable ElectricLoad withdrawals to power balance constraints\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Load/#PowerSimulations.PowerLoadInterruption","page":"Load","title":"PowerSimulations.PowerLoadInterruption","text":"Formulation type to enable (binary) load interruptions\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Load/#PowerSimulations.PowerLoadDispatch","page":"Load","title":"PowerSimulations.PowerLoadDispatch","text":"Formulation type to enable (continuous) load interruption dispatch\n\n\n\n\n\n","category":"type"},{"location":"code_base_developer_guide/extending_powersimulations/#Extending-Source-Code-Functionalities","page":"Extending Source Code Functionalities","title":"Extending Source Code Functionalities","text":"","category":"section"},{"location":"code_base_developer_guide/extending_powersimulations/#Enable-other-recorder-events","page":"Extending Source Code Functionalities","title":"Enable other recorder events","text":"Other types of recorder events can be enabled with a possible performance impact. To do this pass in the specific recorder names to be enabled when you call build.\n\nsim = Simulation(...)\nrecorders = [:execution]\nbuild!(sim; recorders = recorders)\nexecute!(sim)\n\nNow we can examine InitialConditionUpdateEvents for specific steps and stages.\n\nshow_simulation_events(\n    PSI.InitialConditionUpdateEvent,\n    \"./output/aggregation/1\",\n    x -> x.initial_condition_type == \"DeviceStatus\";\n    step = 2,\n    stage = 1\n)\n┌─────────────────────────────┬─────────────────────┬────────────────────────┬─────────────────┬─────────────┬─────┬──────────────┐\n│                        name │     simulation_time │ initial_condition_type │     device_type │ device_name │ val │ stage_number │\n├─────────────────────────────┼─────────────────────┼────────────────────────┼─────────────────┼─────────────┼─────┼──────────────┤\n│ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Solitude │ 0.0 │            1 │\n│ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │   Park City │ 1.0 │            1 │\n│ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │        Alta │ 1.0 │            1 │\n│ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Brighton │ 1.0 │            1 │\n│ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Sundance │ 0.0 │            1 │\n└─────────────────────────────┴─────────────────────┴────────────────────────┴─────────────────┴─────────────┴─────┴──────────────┘","category":"section"},{"location":"code_base_developer_guide/extending_powersimulations/#Show-the-wall-time-with-your-events","page":"Extending Source Code Functionalities","title":"Show the wall time with your events","text":"Sometimes you might want to see how the events line up with the wall time.\n\nshow_simulation_events(\n    PSI.InitialConditionUpdateEvent,\n    \"./output/aggregation/1\",\n    x -> x.initial_condition_type == \"DeviceStatus\";\n    step = 2,\n    stage = 1,\n    wall_time = true\n)\n┌─────────────────────────┬─────────────────────────────┬─────────────────────┬────────────────────────┬─────────────────┬─────────────┬─────┬──────────────┐\n│               timestamp │                        name │     simulation_time │ initial_condition_type │     device_type │ device_name │ val │ stage_number │\n├─────────────────────────┼─────────────────────────────┼─────────────────────┼────────────────────────┼─────────────────┼─────────────┼─────┼──────────────┤\n│ 2020-04-07T15:08:32.711 │ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Solitude │ 0.0 │            1 │\n│ 2020-04-07T15:08:32.711 │ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │   Park City │ 1.0 │            1 │\n│ 2020-04-07T15:08:32.711 │ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │        Alta │ 1.0 │            1 │\n│ 2020-04-07T15:08:32.711 │ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Brighton │ 1.0 │            1 │\n│ 2020-04-07T15:08:32.711 │ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Sundance │ 0.0 │            1 │\n└─────────────────────────┴─────────────────────────────┴─────────────────────┴────────────────────────┴─────────────────┴─────────────┴─────┴──────────────┘","category":"section"}]
}
