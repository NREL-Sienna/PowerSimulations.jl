var documenterSearchIndex = {"docs":
[{"location":"code_base_developer_guide/extending_powersimulations/#Extending-Source-Code-Functionalities","page":"Extending Source Code Functionalities","title":"Extending Source Code Functionalities","text":"","category":"section"},{"location":"code_base_developer_guide/extending_powersimulations/#Enable-other-recorder-events","page":"Extending Source Code Functionalities","title":"Enable other recorder events","text":"","category":"section"},{"location":"code_base_developer_guide/extending_powersimulations/","page":"Extending Source Code Functionalities","title":"Extending Source Code Functionalities","text":"Other types of recorder events can be enabled with a possible performance impact. To do this pass in the specific recorder names to be enabled when you call build.","category":"page"},{"location":"code_base_developer_guide/extending_powersimulations/","page":"Extending Source Code Functionalities","title":"Extending Source Code Functionalities","text":"sim = Simulation(...)\nrecorders = [:execution]\nbuild!(sim; recorders = recorders)\nexecute!(sim)","category":"page"},{"location":"code_base_developer_guide/extending_powersimulations/","page":"Extending Source Code Functionalities","title":"Extending Source Code Functionalities","text":"Now we can examine InitialConditionUpdateEvents for specific steps and stages.","category":"page"},{"location":"code_base_developer_guide/extending_powersimulations/","page":"Extending Source Code Functionalities","title":"Extending Source Code Functionalities","text":"show_simulation_events(\n    PSI.InitialConditionUpdateEvent,\n    \"./output/aggregation/1\",\n    x -> x.initial_condition_type == \"DeviceStatus\";\n    step = 2,\n    stage = 1\n)\n┌─────────────────────────────┬─────────────────────┬────────────────────────┬─────────────────┬─────────────┬─────┬──────────────┐\n│                        name │     simulation_time │ initial_condition_type │     device_type │ device_name │ val │ stage_number │\n├─────────────────────────────┼─────────────────────┼────────────────────────┼─────────────────┼─────────────┼─────┼──────────────┤\n│ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Solitude │ 0.0 │            1 │\n│ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │   Park City │ 1.0 │            1 │\n│ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │        Alta │ 1.0 │            1 │\n│ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Brighton │ 1.0 │            1 │\n│ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Sundance │ 0.0 │            1 │\n└─────────────────────────────┴─────────────────────┴────────────────────────┴─────────────────┴─────────────┴─────┴──────────────┘","category":"page"},{"location":"code_base_developer_guide/extending_powersimulations/#Show-the-wall-time-with-your-events","page":"Extending Source Code Functionalities","title":"Show the wall time with your events","text":"","category":"section"},{"location":"code_base_developer_guide/extending_powersimulations/","page":"Extending Source Code Functionalities","title":"Extending Source Code Functionalities","text":"Sometimes you might want to see how the events line up with the wall time.","category":"page"},{"location":"code_base_developer_guide/extending_powersimulations/","page":"Extending Source Code Functionalities","title":"Extending Source Code Functionalities","text":"show_simulation_events(\n    PSI.InitialConditionUpdateEvent,\n    \"./output/aggregation/1\",\n    x -> x.initial_condition_type == \"DeviceStatus\";\n    step = 2,\n    stage = 1,\n    wall_time = true\n)\n┌─────────────────────────┬─────────────────────────────┬─────────────────────┬────────────────────────┬─────────────────┬─────────────┬─────┬──────────────┐\n│               timestamp │                        name │     simulation_time │ initial_condition_type │     device_type │ device_name │ val │ stage_number │\n├─────────────────────────┼─────────────────────────────┼─────────────────────┼────────────────────────┼─────────────────┼─────────────┼─────┼──────────────┤\n│ 2020-04-07T15:08:32.711 │ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Solitude │ 0.0 │            1 │\n│ 2020-04-07T15:08:32.711 │ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │   Park City │ 1.0 │            1 │\n│ 2020-04-07T15:08:32.711 │ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │        Alta │ 1.0 │            1 │\n│ 2020-04-07T15:08:32.711 │ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Brighton │ 1.0 │            1 │\n│ 2020-04-07T15:08:32.711 │ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Sundance │ 0.0 │            1 │\n└─────────────────────────┴─────────────────────────────┴─────────────────────┴────────────────────────┴─────────────────┴─────────────┴─────┴──────────────┘","category":"page"},{"location":"modeler_guide/simulation_recorder/#Simulation-Recorder","page":"Simulation Recorder","title":"Simulation Recorder","text":"","category":"section"},{"location":"modeler_guide/simulation_recorder/","page":"Simulation Recorder","title":"Simulation Recorder","text":"PowerSimulations.jl provides the ability to record structured data as events during a simulation. These events can be post-processed to help debug problems.","category":"page"},{"location":"modeler_guide/simulation_recorder/","page":"Simulation Recorder","title":"Simulation Recorder","text":"By default only SimulationStepEvent and ProblemExecutionEvent are recorded.  Here is an example.","category":"page"},{"location":"modeler_guide/simulation_recorder/","page":"Simulation Recorder","title":"Simulation Recorder","text":"Suppose a simulation is run in the directory ./output.","category":"page"},{"location":"modeler_guide/simulation_recorder/","page":"Simulation Recorder","title":"Simulation Recorder","text":"Assume that setup commands have been run:","category":"page"},{"location":"modeler_guide/simulation_recorder/","page":"Simulation Recorder","title":"Simulation Recorder","text":"using PowerSimulations\nconst PSI = PowerSimulations","category":"page"},{"location":"modeler_guide/simulation_recorder/","page":"Simulation Recorder","title":"Simulation Recorder","text":"Note that for all functions below you can optionally specify a function to filter events. The function must accept the event type and return true or false.","category":"page"},{"location":"modeler_guide/simulation_recorder/#Show-all-events-of-type-PSI.SimulationStepEvent","page":"Simulation Recorder","title":"Show all events of type PSI.SimulationStepEvent","text":"","category":"section"},{"location":"modeler_guide/simulation_recorder/","page":"Simulation Recorder","title":"Simulation Recorder","text":"julia> show_simulation_events(PSI.SimulationStepEvent, \"./output/aggregation/1\")\n┌─────────────────────┬─────────────────────┬──────┬────────┐\n│                name │     simulation_time │ step │ status │\n├─────────────────────┼─────────────────────┼──────┼────────┤\n│ SimulationStepEvent │ 2024-01-01T00:00:00 │    1 │  start │\n│ SimulationStepEvent │ 2024-01-01T23:00:00 │    1 │   done │\n│ SimulationStepEvent │ 2024-01-01T23:00:00 │    2 │  start │\n│ SimulationStepEvent │ 2024-01-02T23:00:00 │    2 │   done │\n└─────────────────────┴─────────────────────┴──────┴────────┘","category":"page"},{"location":"modeler_guide/simulation_recorder/#Show-events-of-type-PSI.ProblemExecutionEvent-for-a-specific-step-and-stage.","page":"Simulation Recorder","title":"Show events of type PSI.ProblemExecutionEvent for a specific step and stage.","text":"","category":"section"},{"location":"modeler_guide/simulation_recorder/","page":"Simulation Recorder","title":"Simulation Recorder","text":"show_simulation_events(\n    PSI.ProblemExecutionEvent,\n    \"./output/aggregation/1\",\n    x -> x.step == 1 && x.stage == 2 && x.status == \"start\"\n)\n┌──────────────────────┬─────────────────────┬──────┬───────┬────────┐\n│                 name │     simulation_time │ step │ stage │ status │\n├──────────────────────┼─────────────────────┼──────┼───────┼────────┤\n│ ProblemExecutionEvent │ 2024-01-01T00:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T00:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T01:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T02:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T03:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T04:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T05:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T06:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T07:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T08:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T09:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T10:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T11:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T12:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T13:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T14:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T15:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T16:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T17:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T18:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T19:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T20:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T21:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T22:00:00 │    1 │     2 │  start │\n└──────────────────────┴─────────────────────┴──────┴───────┴────────┘","category":"page"},{"location":"modeler_guide/parallel_simulations/#Parallel-Simulations","page":"Parallel Simulations","title":"Parallel Simulations","text":"","category":"section"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"This section contains instructions to:","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Run a Simulation in Parallel on a local computer\nRun a Simulation in Parallel on an HPC","category":"page"},{"location":"modeler_guide/parallel_simulations/#Run-a-Simulation-in-Parallel-on-a-local-computer","page":"Parallel Simulations","title":"Run a Simulation in Parallel on a local computer","text":"","category":"section"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"This page describes how to split a simulation into partitions, run each partition in parallel, and then join the results.","category":"page"},{"location":"modeler_guide/parallel_simulations/#Setup","page":"Parallel Simulations","title":"Setup","text":"","category":"section"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Create a Julia script to build and run simulations. It must meet the requirements below. A full example is in the PowerSimulations repository in test/run_partitioned_simulation.jl.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Call using PowerSimulations.\nImplement a build function that matches the signature below. It must construct a Simulation, call build!, and then return the Simulation instance. It must throw an exception if the build fails.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"function build_simulation(\n    output_dir::AbstractString,\n    simulation_name::AbstractString,\n    partitions::SimulationPartitions,\n    index::Union{Nothing, Integer}=nothing,\n)","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Here is example code to construct the Simulation with these parameters:","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"    sim = Simulation(\n        name=simulation_name,\n        steps=partitions.num_steps,\n        models=models,\n        sequence=sequence,\n        simulation_folder=output_dir,\n    )\n    status = build!(sim; partitions=partitions, index=index, serialize=isnothing(index))\n    if status != PSI.BuildStatus.BUILT\n        error(\"Failed to build simulation: status=$status\")\n    end","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Implement an execute function that matches the signature below. It must throw an exception if the execute fails.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"function execute_simulation(sim, args...; kwargs...)\n    status = execute!(sim)\n    if status != PSI.RunStatus.SUCCESSFUL\n        error(\"Simulation failed to execute: status=$status\")\n    end\nend","category":"page"},{"location":"modeler_guide/parallel_simulations/#Execution","page":"Parallel Simulations","title":"Execution","text":"","category":"section"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"After loading your script, call the function run_parallel_simulation as shown below.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"This example splits a year-long simulation into weekly partitions for a total of 53 individual jobs and then runs them four at a time.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"julia> include(\"my_simulation.jl\")\njulia> run_parallel_simulation(\n        build_simulation,\n        execute_simulation,\n        script=\"my_simulation.jl\",\n        output_dir=\"my_simulation_output\",\n        name=\"my_simulation\",\n        num_steps=365,\n        period=7,\n        num_overlap_steps=1,\n        num_parallel_processes=4,\n        exeflags=\"--project=<path-to-your-julia-environment>\",\n    )","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"The final results will be in ./my_simulation_otuput/my_simulation","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Note the log files and results for each partition are located in ./my_simulation_otuput/my_simulation/simulation_partitions","category":"page"},{"location":"modeler_guide/parallel_simulations/#Run-a-Simulation-in-Parallel-on-an-HPC","page":"Parallel Simulations","title":"Run a Simulation in Parallel on an HPC","text":"","category":"section"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"This page describes how to split a simulation into partitions, run each partition in parallel on HPC compute nodes, and then join the results.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"These steps can be used on a local computer or any HPC supported by the submission software. Some steps may be specific to NREL's HPC Eagle cluster.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Note: Some instructions are preliminary and will change if functionality is moved to a new Julia package.","category":"page"},{"location":"modeler_guide/parallel_simulations/#Setup-2","page":"Parallel Simulations","title":"Setup","text":"","category":"section"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Create a conda environment and install the Python package NREL-jade: https://nrel.github.io/jade/installation.html. The rest of this page assumes that the environment is called jade.\nActivate the environment with conda activate jade.\nLocate the path to that conda environment. It will likely be ~/.conda-envs/jade or ~/.conda/envs/jade.\nLoad the Julia environment that you use to run simulations. Add the packages Conda and PyCall.\nSetup Conda to use the existing jade environment by running these commands:","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"julia> run(`conda create -n conda_jl python conda`)\njulia> ENV[\"CONDA_JL_HOME\"] = joinpath(ENV[\"HOME\"], \".conda-envs\", \"jade\")  # change this to your path\npkg> build Conda","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Copy the code below into a Julia file called configure_parallel_simulation.jl. This is an interface to Jade through PyCall. It will be used to create a Jade configuration. (It may eventually be moved to a separate package.)","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"function configure_parallel_simulation(\n    script::AbstractString,\n    num_steps::Integer,\n    num_period_steps::Integer;\n    num_overlap_steps::Integer=0,\n    project_path=nothing,\n    simulation_name=\"simulation\",\n    config_file=\"config.json\",\n    force=false,\n)\n    partitions = SimulationPartitions(num_steps, num_period_steps, num_overlap_steps)\n    jgc = pyimport(\"jade.extensions.generic_command\")\n    julia_cmd = isnothing(project_path) ? \"julia\" : \"julia --project=$project_path\"\n    setup_command = \"$julia_cmd $script setup --simulation-name=$simulation_name \" *\n    \"--num-steps=$num_steps --num-period-steps=$num_period_steps \" *\n    \"--num-overlap-steps=$num_overlap_steps\"\n    teardown_command = \"$julia_cmd $script join --simulation-name=$simulation_name\"\n    config = jgc.GenericCommandConfiguration(\n        setup_command=setup_command,\n        teardown_command=teardown_command,\n    )\n\n    for i in 1:get_num_partitions(partitions)\n        cmd = \"$julia_cmd $script execute --simulation-name=$simulation_name --index=$i\"\n        job = jgc.GenericCommandParameters(command=cmd, name=\"execute-$i\")\n        config.add_job(job)\n    end\n\n    config.dump(config_file, indent=2)\n    println(\"Created Jade configuration in $config_file. \" *\n            \"Run 'jade submit-jobs [options] $config_file' to execute them.\")\nend","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Create a Julia script to build and run simulations. It must meet the requirements below. A full example is in the PowerSimulations repository in test/run_partitioned_simulation.jl.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Call using PowerSimulations.\nImplement a build function that matches the signature below. It must construct a Simulation, call build!, and then return the Simulation instance. It must throw an exception if the build fails.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"function build_simulation(\n    output_dir::AbstractString,\n    simulation_name::AbstractString,\n    partitions::SimulationPartitions,\n    index::Union{Nothing, Integer}=nothing,\n)","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Here is example code to construct the Simulation with these parameters:","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"    sim = Simulation(\n        name=simulation_name,\n        steps=partitions.num_steps,\n        models=models,\n        sequence=sequence,\n        simulation_folder=output_dir,\n    )\n    status = build!(sim; partitions=partitions, index=index, serialize=isnothing(index))\n    if status != PSI.BuildStatus.BUILT\n        error(\"Failed to build simulation: status=$status\")\n    end","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Implement an execute function that matches the signature below. It must throw an exception if the execute fails.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"function execute_simulation(sim, args...; kwargs...)\n    status = execute!(sim)\n    if status != PSI.RunStatus.SUCCESSFUL\n        error(\"Simulation failed to execute: status=$status\")\n    end\nend","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Make the script runnable as a CLI command by including the following code at the bottom of the","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"file.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"function main()\n    process_simulation_partition_cli_args(build_simulation, execute_simulation, ARGS...)\nend\n\nif abspath(PROGRAM_FILE) == @__FILE__\n    main()\nend","category":"page"},{"location":"modeler_guide/parallel_simulations/#Execution-2","page":"Parallel Simulations","title":"Execution","text":"","category":"section"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Create a Jade configuration that defines the partitioned simulation jobs. Load your Julia environment.\nThis example splits a year-long simulation into weekly partitions for a total of 53 individual jobs.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"julia> include(\"configure_parallel_simulation.jl\")\njulia> num_steps = 365\njulia> period = 7\njulia> num_overlap_steps = 1\njulia> configure_parallel_simulation(\n    \"my_simulation.jl\",  # this is your build/execute script\n    num_steps,\n    period,\n    num_overlap_steps=1,\n    project_path=\".\",  # This optionally specifies the Julia project environment to load.\n)\nCreated Jade configuration in config.json. Run 'jade submit-jobs [options] config.json' to execute them.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Exit Julia.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"View the configuration for accuracy.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"$ jade config show config.json","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Start an interactive session on a debug node. Do not submit the jobs on a login node! The submission step will run a full build of the simulation and that may consume too many CPU and memory resources for the login node.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"$ salloc -t 01:00:00 -N1 --account=<your-account> --partition=debug","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Follow the instructions at https://nrel.github.io/jade/tutorial.html to submit the jobs. The example below will configure Jade to run each partition on its own compute node. Depending on the compute and memory constraints of your simulation, you may be able to pack more jobs on each node.\nAdjust the walltime as necessary.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"$ jade config hpc -c hpc_config.toml -t slurm  --walltime=04:00:00 -a <your-account>\n$ jade submit-jobs config.json --per-node-batch-size=1 -o output","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"If you are unsure about how much memory and CPU resources your simulation consumes, add these options:","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"$ jade submit-jobs config.json --per-node-batch-size=1 -o output --resource-monitor-type periodic --resource-monitor-interval 3","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Jade will create HTML plots of the resource utilization in output/stats. You may be able to customize --per-node-batch-size and --num-processes to finish the simulations more quickly.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Jade will run a final command to join the simulation partitions into one unified file. You can load the results as you normally would.","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"julia> results = SimulationResults(\"<output-dir>/job-outputs/<simulation-name>\")","category":"page"},{"location":"modeler_guide/parallel_simulations/","page":"Parallel Simulations","title":"Parallel Simulations","text":"Note the log files and results for each partition are located in <output-dir>/job-outputs/<simulation-name>/simulation_partitions","category":"page"},{"location":"quick_start_guide/#Quick-Start-Guide","page":"Quick Start Guide","title":"Quick Start Guide","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Julia: If this is your first time using Julia visit our Introduction to Julia and the official Getting started with Julia.\nPackage Installation: If you want to install packages check the Package Manager instructions, or you can refer to the PowerSimulations installation instructions.\nPowerSystems: PowerSystems.jl manages the data and is a fundamental dependency of PowerSimulations.jl. Check the PowerSystems.jl Basics Tutorial and PowerSystems.jl documentation to understand how the inputs to the models are organized.\nDataset Library: If you don't have a data set to start using PowerSimulations.jl check the test systems provided in PowerSystemCaseBuilder.jl","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"tip: Tip\nIf you need to develop a dataset for a simulation check the PowerSystems.jl Tutorials on how to parse data and attach time series","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Tutorial: If you are eager to run your first simulation visit the Solve a Day Ahead Market Scheduling Problem using PowerSimulations.jl tutorial","category":"page"},{"location":"code_base_developer_guide/troubleshooting/#Troubleshooting-code-development","page":"Troubleshooting","title":"Troubleshooting code development","text":"","category":"section"},{"location":"tutorials/decision_problem/#op_problem_tutorial","page":"Single-step Problem","title":"Operations problems with PowerSimulations.jl","text":"","category":"section"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"Originally Contributed by: Clayton Barrows","category":"page"},{"location":"tutorials/decision_problem/#Introduction","page":"Single-step Problem","title":"Introduction","text":"","category":"section"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"PowerSimulations.jl supports the construction and solution of optimal power system scheduling problems (Operations Problems). Operations problems form the fundamental building blocks for sequential simulations. This example shows how to specify and customize a the mathematics that will be applied to the data with an ProblemTemplate, build and execute an DecisionModel, and access the results.","category":"page"},{"location":"tutorials/decision_problem/#Load-Packages","page":"Single-step Problem","title":"Load Packages","text":"","category":"section"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"using PowerSystems\nusing PowerSimulations\nusing PowerSystemCaseBuilder\nusing HiGHS # solver","category":"page"},{"location":"tutorials/decision_problem/#Data","page":"Single-step Problem","title":"Data","text":"","category":"section"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"note: Note\nPowerSystemCaseBuilder.jl is a helper library that makes it easier to reproduce examples in the documentation and tutorials. Normally you would pass your local files to create the system data instead of calling the function build_system. For more details visit PowerSystemCaseBuilder Documentation","category":"page"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"sys = build_system(PSISystems, \"modified_RTS_GMLC_DA_sys\")","category":"page"},{"location":"tutorials/decision_problem/#Define-a-problem-specification-with-an-ProblemTemplate","page":"Single-step Problem","title":"Define a problem specification with an ProblemTemplate","text":"","category":"section"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"You can create an empty template with:","category":"page"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"template_uc = ProblemTemplate()","category":"page"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"Now, you can add a DeviceModel for each device type to create an assignment between PowerSystems device types and the subtypes of AbstractDeviceFormulation. PowerSimulations has a variety of different AbstractDeviceFormulation subtypes that can be applied to different PowerSystems device types, each dispatching to different methods for populating optimization problem objectives, variables, and constraints. Documentation on the formulation options for various devices can be found in the formulation library docs","category":"page"},{"location":"tutorials/decision_problem/#Branch-Formulations","page":"Single-step Problem","title":"Branch Formulations","text":"","category":"section"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"Here is an example of relatively standard branch formulations. Other formulations allow for selective enforcement of transmission limits and greater control on transformer settings.","category":"page"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"set_device_model!(template_uc, Line, StaticBranch)\nset_device_model!(template_uc, Transformer2W, StaticBranch)\nset_device_model!(template_uc, TapTransformer, StaticBranch)","category":"page"},{"location":"tutorials/decision_problem/#Injection-Device-Formulations","page":"Single-step Problem","title":"Injection Device Formulations","text":"","category":"section"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"Here we define template entries for all devices that inject or withdraw power on the network. For each device type, we can define a distinct AbstractDeviceFormulation. In this case, we're defining a basic unit commitment model for thermal generators, curtailable renewable generators, and fixed dispatch (net-load reduction) formulations for HydroDispatch and RenewableFix devices.","category":"page"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"set_device_model!(template_uc, ThermalStandard, ThermalStandardUnitCommitment)\nset_device_model!(template_uc, RenewableDispatch, RenewableFullDispatch)\nset_device_model!(template_uc, PowerLoad, StaticPowerLoad)\nset_device_model!(template_uc, HydroDispatch, FixedOutput)\nset_device_model!(template_uc, HydroDispatchRunOfRiver, HydroDispatchRunOfRiver)\nset_device_model!(template_uc, RenewableFix, FixedOutput)","category":"page"},{"location":"tutorials/decision_problem/#Service-Formulations","page":"Single-step Problem","title":"Service Formulations","text":"","category":"section"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"We have two VariableReserve types, parameterized by their direction. So, similar to creating DeviceModels, we can create ServiceModels. The primary difference being that DeviceModel objects define how constraints get created, while ServiceModel objects define how constraints get modified.","category":"page"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"set_service_model!(template_uc, VariableReserve{ReserveUp}, RangeReserve)\nset_service_model!(template_uc, VariableReserve{ReserveDown}, RangeReserve)","category":"page"},{"location":"tutorials/decision_problem/#Network-Formulations","page":"Single-step Problem","title":"Network Formulations","text":"","category":"section"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"Finally, we can define the transmission network specification that we'd like to model. For simplicity, we'll choose a copper plate formulation. But there are dozens of specifications available through an integration with PowerModels.jl. Note that many formulations will require appropriate data and may be computationally intractable","category":"page"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"set_network_model!(template_uc, NetworkModel(CopperPlatePowerModel))","category":"page"},{"location":"tutorials/decision_problem/#DecisionModel","page":"Single-step Problem","title":"DecisionModel","text":"","category":"section"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"Now that we have a System and an ProblemTemplate, we can put the two together to create an DecisionModel that we solve.","category":"page"},{"location":"tutorials/decision_problem/#Optimizer","page":"Single-step Problem","title":"Optimizer","text":"","category":"section"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"It's most convenient to define an optimizer instance upfront and pass it into the DecisionModel constructor. For this example, we can use the free HiGHS solver with a relatively relaxed MIP gap (ratioGap) setting to improve speed.","category":"page"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"solver = optimizer_with_attributes(HiGHS.Optimizer, \"mip_rel_gap\" => 0.5)","category":"page"},{"location":"tutorials/decision_problem/#Build-an-DecisionModel","page":"Single-step Problem","title":"Build an DecisionModel","text":"","category":"section"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"The construction of an DecisionModel essentially applies an ProblemTemplate to System data to create a JuMP model.","category":"page"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"problem = DecisionModel(template_uc, sys; optimizer = solver, horizon = 24)\nbuild!(problem, output_dir = mktempdir())","category":"page"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"tip: Tip\nThe principal component of the DecisionModel is the JuMP model. But you can serialize to a file using the following command:    serialize_optimization_model(problem, save_path)Keep in mind that if the setting \"storevariablenames\" is set to False then the file won't show the model's names.","category":"page"},{"location":"tutorials/decision_problem/#Solve-an-DecisionModel","page":"Single-step Problem","title":"Solve an DecisionModel","text":"","category":"section"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"solve!(problem)","category":"page"},{"location":"tutorials/decision_problem/#Results-Inspection","page":"Single-step Problem","title":"Results Inspection","text":"","category":"section"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"PowerSimulations collects the DecisionModel results into a ProblemResults struct:","category":"page"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"res = ProblemResults(problem)","category":"page"},{"location":"tutorials/decision_problem/#Optimizer-Stats","page":"Single-step Problem","title":"Optimizer Stats","text":"","category":"section"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"The optimizer summary is included","category":"page"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"get_optimizer_stats(res)","category":"page"},{"location":"tutorials/decision_problem/#Objective-Function-Value","page":"Single-step Problem","title":"Objective Function Value","text":"","category":"section"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"get_objective_value(res)","category":"page"},{"location":"tutorials/decision_problem/#Variable,-Parameter,-Auxillary-Variable,-Dual,-and-Expression-Values","page":"Single-step Problem","title":"Variable, Parameter, Auxillary Variable, Dual, and Expression Values","text":"","category":"section"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"The solution value data frames for variables, parameters, auxillary variables, duals and expressions can be accessed using the read_ methods:","category":"page"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"read_variables(res)","category":"page"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"Or, you can read a single parameter values for parameters that exist in the results.","category":"page"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"list_parameter_names(res)\nread_parameter(res, \"ActivePowerTimeSeriesParameter__RenewableDispatch\")","category":"page"},{"location":"tutorials/decision_problem/#Plotting","page":"Single-step Problem","title":"Plotting","text":"","category":"section"},{"location":"tutorials/decision_problem/","page":"Single-step Problem","title":"Single-step Problem","text":"Take a look at the plotting capabilities in PowerGraphics.jl","category":"page"},{"location":"modeler_guide/tips_and_tricks/#Tips-and-tricks","page":"Tips and tricks","title":"Tips and tricks","text":"","category":"section"},{"location":"formulation_library/ThermalGen/#ThermalGen-Formulations","page":"Thermal Generation","title":"ThermalGen Formulations","text":"","category":"section"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"Valid DeviceModels for subtypes of ThermalGen include the following:","category":"page"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"using PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.generate_device_formulation_combinations()\nfilter!(x -> x[\"device_type\"] <: ThermalGen, combos)\ncombo_table = DataFrame(\n    \"Valid DeviceModel\" => [\"`DeviceModel($(c[\"device_type\"]), $(c[\"formulation\"]))`\" for c in combos],\n    \"Device Type\" => [\"[$(c[\"device_type\"])](https://nrel-Sienna.github.io/PowerSystems.jl/stable/model_library/generated_$(c[\"device_type\"])/)\" for c in combos],\n    \"Formulation\" => [\"[$(c[\"formulation\"])](@ref)\" for c in combos],\n    )\nmdtable(combo_table, latex = false)","category":"page"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"","category":"page"},{"location":"formulation_library/ThermalGen/#ThermalBasicDispatch","page":"Thermal Generation","title":"ThermalBasicDispatch","text":"","category":"section"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"ThermalBasicDispatch","category":"page"},{"location":"formulation_library/ThermalGen/#PowerSimulations.ThermalBasicDispatch","page":"Thermal Generation","title":"PowerSimulations.ThermalBasicDispatch","text":"Formulation type to enable basic dispatch without any intertemporal (ramp) constraints\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"TODO","category":"page"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"","category":"page"},{"location":"formulation_library/ThermalGen/#ThermalCompactDispatch","page":"Thermal Generation","title":"ThermalCompactDispatch","text":"","category":"section"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"ThermalCompactDispatch","category":"page"},{"location":"formulation_library/ThermalGen/#PowerSimulations.ThermalCompactDispatch","page":"Thermal Generation","title":"PowerSimulations.ThermalCompactDispatch","text":"Formulation type to enable thermal compact dispatch\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"TODO","category":"page"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"","category":"page"},{"location":"formulation_library/ThermalGen/#ThermalDispatchNoMin","page":"Thermal Generation","title":"ThermalDispatchNoMin","text":"","category":"section"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"ThermalDispatchNoMin","category":"page"},{"location":"formulation_library/ThermalGen/#PowerSimulations.ThermalDispatchNoMin","page":"Thermal Generation","title":"PowerSimulations.ThermalDispatchNoMin","text":"Formulation type to enable basic dispatch without any intertemporal constraints and relaxed minimum generation. may not work with PWL cost definitions\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"TODO","category":"page"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"","category":"page"},{"location":"formulation_library/ThermalGen/#ThermalStandardDispatch","page":"Thermal Generation","title":"ThermalStandardDispatch","text":"","category":"section"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"ThermalStandardDispatch","category":"page"},{"location":"formulation_library/ThermalGen/#PowerSimulations.ThermalStandardDispatch","page":"Thermal Generation","title":"PowerSimulations.ThermalStandardDispatch","text":"Formulation type to enable standard dispatch with a range and enforce intertemporal ramp constraints\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"TODO","category":"page"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"","category":"page"},{"location":"formulation_library/ThermalGen/#ThermalBasicCompactUnitCommitment","page":"Thermal Generation","title":"ThermalBasicCompactUnitCommitment","text":"","category":"section"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"ThermalBasicCompactUnitCommitment","category":"page"},{"location":"formulation_library/ThermalGen/#PowerSimulations.ThermalBasicCompactUnitCommitment","page":"Thermal Generation","title":"PowerSimulations.ThermalBasicCompactUnitCommitment","text":"Formulation type to enable thermal compact commitment without intertemporal (ramp, min on/off time) constraints\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"TODO","category":"page"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"","category":"page"},{"location":"formulation_library/ThermalGen/#ThermalCompactUnitCommitment","page":"Thermal Generation","title":"ThermalCompactUnitCommitment","text":"","category":"section"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"ThermalCompactUnitCommitment","category":"page"},{"location":"formulation_library/ThermalGen/#PowerSimulations.ThermalCompactUnitCommitment","page":"Thermal Generation","title":"PowerSimulations.ThermalCompactUnitCommitment","text":"Formulation type to enable thermal compact commitment\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"TODO","category":"page"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"","category":"page"},{"location":"formulation_library/ThermalGen/#ThermalMultiStartUnitCommitment","page":"Thermal Generation","title":"ThermalMultiStartUnitCommitment","text":"","category":"section"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"ThermalMultiStartUnitCommitment","category":"page"},{"location":"formulation_library/ThermalGen/#PowerSimulations.ThermalMultiStartUnitCommitment","page":"Thermal Generation","title":"PowerSimulations.ThermalMultiStartUnitCommitment","text":"Formulation type to enable pg-lib commitment formulation with startup/shutdown profiles\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"TODO","category":"page"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"","category":"page"},{"location":"formulation_library/ThermalGen/#ThermalBasicUnitCommitment","page":"Thermal Generation","title":"ThermalBasicUnitCommitment","text":"","category":"section"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"ThermalBasicUnitCommitment","category":"page"},{"location":"formulation_library/ThermalGen/#PowerSimulations.ThermalBasicUnitCommitment","page":"Thermal Generation","title":"PowerSimulations.ThermalBasicUnitCommitment","text":"Formulation type to enable basic unit commitment representation without any intertemporal (ramp, min on/off time) constraints\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"TODO","category":"page"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"","category":"page"},{"location":"formulation_library/ThermalGen/#ThermalStandardUnitCommitment","page":"Thermal Generation","title":"ThermalStandardUnitCommitment","text":"","category":"section"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"ThermalStandardUnitCommitment","category":"page"},{"location":"formulation_library/ThermalGen/#PowerSimulations.ThermalStandardUnitCommitment","page":"Thermal Generation","title":"PowerSimulations.ThermalStandardUnitCommitment","text":"Formulation type to enable standard unit commitment with intertemporal constraints and simplified startup profiles\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"TODO","category":"page"},{"location":"formulation_library/ThermalGen/","page":"Thermal Generation","title":"Thermal Generation","text":"","category":"page"},{"location":"tutorials/adding_new_problem_model/#Adding-an-Operations-Problem-Model","page":"Adding an Operations Problem Model","title":"Adding an Operations Problem Model","text":"","category":"section"},{"location":"tutorials/adding_new_problem_model/","page":"Adding an Operations Problem Model","title":"Adding an Operations Problem Model","text":"This tutorial will show how to create a custom decision problem model. These cases are the ones where the user want to solve a fully specified problem. Some examples of custom decision models include:","category":"page"},{"location":"tutorials/adding_new_problem_model/","page":"Adding an Operations Problem Model","title":"Adding an Operations Problem Model","text":"Solving a custom Security Constrained Unit Commitment Problem\nSolving a market agent utility maximization Problem. See examples of this functionality in HybridSystemsSimulations.jl","category":"page"},{"location":"tutorials/adding_new_problem_model/","page":"Adding an Operations Problem Model","title":"Adding an Operations Problem Model","text":"The tutorial follows the usual steps for operational model building. First, build the decision model in isolation and second, integrate it into a simulation. In most cases there will be more than one way of achieving the same objective when it comes to implementing the model. This guide shows a general set of steps and requirements but it is by no means an exhaustive and detailed guide on developing custom decision models.","category":"page"},{"location":"tutorials/adding_new_problem_model/","page":"Adding an Operations Problem Model","title":"Adding an Operations Problem Model","text":"warning: Warning\nAll the code in this tutorial is considered \"pseudo-code\". Copy-paste will likely not work out of the box. You need to develop the internals of the functions correctly for the examples below to work.","category":"page"},{"location":"tutorials/adding_new_problem_model/#General-Rules","page":"Adding an Operations Problem Model","title":"General Rules","text":"","category":"section"},{"location":"tutorials/adding_new_problem_model/","page":"Adding an Operations Problem Model","title":"Adding an Operations Problem Model","text":"As a general rule you need to understand Julia's terminology such as multiple dispatch, parametric structs and method overloading, among others. Developing custom models for an operational simulation is a highly technical task and requires skilled development. This tutorial also requires good understanding of PowerSystems.jl data structures and features which are covered in the tutorials section of PowerSystems.jl documentation.","category":"page"},{"location":"tutorials/adding_new_problem_model/","page":"Adding an Operations Problem Model","title":"Adding an Operations Problem Model","text":"Finally, developing a custom model decision model that will employ an optimization model under the hood requires understanding JuMP.jl.","category":"page"},{"location":"tutorials/adding_new_problem_model/","page":"Adding an Operations Problem Model","title":"Adding an Operations Problem Model","text":"Need to employ anonymous constraints and variables in JuMP","category":"page"},{"location":"tutorials/adding_new_problem_model/","page":"Adding an Operations Problem Model","title":"Adding an Operations Problem Model","text":"and register the constraints, variables and other optimization objects into PowerSimulations.jl's optimization container. Otherwise the features to use your problem in the simulation like the coordination with other problems and post processing won't work. More on this in the section How to develop your build_model! function below.","category":"page"},{"location":"tutorials/adding_new_problem_model/","page":"Adding an Operations Problem Model","title":"Adding an Operations Problem Model","text":"Implement the required methods for your custom decision models. In some cases it will be possible to re-use some of the other methods that exist in PowerSimulations to make life easier for variable addition and constraint creation but this is not required.","category":"page"},{"location":"tutorials/adding_new_problem_model/#Decision-Problem","page":"Adding an Operations Problem Model","title":"Decision Problem","text":"","category":"section"},{"location":"tutorials/adding_new_problem_model/#Step-1:-Define-a-Custom-Decision-Problem","page":"Adding an Operations Problem Model","title":"Step 1: Define a Custom Decision Problem","text":"","category":"section"},{"location":"tutorials/adding_new_problem_model/","page":"Adding an Operations Problem Model","title":"Adding an Operations Problem Model","text":"Define a decision problem struct as a subtype of PowerSimulations.DecisionProblem. This requirement will enable a lot of the underlying functionality that relies on multiple dispatch. DecisionProblems are used to parameterize the behavior of DecisionModel objects which are just containers for the parameters, references and the optimization problem.","category":"page"},{"location":"tutorials/adding_new_problem_model/","page":"Adding an Operations Problem Model","title":"Adding an Operations Problem Model","text":"It is possible to define a Custom Decision Problem that gives the user full control over the build, solve and execution process since it imposes less requirements on the developer. However, with less requirements there are also less checks and validations performed inside of PowerSimulations which might lead to unexpected errors","category":"page"},{"location":"tutorials/adding_new_problem_model/","page":"Adding an Operations Problem Model","title":"Adding an Operations Problem Model","text":"struct MyCustomDecisionProblem <: PSI.DecisionProblem end","category":"page"},{"location":"tutorials/adding_new_problem_model/","page":"Adding an Operations Problem Model","title":"Adding an Operations Problem Model","text":"Alternatively, it is possible to define a Custom Decision Problem subtyping from DefaultDecisionProblem which imposes more requirements and structure onto the developer but employs more checks and validations in the process. Be aware that this route will decrease the flexibility of what can be done inside the custom model.","category":"page"},{"location":"tutorials/adding_new_problem_model/","page":"Adding an Operations Problem Model","title":"Adding an Operations Problem Model","text":"struct MyCustomDecisionProblem <: PSI.DefaultDecisionProblem end","category":"page"},{"location":"tutorials/adding_new_problem_model/","page":"Adding an Operations Problem Model","title":"Adding an Operations Problem Model","text":"Once the problem type is defined, initialize the decision model container with your custom decision problem passing the solver and some of the settings you need for the solution of the problem. For custom problems some of the settings need manual implementation by the developer. Settings availability is also dependent on wether  you choose to subtype from PSI.DecisionProblem or PSI.DefaultDecisionProblem","category":"page"},{"location":"tutorials/adding_new_problem_model/","page":"Adding an Operations Problem Model","title":"Adding an Operations Problem Model","text":"my_model = DecisionModel{MyCustomDecisionProblem}(\n    sys;\n    name = \"MyModel\",\n    optimizer = optimizer_with_attributes(HiGHS.Optimizer),\n     optimizer_solve_log_print = true,\n)","category":"page"},{"location":"tutorials/adding_new_problem_model/#Mandatory-Method-Implementations","page":"Adding an Operations Problem Model","title":"Mandatory Method Implementations","text":"","category":"section"},{"location":"tutorials/adding_new_problem_model/","page":"Adding an Operations Problem Model","title":"Adding an Operations Problem Model","text":"build_model!: This method build the JuMP optimization model.","category":"page"},{"location":"tutorials/adding_new_problem_model/#Optional-Method-Overloads","page":"Adding an Operations Problem Model","title":"Optional Method Overloads","text":"","category":"section"},{"location":"tutorials/adding_new_problem_model/","page":"Adding an Operations Problem Model","title":"Adding an Operations Problem Model","text":"These methods can be defined optionally for your problem. By default for problems subtyped from DecisionProblem these checks are not executed. If the problems are subtyped from DefaultDecisionProblem these checks are always conducted with PowerSimulations defaults and require compliance with those defaults to pass. In any case, these can be overloaded when necessary depending on the problem requirements.","category":"page"},{"location":"tutorials/adding_new_problem_model/","page":"Adding an Operations Problem Model","title":"Adding an Operations Problem Model","text":"validate_template\nvalidate_time_series\nreset!\nsolve_impl!","category":"page"},{"location":"tutorials/adding_new_problem_model/#How-to-develop-your-build_model!-function","page":"Adding an Operations Problem Model","title":"How to develop your build_model! function","text":"","category":"section"},{"location":"tutorials/adding_new_problem_model/#Registering-a-variable-in-the-model","page":"Adding an Operations Problem Model","title":"Registering a variable in the model","text":"","category":"section"},{"location":"tutorials/adding_new_problem_model/","page":"Adding an Operations Problem Model","title":"Adding an Operations Problem Model","text":"To register a variable in the model, the developer must first allocate the container into the optimization container and then populate it. For example, it require start the build function as follows:","category":"page"},{"location":"tutorials/adding_new_problem_model/","page":"Adding an Operations Problem Model","title":"Adding an Operations Problem Model","text":"info: Info\nWe recommend calling import PowerSimulations and defining the constant CONST PSI = PowerSimulations to make it easier to read the code and determine which package is responsible for defining the functions.","category":"page"},{"location":"tutorials/adding_new_problem_model/","page":"Adding an Operations Problem Model","title":"Adding an Operations Problem Model","text":"    function PSI.build_model!(model::PSI.DecisionModel{MyCustomDecisionProblem})\n        container = PSI.get_optimization_container(model)\n        time_steps = 1:24\n        PSI.set_time_steps!(container, time_steps)\n        system = PSI.get_system(model)\n\n        thermal_gens = PSY.get_components(PSY.ThermalStandard, system)\n        thermal_gens_names = PSY.get_name.(thermal_gens)\n\n        # Create the container for the variable\n        variable = PSI.add_variable_container!(\n            container,\n            PSI.ActivePowerVariable(), # <- This variable is defined in PowerSimulations but the user can define their own\n            PSY.ThermalGeneration, # <- Device type for the variable. Can be from PSY or custom defined\n            thermal_gens_names, # <- First container dimension\n            time_steps, # <- Second container dimension\n        )\n\n        # Iterate over the devices and time to store the JuMP variables into the container.\n        for t in time_steps, d in thermal_gens_names\n            name = PSY.get_name(d)\n            variable[name, t] = JuMP.@variable(get_jump_model(container))\n            # It is possible to use PSY getter functions to retrieve data from the generators\n            JuMP.set_upper_bound(variable[name, t], UB_DATA) # <- Optional\n            JuMP.set_lower_bound(variable[name, t], LB_DATA) # <- Optional\n        end\n\n        # Add More Variables.....\n\n        return\n    end","category":"page"},{"location":"tutorials/adding_new_problem_model/#Registering-a-constraint-in-the-model","page":"Adding an Operations Problem Model","title":"Registering a constraint in the model","text":"","category":"section"},{"location":"tutorials/adding_new_problem_model/","page":"Adding an Operations Problem Model","title":"Adding an Operations Problem Model","text":"A similar pattern is used to add constraints to the model, in this example the field meta is used to avoid creating unnecessary duplicate constraint types. For instance to reflect upperbound and lowerbound or upwards and downwards constraints. Meta can take any string value except for the _ character.","category":"page"},{"location":"tutorials/adding_new_problem_model/","page":"Adding an Operations Problem Model","title":"Adding an Operations Problem Model","text":"    function PSI.build_model!(model::PSI.DecisionModel{MyCustomDecisionProblem})\n        container = PSI.get_optimization_container(model)\n        time_steps = 1:24\n        PSI.set_time_steps!(container, time_steps)\n        system = PSI.get_system(model)\n\n        # VARIABLE ADDITION CODE\n\n        # Constraint additions\n        con_ub = PSI.add_constraints_container!(\n            container,\n            PSI.RangeLimitConstraint(), # <- Constraint Type defined by PSI or your own\n            PSY.ThermalGeneration, # <- Device type for variable. Can be PSY or custom\n            thermal_gens_names, # <- First container dimension\n            time_steps; # <- Second container dimension\n            meta = \"ub\" # <- meta allows to reuse a constraint definition for similar constraints. It only requires to be a string\n            )\n\n        con_lb = PSI.add_constraints_container!(\n            container,\n            PSI.RangeLimitConstraint(),\n            PSY.ThermalGeneration,\n            thermal_gens_names, # <- First container dimension\n            time_steps; # <- Second container dimension\n            meta = \"lb\" # <- meta allows to reuse a constraint definition for similar constraints. It only requires to be a string\n            )\n\n        # Retrieve a relevant variable from the container if not defined in\n        variable = PSI.get_variable(container, PSI.ActivePowerVariable(), PSY.ThermalGeneration)\n        for device in devices, t in time_steps\n            ci_name = PSY.get_name(device)\n            limits = get_min_max_limits(device) # depends on constraint type and formulation type\n            con_ub[ci_name, t] =\n                JuMP.@constraint(get_jump_model(container), variable[ci_name, t] >= limits.min)\n            con_lb[ci_name, t] =\n                JuMP.@constraint(get_jump_model(container), variable[ci_name, t] >= limits.min)\n        end\n\n        return\n    end","category":"page"},{"location":"formulation_library/Branch/#PowerSystems.Branch-Formulations","page":"Branch","title":"PowerSystems.Branch Formulations","text":"","category":"section"},{"location":"formulation_library/Branch/","page":"Branch","title":"Branch","text":"Valid DeviceModels for subtypes of Branch include the following:","category":"page"},{"location":"formulation_library/Branch/","page":"Branch","title":"Branch","text":"using PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.generate_device_formulation_combinations()\nfilter!(x -> x[\"device_type\"] <: Branch, combos)\ncombo_table = DataFrame(\n    \"Valid DeviceModel\" => [\"`DeviceModel($(c[\"device_type\"]), $(c[\"formulation\"]))`\" for c in combos],\n    \"Device Type\" => [\"[$(c[\"device_type\"])](https://nrel-Sienna.github.io/PowerSystems.jl/stable/model_library/generated_$(c[\"device_type\"])/)\" for c in combos],\n    \"Formulation\" => [\"[$(c[\"formulation\"])](@ref)\" for c in combos],\n    )\nmdtable(combo_table, latex = false)","category":"page"},{"location":"formulation_library/Branch/","page":"Branch","title":"Branch","text":"","category":"page"},{"location":"formulation_library/Branch/#StaticBranch","page":"Branch","title":"StaticBranch","text":"","category":"section"},{"location":"formulation_library/Branch/","page":"Branch","title":"Branch","text":"StaticBranch","category":"page"},{"location":"formulation_library/Branch/#PowerSimulations.StaticBranch","page":"Branch","title":"PowerSimulations.StaticBranch","text":"Branch type to add unbounded flow variables and use flow constraints\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Branch/","page":"Branch","title":"Branch","text":"","category":"page"},{"location":"formulation_library/Branch/#StaticBranchBounds","page":"Branch","title":"StaticBranchBounds","text":"","category":"section"},{"location":"formulation_library/Branch/","page":"Branch","title":"Branch","text":"StaticBranchBounds","category":"page"},{"location":"formulation_library/Branch/#PowerSimulations.StaticBranchBounds","page":"Branch","title":"PowerSimulations.StaticBranchBounds","text":"Branch type to add bounded flow variables and use flow constraints\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Branch/","page":"Branch","title":"Branch","text":"","category":"page"},{"location":"formulation_library/Branch/#StaticBranchUnbounded","page":"Branch","title":"StaticBranchUnbounded","text":"","category":"section"},{"location":"formulation_library/Branch/","page":"Branch","title":"Branch","text":"StaticBranchUnbounded","category":"page"},{"location":"formulation_library/Branch/#PowerSimulations.StaticBranchUnbounded","page":"Branch","title":"PowerSimulations.StaticBranchUnbounded","text":"Branch type to avoid flow constraints\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Branch/","page":"Branch","title":"Branch","text":"","category":"page"},{"location":"formulation_library/Branch/#HVDCTwoTerminalLossless","page":"Branch","title":"HVDCTwoTerminalLossless","text":"","category":"section"},{"location":"formulation_library/Branch/","page":"Branch","title":"Branch","text":"HVDCTwoTerminalLossless","category":"page"},{"location":"formulation_library/Branch/#PowerSimulations.HVDCTwoTerminalLossless","page":"Branch","title":"PowerSimulations.HVDCTwoTerminalLossless","text":"Branch type to represent lossless power flow on DC lines\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Branch/","page":"Branch","title":"Branch","text":"","category":"page"},{"location":"formulation_library/Branch/#HVDCTwoTerminalDispatch","page":"Branch","title":"HVDCTwoTerminalDispatch","text":"","category":"section"},{"location":"formulation_library/Branch/","page":"Branch","title":"Branch","text":"HVDCTwoTerminalDispatch","category":"page"},{"location":"formulation_library/Branch/#PowerSimulations.HVDCTwoTerminalDispatch","page":"Branch","title":"PowerSimulations.HVDCTwoTerminalDispatch","text":"Branch type to represent lossy power flow on DC lines\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Branch/","page":"Branch","title":"Branch","text":"","category":"page"},{"location":"formulation_library/Branch/#HVDCTwoTerminalUnbounded","page":"Branch","title":"HVDCTwoTerminalUnbounded","text":"","category":"section"},{"location":"formulation_library/Branch/","page":"Branch","title":"Branch","text":"HVDCTwoTerminalUnbounded","category":"page"},{"location":"formulation_library/Branch/#PowerSimulations.HVDCTwoTerminalUnbounded","page":"Branch","title":"PowerSimulations.HVDCTwoTerminalUnbounded","text":"Branch type to avoid flow constraints\n\n\n\n\n\n","category":"type"},{"location":"modeler_guide/problem_templates/#op_problem_template","page":"Operations ProblemTemplates","title":"Operations ProblemTemplates","text":"","category":"section"},{"location":"modeler_guide/problem_templates/","page":"Operations ProblemTemplates","title":"Operations ProblemTemplates","text":"Templates are used to specify the modeling properties of the devices and network that are going to he used to specify a problem. A ProblemTemplate is just a collection of DeviceModels that allows the user to specify the formulations of each set of devices (by device type) independently so that the modeler can adjust the level of detail according to the question of interest and the available data. For more information about valid DeviceModels and their mathematical representations, check out the Formulation Library.","category":"page"},{"location":"modeler_guide/problem_templates/#Building-a-ProblemTemplate","page":"Operations ProblemTemplates","title":"Building a ProblemTemplate","text":"","category":"section"},{"location":"modeler_guide/problem_templates/","page":"Operations ProblemTemplates","title":"Operations ProblemTemplates","text":"You can build a ProblemTemplate by adding a NetworkModel, DeviceModels, and ServiceModels.","category":"page"},{"location":"modeler_guide/problem_templates/","page":"Operations ProblemTemplates","title":"Operations ProblemTemplates","text":"template = ProblemTemplate()\nset_network_model!(template, NetworkModel(CopperPlatePowerModel))\nset_device_model!(template, PowerLoad, StaticPowerLoad)\nset_device_model!(template, ThermalStandard, ThermalBasicUnitCommitment)\nset_service_model!(template, VariableReserve{ReserveUp}, RangeReserve)","category":"page"},{"location":"modeler_guide/problem_templates/#Default-Templates","page":"Operations ProblemTemplates","title":"Default Templates","text":"","category":"section"},{"location":"modeler_guide/problem_templates/","page":"Operations ProblemTemplates","title":"Operations ProblemTemplates","text":"PowerSimulations.jl provides default templates for common operation problems. You can retrieve a default template and modify it according to your requirements. Currently supported default templates are:","category":"page"},{"location":"modeler_guide/problem_templates/","page":"Operations ProblemTemplates","title":"Operations ProblemTemplates","text":"template_economic_dispatch","category":"page"},{"location":"modeler_guide/problem_templates/#PowerSimulations.template_economic_dispatch","page":"Operations ProblemTemplates","title":"PowerSimulations.template_economic_dispatch","text":"template_economic_dispatch(; kwargs...) -> ProblemTemplate\n\n\ntemplate_economic_dispatch(; kwargs...)\n\nCreates a ProblemTemplate with default DeviceModels for an Economic Dispatch problem.\n\nExample\n\ntemplate = templateeconomicdispatch()\n\n\n# Accepted Key Words\n- `network::Type{<:PM.AbstractPowerModel}` : override default network model settings\n- `devices::Vector{DeviceModel}` : override default `DeviceModel` settings\n- `services::Vector{ServiceModel}` : override default `ServiceModel` settings\n\n\n\n\n\n","category":"function"},{"location":"modeler_guide/problem_templates/","page":"Operations ProblemTemplates","title":"Operations ProblemTemplates","text":"using PowerSimulations #hide\ntemplate_economic_dispatch()","category":"page"},{"location":"modeler_guide/problem_templates/","page":"Operations ProblemTemplates","title":"Operations ProblemTemplates","text":"template_unit_commitment","category":"page"},{"location":"modeler_guide/problem_templates/#PowerSimulations.template_unit_commitment","page":"Operations ProblemTemplates","title":"PowerSimulations.template_unit_commitment","text":"template_unit_commitment(; kwargs...) -> ProblemTemplate\n\n\ntemplate_unit_commitment(; kwargs...)\n\nCreates a ProblemTemplate with default DeviceModels for a Unit Commitment problem.\n\nExample\n\ntemplate = templateunitcommitment()\n\n\n# Accepted Key Words\n- `network::Type{<:PM.AbstractPowerModel}` : override default network model settings\n- `devices::Vector{DeviceModel}` : override default `DeviceModel` settings\n- `services::Vector{ServiceModel}` : override default `ServiceModel` settings\n\n\n\n\n\n","category":"function"},{"location":"modeler_guide/problem_templates/","page":"Operations ProblemTemplates","title":"Operations ProblemTemplates","text":"using PowerSimulations #hide\ntemplate_unit_commitment()","category":"page"},{"location":"modeler_guide/problem_templates/","page":"Operations ProblemTemplates","title":"Operations ProblemTemplates","text":"template_agc_reserve_deployment","category":"page"},{"location":"modeler_guide/problem_templates/#PowerSimulations.template_agc_reserve_deployment","page":"Operations ProblemTemplates","title":"PowerSimulations.template_agc_reserve_deployment","text":"template_agc_reserve_deployment(; kwargs...)\n\n\ntemplate_agc_reserve_deployment(; kwargs...)\n\nCreates a ProblemTemplate with default DeviceModels for an AGC Reserve Deployment Problem. This model doesn't support customization\n\nExample\n\ntemplate = agcreservedeployment()\n\n\n\n\n\n","category":"function"},{"location":"modeler_guide/problem_templates/","page":"Operations ProblemTemplates","title":"Operations ProblemTemplates","text":"using PowerSimulations #hide\ntemplate_agc_reserve_deployment()","category":"page"},{"location":"code_base_developer_guide/developer/#Guidelines-for-Developers","page":"Developer Guide","title":"Guidelines for Developers","text":"","category":"section"},{"location":"code_base_developer_guide/developer/","page":"Developer Guide","title":"Developer Guide","text":"In order to contribute to PowerSystems.jl repository please read the following sections of InfrastructureSystems.jl documentation in detail:","category":"page"},{"location":"code_base_developer_guide/developer/","page":"Developer Guide","title":"Developer Guide","text":"Style Guide\nContributing Guidelines","category":"page"},{"location":"code_base_developer_guide/developer/","page":"Developer Guide","title":"Developer Guide","text":"Pull requests are always welcome to fix bugs or add additional modeling capabilities.","category":"page"},{"location":"code_base_developer_guide/developer/","page":"Developer Guide","title":"Developer Guide","text":"All the code contributions need to include tests with a minimum coverage of 70%","category":"page"},{"location":"modeler_guide/modeling_faq/#Modeling-FAQ","page":"Modeling FAQ","title":"Modeling FAQ","text":"","category":"section"},{"location":"modeler_guide/modeling_faq/","page":"Modeling FAQ","title":"Modeling FAQ","text":"question: How do I reduce the amount of print on my REPL?\nThe print to the REPL is controlled with the logging. Check the Logging documentation page to see how to reduce the print out","category":"page"},{"location":"modeler_guide/modeling_faq/","page":"Modeling FAQ","title":"Modeling FAQ","text":"question: How do I print the optimizer logs to see the solution process?\nWhen specifying the DecisionModel or EmulationModel pass the keyword print_optimizer_log = true","category":"page"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"CurrentModule = PowerSimulations\nDocTestSetup  = quote\n    using PowerSimulations\nend","category":"page"},{"location":"api/PowerSimulations/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/PowerSimulations/#Table-of-Contents","page":"API Reference","title":"Table of Contents","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"Device Models\nDecision Models\nEmulation Models\nService Models\nSimulation Models\nVariables\nConstraints\nParameters","category":"page"},{"location":"api/PowerSimulations/#Device-Models","page":"API Reference","title":"Device Models","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"List of structures and methods for Device models","category":"page"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"DeviceModel","category":"page"},{"location":"api/PowerSimulations/#PowerSimulations.DeviceModel","page":"API Reference","title":"PowerSimulations.DeviceModel","text":"DeviceModel(\n    ::Type{D},\n    ::Type{B},\n    feedforwards::Vector{<:AbstractAffectFeedforward}\n    use_slacks::Bool,\n    duals::Vector{DataType},\n    services::Vector{ServiceModel}\n    attributes::Dict{String, Any}\n)\n\nEstablishes the model for a particular device specified by type. Uses the keyword argument feedforward to enable passing values between operation model at simulation time\n\nArguments\n\n::Type{D} where D<:PSY.Device: Power System Device Type\n::Type{B} where B<:AbstractDeviceFormulation: Abstract Device Formulation\nfeedforward::Array{<:AbstractAffectFeedforward} = Vector{AbstractAffectFeedforward}() : use to pass parameters between models\nuse_slacks::Bool = false : Add slacks to the device model. Implementation is model dependent and not all models feature slacks\nduals::Vector{DataType} = Vector{DataType}(): use to pass constraint type to calculate the duals. The DataType needs to be a valid ConstraintType\ntime_series_names::Dict{Type{<:TimeSeriesParameter}, String} = get_default_time_series_names(D, B) : use to specify time series names associated to the device`\nattributes::Dict{String, Any} = get_default_attributes(D, B) : use to specify attributes to the device\n\nExample\n\nthermal_gens = DeviceModel(ThermalStandard, ThermalBasicUnitCommitment)\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#Formulations","page":"API Reference","title":"Formulations","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"Refer to the Formulations Page for each Abstract Device Formulation.","category":"page"},{"location":"api/PowerSimulations/#Problem-Templates","page":"API Reference","title":"Problem Templates","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"Refer to the Problem Templates Page for available ProblemTemplates.","category":"page"},{"location":"api/PowerSimulations/#Problem-Templates-2","page":"API Reference","title":"Problem Templates","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"Refer to the Problem Templates Page for available ProblemTemplates.","category":"page"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"&nbsp;\n&nbsp;","category":"page"},{"location":"api/PowerSimulations/#Service-Models","page":"API Reference","title":"Service Models","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"List of structures and methods for Service models","category":"page"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"ServiceModel","category":"page"},{"location":"api/PowerSimulations/#PowerSimulations.ServiceModel","page":"API Reference","title":"PowerSimulations.ServiceModel","text":"Establishes the model for a particular services specified by type. Uses the keyword argument use_service_name to assign the model to a service with the same name as the name in the template. Uses the keyword argument feedforward to enable passing values between operation model at simulation time\n\nArguments\n\n-::Type{D}: Power System Service Type -::Type{B}: Abstract Service Formulation\n\nAccepted Key Words\n\nfeedforward::Array{<:AbstractAffectFeedforward} : use to pass parameters between models\nuse_service_name::Bool : use the name as the name for the service\n\nExample\n\nreserves = ServiceModel(PSY.VariableReserve{PSY.ReserveUp}, RangeReserve)\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#Decision-Models","page":"API Reference","title":"Decision Models","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"DecisionModel\nDecisionModel(::Type{M} where {M <: DecisionProblem}, ::ProblemTemplate, ::PSY.System, ::Union{Nothing, JuMP.Model})\nDecisionModel(::AbstractString, ::MOI.OptimizerWithAttributes)\nbuild!(::DecisionModel)\nsolve!(::DecisionModel)","category":"page"},{"location":"api/PowerSimulations/#PowerSimulations.DecisionModel","page":"API Reference","title":"PowerSimulations.DecisionModel","text":"DecisionModel{M}(\n    template::ProblemTemplate,\n    sys::PSY.System,\n    jump_model::Union{Nothing, JuMP.Model}=nothing;\n    kwargs...) where {M<:DecisionProblem}\n\nBuild the optimization problem of type M with the specific system and template.\n\nArguments\n\n::Type{M} where M<:DecisionProblem: The abstract operation model type\ntemplate::ProblemTemplate: The model reference made up of transmission, devices, branches, and services.\nsys::PSY.System: the system created using Power Systems\njump_model::Union{Nothing, JuMP.Model}: Enables passing a custom JuMP model. Use with care\nname = nothing: name of model, string or symbol; defaults to the type of template converted to a symbol.\noptimizer::Union{Nothing,MOI.OptimizerWithAttributes} = nothing : The optimizer does not get serialized. Callers should pass whatever they passed to the original problem.\nhorizon::Int = UNSET_HORIZON: Manually specify the length of the forecast Horizon\nwarm_start::Bool = true: True will use the current operation point in the system to initialize variable values. False initializes all variables to zero. Default is true\nsystem_to_file::Bool = true:: True to create a copy of the system used in the model.\ninitialize_model::Bool = true: Option to decide to initialize the model or not.\ninitialization_file::String = \"\": This allows to pass pre-existing initialization values to avoid the solution of an optimization problem to find feasible initial conditions.\ndeserialize_initial_conditions::Bool = false: Option to deserialize conditions\nexport_pwl_vars::Bool = false: True to export all the pwl intermediate variables. It can slow down significantly the build and solve time.\nallow_fails::Bool = false: True to allow the simulation to continue even if the optimization step fails. Use with care.\noptimizer_solve_log_print::Bool = false: Uses JuMP.unset_silent() to print the optimizer's log. By default all solvers are set to MOI.Silent()\ndetailed_optimizer_stats::Bool = false: True to save detailed optimizer stats log.\ncalculate_conflict::Bool = false: True to use solver to calculate conflicts for infeasible problems. Only specific solvers are able to calculate conflicts.\ndirect_mode_optimizer::Bool = false: True to use the solver in direct mode. Creates a JuMP.direct_model.\nstore_variable_names::Bool = false: to store variable names in optimization model. Decreases the build times.\nrebuild_model::Bool = false: It will force the rebuild of the underlying JuMP model with each call to update the model. It increases solution times, use only if the model can't be updated in memory.\ninitial_time::Dates.DateTime = UNSET_INI_TIME: Initial Time for the model solve.\ntime_series_cache_size::Int = IS.TIME_SERIES_CACHE_SIZE_BYTES: Size in bytes to cache for each time array. Default is 1 MiB. Set to 0 to disable.\n\nExample\n\ntemplate = ProblemTemplate(CopperPlatePowerModel, devices, branches, services)\nOpModel = DecisionModel(MockOperationProblem, template, system)\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.DecisionModel-Tuple{Type{M} where M<:PowerSimulations.DecisionProblem, ProblemTemplate, System, Union{Nothing, JuMP.Model}}","page":"API Reference","title":"PowerSimulations.DecisionModel","text":"DecisionModel(\n    ::Type{M<:PowerSimulations.DecisionProblem},\n    template::ProblemTemplate,\n    sys::System\n) -> DecisionModel\nDecisionModel(\n    ::Type{M<:PowerSimulations.DecisionProblem},\n    template::ProblemTemplate,\n    sys::System,\n    jump_model::Union{Nothing, JuMP.Model};\n    kwargs...\n) -> DecisionModel\n\n\nBuild the optimization problem of type M with the specific system and template\n\nArguments\n\n::Type{M} where M<:DecisionProblem: The abstract operation model type\ntemplate::ProblemTemplate: The model reference made up of transmission, devices, branches, and services.\nsys::PSY.System: the system created using Power Systems\njump_model::Union{Nothing, JuMP.Model} = nothing: Enables passing a custom JuMP model. Use with care.\n\nExample\n\ntemplate = ProblemTemplate(CopperPlatePowerModel, devices, branches, services)\nproblem = DecisionModel(MyOpProblemType, template, system, optimizer)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.DecisionModel-Tuple{AbstractString, MathOptInterface.OptimizerWithAttributes}","page":"API Reference","title":"PowerSimulations.DecisionModel","text":"DecisionModel(\n    directory::AbstractString,\n    optimizer::MathOptInterface.OptimizerWithAttributes;\n    jump_model,\n    system\n) -> Any\n\n\nConstruct an DecisionProblem from a serialized file.\n\nArguments\n\ndirectory::AbstractString: Directory containing a serialized model\njump_model::Union{Nothing, JuMP.Model} = nothing: The JuMP model does not get serialized. Callers should pass whatever they passed to the original problem.\noptimizer::Union{Nothing,MOI.OptimizerWithAttributes} = nothing: The optimizer does not get serialized. Callers should pass whatever they passed to the original problem.\nsystem::Union{Nothing, PSY.System}: Optionally, the system used for the model. If nothing and systofile was set to true when the model was created, the system will be deserialized from a file.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.build!-Tuple{DecisionModel}","page":"API Reference","title":"PowerSimulations.build!","text":"build!(\n    model::DecisionModel;\n    output_dir,\n    recorders,\n    console_level,\n    file_level,\n    disable_timer_outputs\n)\n\n\nBuild the Decision Model based on the specified DecisionProblem.\n\nArguments\n\nmodel::DecisionModel{<:DecisionProblem}: DecisionModel object\noutput_dir::String: Output directory for results\nrecorders::Vector{Symbol} = []: recorder names to register\nconsole_level = Logging.Error:\nfile_level = Logging.Info:\ndisable_timer_outputs = false : Enable/Disable timing outputs\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.solve!-Tuple{DecisionModel}","page":"API Reference","title":"PowerSimulations.solve!","text":"solve!(\n    model::DecisionModel;\n    export_problem_results,\n    console_level,\n    file_level,\n    disable_timer_outputs,\n    serialize,\n    kwargs...\n) -> RunStatus\n\n\nDefault solve method for models that conform to the requirements of DecisionModel{<: DecisionProblem}.\n\nThis will call build! on the model if it is not already built. It will forward all keyword arguments to that function.\n\nArguments\n\nmodel::OperationModel = model: operation model\nexport_problem_results::Bool = false: If true, export ProblemResults DataFrames to CSV files. Reduces solution times during simulation.\nconsole_level = Logging.Error:\nfile_level = Logging.Info:\ndisable_timer_outputs = false : Enable/Disable timing outputs\nserialize::Bool = true: If true, serialize the model to a file to allow re-execution later.\n\nExamples\n\nresults = solve!(OpModel)\nresults = solve!(OpModel, export_problem_results = true)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"&nbsp;\n&nbsp;","category":"page"},{"location":"api/PowerSimulations/#Emulation-Models","page":"API Reference","title":"Emulation Models","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"EmulationModel\nEmulationModel(::Type{M} where {M <: EmulationProblem}, ::ProblemTemplate, ::PSY.System, ::Union{Nothing, JuMP.Model})\nEmulationModel(::AbstractString, ::MOI.OptimizerWithAttributes)\nbuild!(::EmulationModel)\nrun!(::EmulationModel)","category":"page"},{"location":"api/PowerSimulations/#PowerSimulations.EmulationModel","page":"API Reference","title":"PowerSimulations.EmulationModel","text":"EmulationModel{M}(\n    template::ProblemTemplate,\n    sys::PSY.System,\n    jump_model::Union{Nothing, JuMP.Model}=nothing;\n    kwargs...) where {M<:EmulationProblem}\n\nBuild the optimization problem of type M with the specific system and template.\n\nArguments\n\n::Type{M} where M<:EmulationProblem: The abstract Emulation model type\ntemplate::ProblemTemplate: The model reference made up of transmission, devices, branches, and services.\nsys::PSY.System: the system created using Power Systems\njump_model::Union{Nothing, JuMP.Model}: Enables passing a custom JuMP model. Use with care\nname = nothing: name of model, string or symbol; defaults to the type of template converted to a symbol.\noptimizer::Union{Nothing,MOI.OptimizerWithAttributes} = nothing : The optimizer does not get serialized. Callers should pass whatever they passed to the original problem.\nwarm_start::Bool = true: True will use the current operation point in the system to initialize variable values. False initializes all variables to zero. Default is true\nsystem_to_file::Bool = true:: True to create a copy of the system used in the model.\ninitialize_model::Bool = true: Option to decide to initialize the model or not.\ninitialization_file::String = \"\": This allows to pass pre-existing initialization values to avoid the solution of an optimization problem to find feasible initial conditions.\ndeserialize_initial_conditions::Bool = false: Option to deserialize conditions\nexport_pwl_vars::Bool = false: True to export all the pwl intermediate variables. It can slow down significantly the build and solve time.\nallow_fails::Bool = false: True to allow the simulation to continue even if the optimization step fails. Use with care.\ncalculate_conflict::Bool = false: True to use solver to calculate conflicts for infeasible problems. Only specific solvers are able to calculate conflicts.\noptimizer_solve_log_print::Bool = false: Uses JuMP.unset_silent() to print the optimizer's log. By default all solvers are set to MOI.Silent()\ndetailed_optimizer_stats::Bool = false: True to save detailed optimizer stats log.\ndirect_mode_optimizer::Bool = false: True to use the solver in direct mode. Creates a JuMP.direct_model.\nstore_variable_names::Bool = false: True to store variable names in optimization model.\nrebuild_model::Bool = false: It will force the rebuild of the underlying JuMP model with each call to update the model. It increases solution times, use only if the model can't be updated in memory.\ninitial_time::Dates.DateTime = UNSET_INI_TIME: Initial Time for the model solve.\ntime_series_cache_size::Int = IS.TIME_SERIES_CACHE_SIZE_BYTES: Size in bytes to cache for each time array. Default is 1 MiB. Set to 0 to disable.\n\nExample\n\ntemplate = ProblemTemplate(CopperPlatePowerModel, devices, branches, services)\nOpModel = EmulationModel(MockEmulationProblem, template, system)\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.EmulationModel-Tuple{Type{M} where M<:PowerSimulations.EmulationProblem, ProblemTemplate, System, Union{Nothing, JuMP.Model}}","page":"API Reference","title":"PowerSimulations.EmulationModel","text":"EmulationModel(\n    ::Type{M<:PowerSimulations.EmulationProblem},\n    template::ProblemTemplate,\n    sys::System\n) -> EmulationModel\nEmulationModel(\n    ::Type{M<:PowerSimulations.EmulationProblem},\n    template::ProblemTemplate,\n    sys::System,\n    jump_model::Union{Nothing, JuMP.Model};\n    kwargs...\n) -> EmulationModel\n\n\nBuild the optimization problem of type M with the specific system and template\n\nArguments\n\n::Type{M} where M<:EmulationProblem: The abstract Emulation model type\ntemplate::ProblemTemplate: The model reference made up of transmission, devices, branches, and services.\nsys::PSY.System: the system created using Power Systems\njump_model::Union{Nothing, JuMP.Model}: Enables passing a custom JuMP model. Use with care\n\nExample\n\ntemplate = ProblemTemplate(CopperPlatePowerModel, devices, branches, services)\nproblem = EmulationModel(MyEmProblemType, template, system, optimizer)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.EmulationModel-Tuple{AbstractString, MathOptInterface.OptimizerWithAttributes}","page":"API Reference","title":"PowerSimulations.EmulationModel","text":"EmulationModel(\n    directory::AbstractString,\n    optimizer::MathOptInterface.OptimizerWithAttributes;\n    jump_model,\n    system,\n    kwargs...\n) -> Any\n\n\nConstruct an EmulationProblem from a serialized file.\n\nArguments\n\ndirectory::AbstractString: Directory containing a serialized model.\noptimizer::MOI.OptimizerWithAttributes: The optimizer does not get serialized. Callers should pass whatever they passed to the original problem.\njump_model::Union{Nothing, JuMP.Model} = nothing: The JuMP model does not get serialized. Callers should pass whatever they passed to the original problem.\nsystem::Union{Nothing, PSY.System}: Optionally, the system used for the model. If nothing and systofile was set to true when the model was created, the system will be deserialized from a file.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.build!-Tuple{EmulationModel}","page":"API Reference","title":"PowerSimulations.build!","text":"build!(\n    model::EmulationModel;\n    executions,\n    output_dir,\n    recorders,\n    console_level,\n    file_level,\n    disable_timer_outputs\n)\n\n\nImplementation of build for any EmulationProblem\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.run!-Tuple{EmulationModel}","page":"API Reference","title":"PowerSimulations.run!","text":"run!(\n    model::EmulationModel;\n    export_problem_results,\n    console_level,\n    file_level,\n    disable_timer_outputs,\n    serialize,\n    kwargs...\n) -> RunStatus\n\n\nDefault run method for problems that conform to the requirements of EmulationModel{<: EmulationProblem}\n\nThis will call build! on the model if it is not already built. It will forward all keyword arguments to that function.\n\nArguments\n\nmodel::EmulationModel = model: Emulation model\noptimizer::MOI.OptimizerWithAttributes: The optimizer that is used to solve the model\nexecutions::Int: Number of executions for the emulator run\nexport_problem_results::Bool: If true, export ProblemResults DataFrames to CSV files.\noutput_dir::String: Required if the model is not already built, otherwise ignored\nenable_progress_bar::Bool: Enables/Disable progress bar printing\nserialize::Bool: If true, serialize the model to a file to allow re-execution later.\n\nExamples\n\nstatus = run!(model; optimizer = GLPK.Optimizer, executions = 10)\nstatus = run!(model; output_dir = ./model_output, optimizer = GLPK.Optimizer, executions = 10)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"&nbsp;\n&nbsp;","category":"page"},{"location":"api/PowerSimulations/#Simulation-Models","page":"API Reference","title":"Simulation Models","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"Refer to the Simulations Page to explanations on how to setup a Simulation, with Sequencing and Feedforwards.","category":"page"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"SimulationModels\nSimulationSequence\nSimulation\nSimulation(::AbstractString, ::Dict)\nbuild!(::Simulation)\nexecute!(::Simulation)","category":"page"},{"location":"api/PowerSimulations/#PowerSimulations.SimulationModels","page":"API Reference","title":"PowerSimulations.SimulationModels","text":"SimulationModels(\n    decision_models::Vector{<:DecisionModel},\n    emulation_models::Union{Nothing, EmulationModel}\n)\n\nStores the OperationProblem definitions to be used in the simulation. When creating the SimulationModels, the order in which the models are created determines the order on which the simulation is executed.\n\nArguments\n\ndecision_models::Vector{<:DecisionModel}: Vector of decision models.\nemulation_models::Union{Nothing, EmulationModel}: Optional argument to include\n\nan EmulationModel in the Simulation\n\nExample\n\ntemplate_uc = template_unit_commitment()\ntemplate_ed = template_economic_dispatch()\nmy_decision_model_uc = DecisionModel(template_1, sys_uc, optimizer, name = \"UC\")\nmy_decision_model_ed = DecisionModel(template_ed, sys_ed, optimizer, name = \"ED\")\nmodels = SimulationModels(\n    decision_models = [\n        my_decision_model_uc,\n        my_decision_model_ed\n    ]\n)\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.SimulationSequence","page":"API Reference","title":"PowerSimulations.SimulationSequence","text":"SimulationSequence(\n    models::SimulationModels,\n    feedforward::Dict{String, Vector{<:AbstractAffectFeedforward}}\n    ini_cond_chronology::InitialConditionChronology\n)\n\nConstruct the simulation sequence between decision and emulation models.\n\nArguments\n\nmodels::SimulationModels: Vector of decisions and emulation models.\nfeedforward = Dict{String, Vector{<:AbstractAffectFeedforward}}(): Optional dictionary to specify how information\n\nand variables are exchanged between decision and emulation models.\n\nini_cond_chronology::nitialConditionChronology =  InterProblemChronology(): TODO\n\nExample\n\ntemplate_uc = template_unit_commitment()\ntemplate_ed = template_economic_dispatch()\nmy_decision_model_uc = DecisionModel(template_1, sys_uc, optimizer, name = \"UC\")\nmy_decision_model_ed = DecisionModel(template_ed, sys_ed, optimizer, name = \"ED\")\nmodels = SimulationModels(\n    decision_models = [\n        my_decision_model_uc,\n        my_decision_model_ed\n    ]\n)\n# The following sequence set the commitment variables (`OnVariable`) for `ThermalStandard` units from UC to ED.\nsequence = SimulationSequence(;\n    models = models,\n    feedforwards = Dict(\n        \"ED\" => [\n            SemiContinuousFeedforward(;\n                component_type = ThermalStandard,\n                source = OnVariable,\n                affected_values = [ActivePowerVariable],\n            ),\n        ],\n    ),\n)\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.Simulation","page":"API Reference","title":"PowerSimulations.Simulation","text":"Simulation(\n    sequence::SimulationSequence,\n    name::String,\n    steps::Int\n    models::SimulationModels,\n    simulation_folder::String,\n    initial_time::Union{Nothing, Dates.DateTime}\n)\n\nConstruct the Simulation structure to run the sequence of decision and emulation models specified.\n\nArguments\n\n-sequence::SimulationSequence: Simulation sequence that specify how the decision and emulation models will be executed.   -name::String: Name of the Simulation   -steps::Int: Number of steps on which the sequence of models will be executed   -models::SimulationModels: List of Decision and Emulation Models   -simulation_folder::String: Folder on which results will be stored   -initial_time::Union{Nothing, Dates.DateTime} = nothing: Initial time of which the simulation starts. If nothing it will default to the first timestamp     of time series of the system.\n\nExample\n\ntemplate_uc = template_unit_commitment()\ntemplate_ed = template_economic_dispatch()\nmy_decision_model_uc = DecisionModel(template_1, sys_uc, optimizer, name = \"UC\")\nmy_decision_model_ed = DecisionModel(template_ed, sys_ed, optimizer, name = \"ED\")\nmodels = SimulationModels(\n    decision_models = [\n        my_decision_model_uc,\n        my_decision_model_ed\n    ]\n)\n# The following sequence set the commitment variables (`OnVariable`) for `ThermalStandard` units from UC to ED.\nsequence = SimulationSequence(;\n    models = models,\n    feedforwards = Dict(\n        \"ED\" => [\n            SemiContinuousFeedforward(;\n                component_type = ThermalStandard,\n                source = OnVariable,\n                affected_values = [ActivePowerVariable],\n            ),\n        ],\n    ),\n)\n\nsim = Simulation(\n    sequence = sequence,\n    name = \"Sim\",\n    steps = 5,\n    models = models,\n    simulation_folder = mktempdir(cleanup=true),\n)\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.Simulation-Tuple{AbstractString, Dict}","page":"API Reference","title":"PowerSimulations.Simulation","text":"Simulation(directory::AbstractString, model_info::Dict)\n\n\nConstructs Simulation from a serialized directory. Callers should pass any kwargs here that they passed to the original Simulation.\n\nArguments\n\ndirectory::AbstractString: the directory returned from the call to serialize\nmodel_info::Dict: Two-level dictionary containing model parameters that cannot be serialized. The outer dict should be keyed by the problem name. The inner dict must contain 'optimizer' and may contain 'jump_model'. These should be the same values used for the original simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.build!-Tuple{Simulation}","page":"API Reference","title":"PowerSimulations.build!","text":"build!(\n    sim::Simulation;\n    recorders,\n    console_level,\n    file_level,\n    serialize,\n    partitions,\n    index\n) -> BuildStatus\n\n\nBuild the Simulation, problems and the related folder structure.\n\nArguments\n\nsim::Simulation: simulation object\nrecorders::Vector{Symbol} = []: recorder names to register\nserialize::Bool = true: serializes the simulation objects in the simulation\nconsole_level = Logging.Error:\nfile_level = Logging.Info:\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.execute!-Tuple{Simulation}","page":"API Reference","title":"PowerSimulations.execute!","text":"execute!(sim::Simulation; kwargs...) -> RunStatus\n\n\nSolves the simulation model for sequential Simulations.\n\nArguments\n\nsim::Simulation=sim: simulation object created by Simulation()\n\nThe optional keyword argument exports controls exporting of results to CSV files as the simulation runs. Refer to export_results for a description of this argument.\n\nExample\n\nsim = Simulation(\"Test\", 7, problems, \"/Users/folder\")\nexecute!(sim::Simulation; kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"&nbsp;\n&nbsp;","category":"page"},{"location":"api/PowerSimulations/#Variables","page":"API Reference","title":"Variables","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"For a list of variables for each device refer to its Formulations page.","category":"page"},{"location":"api/PowerSimulations/#Common-Variables","page":"API Reference","title":"Common Variables","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"ActivePowerVariable\nReactivePowerVariable\nPieceWiseLinearCostVariable","category":"page"},{"location":"api/PowerSimulations/#PowerSimulations.ActivePowerVariable","page":"API Reference","title":"PowerSimulations.ActivePowerVariable","text":"Struct to dispatch the creation of Active Power Variables\n\nDocs abbreviation: Pg\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ReactivePowerVariable","page":"API Reference","title":"PowerSimulations.ReactivePowerVariable","text":"Struct to dispatch the creation of Reactive Power Variables\n\nDocs abbreviation: Qg\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#Thermal-Unit-Variables","page":"API Reference","title":"Thermal Unit Variables","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"OnVariable\nStartVariable\nStopVariable\nTimeDurationOn\nTimeDurationOff\nHotStartVariable\nWarmStartVariable\nColdStartVariable\nPowerAboveMinimumVariable","category":"page"},{"location":"api/PowerSimulations/#PowerSimulations.OnVariable","page":"API Reference","title":"PowerSimulations.OnVariable","text":"Struct to dispatch the creation of a binary commitment status variable\n\nDocs abbreviation: u\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.PowerAboveMinimumVariable","page":"API Reference","title":"PowerSimulations.PowerAboveMinimumVariable","text":"Struct to dispatch the creation of Active Power Variables above minimum power for Thermal Compact formulations\n\nDocs abbreviation: hatPg\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#Storage-Unit-Variables","page":"API Reference","title":"Storage Unit Variables","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"ReservationVariable","category":"page"},{"location":"api/PowerSimulations/#PowerSimulations.ReservationVariable","page":"API Reference","title":"PowerSimulations.ReservationVariable","text":"Struct to dispatch the creation of binary storage charge reservation variable\n\nDocs abbreviation: r\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#Branches-and-Network-Variables","page":"API Reference","title":"Branches and Network Variables","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"FlowActivePowerVariable\nFlowActivePowerFromToVariable\nFlowActivePowerToFromVariable\nFlowReactivePowerFromToVariable\nFlowReactivePowerToFromVariable\nPhaseShifterAngle\nHVDCLosses\nHVDCFlowDirectionVariable\nVoltageMagnitude\nVoltageAngle","category":"page"},{"location":"api/PowerSimulations/#PowerSimulations.FlowActivePowerVariable","page":"API Reference","title":"PowerSimulations.FlowActivePowerVariable","text":"Struct to dispatch the creation of bidirectional Active Power Flow Variables\n\nDocs abbreviation: P\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.FlowActivePowerFromToVariable","page":"API Reference","title":"PowerSimulations.FlowActivePowerFromToVariable","text":"Struct to dispatch the creation of unidirectional Active Power Flow Variables\n\nDocs abbreviation: overrightarrowP\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.FlowActivePowerToFromVariable","page":"API Reference","title":"PowerSimulations.FlowActivePowerToFromVariable","text":"Struct to dispatch the creation of unidirectional Active Power Flow Variables\n\nDocs abbreviation: overleftarrowP\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.FlowReactivePowerFromToVariable","page":"API Reference","title":"PowerSimulations.FlowReactivePowerFromToVariable","text":"Struct to dispatch the creation of unidirectional Reactive Power Flow Variables\n\nDocs abbreviation: overrightarrowQ\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.FlowReactivePowerToFromVariable","page":"API Reference","title":"PowerSimulations.FlowReactivePowerToFromVariable","text":"Struct to dispatch the creation of unidirectional Reactive Power Flow Variables\n\nDocs abbreviation: overleftarrowQ\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#Regulation-and-Services-Variables","page":"API Reference","title":"Regulation and Services Variables","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"ActivePowerReserveVariable\nServiceRequirementVariable\nDeltaActivePowerUpVariable\nDeltaActivePowerDownVariable\nAdditionalDeltaActivePowerUpVariable\nAdditionalDeltaActivePowerDownVariable\nAreaMismatchVariable\nSteadyStateFrequencyDeviation\nSmoothACE\nSystemBalanceSlackUp\nSystemBalanceSlackDown\nReserveRequirementSlack","category":"page"},{"location":"api/PowerSimulations/#PowerSimulations.ActivePowerReserveVariable","page":"API Reference","title":"PowerSimulations.ActivePowerReserveVariable","text":"Struct to dispatch the creation of Active Power Reserve Variables\n\nDocs abbreviation: Pr\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"&nbsp;\n&nbsp;","category":"page"},{"location":"api/PowerSimulations/#Constraints","page":"API Reference","title":"Constraints","text":"","category":"section"},{"location":"api/PowerSimulations/#Common-Constraints","page":"API Reference","title":"Common Constraints","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"PieceWiseLinearCostConstraint\n","category":"page"},{"location":"api/PowerSimulations/#Network-Constraints","page":"API Reference","title":"Network Constraints","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"AreaDispatchBalanceConstraint\nAreaParticipationAssignmentConstraint\nBalanceAuxConstraint\nCopperPlateBalanceConstraint\nFrequencyResponseConstraint\nNodalBalanceActiveConstraint\nNodalBalanceReactiveConstraint","category":"page"},{"location":"api/PowerSimulations/#Power-Variable-Limit-Constraints","page":"API Reference","title":"Power Variable Limit Constraints","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"ActivePowerVariableLimitsConstraint\nReactivePowerVariableLimitsConstraint\nActivePowerVariableTimeSeriesLimitsConstraint\nInputActivePowerVariableLimitsConstraint\nOutputActivePowerVariableLimitsConstraint","category":"page"},{"location":"api/PowerSimulations/#Regulation-and-Services-Constraints","page":"API Reference","title":"Regulation and Services Constraints","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"ParticipationAssignmentConstraint\nRegulationLimitsConstraint\nRequirementConstraint\nReserveEnergyCoverageConstraint\nReservePowerConstraint","category":"page"},{"location":"api/PowerSimulations/#Thermal-Unit-Constraints","page":"API Reference","title":"Thermal Unit Constraints","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"ActiveRangeICConstraint\nCommitmentConstraint\nDurationConstraint\nRampConstraint\nRampLimitConstraint\nStartupInitialConditionConstraint\nStartupTimeLimitTemperatureConstraint","category":"page"},{"location":"api/PowerSimulations/#Renewable-Unit-Constraints","page":"API Reference","title":"Renewable Unit Constraints","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"EqualityConstraint\n","category":"page"},{"location":"api/PowerSimulations/#Branches-Constraints","page":"API Reference","title":"Branches Constraints","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"AbsoluteValueConstraint\nFlowLimitFromToConstraint\nFlowLimitToFromConstraint\nFlowRateConstraint\nFlowRateConstraintFromTo\nFlowRateConstraintToFrom\nHVDCDirection\nHVDCLossesAbsoluteValue\nHVDCPowerBalance\nNetworkFlowConstraint\nRateLimitConstraint\nRateLimitConstraintFromTo\nRateLimitConstraintToFrom\nPhaseAngleControlLimit","category":"page"},{"location":"api/PowerSimulations/#Feedforward-Constraints","page":"API Reference","title":"Feedforward Constraints","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"FeedforwardSemiContinousConstraint\nFeedforwardIntegralLimitConstraint\nFeedforwardUpperBoundConstraint\nFeedforwardLowerBoundConstraint\nFeedforwardEnergyTargetConstraint","category":"page"},{"location":"api/PowerSimulations/#Parameters","page":"API Reference","title":"Parameters","text":"","category":"section"},{"location":"api/PowerSimulations/#Time-Series-Parameters","page":"API Reference","title":"Time Series Parameters","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"ActivePowerTimeSeriesParameter\nReactivePowerTimeSeriesParameter\nRequirementTimeSeriesParameter","category":"page"},{"location":"api/PowerSimulations/#PowerSimulations.ActivePowerTimeSeriesParameter","page":"API Reference","title":"PowerSimulations.ActivePowerTimeSeriesParameter","text":"Parameter to define active power time series\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ReactivePowerTimeSeriesParameter","page":"API Reference","title":"PowerSimulations.ReactivePowerTimeSeriesParameter","text":"Parameter to define reactive power time series\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.RequirementTimeSeriesParameter","page":"API Reference","title":"PowerSimulations.RequirementTimeSeriesParameter","text":"Paramter to define requirement time series\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#Variable-Value-Parameters","page":"API Reference","title":"Variable Value Parameters","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"UpperBoundValueParameter\nLowerBoundValueParameter\nOnStatusParameter\nEnergyLimitParameter\nFixValueParameter\nEnergyTargetParameter","category":"page"},{"location":"api/PowerSimulations/#PowerSimulations.UpperBoundValueParameter","page":"API Reference","title":"PowerSimulations.UpperBoundValueParameter","text":"Parameter to define variable upper bound\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.LowerBoundValueParameter","page":"API Reference","title":"PowerSimulations.LowerBoundValueParameter","text":"Parameter to define variable lower bound\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.OnStatusParameter","page":"API Reference","title":"PowerSimulations.OnStatusParameter","text":"Parameter to define unit commitment status\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.FixValueParameter","page":"API Reference","title":"PowerSimulations.FixValueParameter","text":"Parameter to FixValueParameter\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#Objective-Function-Parameters","page":"API Reference","title":"Objective Function Parameters","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"API Reference","title":"API Reference","text":"CostFunctionParameter","category":"page"},{"location":"api/PowerSimulations/#PowerSimulations.CostFunctionParameter","page":"API Reference","title":"PowerSimulations.CostFunctionParameter","text":"Parameter to define cost function coefficient\n\n\n\n\n\n","category":"type"},{"location":"tutorials/basics_of_developing_models/#Basics-of-Developing-Operation-Models","page":"Basics of Developing Operation Models","title":"Basics of Developing Operation Models","text":"","category":"section"},{"location":"tutorials/basics_of_developing_models/","page":"Basics of Developing Operation Models","title":"Basics of Developing Operation Models","text":"Check the page PowerSimulations Structure for more background on PowerSimulations.jl","category":"page"},{"location":"modeler_guide/definitions/#Definitions","page":"Definitions","title":"Definitions","text":"","category":"section"},{"location":"modeler_guide/definitions/#D","page":"Definitions","title":"D","text":"","category":"section"},{"location":"modeler_guide/definitions/","page":"Definitions","title":"Definitions","text":"Decision Problem: A decision problem calculates the desired system operation based on forecasts of uncertain inputs and information about the state of the system. The output of a decision problem represents the policies used to drive the set-points of the system's devices, like generators or switches, and depends on the purpose of the problem. See the Decision Model Tutorial to learn more about solving individual problems.\nDevice Formulation: The model of a device that is incorporated into a large system optimization models. For instance, the storage device model used inside of a Unit Commitment (UC) problem. A device model needs to follow some requirements to be integrated into operation problems.","category":"page"},{"location":"modeler_guide/definitions/#E","page":"Definitions","title":"E","text":"","category":"section"},{"location":"modeler_guide/definitions/","page":"Definitions","title":"Definitions","text":"Emulation Problem: An emulation problem is used to mimic the system's behavior subject to an incoming decision and the realization of a forecasted inputs. The solution of the emulator produces outputs representative of the system performance when operating subject the policies resulting from the decision models.","category":"page"},{"location":"modeler_guide/definitions/#H","page":"Definitions","title":"H","text":"","category":"section"},{"location":"modeler_guide/definitions/","page":"Definitions","title":"Definitions","text":"Horizon: The number of steps in the look-ahead of a decision problem. For instance, a Day-Ahead problem usually has a 48 step horizon. Check the time Time Series Data Section in PowerSystems.jl","category":"page"},{"location":"modeler_guide/definitions/#I","page":"Definitions","title":"I","text":"","category":"section"},{"location":"modeler_guide/definitions/","page":"Definitions","title":"Definitions","text":"Interval: The amount of time between updates to the decision problem. For instance, Day-Ahead problems usually have a 24-hour intervals and Real-Time problems have 5-minute intervals. Check the time Time Series Data Section in PowerSystems.jl","category":"page"},{"location":"modeler_guide/definitions/#R","page":"Definitions","title":"R","text":"","category":"section"},{"location":"modeler_guide/definitions/","page":"Definitions","title":"Definitions","text":"Resolution: The amount of time between timesteps in a simulation. For instance 1-hour or 5-minutes. In Julia these are defined using the syntax Hour(1) and Minute(5). Check the time Time Series Data Section in PowerSystems.jl","category":"page"},{"location":"modeler_guide/debugging_infeasible_models/#Debugging-infeasible-models","page":"Debugging infeasible models","title":"Debugging infeasible models","text":"","category":"section"},{"location":"modeler_guide/debugging_infeasible_models/","page":"Debugging infeasible models","title":"Debugging infeasible models","text":"Getting infeasible solutions to models is a common occurrence in operations simulations, there are multiple reasons why this can happen. PowerSimulations.jl has several tools to help debug this situation.","category":"page"},{"location":"modeler_guide/debugging_infeasible_models/#Adding-slacks-to-the-model","page":"Debugging infeasible models","title":"Adding slacks to the model","text":"","category":"section"},{"location":"modeler_guide/debugging_infeasible_models/#Getting-the-infeasibility-conflict","page":"Debugging infeasible models","title":"Getting the infeasibility conflict","text":"","category":"section"},{"location":"modeler_guide/psi_structure/#psi_structure","page":"PowerSimulations.jl Modeling Structure","title":"PowerSimulations.jl Modeling Structure","text":"","category":"section"},{"location":"modeler_guide/psi_structure/","page":"PowerSimulations.jl Modeling Structure","title":"PowerSimulations.jl Modeling Structure","text":"PowerSimulations enables the simulation of a sequence of power systems optimization problems and provides user control over each aspect of the simulation configuration. Specifically:","category":"page"},{"location":"modeler_guide/psi_structure/","page":"PowerSimulations.jl Modeling Structure","title":"PowerSimulations.jl Modeling Structure","text":"mathematical formulations can be selected for each component with DeviceModel and ServiceModel\na problem can be defined by creating model entries in a Operations ProblemTemplates\nmodels (DecisionModel or EmulationModel) can be built by applying a ProblemTemplate to a System and can be executed/solved in isolation or as part of a Simulation\nSimulations can be defined and executed by sequencing one or more models and defining how and when data flows between models.","category":"page"},{"location":"modeler_guide/psi_structure/","page":"PowerSimulations.jl Modeling Structure","title":"PowerSimulations.jl Modeling Structure","text":"question: What is the difference between a Model and a Problem?\nA \"Problem\" is an abstract mathematical description of how to represent power system behavior, whereas a \"Model\" is a concrete representation of a \"Problem\" applied to a dataset. I.e. once a Problem is populated with data describing all the loads, generators, lines, etc., it becomes a Model.","category":"page"},{"location":"formulation_library/General/#formulation_library","page":"General","title":"Formulations","text":"","category":"section"},{"location":"formulation_library/General/","page":"General","title":"General","text":"Modeling formulations are created by dispatching on abstract subtypes of PowerSimulations.AbstractDeviceFormulation","category":"page"},{"location":"formulation_library/General/#FixedOutput","page":"General","title":"FixedOutput","text":"","category":"section"},{"location":"formulation_library/General/","page":"General","title":"General","text":"FixedOutput","category":"page"},{"location":"formulation_library/General/#PowerSimulations.FixedOutput","page":"General","title":"PowerSimulations.FixedOutput","text":"Formulation type to augment the power balance constraint expression with a time series parameter\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/General/","page":"General","title":"General","text":"Variables:","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"No variables are created for DeviceModel(<:DeviceType, FixedOutput)","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"Static Parameters:","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"ThermalGen:\nPg^textmax = PowerSystems.get_max_active_power(device)\nQg^textmax = PowerSystems.get_max_reactive_power(device)\nStorage:\nPg^textmax = PowerSystems.get_max_active_power(device)\nQg^textmax = PowerSystems.get_max_reactive_power(device)","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"Time Series Parameters:","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"using PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombo_tables = []\nfor t in [RenewableGen, ThermalGen, HydroGen, ElectricLoad]\n    combos = PowerSimulations.get_default_time_series_names(t, FixedOutput)\n    combo_table = DataFrame(\n        \"Parameter\" => map(x -> \"[`$x`](@ref)\", collect(keys(combos))),\n        \"Default Time Series Name\" => map(x -> \"`$x`\", collect(values(combos))),\n        )\n    insertcols!(combo_table, 1, \"Device Type\" => fill(string(t), length(combos)))\n    push!(combo_tables, combo_table)\nend\nmdtable(vcat(combo_tables...), latex = false)","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"Objective:","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"No objective terms are created for DeviceModel(<:DeviceType, FixedOutput)","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"Expressions:","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"Adds the active and reactive parameters listed for specific device types above to the respective active and reactive power balance expressions created by the selected Network Formulations","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"Constraints:","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"No constraints are created for DeviceModel(<:DeviceType, FixedOutput)","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"","category":"page"},{"location":"formulation_library/General/#VariableCost-Options","page":"General","title":"VariableCost Options","text":"","category":"section"},{"location":"formulation_library/General/","page":"General","title":"General","text":"PowerSimulations can represent variable costs using a variety of different methods depending on the data available in each device. The following describes the objective function terms that are populated for each variable cost option.","category":"page"},{"location":"formulation_library/General/#Scalar-VariableCost","page":"General","title":"Scalar VariableCost","text":"","category":"section"},{"location":"formulation_library/General/","page":"General","title":"General","text":"variable_cost <: Float64: creates a fixed marginal cost term in the objective function","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"beginaligned\n  textmin sum_t C * G_t\nendaligned","category":"page"},{"location":"formulation_library/General/#Polynomial-VariableCost","page":"General","title":"Polynomial VariableCost","text":"","category":"section"},{"location":"formulation_library/General/","page":"General","title":"General","text":"variable_cost <: Tuple{Float64, Float64}: creates a polynomial cost term in the objective function where","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"C_g=variable_cost[1]\nC_g^prime=variable_cost[2]","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"beginaligned\n  textmin sum_t C * G_t + C^prime * G_t^2\nendaligned","category":"page"},{"location":"formulation_library/General/#Piecewise-Linear-VariableCost","page":"General","title":"Piecewise Linear VariableCost","text":"","category":"section"},{"location":"formulation_library/General/","page":"General","title":"General","text":"variable_cost <: Vector{Tuple{Float64, Float64}}: creates a piecewise linear cost term in the objective function","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"TODO: add formulation","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"___","category":"page"},{"location":"formulation_library/General/#StorageManagementCost","page":"General","title":"StorageManagementCost","text":"","category":"section"},{"location":"formulation_library/General/","page":"General","title":"General","text":"Adds an objective function cost term according to:","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"beginaligned\n  textmin sum_t quad E^surplus_t * C^penalty - E^shortage_t * C^value\nendaligned","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"Impact of different cost configurations:","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"The following table describes all possible configuration of the StorageManagementCost with the target constraint in hydro or storage device models. Cases 1(a) & 2(a) will have no impact of the models operations and the target constraint will be rendered useless. In most cases that have no energy target and a non-zero value for C^value, if this cost is too high (C^value  0) or too low (C^value 0) can result in either the model holding on to stored energy till the end or the model not storing any energy in the device. This is caused by the fact that when energy target is zero, we have E_t = - E^shortage_t, and - E^shortage_t * C^value in the objective function is replaced by E_t * C^value, thus resulting in C^value to be seen as the cost of stored energy.","category":"page"},{"location":"formulation_library/General/","page":"General","title":"General","text":"Case Energy Target Energy Shortage Cost Energy Value / Energy Surplus cost Effect\nCase 1(a) hatE=0 C^penalty=0 C^value=0 no change\nCase 1(b) hatE=0 C^penalty=0 C^value0 penalty for storing energy\nCase 1(c) hatE=0 C^penalty0 C^value=0 no penalties or incentives applied\nCase 1(d) hatE=0 C^penalty=0 C^value0 incentive for storing energy\nCase 1(e) hatE=0 C^penalty0 C^value0 penalty for storing energy\nCase 1(f) hatE=0 C^penalty0 C^value0 incentive for storing energy\nCase 2(a) hatE0 C^penalty=0 C^value=0 no change\nCase 2(b) hatE0 C^penalty=0 C^value0 penalty on energy storage in excess of target\nCase 2(c) hatE0 C^penalty0 C^value=0 penalty on energy storage short of target\nCase 2(d) hatE0 C^penalty=0 C^value0 incentive on excess energy\nCase 2(e) hatE0 C^penalty0 C^value0 penalty on both excess/shortage of energy\nCase 2(f) hatE0 C^penalty0 C^value0 penalty for shortage, incentive for excess energy","category":"page"},{"location":"modeler_guide/logging/#Logging","page":"Logging","title":"Logging","text":"","category":"section"},{"location":"modeler_guide/logging/","page":"Logging","title":"Logging","text":"PowerSimulations.jl will output many log messages when building systems and running simulations. You may want to customize what gets logged to the console and, optionally, a file.","category":"page"},{"location":"modeler_guide/logging/","page":"Logging","title":"Logging","text":"By default all log messages of level Logging.Info or higher will get displayed to the console.  When you run a simulation a simulation-specific logger will take over and log its messages to a file in the logs directory in the simulation output directory. When finished it will relinquish control back to the global logger.","category":"page"},{"location":"modeler_guide/logging/#Configuring-the-global-logger","page":"Logging","title":"Configuring the global logger","text":"","category":"section"},{"location":"modeler_guide/logging/","page":"Logging","title":"Logging","text":"To configure the global logger in a Jupyter Notebook or REPL you may configure your own logger with the Julia Logging standard library or use the convenience function provided by PowerSimulations.  This example will log messages of level Logging.Error to console and Logging.Info and higher to the file power-simulations.log in the current directory.","category":"page"},{"location":"modeler_guide/logging/","page":"Logging","title":"Logging","text":"import Logging\nusing PowerSimulations\nlogger = configure_logging(\n    console_level = Logging.Error,\n    file_level = Logging.Info,\n    filename = \"power-simulations.log\"\n)","category":"page"},{"location":"modeler_guide/logging/#Configuring-the-simulation-logger","page":"Logging","title":"Configuring the simulation logger","text":"","category":"section"},{"location":"modeler_guide/logging/","page":"Logging","title":"Logging","text":"You can configure the logging level used by the simulation logger when you call build!(simulation).  Here is an example that increases logging verbosity:","category":"page"},{"location":"modeler_guide/logging/","page":"Logging","title":"Logging","text":"import Logging\nusing PowerSimulations\nsimulation = Simulation(...)\nbuild!(simulation, console_level = Logging.Info, file_level = Logging.Debug)","category":"page"},{"location":"modeler_guide/logging/","page":"Logging","title":"Logging","text":"The log file will be located at <your-output-path>/<simulation-name>/<run-output-dir>/logs/simulation.log.","category":"page"},{"location":"modeler_guide/logging/#Solver-logs","page":"Logging","title":"Solver logs","text":"","category":"section"},{"location":"modeler_guide/logging/","page":"Logging","title":"Logging","text":"You can configure logging for the solver you use.  Refer to the solver documentation.  PowerSimulations does not redirect or intercept prints to stdout or stderr from other libraries.","category":"page"},{"location":"modeler_guide/logging/#Recorder-events","page":"Logging","title":"Recorder events","text":"","category":"section"},{"location":"modeler_guide/logging/","page":"Logging","title":"Logging","text":"PowerSimulations uses the InfrastructureSystems.Recorder to store simulation events in a log file.  Refer to this link for more information.","category":"page"},{"location":"formulation_library/RenewableGen/#PowerSystems.RenewableGen-Formulations","page":"Renewable Generation","title":"PowerSystems.RenewableGen Formulations","text":"","category":"section"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Valid DeviceModels for subtypes of RenewableGen include the following:","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"using PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.generate_device_formulation_combinations()\nfilter!(x -> x[\"device_type\"] <: RenewableGen, combos)\ncombo_table = DataFrame(\n    \"Valid DeviceModel\" => [\"`DeviceModel($(c[\"device_type\"]), $(c[\"formulation\"]))`\" for c in combos],\n    \"Device Type\" => [\"[$(c[\"device_type\"])](https://nrel-Sienna.github.io/PowerSystems.jl/stable/model_library/generated_$(c[\"device_type\"])/)\" for c in combos],\n    \"Formulation\" => [\"[$(c[\"formulation\"])](@ref)\" for c in combos],\n    )\nmdtable(combo_table, latex = false)","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"","category":"page"},{"location":"formulation_library/RenewableGen/#RenewableFullDispatch","page":"Renewable Generation","title":"RenewableFullDispatch","text":"","category":"section"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"RenewableFullDispatch","category":"page"},{"location":"formulation_library/RenewableGen/#PowerSimulations.RenewableFullDispatch","page":"Renewable Generation","title":"PowerSimulations.RenewableFullDispatch","text":"Formulation type to add injection variables constrained by a maximum injection time series for RenewableGen\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Variables:","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"ActivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_active_power(device)\nReactivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_reactive_power(device)","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Static Parameters:","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Pg^textmin = PowerSystems.get_active_power_limits(device).min\nQg^textmin = PowerSystems.get_reactive_power_limits(device).min\nQg^textmax = PowerSystems.get_reactive_power_limits(device).max","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Time Series Parameters:","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"using PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.get_default_time_series_names(RenewableGen, RenewableFullDispatch)\ncombo_table = DataFrame(\n    \"Parameter\" => map(x -> \"[`$x`](@ref)\", collect(keys(combos))),\n    \"Default Time Series Name\" => map(x -> \"`$x`\", collect(values(combos))),\n    )\nmdtable(combo_table, latex = false)","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Objective:","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Creates an objective function term based on the VariableCost Options where the quantity term is defined as - Pg_t to incentivize generation from RenewableGen devices.","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Expressions:","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Adds Pg and Qg terms to the respective active and reactive power balance expressions created by the selected Network Formulations","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Constraints:","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"beginaligned\n  Pg^textmin le Pg_t le ActivePowerTimeSeriesParameter_t \n  Qg^textmin le Qg_t le Qg^textmax\nendaligned","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"","category":"page"},{"location":"formulation_library/RenewableGen/#RenewableConstantPowerFactor","page":"Renewable Generation","title":"RenewableConstantPowerFactor","text":"","category":"section"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"RenewableConstantPowerFactor","category":"page"},{"location":"formulation_library/RenewableGen/#PowerSimulations.RenewableConstantPowerFactor","page":"Renewable Generation","title":"PowerSimulations.RenewableConstantPowerFactor","text":"Formulation type to add real and reactive injection variables with constant power factor with maximum real power injections constrained by a time series for RenewableGen\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Variables:","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"ActivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_active_power(device)\nReactivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_reactive_power(device)","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Static Parameters:","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Pg^textmin = PowerSystems.get_active_power_limits(device).min\nQg^textmin = PowerSystems.get_reactive_power_limits(device).min\nQg^textmax = PowerSystems.get_reactive_power_limits(device).max\npf = PowerSystems.get_power_factor(device)","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Time Series Parameters:","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"using PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.get_default_time_series_names(RenewableGen, RenewableConstantPowerFactor)\ncombo_table = DataFrame(\n    \"Parameter\" => map(x -> \"[`$x`](@ref)\", collect(keys(combos))),\n    \"Default Time Series Name\" => map(x -> \"`$x`\", collect(values(combos))),\n    )\nmdtable(combo_table, latex = false)","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Objective:","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Creates an objective function term based on the VariableCost Options where the quantity term is defined as - Pg_t to incentivize generation from RenewableGen devices.","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Expressions:","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Adds Pg and Qg terms to the respective active and reactive power balance expressions created by the selected Network Formulations","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"Constraints:","category":"page"},{"location":"formulation_library/RenewableGen/","page":"Renewable Generation","title":"Renewable Generation","text":"beginaligned\n  Pg^textmin le Pg_t le ActivePowerTimeSeriesParameter_t \n  Qg^textmin le Qg_t le Qg^textmax \n  Qg_t = pf * Pg_t\nendaligned","category":"page"},{"location":"formulation_library/Service/#PowerSystems.Service-Formulations","page":"PowerSystems.Service Formulations","title":"PowerSystems.Service Formulations","text":"","category":"section"},{"location":"formulation_library/Service/","page":"PowerSystems.Service Formulations","title":"PowerSystems.Service Formulations","text":"TODO","category":"page"},{"location":"model_developer_guide/structure_of_operation_problem/#Structure-of-an-operations-problem-model","page":"Operation Problem Structure","title":"Structure of an operations problem model","text":"","category":"section"},{"location":"model_developer_guide/structure_of_operation_problem/","page":"Operation Problem Structure","title":"Operation Problem Structure","text":"In most cases operation problem models are optimization models. Although in PowerSimulations.jl it is possible to define arbitrary problems that can reflect heuristic decision rules, this is not the common case. This page focuses on explaining the structure of operations problems that employ an optimization problem and solver.","category":"page"},{"location":"model_developer_guide/structure_of_operation_problem/","page":"Operation Problem Structure","title":"Operation Problem Structure","text":"The first aspect to consider when thinking about developing a model compatible with PowerSimulations.jl is that although we support all of JuMP.jl objects, you need to employ anonymous constraints and variables in JuMP and register the constraints, variables and other optimization objects into PowerSimulations.jl's optimization container. Otherwise the features to use your problem in the simulation like the coordination with other problems and post processing won't work.","category":"page"},{"location":"model_developer_guide/structure_of_operation_problem/","page":"Operation Problem Structure","title":"Operation Problem Structure","text":"info: Info\nThe requirements for the simulation of Power Systems operations are more strict than solving an optimization problem once with just JuMP.jl. The requirements imposed by PowerSimulations.jl to integrate your models in a simulation are designed to help with other complex operations that go beyond JuMP.jl scope.","category":"page"},{"location":"model_developer_guide/structure_of_operation_problem/","page":"Operation Problem Structure","title":"Operation Problem Structure","text":"warning: Warning\nAll the code in this page is considered \"pseudo-code\". Copy-paste will likely not work out of the box. You need to develop the internals of the functions correctly for the examples below to work.","category":"page"},{"location":"model_developer_guide/structure_of_operation_problem/#Registering-a-variable-in-the-model","page":"Operation Problem Structure","title":"Registering a variable in the model","text":"","category":"section"},{"location":"model_developer_guide/structure_of_operation_problem/","page":"Operation Problem Structure","title":"Operation Problem Structure","text":"To register a variable in the model, the developer must first allocate the container into the optimization container and then populate it. For example, it require start the build function as follows:","category":"page"},{"location":"model_developer_guide/structure_of_operation_problem/","page":"Operation Problem Structure","title":"Operation Problem Structure","text":"info: Info\nWe recommend calling import PowerSimulations and defining the constant CONST PSI = PowerSimulations to make it easier to read the code and determine which package is responsible for defining the functions.","category":"page"},{"location":"model_developer_guide/structure_of_operation_problem/","page":"Operation Problem Structure","title":"Operation Problem Structure","text":"    function PSI.build_model!(model::PSI.DecisionModel{MyCustomModel})\n        container = PSI.get_optimization_container(model)\n        PSI.set_time_steps!(container, 1:24)\n\n        # Create the container for the variable\n        variable = PSI.add_variable_container!(\n            container,\n            PSI.ActivePowerVariable(), # <- This variable is defined in PowerSimulations but the user can define their own\n            PSY.ThermalGeneration, # <- Device type for the variable. Can be from PSY or custom defined\n            devices_names, # <- First container dimension\n            time_steps, # <- Second container dimension\n        )\n\n        # Iterate over the devices and time to store the JuMP variables into the container.\n        for t in time_steps, d in devices\n            name = PSY.get_name(d)\n            variable[name, t] = JuMP.@variable(get_jump_model(container))\n            # It is possible to use PSY getter functions to retrieve data from the generators\n            # Any other variable property can be specified inside this loop.\n            JuMP.set_upper_bound(variable[name, t], UB_DATA) # <- Optional\n            JuMP.set_lower_bound(variable[name, t], LB_DATA) # <- Optional\n        end\n\n    return\n    end","category":"page"},{"location":"model_developer_guide/troubleshooting/#Troubleshooting-model-development","page":"Troubleshooting","title":"Troubleshooting model development","text":"","category":"section"},{"location":"formulation_library/README/#Formulation-documentation-guide","page":"Formulation documentation guide","title":"Formulation documentation guide","text":"","category":"section"},{"location":"formulation_library/README/","page":"Formulation documentation guide","title":"Formulation documentation guide","text":"Formulation documentation should roughly follow the template established by RenewableGen.md","category":"page"},{"location":"formulation_library/README/#Auto-generated-items","page":"Formulation documentation guide","title":"Auto generated items","text":"","category":"section"},{"location":"formulation_library/README/","page":"Formulation documentation guide","title":"Formulation documentation guide","text":"Valid DeviceModel table: just change the device category in the filter function\nTime Series Parameters: just change the device category and formulation in the get_default_time_series_names method call","category":"page"},{"location":"formulation_library/README/#Linked-items","page":"Formulation documentation guide","title":"Linked items","text":"","category":"section"},{"location":"formulation_library/README/","page":"Formulation documentation guide","title":"Formulation documentation guide","text":"Formulations in the Valid DeviceModel table must have a docstring in src/core/formulations.jl\nThe Formulation in the @docs block must have a docstring in src/core/formulations.jl\nThe Variables must have docstrings in src/core/variables.jl \nThe Time Series Parameters must have docstrings in src/core/parameters.jl","category":"page"},{"location":"tutorials/pcm_simulation/#pcm_tutorial","page":"Multi-stage Production Cost Simulation","title":"Sequential Simulations with PowerSimulations.jl","text":"","category":"section"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"Originally Contributed by: Clayton Barrows","category":"page"},{"location":"tutorials/pcm_simulation/#Introduction","page":"Multi-stage Production Cost Simulation","title":"Introduction","text":"","category":"section"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"PowerSimulations.jl supports simulations that consist of sequential optimization problems where results from previous problems inform subsequent problems in a variety of ways. This example demonstrates some of these capabilities to represent electricity market clearing. This example is intended to be an extension of the OperationsProblem tutorial.","category":"page"},{"location":"tutorials/pcm_simulation/#Load-Packages","page":"Multi-stage Production Cost Simulation","title":"Load Packages","text":"","category":"section"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"using PowerSystems\nusing PowerSimulations\nconst PSI = PowerSimulations\nusing PowerSystemCaseBuilder\nusing Dates\nusing HiGHS #solver","category":"page"},{"location":"tutorials/pcm_simulation/#Optimizer","page":"Multi-stage Production Cost Simulation","title":"Optimizer","text":"","category":"section"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"It's most convenient to define an optimizer instance upfront and pass it into the DecisionModel constructor. For this example, we can use the free HiGHS solver with a relatively relaxed MIP gap (ratioGap) setting to improve speed.","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"solver = optimizer_with_attributes(HiGHS.Optimizer, \"mip_rel_gap\" => 0.5)","category":"page"},{"location":"tutorials/pcm_simulation/#Hourly-day-ahead-system","page":"Multi-stage Production Cost Simulation","title":"Hourly day-ahead system","text":"","category":"section"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"First, we'll create a System with hourly data to represent day-ahead forecasted wind, solar, and load profiles:","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"sys_DA = build_system(PSISystems, \"modified_RTS_GMLC_DA_sys\")","category":"page"},{"location":"tutorials/pcm_simulation/#Minute-system","page":"Multi-stage Production Cost Simulation","title":"5-Minute system","text":"","category":"section"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"The RTS data also includes 5-minute resolution time series data. So, we can create another System to represent 15 minute ahead forecasted data for a \"real-time\" market:","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"sys_RT = build_system(PSISystems, \"modified_RTS_GMLC_RT_sys\")","category":"page"},{"location":"tutorials/pcm_simulation/#ProblemTemplates-define-stages","page":"Multi-stage Production Cost Simulation","title":"ProblemTemplates define stages","text":"","category":"section"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"Sequential simulations in PowerSimulations are created by defining OperationsProblems that represent stages, and how information flows between executions of a stage and between different stages.","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"Let's start by defining a two stage simulation that might look like a typical day-Ahead and real-time electricity market clearing process.","category":"page"},{"location":"tutorials/pcm_simulation/#Day-ahead-unit-commitment-stage","page":"Multi-stage Production Cost Simulation","title":"Day-ahead unit commitment stage","text":"","category":"section"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"First, we can define a unit commitment template for the day ahead problem. We can use the included UC template, but in this example, we'll replace the ThermalBasicUnitCommitment with the slightly more complex ThermalStandardUnitCommitment for the thermal generators.","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"template_uc = template_unit_commitment()\nset_device_model!(template_uc, ThermalStandard, ThermalStandardUnitCommitment)","category":"page"},{"location":"tutorials/pcm_simulation/#Define-the-reference-model-for-the-real-time-economic-dispatch","page":"Multi-stage Production Cost Simulation","title":"Define the reference model for the real-time economic dispatch","text":"","category":"section"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"In addition to the manual specification process demonstrated in the OperationsProblem example, PSI also provides pre-specified templates for some standard problems:","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"template_ed = template_economic_dispatch(\n    network = NetworkModel(StandardPTDFModel, use_slacks = true),\n)","category":"page"},{"location":"tutorials/pcm_simulation/#Define-the-SimulationModels","page":"Multi-stage Production Cost Simulation","title":"Define the SimulationModels","text":"","category":"section"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"DecisionModels define the problems that are executed in the simulation. The actual problem will change as the stage gets updated to represent different time periods, but the formulations applied to the components is constant within a stage. In this case, we want to define two stages with the ProblemTemplates and the Systems that we've already created.","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"models = SimulationModels(\n    decision_models = [\n        DecisionModel(template_uc, sys_DA, optimizer = solver, name = \"UC\"),\n        DecisionModel(template_ed, sys_RT, optimizer = solver, name = \"ED\"),\n    ],\n)","category":"page"},{"location":"tutorials/pcm_simulation/#SimulationSequence","page":"Multi-stage Production Cost Simulation","title":"SimulationSequence","text":"","category":"section"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"Similar to an ProblemTemplate, the SimulationSequence provides a template of how to execute a sequential set of operations problems.","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"Let's review some of the SimulationSequence arguments.","category":"page"},{"location":"tutorials/pcm_simulation/#Chronologies","page":"Multi-stage Production Cost Simulation","title":"Chronologies","text":"","category":"section"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"In PowerSimulations, chronologies define where information is flowing. There are two types of chronologies.","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"inter-stage chronologies: Define how information flows between stages. e.g. day-ahead solutions are used to inform economic dispatch problems\nintra-stage chronologies: Define how information flows between multiple executions of a single stage. e.g. the dispatch setpoints of the first period of an economic dispatch problem are constrained by the ramping limits from setpoints in the final period of the previous problem.","category":"page"},{"location":"tutorials/pcm_simulation/#FeedForward","page":"Multi-stage Production Cost Simulation","title":"FeedForward","text":"","category":"section"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"The definition of exactly what information is passed using the defined chronologies is accomplished with FeedForward. Specifically, FeedForward is used to define what to do with information being passed with an inter-stage chronology. Let's define a FeedForward that affects the semi-continuous range constraints of thermal generators in the economic dispatch problems based on the value of the unit-commitment variables.","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"feedforward = Dict(\n    \"ED\" => [\n        SemiContinuousFeedforward(\n            component_type = ThermalStandard,\n            source = OnVariable,\n            affected_values = [ActivePowerVariable],\n        ),\n    ],\n)","category":"page"},{"location":"tutorials/pcm_simulation/#Sequencing","page":"Multi-stage Production Cost Simulation","title":"Sequencing","text":"","category":"section"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"The stage problem length, look-ahead, and other details surrounding the temporal Sequencing of stages are controlled using the structure of the time series data in the Systems. So, to define a typical day-ahead - real-time sequence:","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"Day ahead problems should represent 48 hours, advancing 24 hours after each execution (24-hour look-ahead)\nReal time problems should represent 1 hour (12 5-minute periods), advancing 15 min after each execution (15 min look-ahead)","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"We can adjust the time series data to reflect this structure in each System:","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"transform_single_time_series!(sys_DA, 48, Hour(1))\ntransform_single_time_series!(sys_RT, 12, Minute(15))","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"Now we can put it all together to define a SimulationSequence","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"DA_RT_sequence = SimulationSequence(\n    models = models,\n    ini_cond_chronology = InterProblemChronology(),\n    feedforwards = feedforward,\n)","category":"page"},{"location":"tutorials/pcm_simulation/#Simulation","page":"Multi-stage Production Cost Simulation","title":"Simulation","text":"","category":"section"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"Now, we can build and execute a simulation using the SimulationSequence and Stages that we've defined.","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"sim = Simulation(\n    name = \"rts-test\",\n    steps = 2,\n    models = models,\n    sequence = DA_RT_sequence,\n    simulation_folder = mktempdir(\".\", cleanup = true),\n)","category":"page"},{"location":"tutorials/pcm_simulation/#Build-simulation","page":"Multi-stage Production Cost Simulation","title":"Build simulation","text":"","category":"section"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"build!(sim)","category":"page"},{"location":"tutorials/pcm_simulation/#Execute-simulation","page":"Multi-stage Production Cost Simulation","title":"Execute simulation","text":"","category":"section"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"the following command returns the status of the simulation (0: is proper execution) and stores the results in a set of HDF5 files on disk.","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"execute!(sim, enable_progress_bar = false)","category":"page"},{"location":"tutorials/pcm_simulation/#Results","page":"Multi-stage Production Cost Simulation","title":"Results","text":"","category":"section"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"To access the results, we need to load the simulation result metadata and then make requests to the specific data of interest. This allows you to efficiently access the results of interest without overloading resources.","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"results = SimulationResults(sim);\nuc_results = get_decision_problem_results(results, \"UC\"); # UC stage result metadata\ned_results = get_decision_problem_results(results, \"ED\"); # ED stage result metadata","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"We can read all the result variables","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"read_variables(uc_results)","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"or all the parameters","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"read_parameters(uc_results)","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"We can just list the variable names contained in uc_results:","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"list_variable_names(uc_results)","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"and a number of parameters (this pattern also works for aux_variables, expressions, and duals)","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"list_parameter_names(uc_results)","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"Now we can read the specific results of interest for a specific problem, time window (optional), and set of variables, duals, or parameters (optional)","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"Dict([\n    v => read_variable(uc_results, v) for v in [\n        \"ActivePowerVariable__RenewableDispatch\",\n        \"ActivePowerVariable__HydroDispatch\",\n        \"StopVariable__ThermalStandard\",\n    ]\n])","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"Or if we want the result of just one variable, parameter, or dual (must be defined in the problem definition), we can use:","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"read_parameter(\n    ed_results,\n    \"ActivePowerTimeSeriesParameter__RenewableFix\",\n    initial_time = DateTime(\"2020-01-01T06:00:00\"),\n    count = 5,\n)","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"note that this returns the results of each execution step in a separate dataframe *","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"If you want the realized results (without lookahead periods), you can call read_realized_*:","category":"page"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"read_realized_variables(\n    uc_results,\n    [\"ActivePowerVariable__ThermalStandard\", \"ActivePowerVariable__RenewableDispatch\"],\n)","category":"page"},{"location":"tutorials/pcm_simulation/#Plotting","page":"Multi-stage Production Cost Simulation","title":"Plotting","text":"","category":"section"},{"location":"tutorials/pcm_simulation/","page":"Multi-stage Production Cost Simulation","title":"Multi-stage Production Cost Simulation","text":"Take a look at the plotting capabilities in PowerGraphics.jl","category":"page"},{"location":"modeler_guide/running_a_simulation/#running_a_simulation","page":"Simulation","title":"Simulation","text":"","category":"section"},{"location":"modeler_guide/running_a_simulation/","page":"Simulation","title":"Simulation","text":"tip: Always try to solve the operations problem first before putting together the simulation\nIt is not uncommon that when trying to solve a complex simulation the resulting models are infeasible. This situation can be the result of many factors like the input data, the incorrect specification of the initial conditions for models with time dependencies or a poorly specified model. Therefore, it's highly recommended to run and analyze an Operations Problems that reflect the problems that will be included in a simulation prior to executing a simulation.","category":"page"},{"location":"modeler_guide/running_a_simulation/","page":"Simulation","title":"Simulation","text":"Check out the Operations Problem Tutorial","category":"page"},{"location":"modeler_guide/running_a_simulation/#Feedforward","page":"Simulation","title":"Feedforward","text":"","category":"section"},{"location":"modeler_guide/running_a_simulation/","page":"Simulation","title":"Simulation","text":"TODO","category":"page"},{"location":"modeler_guide/running_a_simulation/#Sequencing","page":"Simulation","title":"Sequencing","text":"","category":"section"},{"location":"modeler_guide/running_a_simulation/","page":"Simulation","title":"Simulation","text":"In a typical simulation pipeline, we want to connect daily (24-hours) day-ahead unit commitment problems, with multiple economic dispatch problems. Usually, our day-ahead unit commitment problem will have an hourly (1-hour) resolution, while the economic dispatch will have a 5-minute resolution.","category":"page"},{"location":"modeler_guide/running_a_simulation/","page":"Simulation","title":"Simulation","text":"Depending on your problem, it is common to use a 2-day look-ahead for unit commitment problems, so in this case, the Day-Ahead problem will have: resolution = Hour(1) with interval = Hour(24) and horizon = 48. In the case of the economic dispatch problem, it is common to use a look-ahead of two hours. Thus, the Real-Time problem will have: resolution = Minute(5), with interval = Minute(5) (we only store the first operating point) and horizon = 24 (24 time steps of 5 minutes are 120 minutes, that is 2 hours).","category":"page"},{"location":"tutorials/adding_new_device_formulation/#Adding-Device-Formulations","page":"Adding Device Formulations","title":"Adding Device Formulations","text":"","category":"section"},{"location":"formulation_library/Network/#network_formulations","page":"Network","title":"Network Formulations","text":"","category":"section"},{"location":"formulation_library/Network/","page":"Network","title":"Network","text":"TODO","category":"page"},{"location":"formulation_library/Load/#PowerSystems.ElectricLoad-Formulations","page":"Load","title":"PowerSystems.ElectricLoad Formulations","text":"","category":"section"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Valid DeviceModels for subtypes of ElectricLoad include the following:","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"using PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.generate_device_formulation_combinations()\nfilter!(x -> x[\"device_type\"] <: ElectricLoad, combos)\ncombo_table = DataFrame(\n    \"Valid DeviceModel\" => [\"`DeviceModel($(c[\"device_type\"]), $(c[\"formulation\"]))`\" for c in combos],\n    \"Device Type\" => [\"[$(c[\"device_type\"])](https://nrel-Sienna.github.io/PowerSystems.jl/stable/model_library/generated_$(c[\"device_type\"])/)\" for c in combos],\n    \"Formulation\" => [\"[$(c[\"formulation\"])](@ref)\" for c in combos],\n    )\nmdtable(combo_table, latex = false)","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"","category":"page"},{"location":"formulation_library/Load/#StaticPowerLoad","page":"Load","title":"StaticPowerLoad","text":"","category":"section"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"StaticPowerLoad","category":"page"},{"location":"formulation_library/Load/#PowerSimulations.StaticPowerLoad","page":"Load","title":"PowerSimulations.StaticPowerLoad","text":"Formulation type to add a time series parameter for non-dispatchable ElectricLoad withdrawls to power balance constraints\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Variables:","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"No variables are created","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Time Series Parameters:","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"using PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.get_default_time_series_names(ElectricLoad, StaticPowerLoad)\ncombo_table = DataFrame(\n    \"Parameter\" => map(x -> \"[`$x`](@ref)\", collect(keys(combos))),\n    \"Default Time Series Name\" => map(x -> \"`$x`\", collect(values(combos))),\n    )\nmdtable(combo_table, latex = false)","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Expressions:","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Subtracts the parameters listed above from the respective active and reactive power balance expressions created by the selected Network Formulations","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Constraints:","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"No constraints are created","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"","category":"page"},{"location":"formulation_library/Load/#PowerLoadInterruption","page":"Load","title":"PowerLoadInterruption","text":"","category":"section"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"PowerLoadInterruption","category":"page"},{"location":"formulation_library/Load/#PowerSimulations.PowerLoadInterruption","page":"Load","title":"PowerSimulations.PowerLoadInterruption","text":"Formulation type to enable (binary) load interruptions\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Variables:","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"ActivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: 0.0\nReactivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: 0.0\nOnVariable:\nBounds: {0,1}\nDefault initial value: 1","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Time Series Parameters:","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"using PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.get_default_time_series_names(ElectricLoad, PowerLoadInterruption)\ncombo_table = DataFrame(\n    \"Parameter\" => map(x -> \"[`$x`](@ref)\", collect(keys(combos))),\n    \"Default Time Series Name\" => map(x -> \"`$x`\", collect(values(combos))),\n    )\nmdtable(combo_table, latex = false)","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Objective:","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Creates an objective function term based on the VariableCost Options where the quantity term is defined as Pg.","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Expressions:","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Adds Pg and Qg terms and to the respective active and reactive power balance expressions created by the selected Network Formulations\nSubtracts the time series parameters listed above terms from the respective active and reactive power balance expressions created by the selected Network Formulations","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Constraints:","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Pg and Qg represent the \"unserved\" active and reactive power loads","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"beginaligned\n  Pg_t le ActivePowerTimeSeriesParameter_t\n  Pg_t - u_t ActivePowerTimeSeriesParameter_t le 0 \n  Qg_t le ReactivePowerTimeSeriesParameter_t\n  Qg_t - u_t ReactivePowerTimeSeriesParameter_tle 0\nendaligned","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"","category":"page"},{"location":"formulation_library/Load/#PowerLoadDispatch","page":"Load","title":"PowerLoadDispatch","text":"","category":"section"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"PowerLoadDispatch","category":"page"},{"location":"formulation_library/Load/#PowerSimulations.PowerLoadDispatch","page":"Load","title":"PowerSimulations.PowerLoadDispatch","text":"Formulation type to enable (continuous) load interruption dispatch\n\n\n\n\n\n","category":"type"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Variables:","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"ActivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_active_power(device)\nReactivePowerVariable:\nBounds: [0.0, ]\nDefault initial value: PowerSystems.get_reactive_power(device)","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Time Series Parameters:","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"using PowerSimulations\nusing PowerSystems\nusing DataFrames\nusing Latexify\ncombos = PowerSimulations.get_default_time_series_names(ElectricLoad, PowerLoadDispatch)\ncombo_table = DataFrame(\n    \"Parameter\" => map(x -> \"[`$x`](@ref)\", collect(keys(combos))),\n    \"Default Time Series Name\" => map(x -> \"`$x`\", collect(values(combos))),\n    )\nmdtable(combo_table, latex = false)","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Objective:","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Creates an objective function term based on the VariableCost Options where the quantity term is defined as Pg.","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Expressions:","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Adds Pg and Qg terms and to the respective active and reactive power balance expressions created by the selected Network Formulations\nSubtracts the time series parameters listed above terms from the respective active and reactive power balance expressions created by the selected Network Formulations","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Constraints:","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"Pg and Qg represent the \"unserved\" active and reactive power loads","category":"page"},{"location":"formulation_library/Load/","page":"Load","title":"Load","text":"beginaligned\n  Pg_t le ActivePowerTimeSeriesParameter_t\n  Qg_t le ReactivePowerTimeSeriesParameter_t\nendaligned","category":"page"},{"location":"#PowerSimulations.jl","page":"Welcome Page","title":"PowerSimulations.jl","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"CurrentModule = PowerSimulations","category":"page"},{"location":"#Overview","page":"Welcome Page","title":"Overview","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"PowerSimulations.jl is a power system operations simulation tool developed as a flexible and open source software for quasi-static power systems simulations including Production Cost Models. PowerSimulations.jl tackles the issues of developing a simulation model in a modular way providing tools for the formulation of decision models and emulation models that can be solved independently or in an interconnected fashion.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"PowerSimulations.jl supports the workflows to develop simulations by separating the development of operations models and simulation models.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"Operation Models: Optimization model used to find the solution of an operation problem.\nSimulations Models: Defined the requirements to find solutions to a sequence of operation problems in a way that resembles the procedures followed by operators.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"The most common Simulation Model is the solution of a Unit Commitment and Economic Dispatch sequence of problems. This model is used in commercial Production Cost Modeling tools, but it has a limited scope of analysis.","category":"page"},{"location":"#How-the-documentation-is-structured","page":"Welcome Page","title":"How the documentation is structured","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"PowerSimulations.jl documentation and code are organized according to the needs of different users depending on their skillset and requirements. In broad terms there are three categories:","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"Modeler: Users that want to solve an operations problem or run a simulation using the existing models in PowerSimulations.jl. For instance, answer questions about the change in operation costs in future fuel mixes. Check the formulations library page to choose a modeling strategy that fits your needs.\nModel Developer: Users that want to develop custom models and workflows for the simulation of a power system operation. For instance, study the impacts of an stochastic optimization problem over a deterministic.\nCode Base Developers: Users that want to add new core functionalities or fix bugs in the core capabilities of PowerSimulations.jl.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"PowerSimulations.jl is an active project under development, and we welcome your feedback, suggestions, and bug reports.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"Note: PowerSimulations.jl uses the data model implemented in PowerSystems.jl to construct optimization models. In most cases, you need to add PowerSystems.jl to your scripts.","category":"page"},{"location":"#Installation","page":"Welcome Page","title":"Installation","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"The latest stable release of PowerSimulations can be installed using the Julia package manager with","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"] add PowerSimulations","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"For the current development version, \"checkout\" this package with","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"] add PowerSimulations#main","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"An appropriate optimization solver is required for running PowerSimulations models. Refer to JuMP.jl solver's page to select the most appropriate for the application of interest.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"PowerSystems has been developed as part of the Scalable Integrated Infrastructure Planning (SIIP) initiative at the U.S. Department of Energy's National Renewable Energy Laboratory (NREL).","category":"page"}]
}
