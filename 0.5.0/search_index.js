var documenterSearchIndex = {"docs":
[{"location":"man/simulation_recorder/#Simulation-Recorder-1","page":"Simulation Recorder","title":"Simulation Recorder","text":"","category":"section"},{"location":"man/simulation_recorder/#","page":"Simulation Recorder","title":"Simulation Recorder","text":"PowerSimulations provides the ability to record structured data as events during a simulation. These events can be post-processed to help debug problems.","category":"page"},{"location":"man/simulation_recorder/#","page":"Simulation Recorder","title":"Simulation Recorder","text":"By default only SimulationStepEvent and SimulationStageEvent are recorded.  Here is an example.","category":"page"},{"location":"man/simulation_recorder/#","page":"Simulation Recorder","title":"Simulation Recorder","text":"Suppose a simulation is run in the directory ./output.","category":"page"},{"location":"man/simulation_recorder/#","page":"Simulation Recorder","title":"Simulation Recorder","text":"Assume that setup commands have been run:","category":"page"},{"location":"man/simulation_recorder/#","page":"Simulation Recorder","title":"Simulation Recorder","text":"using PowerSimulations\nconst PSI = PowerSimulations","category":"page"},{"location":"man/simulation_recorder/#","page":"Simulation Recorder","title":"Simulation Recorder","text":"Note that for all functions below you can optionally specify a function to filter events. The function must accept the event type and return true or false.","category":"page"},{"location":"man/simulation_recorder/#Show-all-events-of-type-PSI.SimulationStepEvent-1","page":"Simulation Recorder","title":"Show all events of type PSI.SimulationStepEvent","text":"","category":"section"},{"location":"man/simulation_recorder/#","page":"Simulation Recorder","title":"Simulation Recorder","text":"julia> show_simulation_events(PSI.SimulationStepEvent, \"./output/aggregation/1\")\n┌─────────────────────┬─────────────────────┬──────┬────────┐\n│                name │     simulation_time │ step │ status │\n├─────────────────────┼─────────────────────┼──────┼────────┤\n│ SimulationStepEvent │ 2024-01-01T00:00:00 │    1 │  start │\n│ SimulationStepEvent │ 2024-01-01T23:00:00 │    1 │   done │\n│ SimulationStepEvent │ 2024-01-01T23:00:00 │    2 │  start │\n│ SimulationStepEvent │ 2024-01-02T23:00:00 │    2 │   done │\n└─────────────────────┴─────────────────────┴──────┴────────┘","category":"page"},{"location":"man/simulation_recorder/#Show-events-of-type-PSI.SimulationStageEvent-for-a-specific-step-and-stage.-1","page":"Simulation Recorder","title":"Show events of type PSI.SimulationStageEvent for a specific step and stage.","text":"","category":"section"},{"location":"man/simulation_recorder/#","page":"Simulation Recorder","title":"Simulation Recorder","text":"show_simulation_events(\n    PSI.SimulationStageEvent,\n    \"./output/aggregation/1\",\n    x -> x.step == 1 && x.stage == 2 && x.status == \"start\"\n)\n┌──────────────────────┬─────────────────────┬──────┬───────┬────────┐\n│                 name │     simulation_time │ step │ stage │ status │\n├──────────────────────┼─────────────────────┼──────┼───────┼────────┤\n│ SimulationStageEvent │ 2024-01-01T00:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T00:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T01:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T02:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T03:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T04:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T05:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T06:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T07:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T08:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T09:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T10:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T11:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T12:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T13:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T14:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T15:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T16:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T17:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T18:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T19:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T20:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T21:00:00 │    1 │     2 │  start │\n│ SimulationStageEvent │ 2024-01-01T22:00:00 │    1 │     2 │  start │\n└──────────────────────┴─────────────────────┴──────┴───────┴────────┘","category":"page"},{"location":"man/simulation_recorder/#Enable-other-recorder-events-1","page":"Simulation Recorder","title":"Enable other recorder events","text":"","category":"section"},{"location":"man/simulation_recorder/#","page":"Simulation Recorder","title":"Simulation Recorder","text":"Other types of recorder events can be enabled with a possible performance impact. To do this pass in the specific recorder names to be enabled when you call build.","category":"page"},{"location":"man/simulation_recorder/#","page":"Simulation Recorder","title":"Simulation Recorder","text":"sim = Simulation(...)\nrecorders = [:simulation]\nbuild!(sim; recorders = recorders)\nexecute!(sim)","category":"page"},{"location":"man/simulation_recorder/#","page":"Simulation Recorder","title":"Simulation Recorder","text":"Now we can examine InitialConditionUpdateEvents for specific steps and stages.","category":"page"},{"location":"man/simulation_recorder/#","page":"Simulation Recorder","title":"Simulation Recorder","text":"show_simulation_events(\n    PSI.InitialConditionUpdateEvent,\n    \"./output/aggregation/1\",\n    x -> x.initial_condition_type == \"DeviceStatus\";\n    step = 2,\n    stage = 1\n)\n┌─────────────────────────────┬─────────────────────┬────────────────────────┬─────────────────┬─────────────┬─────┬──────────────┐\n│                        name │     simulation_time │ initial_condition_type │     device_type │ device_name │ val │ stage_number │\n├─────────────────────────────┼─────────────────────┼────────────────────────┼─────────────────┼─────────────┼─────┼──────────────┤\n│ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Solitude │ 0.0 │            1 │\n│ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │   Park City │ 1.0 │            1 │\n│ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │        Alta │ 1.0 │            1 │\n│ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Brighton │ 1.0 │            1 │\n│ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Sundance │ 0.0 │            1 │\n└─────────────────────────────┴─────────────────────┴────────────────────────┴─────────────────┴─────────────┴─────┴──────────────┘","category":"page"},{"location":"man/simulation_recorder/#Show-the-wall-time-with-your-events-1","page":"Simulation Recorder","title":"Show the wall time with your events","text":"","category":"section"},{"location":"man/simulation_recorder/#","page":"Simulation Recorder","title":"Simulation Recorder","text":"Sometimes you might want to see how the events line up with the wall time.","category":"page"},{"location":"man/simulation_recorder/#","page":"Simulation Recorder","title":"Simulation Recorder","text":"show_simulation_events(\n    PSI.InitialConditionUpdateEvent,\n    \"./output/aggregation/1\",\n    x -> x.initial_condition_type == \"DeviceStatus\";\n    step = 2,\n    stage = 1,\n    wall_time = true\n)\n┌─────────────────────────┬─────────────────────────────┬─────────────────────┬────────────────────────┬─────────────────┬─────────────┬─────┬──────────────┐\n│               timestamp │                        name │     simulation_time │ initial_condition_type │     device_type │ device_name │ val │ stage_number │\n├─────────────────────────┼─────────────────────────────┼─────────────────────┼────────────────────────┼─────────────────┼─────────────┼─────┼──────────────┤\n│ 2020-04-07T15:08:32.711 │ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Solitude │ 0.0 │            1 │\n│ 2020-04-07T15:08:32.711 │ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │   Park City │ 1.0 │            1 │\n│ 2020-04-07T15:08:32.711 │ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │        Alta │ 1.0 │            1 │\n│ 2020-04-07T15:08:32.711 │ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Brighton │ 1.0 │            1 │\n│ 2020-04-07T15:08:32.711 │ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Sundance │ 0.0 │            1 │\n└─────────────────────────┴─────────────────────────────┴─────────────────────┴────────────────────────┴─────────────────┴─────────────┴─────┴──────────────┘","category":"page"},{"location":"api/PowerSimulations/#PowerSimulations-1","page":"PowerSimulations","title":"PowerSimulations","text":"","category":"section"},{"location":"api/PowerSimulations/#","page":"PowerSimulations","title":"PowerSimulations","text":"CurrentModule = PowerSimulations\nDocTestSetup  = quote\n    using PowerSimulations\nend","category":"page"},{"location":"api/PowerSimulations/#","page":"PowerSimulations","title":"PowerSimulations","text":"API documentation","category":"page"},{"location":"api/PowerSimulations/#","page":"PowerSimulations","title":"PowerSimulations","text":"Pages = [\"PowerSimulations.md\"]","category":"page"},{"location":"api/PowerSimulations/#Index-1","page":"PowerSimulations","title":"Index","text":"","category":"section"},{"location":"api/PowerSimulations/#","page":"PowerSimulations","title":"PowerSimulations","text":"Pages = [\"PowerSimulations.md\"]","category":"page"},{"location":"api/PowerSimulations/#Exported-1","page":"PowerSimulations","title":"Exported","text":"","category":"section"},{"location":"api/PowerSimulations/#","page":"PowerSimulations","title":"PowerSimulations","text":"Modules = [PowerSimulations]\nPrivate = false","category":"page"},{"location":"api/PowerSimulations/#PowerSimulations.DeviceModel","page":"PowerSimulations","title":"PowerSimulations.DeviceModel","text":"DeviceModel(::Type{D}, ::Type{B}) where {D<:PSY.Device,\n                                   B<:AbstractDeviceFormulation}\n\nThis validates the device formulation for the Power System Device and the abstract device formulation and returns  Power System Device and the abstract device formulation if the power system device is a concrete type.\n\nArguments\n\n-::Type{D}: Power System Device -::Type{B}: Abstract Device Formulation\n\nOutputs\n\nDeviceModel(D, B, nothing): D::PSY.Device, B::AbstractDeviceFormulation\n\nExample\n\nbranches = Dict{Symbol, DeviceModel}\n    (:L => DeviceModel(PSY.Line, StaticLine),\n    :T => DeviceModel(PSY.Transformer2W, StaticTransformer),\n    :TT => DeviceModel(PSY.TapTransformer , StaticTransformer),\n    :dc_line => DeviceModel(PSY.HVDCLine, HVDCDispatch))\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.IntraStageChronology","page":"PowerSimulations","title":"PowerSimulations.IntraStageChronology","text":"InterStageChronology()\n\nType struct to select an information sharing model between stages that uses results from the same recent stage to calculate the initial conditions. This model ignores solutions from stages defined finer resolutions.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.OperationsProblem-Tuple{AbstractString}","page":"PowerSimulations","title":"PowerSimulations.OperationsProblem","text":"OperationsProblem(filename::AbstractString)\n\nConstruct an OperationsProblem from a serialized file.\n\nArguments\n\nfilename::AbstractString: path to serialized file\njump_model::Union{Nothing, JuMP.AbstractModel} = nothing: The JuMP model does not get  serialized. Callers should pass whatever they passed to the original problem.\noptimizer::Union{Nothing,JuMP.MOI.OptimizerWithAttributes} = nothing: The optimizer does  not get serialized. Callers should pass whatever they passed to the original problem.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.OperationsProblem-Union{Tuple{M}, Tuple{Type{M},OperationsProblemTemplate,PowerSystems.System}, Tuple{Type{M},OperationsProblemTemplate,PowerSystems.System,Union{Nothing, JuMP.AbstractModel}}} where M<:PowerSimulations.AbstractOperationsProblem","page":"PowerSimulations","title":"PowerSimulations.OperationsProblem","text":"OperationsProblem(::Type{M},\ntemplate::OperationsProblemTemplate,\nsys::PSY.System,\njump_model::Union{Nothing, JuMP.AbstractModel}=nothing;\nkwargs...) where {M<:AbstractOperationsProblem,\n                  T<:PM.AbstractPowerFormulation}\n\nThis builds the optimization problem of type M with the specific system and template.\n\nArguments\n\n::Type{M} where M<:AbstractOperationsProblem: The abstract operation model type\ntemplate::OperationsProblemTemplate: The model reference made up of transmission, devices,                                         branches, and services.\nsys::PSY.System: the system created using Power Systems\njump_model::Union{Nothing, JuMP.AbstractModel}: Enables passing a custom JuMP model. Use with care\n\nOutput\n\nop_problem::OperationsProblem: The operation model containing the model type, built JuMP model, Power\n\nSystems system.\n\nExample\n\ntemplate = OperationsProblemTemplate(CopperPlatePowerModel, devices, branches, services)\nOpModel = OperationsProblem(TestOpProblem, template, system)\n\nAccepted Key Words\n\nHorizon::Int: Manually specify the length of the forecast Horizon\ninitial_time::Dates.DateTime: Initial Time for the model solve\nuse_forecast_data::Bool : If true uses the data in the system forecasts. If false uses the data for current operating point in the system.\nPTDF::PTDF: Passes the PTDF matrix into the optimization model for StandardPTDFModel networks.\noptimizer::JuMP.MOI.OptimizerWithAttributes: The optimizer that will be used in the optimization model.\nuse_parameters::Bool: True will substitute will implement formulations using ParameterJuMP parameters. Defatul is false.\nwarm_start::Bool True will use the current operation point in the system to initialize variable values. False initializes all variables to zero. Default is true\nslack_variables::Bool True will add slacks to the system balance constraints\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.OperationsProblem-Union{Tuple{T}, Tuple{M}, Tuple{Type{M},Type{T},PowerSystems.System}, Tuple{Type{M},Type{T},PowerSystems.System,Union{Nothing, JuMP.AbstractModel}}} where T<:PowerModels.AbstractPowerModel where M<:PowerSimulations.AbstractOperationsProblem","page":"PowerSimulations","title":"PowerSimulations.OperationsProblem","text":"OperationsProblem(op_problem::Type{M},\n                ::Type{T},\n                sys::PSY.System,\n                jump_model::Union{Nothing, JuMP.AbstractModel}=nothing;\n                kwargs...) where {M<:AbstractOperationsProblem,\n                                  T<:PM.AbstractPowerFormulation}\n\nReturn an unbuilt operation problem of type M with the specific system and network model T.     This constructor doesn't build any device model; it is meant to built device models individually using construct_device!\n\nArguments\n\n::Type{M} where M<:AbstractOperationsProblem: The abstract operation model type\n::Type{T} where T<:AbstractPowerModel: The abstract network formulation\nsys::PSY.System: the system created using Power Systems\njump_model::Union{Nothing, JuMP.AbstractModel}: Enables passing a custom JuMP model. Use with care\n\nOutput\n\nop_problem::OperationsProblem: The operation model containing the model type, unbuilt JuMP model, Power\n\nSystems system.\n\nExample\n\nOpModel = OperationsProblem(MyCustomOpProblem, DCPPowerModel, system)\nmodel = DeviceModel(ThermalStandard, ThermalStandardUnitCommitment)\nconstruct_device!(op_problem, :Thermal, model)\n\nAccepted Key Words\n\nHorizon::Int: Manually specify the length of the forecast Horizon\ninitial_time::Dates.DateTime: Initial Time for the model solve\nuse_forecast_data::Bool : If true uses the data in the system forecasts. If false uses the data for current operating point in the system.\nPTDF::PTDF: Passes the PTDF matrix into the optimization model for StandardPTDFModel networks.\noptimizer::JuMP.MOI.OptimizerWithAttributes: The optimizer that will be used in the optimization model.\nuse_parameters::Bool: True will substitute will implement formulations using ParameterJuMP parameters. Defatul is false.\nwarm_start::Bool True will use the current operation point in the system to initialize variable values. False initializes all variables to zero. Default is true\nslack_variables::Bool True will add slacks to the system balance constraints\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.OperationsProblem-Union{Tuple{T}, Tuple{Type{T},PowerSystems.System}, Tuple{Type{T},PowerSystems.System,Union{Nothing, JuMP.AbstractModel}}} where T<:PowerModels.AbstractPowerModel","page":"PowerSimulations","title":"PowerSimulations.OperationsProblem","text":"OperationsProblem(::Type{T},\n                sys::PSY.System,\n                jump_model::Union{Nothing, JuMP.AbstractModel}=nothing;\n                kwargs...) where {M<:AbstractOperationsProblem,\n                                  T<:PM.AbstractPowerFormulation}\n\nReturn an unbuilt operation problem of type GenericOpProblem with the specific system and network model T.     This constructor doesn't build any device model; it is meant to built device models individually using construct_device!\n\nArguments\n\n::Type{T} where T<:AbstractPowerModel: The abstract network formulation\nsys::PSY.System: the system created using Power Systems\njump_model::Union{Nothing, JuMP.AbstractModel}: Enables passing a custom JuMP model. Use with care\n\nOutput\n\nop_problem::OperationsProblem: The operation model containing the model type, unbuilt JuMP model, Power\n\nSystems system.\n\nExample\n\nOpModel = OperationsProblem(DCPPowerModel, system)\nmodel = DeviceModel(ThermalStandard, ThermalStandardUnitCommitment)\nconstruct_device!(op_problem, :Thermal, model)\n\nAccepted Key Words\n\nHorizon::Int: Manually specify the length of the forecast Horizon\ninitial_time::Dates.DateTime: Initial Time for the model solve\nuse_forecast_data::Bool : If true uses the data in the system forecasts. If false uses the data for current operating point in the system.\nPTDF::PTDF: Passes the PTDF matrix into the optimization model for StandardPTDFModel networks.\noptimizer::JuMP.MOI.OptimizerWithAttributes: The optimizer that will be used in the optimization model.\nuse_parameters::Bool: True will substitute will implement formulations using ParameterJuMP parameters. Defatul is false.\nwarm_start::Bool True will use the current operation point in the system to initialize variable values. False initializes all variables to zero. Default is true\nslack_variables::Bool True will add slacks to the system balance constraints\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.OperationsProblemTemplate-Union{Tuple{Type{T}}, Tuple{T}} where T<:PowerModels.AbstractPowerModel","page":"PowerSimulations","title":"PowerSimulations.OperationsProblemTemplate","text":"OperationsProblemTemplate(::Type{T}) where {T<:PM.AbstractPowerFormulation}\n\nCreates a model reference of the Power Formulation, devices, branches, and services.\n\nArguments\n\nmodel::Type{T<:PM.AbstractPowerFormulation}:\ndevices::Dict{Symbol, DeviceModel}: device dictionary\nbranches::Dict{Symbol, BranchModel}: branch dictionary\nservices::Dict{Symbol, ServiceModel}: service dictionary\n\nExample\n\ntemplate = OperationsProblemTemplate(CopperPlatePowerModel, devices, branches, services)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.RecedingHorizon","page":"PowerSimulations","title":"PowerSimulations.RecedingHorizon","text":"RecedingHorizon(period::Int)\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.Simulation","page":"PowerSimulations","title":"PowerSimulations.Simulation","text":"Simulation(steps::Int\n            stages::Dict{String, Stage{<:AbstractOperationsProblem}}\n            sequence::Union{Nothing, SimulationSequence}\n            simulation_folder::String\n            name::String\n            internal::Union{Nothing, SimulationInternal}\n            )\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.Simulation-Tuple{AbstractString,Dict}","page":"PowerSimulations","title":"PowerSimulations.Simulation","text":"Simulation(directory::AbstractString)\n\nConstructs Simulation from a serialized directory. Callers should pass any kwargs here that they passed to the original Simulation.\n\nArguments\n\ndirectory::AbstractString: the directory returned from the call to serialize\nstage_info::Dict: Two-level dictionary containing stage parameters that cannot be serialized. The outer dict should be keyed by the stage name. The inner dict must contain 'optimizer' and may contain 'jump_model'. These should be the same values used for the original simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.SimulationSequence","page":"PowerSimulations","title":"PowerSimulations.SimulationSequence","text":"SimulationSequence(initial_time::Union{Dates.DateTime, Nothing}\n                    horizons::Dict{String, Int}\n                    intervals::Dict{String, <:Tuple{<:Dates.TimePeriod, <:FeedForwardChronology}}\n                    order::Dict{Int, String}\n                    feedforward_chronologies::Dict{Pair{String, String}, <:FeedForwardChronology}\n                    feedforward::Dict{Tuple{String, Symbol, Symbol}, <:AbstractAffectFeedForward}\n                    ini_cond_chronology::Dict{String, <:FeedForwardChronology}\n                    cache::Dict{String, AbstractCache}\n                    )\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.Stage","page":"PowerSimulations","title":"PowerSimulations.Stage","text":"Stage({M<:AbstractOperationsProblem}\n    template::OperationsProblemTemplate\n    sys::PSY.System\n    optimizer::JuMP.MOI.OptimizerWithAttributes\n    internal::Union{Nothing, StageInternal}\n    )\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.Stage-Union{Tuple{M}, Tuple{Type{M},OperationsProblemTemplate,PowerSystems.System,MathOptInterface.OptimizerWithAttributes}, Tuple{Type{M},OperationsProblemTemplate,PowerSystems.System,MathOptInterface.OptimizerWithAttributes,Union{Nothing, JuMP.AbstractModel}}} where M<:PowerSimulations.AbstractOperationsProblem","page":"PowerSimulations","title":"PowerSimulations.Stage","text":"Stage(::Type{M},\ntemplate::OperationsProblemTemplate,\nsys::PSY.System,\noptimizer::JuMP.MOI.OptimizerWithAttributes,\njump_model::Union{Nothing, JuMP.AbstractModel}=nothing;\nkwargs...) where {M<:AbstractOperationsProblem}\n\nThis builds the optimization problem of type M with the specific system and template for the simulation stage\n\nArguments\n\n::Type{M} where M<:AbstractOperationsProblem: The abstract operation model type\ntemplate::OperationsProblemTemplate: The model reference made up of transmission, devices,                                         branches, and services.\nsys::PSY.System: the system created using Power Systems\njump_model::Union{Nothing, JuMP.AbstractModel}: Enables passing a custom JuMP model. Use with care\n\nOutput\n\nStage::Stage: The operation model containing the model type, unbuilt JuMP model, Power\n\nSystems system.\n\nExample\n\ntemplate = OperationsProblemTemplate(CopperPlatePowerModel, devices, branches, services)\nstage = Stage(MyOpProblemType template, system, optimizer)\n\nAccepted Key Words\n\ninitial_time::Dates.DateTime: Initial Time for the model solve\nPTDF::PTDF: Passes the PTDF matrix into the optimization model for StandardPTDFModel networks.\nwarm_start::Bool True will use the current operation point in the system to initialize variable values. False initializes all variables to zero. Default is true\nslack_variables::Bool True will add slacks to the system balance constraints\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.Synchronize","page":"PowerSimulations","title":"PowerSimulations.Synchronize","text":"Synchronize(periods::Int)\n\nDefines the co-ordination of time between Two stages.\n\nArguments\n\nperiods::Int: Number of time periods to grab data from\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.TimeStatusChange","page":"PowerSimulations","title":"PowerSimulations.TimeStatusChange","text":"Tracks the last time status of a device changed in a simulation\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#InfrastructureSystems.write_results-Tuple{PowerSimulations.OperationsProblemResults,String}","page":"PowerSimulations","title":"InfrastructureSystems.write_results","text":"write_results(results::IS.Results, save_path::String)\n\nExports Operational Problem Results to a path\n\nArguments\n\nresults::OperationsProblemResults: results from the simulation\nsave_path::String: folder path where the files will be written\n\nAccepted Key Words\n\nfile_type = CSV: only CSV and featherfile are accepted\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.build!-Tuple{Simulation}","page":"PowerSimulations","title":"PowerSimulations.build!","text":"build!(sim::Simulation)\n\nBuild the Simulation and all stages.\n\nArguments\n\nsim::Simulation: simulation object\noutput_dir = nothing: If nothing then generate a unique name.\nrecorders::Vector{Symbol} = []: recorder names to register\nconsole_level = Logging.Error:\nfile_level = Logging.Info:\n\nThrows an exception if label is passed and the directory already exists.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.check_file_integrity-Tuple{String}","page":"PowerSimulations","title":"PowerSimulations.check_file_integrity","text":"check_file_integrity(path::String)\n\nChecks the hash value for each file made with the file is written with the new hash_value to verify the file hasn't been tampered with since written\n\nArguments\n\npath::String: this is the folder path that contains the results and the check.sha256 file\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.configure_logging-Tuple{}","page":"PowerSimulations","title":"PowerSimulations.configure_logging","text":"configure_logging(;\n    console_level = Logging.Error,\n    file_level = Logging.Info,\n    filename = \"power-simulations.log\",\n)\n\nCreates console and file loggers.\n\nNote: Log messages may not be written to the file until flush() or close() is called on the returned logger.\n\nArguments\n\nconsole_level = Logging.Error: level for console messages\nfile_level = Logging.Info: level for file messages\nfilename::String = power-simulations.log: log file\n\nExample\n\nlogger = configure_logging(console_level = Logging.Info)\n@info \"log message\"\nclose(logger)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,PowerSystems.System,DeviceModel{T,D},Type{S}}} where S<:PowerModels.AbstractActivePowerModel where D<:PowerSimulations.AbstractThermalFormulation where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"This function creates the model for a full themal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,PowerSystems.System,DeviceModel{T,D},Type{S}}} where S<:PowerModels.AbstractPowerModel where D<:PowerSimulations.AbstractThermalFormulation where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"This function creates the model for a full themal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,PowerSystems.System,DeviceModel{T,ThermalBasicUnitCommitment},Type{S}}} where S<:PowerModels.AbstractActivePowerModel where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"This function creates the model for a full themal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,PowerSystems.System,DeviceModel{T,ThermalBasicUnitCommitment},Type{S}}} where S<:PowerModels.AbstractPowerModel where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"This function creates the model for a full themal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,PowerSystems.System,DeviceModel{T,ThermalRampLimited},Type{S}}} where S<:PowerModels.AbstractActivePowerModel where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"This function creates the model for a full themal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,PowerSystems.System,DeviceModel{T,ThermalRampLimited},Type{S}}} where S<:PowerModels.AbstractPowerModel where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"This function creates the model for a full themal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_all_constraint_index-Tuple{OperationsProblem}","page":"PowerSimulations","title":"PowerSimulations.get_all_constraint_index","text":"\"Each Tuple corresponds to (conname, internalindex, moi_index)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_all_var_index-Tuple{OperationsProblem}","page":"PowerSimulations","title":"PowerSimulations.get_all_var_index","text":"\"Each Tuple corresponds to (conname, internalindex, moi_index)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.list_simulation_events-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Union{Nothing, Function}}} where T<:InfrastructureSystems.AbstractRecorderEvent","page":"PowerSimulations","title":"PowerSimulations.list_simulation_events","text":"list_simulation_events(\n    ::Type{T},\n    output_dir::AbstractString,\n    filter_func::Union{Nothing, Function} = nothing;\n    step = nothing,\n    stage = nothing,\n) where {T <: IS.AbstractRecorderEvent}\n\nList simulation events of type T in a simulation output directory.\n\nArguments\n\noutput_dir::AbstractString: Simulation output directory\nfilter_func::Union{Nothing, Function} = nothing: Refer to show_simulation_events.\nstep::Int = nothing: Filter events by step. Required if stage is passed.\nstage::Int = nothing: Filter events by stage.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.load_operation_results-Tuple{AbstractString}","page":"PowerSimulations","title":"PowerSimulations.load_operation_results","text":"results = load_operation_results(path)\n\nThis function can be used to load results from a folder of results from a single-step problem, or for a single foulder within a simulation.\n\nArguments\n\npath::AbstractString = folder path\ndirectory::AbstractString = \"2019-10-03T09-18-00\": the foulder name that contains\n\nfeather files of the results.\n\nExample\n\nresults = load_operation_results(\"/Users/test/2019-10-03T09-18-00\")\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.load_simulation_results-Tuple{SimulationResultsReference,String}","page":"PowerSimulations","title":"PowerSimulations.load_simulation_results","text":"load_simulation_results(sim_output, stage)\n\nThis function goes through the reference table of file paths and aggregates the results over time into a struct of type OperationsProblemResults\n\nArguments\n\nsim_output::SimulationResultsReference: the container for the reference dictionary created in execute!\nstage_number::String: The stage of the results getting parsed\n\nExample\n\nsim_output = execute!(simulation)\nresults = load_simulation_results(sim_output, \"stage_name\")\n\nAccepted Key Words\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.load_simulation_results-Tuple{String,String,Vararg{Any,N} where N}","page":"PowerSimulations","title":"PowerSimulations.load_simulation_results","text":"load_simulation_results(file_path, stage)\n\nThis function goes through the reference table of file paths and aggregates the results over time into a struct of type OperationsProblemResults\n\nArguments\n\nfile_path::String: the file path to the dated folder with the raw results\nstage_number::String: The stage of the results getting parsed\n\nExample\n\nexecute!(simulation)\nresults = load_simulation_results(\"file_path\", \"stage_name\")\n\nAccepted Key Words\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.make_references-Tuple{Simulation,String}","page":"PowerSimulations","title":"PowerSimulations.make_references","text":"make_references(sim::Simulation, date_run::String; kwargs...)\n\nCreates a dictionary of variables with a dictionary of stages that contains dataframes of date/step/and desired file path so that the results can be parsed sequentially by variable and stage type.\n\nNote: makereferences can only be run after runsim_model or else, the folder structure will not yet be populated with results\n\nArguments\n\nsim::Simulation = sim: simulation object created by Simulation()\ndate_run::String = \"2019-10-03T09-18-00\"`: the name of the file created\n\nthat contains the specific simulation run of the date run and \"-test\"\n\nExample\n\nsim = Simulation(\"Test\", 7, stages, \"/Users/yourusername/Desktop/\"; system_to_file = false)\nexecute!(sim::Simulation; kwargs...)\nreferences = make_references(sim, \"2019-10-03T09-18-00-test\")\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.show_recorder_events-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Union{Nothing, Function}}} where T<:InfrastructureSystems.AbstractRecorderEvent","page":"PowerSimulations","title":"PowerSimulations.show_recorder_events","text":"show_recorder_events(\n    ::Type{T},\n    filename::AbstractString,\n    filter_func::Union{Nothing, Function} = nothing;\n    wall_time = false,\n    kwargs...,\n) where {T <: IS.AbstractRecorderEvent}\n\nShow the events of type T in a recorder file.\n\nArguments\n\n::Type{T}: Recorder event type\nfilename::AbstractString: recorder filename\nfilter_func::Union{Nothing, Function} = nothing: Optional function that accepts an event  of type T and returns a Bool. Apply this function to each event and only return events  where the result is true.\nwall_time = false: If true, show the wall_time timestamp.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.show_simulation_events-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Union{Nothing, Function}}} where T<:InfrastructureSystems.AbstractRecorderEvent","page":"PowerSimulations","title":"PowerSimulations.show_simulation_events","text":"show_simulation_events(\n    ::Type{T},\n    output_dir::AbstractString,\n    filter_func::Union{Nothing,Function} = nothing;\n    step = nothing,\n    stage = nothing,\n    wall_time = false,\n    kwargs...,\n) where { T <: IS.AbstractRecorderEvent}\n\nShow all simulation events of type T in a simulation output directory.\n\nArguments\n\n::Type{T}: Recorder event type\noutput_dir::AbstractString: Simulation output directory\nfilter_func::Union{Nothing, Function} = nothing: Refer to show_recorder_events.\nstep::Int = nothing: Filter events by step. Required if stage is passed.\nstage::Int = nothing: Filter events by stage.\nwall_time = false: If true, show the wall_time timestamp.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.solve!-Union{Tuple{OperationsProblem{T}}, Tuple{T}} where T<:PowerSimulations.AbstractOperationsProblem","page":"PowerSimulations","title":"PowerSimulations.solve!","text":"solve!(op_problem::OperationsProblem; kwargs...)\n\nThis solves the operational model for a single instance and outputs results of type OperationsProblemResult\n\nArguments\n\nop_problem::OperationModel = op_problem: operation model\n\nExamples\n\nresults = solve!(OpModel)\n\nAccepted Key Words\n\nsave_path::String: If a file path is provided the results\n\nautomatically get written to feather files\n\noptimizer::MOI.OptimizerWithAttributes: The optimizer that is used to solve the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.template_economic_dispatch-Tuple{}","page":"PowerSimulations","title":"PowerSimulations.template_economic_dispatch","text":"template_economic_dispatch(; kwargs...)\n\nCreates an OperationsProblemTemplate with default DeviceModels for an Economic Dispatch problem.\n\nExample\n\ntemplate = template_economic_dispatch()\n\nAccepted Key Words\n\nnetwork::Type{<:PM.AbstractPowerModel} : override default network model settings\ndevices::Dict{Symbol, DeviceModel} : override default DeviceModel settings\nbranches::Dict{Symbol, DeviceModel} : override default DeviceModel settings\nservices::Dict{Symbol, ServiceModel} : override default ServiceModel settings\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.template_unit_commitment-Tuple{}","page":"PowerSimulations","title":"PowerSimulations.template_unit_commitment","text":"template_unit_commitment(; kwargs...)\n\nCreates an OperationsProblemTemplate with default DeviceModels for a Unit Commitment problem.\n\nExample\n\ntemplate = template_unit_commitment()\n\nAccepted Key Words\n\nnetwork::Type{<:PM.AbstractPowerModel} : override default network model settings\ndevices::Dict{Symbol, DeviceModel} : override default DeviceModel settings\nbranches::Dict{Symbol, DeviceModel} : override default DeviceModel settings\nservices::Dict{Symbol, ServiceModel} : override default ServiceModel settings\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#Internal-1","page":"PowerSimulations","title":"Internal","text":"","category":"section"},{"location":"api/PowerSimulations/#","page":"PowerSimulations","title":"PowerSimulations","text":"Modules = [PowerSimulations]\nPublic = false","category":"page"},{"location":"api/PowerSimulations/#PowerSimulations.AbstractSimulationStatusEvent","page":"PowerSimulations","title":"PowerSimulations.AbstractSimulationStatusEvent","text":"All events subtyped from this need to be recorded under :simulation_status.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.DeviceRange","page":"PowerSimulations","title":"PowerSimulations.DeviceRange","text":"Data Container to construct range constraints\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.UpdateRef","page":"PowerSimulations","title":"PowerSimulations.UpdateRef","text":"Reference for parameters update when present\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#Base.show-Tuple{IO,MIME{Symbol(\"text/plain\")},OperationsProblem}","page":"PowerSimulations","title":"Base.show","text":"Base.show(io::IO, ::MIME\"text/plain\", op_problem::OperationsProblem)\n\nThis function goes through the fields in OperationsProblem and then in OperationsProblemTemplate, if the field contains a Device model dictionary, it calls organizedevicemodel() & prints the data by field, key, value. If the field is not a Device model dictionary, and a value exists for that field it prints the value.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._allocate_execution_order-Tuple{Dict{Int64,Int64}}","page":"PowerSimulations","title":"PowerSimulations._allocate_execution_order","text":"Function calculates the total number of stage executions in the simulation and allocates the appropiate vector\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._calculate_interval_inner_counts-Tuple{Dict{Int64,String},Dict{String,Tuple{Dates.TimePeriod,#s109} where #s109<:PowerSimulations.FeedForwardChronology},Dates.TimePeriod}","page":"PowerSimulations","title":"PowerSimulations._calculate_interval_inner_counts","text":"_calculate_interval_inner_counts(order::Dict{Int,String},\n                                      intervals::Dict{String,<:Dates.TimePeriod},\n                                      step_resolution::Dates.TimePeriod)\n\nCalculates how many times a stage is executed for every interval of the previous stage\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._get_data_for_rocc-Tuple{Array{InitialCondition,1},Dates.TimePeriod}","page":"PowerSimulations","title":"PowerSimulations._get_data_for_rocc","text":"This function gets the data for the generators\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._get_data_for_tdc-Tuple{Array{InitialCondition,1},Array{InitialCondition,1},Dates.TimePeriod}","page":"PowerSimulations","title":"PowerSimulations._get_data_for_tdc","text":"If the fraction of hours that a generator has a duration constraint is less than the fraction of hours that a single time_step represents then it is not binding.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._pwl_cost-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JV,Array{Tuple{Float64,Float64},1}}} where JV<:JuMP.AbstractVariableRef","page":"PowerSimulations","title":"PowerSimulations._pwl_cost","text":"_gen_cost(cost_)\n\nReturns JuMP expression for a piecewise linear cost function depending on the data compatibility.\n\nReturns gen_cost\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nvariable::JuMP.Containers.DenseAxisArray{JV} : variable array\ncost_component::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._pwlgencost_linear-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JV,Array{Tuple{Float64,Float64},1}}} where JV<:JuMP.AbstractVariableRef","page":"PowerSimulations","title":"PowerSimulations._pwlgencost_linear","text":"_pwlgencost_linear(psi_container::PSIContainer,\n            variable::JuMP.Containers.DenseAxisArray{JV},\n            cost_component::PSY.VariableCost{NTuple{2, Float64}}) where {JV <: JuMP.AbstractVariableRef}\n\nReturns piecewise cost expression using linear implementation for psi_container model.\n\nEquations\n\n0 <= pwl_var[i] <= (cost_component[2][i] - cost_component[2][i-1])\n\nvariable = sum(pwl_var[i])\n\ngen_cost = sum(pwl_var[i]*cost_component[1][i]/cost_component[2][i])\n\nLaTeX\n\n0 = pwl_i = (c_2 i - c_2 i-1)\n\nvariable = (sum_iin I pwl_i)\n\ngen_cost = (sum_iin I  pwl_i) c_1 ic_2 i\n\nReturns gen_cost\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nvariable::JuMP.Containers.DenseAxisArray{JV} : variable array\ncost_component::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._pwlgencost_sos-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JV,Array{Tuple{Float64,Float64},1}}} where JV<:JuMP.AbstractVariableRef","page":"PowerSimulations","title":"PowerSimulations._pwlgencost_sos","text":"_pwlgencost_sos(psi_container::PSIContainer,\n            variable::JuMP.Containers.DenseAxisArray{JV},\n            cost_component::PSY.VariableCost{NTuple{2, Float64}}) where {JV <: JuMP.AbstractVariableRef}\n\nReturns piecewise cost expression using SOS Type-2 implementation for psi_container model.\n\nEquations\n\nvariable = sum(sos_var[i]*cost_component[2][i])\n\ngen_cost = sum(sos_var[i]*cost_component[1][i])\n\nLaTeX\n\nvariable = (sum_iin I c_2 i sos_i)\n\ngen_cost = (sum_iin I c_1 i sos_i)\n\nReturns gen_cost\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nvariable::JuMP.Containers.DenseAxisArray{JV} : variable array\ncost_component::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._pwlparamcheck-Tuple{Any}","page":"PowerSimulations","title":"PowerSimulations._pwlparamcheck","text":"_pwlparamcheck(cost_)\n\nReturns True/False depending on compatibility of the cost data with the linear implementation method\n\nReturns flag\n\nArguments\n\ncost_::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._update_stage!-Tuple{Stage,Simulation}","page":"PowerSimulations","title":"PowerSimulations._update_stage!","text":"Required update stage function call\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._write_psi_container-Tuple{PowerSimulations.PSIContainer,String}","page":"PowerSimulations","title":"PowerSimulations._write_psi_container","text":"Exports the OpModel JuMP object in MathOptFormat\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.activepower_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,#s531} where #s531<:PowerSimulations.AbstractThermalDispatchFormulation,Type{#s109} where #s109<:PowerModels.AbstractPowerModel,Nothing}} where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.activepower_constraints!","text":"This function adds the active power limits of generators when there are no CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.activepower_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,#s531} where #s531<:PowerSimulations.AbstractThermalFormulation,Type{#s109} where #s109<:PowerModels.AbstractPowerModel,Nothing}} where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.activepower_constraints!","text":"This function adds the active power limits of generators when there are CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.activepower_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,ThermalDispatchNoMin},Type{#s531} where #s531<:PowerModels.AbstractPowerModel,Nothing}} where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.activepower_constraints!","text":"This function adds the active power limits of generators when there are     no CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.activepower_variables!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.activepower_variables!","text":"This function add the variables for power generation output to the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.activeservice_variables!-Union{Tuple{SR}, Tuple{PowerSimulations.PSIContainer,SR,Array{#s534,1} where #s534<:PowerSystems.Device}} where SR<:PowerSystems.Reserve","page":"PowerSimulations","title":"PowerSimulations.activeservice_variables!","text":"This function add the variables for reserves to the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_to_cost-Union{Tuple{D}, Tuple{PowerSimulations.PSIContainer,D,Symbol,Symbol}, Tuple{PowerSimulations.PSIContainer,D,Symbol,Symbol,Float64}} where D<:(InfrastructureSystems.FlattenIteratorWrapper{#s532} where #s532<:PowerSystems.Device)","page":"PowerSimulations","title":"PowerSimulations.add_to_cost","text":"add_to_cost(psi_container::PSIContainer,\n                 devices::D,\n                 var_name::Symbol,\n                 cost_symbol::Symbol,\n                 sign::Float64 = 1.0) where {D<:IS.FlattenIteratorWrapper{<:PSY.Device}}\n\nAdds cost expression for each device using appropriate call to ps_cost.\n\nExpression\n\nfor d in devices\n\n                              variable[PSY.get_name(d), :],\n                              getfield(PSY.get_op_cost(d), cost_symbol),\n                              dt,\n                              sign) ```\n\npsicontainer.costfunction += cost_expression ```\n\nLaTeX\n\nCOST = sum_din D cost_d\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\ndevices::D : set of devices\nvar_name::Symbol : name of variable\ncost_symbol::Symbol : symbol associated with costx\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_variable-Union{Tuple{D}, Tuple{PowerSimulations.PSIContainer,D,Symbol,Bool}, Tuple{PowerSimulations.PSIContainer,D,Symbol,Bool,Union{Nothing, Symbol}}, Tuple{PowerSimulations.PSIContainer,D,Symbol,Bool,Union{Nothing, Symbol},Float64}} where D<:Union{Array{#s35,1} where #s35<:PowerSystems.Device, InfrastructureSystems.FlattenIteratorWrapper{#s34} where #s34<:PowerSystems.Device}","page":"PowerSimulations","title":"PowerSimulations.add_variable","text":"add_variable(psi_container::PSIContainer,\n                  devices::D,\n                  var_name::Symbol,\n                  binary::Bool,\n                  expression_name::Symbol,\n                  sign::Float64)\n\nAdds a variable to the optimization model and to the affine expressions contained in the psi_container model according to the specified sign. Based on the inputs, the variable can be specified as binary.\n\nBounds\n\nlb_value_function <= varstart[name, t] <= ub_value_function\n\nIf binary = true:\n\nvarstart[name, t] in {0,1}\n\nLaTeX\n\nlb ge x^device_t le ub forall t\n\nx^device_t in 01 forall t iff textbinary = true\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\ndevices : Vector or Iterator with the devices\nvar_name::Symbol : Base Name for the variable\nbinary::Bool : Select if the variable is binary\nexpressionname::Symbol : Expressionname name stored in psi_container.expressions to add the variable\nsign::Float64 : sign of the addition of the variable to the expression_name. Default Value is 1.0\n\nAccepted Keyword Arguments\n\nubvaluefunction : Provides the function over device to obtain the value for a upper_bound\nlbvaluefunction : Provides the function over device to obtain the value for a lower_bound. If the variable is meant to be positive define lb = x -> 0.0\ninitialvaluefunction : Provides the function over device to obtain the warm start value\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.build_nip-Tuple{PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.build_nip","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.commitment_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,D},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S<:PowerModels.AbstractPowerModel where D<:PowerSimulations.AbstractThermalFormulation where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.commitment_constraints!","text":"This function adds the Commitment Status constraint when there are CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.commitment_variables!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.commitment_variables!","text":"This function add the variables for power generation commitment to the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.compute_sha256-Tuple{AbstractString}","page":"PowerSimulations","title":"PowerSimulations.compute_sha256","text":"Return the SHA 256 hash of a file.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.constraint_power_balance_ni-Tuple{PowerModels.AbstractActivePowerModel,Int64,Int64,Any,Any}","page":"PowerSimulations","title":"PowerSimulations.constraint_power_balance_ni","text":"active power only models ignore reactive power flows\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.constraint_power_balance_ni-Tuple{PowerModels.AbstractPowerModel,Int64,Int64,Any,Any}","page":"PowerSimulations","title":"PowerSimulations.constraint_power_balance_ni","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.constraint_power_balance_ni-Tuple{PowerModels.AbstractPowerModel,Int64}","page":"PowerSimulations","title":"PowerSimulations.constraint_power_balance_ni","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractActivePowerModel,Int64,Int64,Any,Any,Any,Any}","page":"PowerSimulations","title":"PowerSimulations.constraint_power_balance_ni_expr","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel,Int64,Int64,Any,Any,Any,Any}","page":"PowerSimulations","title":"PowerSimulations.constraint_power_balance_ni_expr","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel,Int64}","page":"PowerSimulations","title":"PowerSimulations.constraint_power_balance_ni_expr","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.container_spec-Union{Tuple{M}, Tuple{M,Vararg{Any,N} where N}} where M<:JuMP.AbstractModel","page":"PowerSimulations","title":"PowerSimulations.container_spec","text":"Returns the correct container spec for the selected type of JuMP Model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_commitment-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Symbol,Tuple{Symbol,Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.device_commitment","text":"device_commitment(psi_container::PSIContainer,\n                    initial_conditions::Vector{InitialCondition},\n                    cons_name::Symbol,\n                    var_names::Tuple{Symbol, Symbol, Symbol})\n\nConstructs multi-timestep constraint from initial conditions and binary variable tuple.\n\nConstraints\n\nvarstart + varstop <= 1.0\n\nIf t = 1:\n\nvaron[name, 1] == ic.value + varstart[name, 1] - varstop[name, 1]\n\nwhere ic in initial_condtions.\n\nIf t > 1:\n\nvaron[name, t] == varon[name, t-1] + varstart[name, t] - varstop[name, t]\n\nLaTeX\n\nx^on_t + x^off_t leq 10 forall t\n\nx^on_1 = x^on_init + x^start_1 - x^stop_1 text for  t = 1\n\nx^on_t = x^on_t-1 + x^start_t - x^stop_t forall t geq 2\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\ninitial_conditions::Vector{InitialCondition} : for time zero 'varon'\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables\n: var_names[1] : varstart\n: var_names[2] : varstop\n: var_names[3] : varon\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_duration_look_ahead-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.device_duration_look_ahead","text":"device_duration_look_ahead(psi_container::PSIContainer,\n                            duration_data::Vector{UpDown},\n                            initial_duration::Matrix{InitialCondition},\n                            cons_name::Symbol,\n                            var_names::Tuple{Symbol, Symbol, Symbol})\n\nThis formulation of the duration constraints looks ahead in the time frame of the model.\n\nLaTeX\n\nMinimum up-time constraint:\n\nIf t leq d_min^up\n\nd_min^downx_t^stop - sum_i=t-d_min^up + 1^t x_i^on - x_init^up leq 0\n\nfor i in the set of time steps. Otherwise:\n\nd_min^downx_t^stop - sum_i=t-d_min^up + 1^t x_i^on leq 0\n\nfor i in the set of time steps.\n\nMinimum down-time constraint:\n\nIf t leq d_min^down\n\nd_min^upx_t^start - sum_i=t-d_min^down + 1^t (1 - x_i^on) - x_init^down leq 0\n\nfor i in the set of time steps. Otherwise:\n\nd_min^upx_t^start - sum_i=t-d_min^down + 1^t (1 - x_i^on) leq 0\n\nfor i in the set of time steps.\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nduration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down\ninitial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol, Symbol}) : names of the variables\n: var_names[1] : varon\n: var_names[2] : varstart\n: var_names[3] : varstop\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_duration_parameters-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.device_duration_parameters","text":"device_duration_parameters(psi_container::PSIContainer,\n                         duration_data::Vector{UpDown},\n                         initial_duration_on::Vector{InitialCondition},\n                         initial_duration_off::Vector{InitialCondition},\n                         cons_name::Symbol,\n                         var_names::Tuple{Symbol, Symbol, Symbol})\n\nThis formulation of the duration constraints considers parameters.\n\nLaTeX\n\nMinimum up-time constraint:\n\nIf t leq d_min^up\n\nd_min^downx_t^stop - sum_i=t-d_min^up + 1^t x_i^on - x_init^up leq 0\n\nfor i in the set of time steps. Otherwise:\n\nsum_i=t-d_min^up + 1^t x_i^start - x_t^on leq 0\n\nfor i in the set of time steps.\n\nMinimum down-time constraint:\n\nIf t leq d_min^down\n\nd_min^upx_t^start - sum_i=t-d_min^down + 1^t (1 - x_i^on) - x_init^down leq 0\n\nfor i in the set of time steps. Otherwise:\n\nsum_i=t-d_min^down + 1^t x_i^stop + x_t^on leq 1\n\nfor i in the set of time steps.\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nduration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down\ninitialdurationon::Vector{InitialCondition} : gives initial number of time steps variable is up\ninitialdurationoff::Vector{InitialCondition} : gives initial number of time steps variable is down\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol, Symbol}) : names of the variables\n: var_names[1] : varon\n: var_names[2] : varstart\n: var_names[3] : varstop\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_duration_retrospective-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.device_duration_retrospective","text":"device_duration_retrospective(psi_container::PSIContainer,\n                                    duration_data::Vector{UpDown},\n                                    initial_duration::Matrix{InitialCondition},\n                                    cons_name::Symbol,\n                                    var_names::Tuple{Symbol, Symbol, Symbol})\n\nThis formulation of the duration constraints adds over the start times looking backwards.\n\nLaTeX\n\nMinimum up-time constraint:\n\nIf t leq d_min^up - d_init^up and d_init^up  0\n\n1 + sum_i=t-d_min^up + 1^t x_i^start - x_t^on leq 0\n\nfor i in the set of time steps. Otherwise:\n\nsum_i=t-d_min^up + 1^t x_i^start - x_t^on leq 0\n\nfor i in the set of time steps.\n\nMinimum down-time constraint:\n\nIf t leq d_min^down - d_init^down and d_init^down  0\n\n1 + sum_i=t-d_min^down + 1^t x_i^stop + x_t^on leq 1\n\nfor i in the set of time steps. Otherwise:\n\nsum_i=t-d_min^down + 1^t x_i^stop + x_t^on leq 1\n\nfor i in the set of time steps.\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nduration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down\ninitial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol, Symbol}) : names of the variables\n: var_names[1] : varon\n: var_names[2] : varstart\n: var_names[3] : varstop\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_linear_rateofchange-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,1},Symbol,Symbol}","page":"PowerSimulations","title":"PowerSimulations.device_linear_rateofchange","text":"device_linear_rateofchange(psi_container::PSIContainer,\n                                rate_data::Tuple{Vector{String}, Vector{UpDown}},\n                                initial_conditions::Vector{InitialCondition},\n                                cons_name::Symbol,\n                                var_name::Symbol)\n\nConstructs allowed rate-of-change constraints from variables, initial condtions, and rate data.\n\nConstraints\n\nIf t = 1:\n\nvariable[name, 1] - initial_conditions[ix].value <= rate_data[1][ix].up\n\ninitial_conditions[ix].value - variable[name, 1] <= rate_data[1][ix].down\n\nIf t > 1:\n\nvariable[name, t] - variable[name, t-1] <= rate_data[1][ix].up\n\nvariable[name, t-1] - variable[name, t] <= rate_data[1][ix].down\n\nLaTeX\n\nr^down leq x_1 - x_init leq r^up text for  t = 1\n\nr^down leq x_t - x_t-1 leq r^up forall t geq 2\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nrate_data::Tuple{Vector{String}, Vector{UpDown}} : gives name (1) and max ramp up/down rates (2)\ninitial_conditions::Vector{InitialCondition} : for time zero 'variable'\ncons_name::Symbol : name of the constraint\nvar_name::Tuple{Symbol, Symbol, Symbol} : the name of the variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_mixedinteger_rateofchange-Tuple{PowerSimulations.PSIContainer,Tuple{Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{NamedTuple{(:min, :max),Tuple{Float64,Float64}},1}},Array{InitialCondition,1},Symbol,Tuple{Symbol,Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.device_mixedinteger_rateofchange","text":"device_mixedinteger_rateofchange(psi_container::PSIContainer,\n                                      rate_data::Tuple{Vector{String}, Vector{UpDown}, Vector{MinMax}},\n                                      initial_conditions::Vector{InitialCondition},\n                                      cons_name::Symbol,\n                                      var_names::Tuple{Symbol, Symbol, Symbol})\n\nConstructs allowed rate-of-change constraints from variables, initial condtions, start/stop status, and rate data\n\nEquations\n\nIf t = 1:\n\nvariable[name, 1] - initial_conditions[ix].value <= rate_data[1][ix].up + rate_data[2][ix].max*varstart[name, 1]\n\ninitial_conditions[ix].value - variable[name, 1] <= rate_data[1][ix].down + rate_data[2][ix].min*varstop[name, 1]\n\nIf t > 1:\n\nvariable[name, t] - variable[name, t-1] <= rate_data[1][ix].up + rate_data[2][ix].max*varstart[name, t]\n\nvariable[name, t-1] - variable[name, t] <= rate_data[1][ix].down + rate_data[2][ix].min*varstop[name, t]\n\nLaTeX\n\nr^down + r^min x^stop_1 leq x_1 - x_init leq r^up + r^max x^start_1 text for  t = 1\n\nr^down + r^min x^stop_t leq x_t - x_t-1 leq r^up + r^max x^start_t forall t geq 2\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nrate_data::Tuple{Vector{String}, Vector{UpDown}, Vector{MinMax}} : (1) gives name                                                                    (2) gives min/max ramp rates                                                                    (3) gives min/max for 'variable'\ninitial_conditions::Vector{InitialCondition} : for time zero 'variable'\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables\n: var_names[1] : 'variable'\n: var_names[2] : 'varstart'\n: var_names[3] : 'varstop'\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_range-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRange,1},Symbol,Symbol}","page":"PowerSimulations","title":"PowerSimulations.device_range","text":"device_range(psi_container::PSIContainer,\n             range_data::Vector{DeviceRange},\n             cons_name::Symbol,\n             var_name::Symbol)\n\nConstructs min/max range constraint from device variable.\n\nConstraints\n\nIf min and max within an epsilon width:\n\nvariable[name, t] == limits.max\n\nOtherwise:\n\nlimits.min <= variable[name, t] <= limits.max\n\nwhere limits in range_data.\n\nLaTeX\n\nx = limits^max text for  limits^max - limits^min  varepsilon\n\nlimits^min leq x leq limits^max text otherwise \n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nrange_data::Vector{DeviceRange} : contains names and vector of min/max\ncons_name::Symbol : name of the constraint\nvar_name::Symbol : the name of the continuous variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_semicontinuousrange-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRange,1},Symbol,Symbol,Symbol}","page":"PowerSimulations","title":"PowerSimulations.device_semicontinuousrange","text":"device_semicontinuousrange(psi_container::PSIContainer,\n                                range_data::Vector{DeviceRange},\n                                cons_name::Symbol,\n                                var_name::Symbol,\n                                binvar_name::Symbol)\n\nConstructs min/max range constraint from device variable and on/off decision variable.\n\nConstraints\n\nIf device min = 0:\n\nvarcts[name, t] <= limits.max*varbin[name, t])\n\nvarcts[name, t] >= 0.0\n\nOtherwise:\n\nvarcts[name, t] <= limits.max*varbin[name, t]\n\nvarcts[name, t] >= limits.min*varbin[name, t]\n\nwhere limits in range_data.\n\nLaTeX\n\n0 leq x^cts leq limits^max x^bin text for  limits^min = 0\n\nlimits^min x^bin leq x^cts leq limits^max x^bin text otherwise \n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nrange_data::Vector{DeviceRange} : contains names and vector of min/max\ncons_name::Symbol : name of the constraint\nvar_name::Symbol : the name of the continuous variable\nbinvar_name::Symbol : the name of the binary variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_timeseries_lb-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeries,1},Symbol,Symbol}","page":"PowerSimulations","title":"PowerSimulations.device_timeseries_lb","text":"device_timeseries_lb(psi_container::PSIContainer,\n                 ts_data::Vector{DeviceTimeSeries},\n                 cons_name::Symbol,\n                 var_name::Symbol)\n\nConstructs lower bound for given variable subject to time series data and a multiplier.\n\nConstraint\n\nts_data[name].multiplier * ts_data[name].timeseries[t] <= variable[name, t]\n\nLaTeX\n\nr^val r_t leq x_t forall t\n\nwhere (name, data) in range_data.\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nts_data::Vector{DeviceTimeSeries} : container of device time series data and scaling factors\ncons_name::Symbol : name of the constraint\nvar_name::Symbol : the name of the variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_timeseries_param_lb-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeries,1},Symbol,PowerSimulations.UpdateRef,Symbol}","page":"PowerSimulations","title":"PowerSimulations.device_timeseries_param_lb","text":"device_timeseries_param_lb(psi_container::PSIContainer,\n                                ts_data::Vector{DeviceTimeSeries},\n                                cons_name::Symbol,\n                                param_reference::UpdateRef,\n                                var_name::Symbol)\n\nConstructs lower bound for given variable using a parameter. The constraint is     built with a time series data vector and a multiplier\n\nConstraint\n\nts_data[name].multiplier * param[name, t] <= variable[name, t]\n\nLaTeX\n\nr^val x^param_t leq x^var_t forall t\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nts_data::Vector{DeviceTimeSeries} : container of device time series data and scaling factors\ncons_name::Symbol : name of the constraint\nparam_reference::UpdateRef : UpdateRef to access the parameter\nvar_name::Symbol : the name of the variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_timeseries_param_ub-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeries,1},Symbol,PowerSimulations.UpdateRef,Symbol}","page":"PowerSimulations","title":"PowerSimulations.device_timeseries_param_ub","text":"device_timeseries_param_ub(psi_container::PSIContainer,\n                                ts_data::Vector{DeviceTimeSeries},\n                                cons_name::Symbol,\n                                param_reference::UpdateRef,\n                                var_name::Symbol)\n\nConstructs upper bound for given variable using a parameter. The constraint is     built with a time series data vector and a multiplier\n\nConstraint\n\nvariable[name, t] <= ts_data[name].multiplier * param[name, t]\n\nLaTeX\n\nx^var_t leq r^val x^param_t forall t\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nts_data::Vector{DeviceTimeSeries} : container of device time series data and scaling factors\ncons_name::Symbol : name of the constraint\nparam_reference::UpdateRef : UpdateRef to access the parameter\nvar_name::Symbol : the name of the variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_timeseries_ub-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeries,1},Symbol,Symbol}","page":"PowerSimulations","title":"PowerSimulations.device_timeseries_ub","text":"device_timeseries_ub(psi_container::PSIContainer,\n                 ts_data::Vector{DeviceTimeSeries},\n                 cons_name::Symbol,\n                 var_name::Symbol)\n\nConstructs upper bound for given variable and time series data and a multiplier.\n\nConstraint\n\nvariable[name, t] <= ts_data[name].multiplier * ts_data[name].timeseries[t]\n\nLaTeX\n\nx_t leq r^val r_t forall t\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nts_data::Vector{DeviceTimeSeries} : container of device time series data and scaling factors\ncons_name::Symbol : name of the constraint\nvar_name::Symbol : the name of the variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_timeseries_ub_bigM","page":"PowerSimulations","title":"PowerSimulations.device_timeseries_ub_bigM","text":"device_timeseries_ub_bigM(psi_container::PSIContainer,\n                                ts_data::Vector{DeviceTimeSeries},\n                                cons_name::Symbol,\n                                var_name::Symbol,\n                                param_reference::UpdateRef,\n                                binvar_name::Symbol,\n                                M_value::Float64 = 1e6)\n\nConstructs upper bound for variable and time series and a multiplier or confines to 0 depending on binary variable.     Uses BigM constraint type to allow for parameter since ParameterJuMP doesn't support var*parameter\n\nConstraints\n\nvarcts[name, t] - ts_data[name].multipliers * param[name, t] <= (1 - varbin[name, t]) * M_value\n\nvarcts[name, t] <= varbin[name, t]*M_value\n\nLaTeX\n\nx^cts_t - r^val x^param_t leq M(1 - x^bin_t ) forall t\n\nx^cts_t leq M x^bin_t forall t\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nts_data::Vector{DeviceTimeSeries} : container of device time series data and scaling factors\ncons_name::Symbol : name of the constraint\nvar_name::Symbol :  name of the variable\n\nparam_reference::UpdateRef : UpdateRef of access the parameters\n\nbinvar_name::Symbol : name of binary variable\nM_value::Float64 : bigM\n\n\n\n\n\n","category":"function"},{"location":"api/PowerSimulations/#PowerSimulations.device_timeseries_ub_bin-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeries,1},Symbol,Symbol,Symbol}","page":"PowerSimulations","title":"PowerSimulations.device_timeseries_ub_bin","text":"device_timeseries_ub_bin(psi_container::PSIContainer,\n                                ts_data::Vector{DeviceTimeSeries},\n                                var_name::Symbol,\n                                binvar_name::Symbol)\n\nConstructs upper bound for variable and time series or confines to 0 depending on binary variable.     The upper bound is defined by a time series and a multiplier.\n\nConstraints\n\nvarcts[name, t] <= varbin[name, t]* ts_data[name].multiplier * ts_data[name].timeseries[t]\n\nwhere (name, data) in range_data.\n\nLaTeX\n\nx^cts_t leq r^val r_t x^bin_t forall t\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nts_data::Vector{DeviceTimeSeries} : container of device time series data and scaling factors\ncons_name::Symbol : name of the constraint\nvar_name::Symbol :  name of the variable\nbinvar_name::Symbol : name of binary variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.energy_balance-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Tuple{Array{String,1},Array{NamedTuple{(:in, :out),Tuple{Float64,Float64}},1}},Symbol,Tuple{Symbol,Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.energy_balance","text":"energy_balance(psi_container::PSIContainer,\n                    initial_conditions::Vector{InitialCondition},\n                    efficiency_data::Tuple{Vector{String}, Vector{InOut}},\n                    cons_name::Symbol,\n                    var_names::Tuple{Symbol, Symbol, Symbol})\n\nConstructs multi-timestep constraint from initial condition, efficiency data, and variable tuple\n\nConstraints\n\nIf t = 1:\n\nvarenergy[name, 1] == initial_conditions[ix].value + varin[name, 1]*eff_in*fraction_of_hour - varout[name, 1]*fraction_of_hour/eff_out\n\nIf t > 1:\n\nvarenergy[name, t] == varenergy[name, t-1] + varin[name, t]*eff_in*fraction_of_hour - varout[name, t]*fraction_of_hour/eff_out\n\nLaTeX\n\nx^energy_1 == x^energy_init + frhr eta^in x^in_1 - fracfrhreta^out x^out_1 text for  t = 1\n\nx^energy_t == x^energy_t-1 + frhr eta^in x^in_t - fracfrhreta^out x^out_t forall t geq 2\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\ninitial_conditions::Vector{InitialCondition} : for time zero 'varenergy'\nefficiency_data::Tuple{Vector{String}, Vector{InOut}} :: charging/discharging efficiencies\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables\n: var_names[1] : varin\n: var_names[2] : varout\n: var_names[3] : varenergy\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.energy_balance_external_input-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Array{PowerSimulations.DeviceTimeSeries,1},Symbol,Tuple{Symbol,Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.energy_balance_external_input","text":"energy_balance_external_input(psi_container::PSIContainer,\n                    initial_conditions::Vector{InitialCondition},\n                    efficiency_data::Tuple{Vector{String}, Vector{InOut}},\n                    cons_name::Symbol,\n                    var_names::Tuple{Symbol, Symbol, Symbol})\n\nConstructs multi-timestep constraint from initial condition, efficiency data, and variable tuple\n\nConstraints\n\nIf t = 1: varenergy[name, 1] == initial_conditions[ix].value + (paraminflow[name, t] - varspill[name, 1] - varout[name, 1])*fraction_of_hour If t > 1: varenergy[name, t] == varenergy[name, t-1] + (paraminflow[name, t] - varspill[name, t] - varout[name, t])*fraction_of_hour\n\nLaTeX\n\nx^energy_1 == x^energy_init + frhr  (x^in_1 - x^spillage_1 -  x^out_1) text for  t = 1 x^energy_t == x^energy_t-1 + frhr (x^in_t - x^spillage_t - x^out_t) forall t geq 2\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\ninitial_conditions::Vector{InitialCondition} : for time zero 'varenergy'\ninflow_data::TVector{DeviceTimeSeries} :: Inflow energy forecast information\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables\n: var_names[1] : varspill\n: var_names[2] : varout\n: var_names[3] : varenergy\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.energy_balance_external_input_param-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Array{PowerSimulations.DeviceTimeSeries,1},Symbol,Tuple{Symbol,Symbol,Symbol},PowerSimulations.UpdateRef}","page":"PowerSimulations","title":"PowerSimulations.energy_balance_external_input_param","text":"energy_balance_external_input(psi_container::PSIContainer,\n                    initial_conditions::Vector{InitialCondition},\n                    efficiency_data::Tuple{Vector{String}, Vector{InOut}},\n                    cons_name::Symbol,\n                    var_names::Tuple{Symbol, Symbol, Symbol})\n\nConstructs multi-timestep constraint from initial condition, efficiency data, and variable tuple\n\nConstraints\n\nIf t = 1: varenergy[name, 1] == initial_conditions[ix].value + (paraminflow[name, t] - varspill[name, 1] - varout[name, 1])*fraction_of_hour If t > 1: varenergy[name, t] == varenergy[name, t-1] + (paraminflow[name, t] - varspill[name, t] - varout[name, t])*fraction_of_hour\n\nLaTeX\n\nx^energy_1 == x^energy_init + frhr  (x^in_1 - x^spillage_1 -  x^out_1) text for  t = 1 x^energy_t == x^energy_t-1 + frhr (x^in_t - x^spillage_t - x^out_t) forall t geq 2\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\ninitial_conditions::Vector{InitialCondition} : for time zero 'varenergy'\ninflow_data::Vector{DeviceTimeSeries} :: Inflow energy forecast information\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables\n: var_names[1] : varspill\n: var_names[2] : varout\n: var_names[3] : varenergy\nparam_reference::UpdateRef : UpdateRef to access the inflow parameter\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.export_op_model-Tuple{OperationsProblem,String}","page":"PowerSimulations","title":"PowerSimulations.export_op_model","text":"Exports the OpModel JuMP object in MathOptFormat\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.find_key_with_value-Tuple{Any,Any}","page":"PowerSimulations","title":"PowerSimulations.find_key_with_value","text":"Return the key for the given value\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.initial_condition_update!-Tuple{Stage,PowerSimulations.ICKey,Array{InitialCondition,1},InterStageChronology,Simulation}","page":"PowerSimulations","title":"PowerSimulations.initial_condition_update!","text":"Updates the initial conditions of the stage\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.initial_condition_update!-Tuple{Stage,PowerSimulations.ICKey,Array{InitialCondition,1},IntraStageChronology,Simulation}","page":"PowerSimulations","title":"PowerSimulations.initial_condition_update!","text":"Updates the initial conditions of the stage\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.instantiate_nip_expr-Tuple{PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.instantiate_nip_expr","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.instantiate_nip_expr_model-Tuple{Dict{String,Any},Any}","page":"PowerSimulations","title":"PowerSimulations.instantiate_nip_expr_model","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.instantiate_nip_model-Tuple{Dict{String,Any},Any}","page":"PowerSimulations","title":"PowerSimulations.instantiate_nip_model","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.integral_limit_ff-Tuple{PowerSimulations.PSIContainer,Symbol,PowerSimulations.UpdateRef,Symbol}","page":"PowerSimulations","title":"PowerSimulations.integral_limit_ff","text":"    integral_limit_ff(psi_container::PSIContainer,\n                    cons_name::Symbol,\n                    param_reference::UpdateRef,\n                    var_name::Symbol)\n\nConstructs a parametrized integral limit constraint to implement feedforward from other models. The Parameters are initialized using the upper boundary values of the provided variables.\n\nConstraints\n\nsum(variable[var_name, t] for t in time_steps)/length(time_steps) <= param_reference[var_name]\n\nLaTeX\n\nsum_t x leq param^max\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\ncons_name::Symbol : name of the constraint\nparam_reference : Reference to the PJ.ParameterRef used to determine the upperbound\nvar_name::Symbol : the name of the continuous variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.iterate_initial_conditions-Tuple{PowerSimulations.InitialConditions}","page":"PowerSimulations","title":"PowerSimulations.iterate_initial_conditions","text":"Iterate over the keys and vectors of initial conditions.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,Type{S},PowerSystems.System}} where S<:PowerModels.AbstractActivePowerModel","page":"PowerSimulations","title":"PowerSimulations.powermodels_network!","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,Type{S},PowerSystems.System}} where S<:PowerModels.AbstractPowerModel","page":"PowerSimulations","title":"PowerSimulations.powermodels_network!","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L<:Tuple{Vararg{Dict,N}} where Ax where N,Float64,Float64,Float64}} where JV<:JuMP.AbstractVariableRef","page":"PowerSimulations","title":"PowerSimulations.ps_cost","text":"ps_cost(psi_container::PSIContainer,\n            variable::JuMP.Containers.DenseAxisArray{JV},\n            cost_component::Float64,\n            dt::Float64,\n            sign::Float64) where {JV <: JuMP.AbstractVariableRef}\n\nReturns linear cost terms for sum of variables with common factor to be used for cost expression for psi_container model.\n\nEquation\n\ngen_cost = sum(variable)*cost_component\n\nLaTeX\n\ncost = dttimes signsum_iin I c x_i\n\nReturns:\n\nsign*gen_cost*dt\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nvariable::JuMP.Containers.DenseAxisArray{JV} : variable array\ncost_component::Float64 : cost to be associated with variable\ndt::Float64 : fraction of hour\nsign::Float64 : positive or negative sign to be associated cost term\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L<:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Array{Tuple{Float64,Float64},1}},Float64,Float64}} where JV<:JuMP.AbstractVariableRef","page":"PowerSimulations","title":"PowerSimulations.ps_cost","text":"ps_cost(psi_container::PSIContainer,\n             variable::JuMP.Containers.DenseAxisArray{JV},\n             cost_component::PSY.VariableCost{Vector{NTuple{2, Float64}}},\n             dt::Float64,\n             sign::Float64) where {JV<:JuMP.AbstractVariableRef}\n\nCreates piecewise linear cost function using a sum of variables and expression with sign and time step included.\n\nExpression\n\nJuMP.add_to_expression!(gen_cost, c)\n\nReturns signgen_costdt\n\nLaTeX\n\ncost = signtimes dt sum_vin V c_v\n\nwhere c_v is given by\n\nc_v = sum_iin Ix fracy_i - y_i-1x_i - x_i-1 v^pw_i\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nvariable::JuMP.Containers.DenseAxisArray{JV} : variable array\ncost_component::PSY.VariableCost{Vector{NTuple{2, Float64}}}\ndt::Float64 : fraction of hour\nsign::Float64 : positive or negative sign to be associated cost term\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L<:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Float64},Float64,Float64}} where JV<:JuMP.AbstractVariableRef","page":"PowerSimulations","title":"PowerSimulations.ps_cost","text":"ps_cost(psi_container::PSIContainer,\n            variable::JuMP.Containers.DenseAxisArray{JV},\n            cost_component::PSY.VariableCost{Float64},\n            dt::Float64,\n            sign::Float64) where {JV <: JuMP.AbstractVariableRef}\n\nReturns linear cost terms for sum of variables with common factor to be used for cost expression for psicontainer model. Does this by calling ```pscost``` that has Float64 cost component input.\n\nReturns:\n\nps_cost(psi_container, variable, PSY.get_cost(cost_component), dt, sign)\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nvariable::JuMP.Containers.DenseAxisArray{JV} : variable array\ncost_component::PSY.VariableCost{Float64} : container for cost to be associated with variable\ndt::Float64 : fraction of hour\nsign::Float64 : positive or negative sign to be associated cost term\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L<:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Tuple{Float64,Float64}},Float64,Float64}} where JV<:JuMP.AbstractVariableRef","page":"PowerSimulations","title":"PowerSimulations.ps_cost","text":"ps_cost(psi_container::PSIContainer,\n            variable::JuMP.Containers.DenseAxisArray{JV},\n            cost_component::PSY.VariableCost{NTuple{2, Float64}}\n            dt::Float64,\n            sign::Float64) where {JV <: JuMP.AbstractVariableRef}\n\nReturns quadratic cost terms for sum of variables with common factor to be used for cost expression for psi_container model.\n\nEquation\n\ngen_cost = dt*sign*(sum(variable.^2)*cost_component[1] + sum(variable)*cost_component[2])\n\nLaTeX\n\ncost = dttimes sign (sum_iin I c_1 v_i^2 + sum_iin I c_2 v_i )\n\nfor quadratic factor large enough. Otherwise\n\nreturn ps_cost(psi_container, variable, cost_component[2], dt, 1.0)\n\nReturns gen_cost\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nvariable::JuMP.Containers.DenseAxisArray{JV} : variable array\ncost_component::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors\nsign::Float64 : positive or negative sign to be associated cost term\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.ramp_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,D},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S<:PowerModels.AbstractPowerModel where D<:PowerSimulations.AbstractThermalFormulation where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.ramp_constraints!","text":"This function adds the ramping limits of generators when there are CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.range_ff-Tuple{PowerSimulations.PSIContainer,Symbol,Tuple{PowerSimulations.UpdateRef,PowerSimulations.UpdateRef},Symbol}","page":"PowerSimulations","title":"PowerSimulations.range_ff","text":"    range_ff(psi_container::PSIContainer,\n                    cons_name::Symbol,\n                    param_reference::NTuple{2, UpdateRef},\n                    var_name::Symbol)\n\nConstructs min/max range parametrized constraint from device variable to include feedforward.\n\nConstraints\n\nparam_reference[1][var_name] <= variable[var_name, t] variable[var_name, t] <= param_reference[2][var_name]\n\nwhere r in range_data.\n\nLaTeX\n\nparam^min leq x x leq param^max\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nparam_reference::NTuple{2, UpdateRef} : Tuple with the lower bound and upper bound parameter reference\ncons_name::Symbol : name of the constraint\nvar_name::Symbol : the name of the continuous variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.rating_constraint!-Tuple{PowerSimulations.PSIContainer,Array{Tuple{String,Float64},1},Symbol,Tuple{Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.rating_constraint!","text":"rating_constraint!(psi_container::PSIContainer,\n                        rating_data::Vector{Tuple{String, Float64}},\n                        cons_name::Symbol,\n                        var_names::Tuple{Symbol, Symbol})\n\nConstructs constraint from rating data and related variable tuple.\n\nConstraint\n\nvar1[r[1], t]^2 + var2[r[1], t]^2 <= r[2]^2\n\nwhere r in rating data and t in time steps.\n\nLaTeX\n\nx_1^2 + x_2^2 leq r^2\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nrating_data::Vector{Tuple{String, Float64}} : rating data name (1) and value (2)\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol} : the names of the variables\n: var_names[1] : var1\n: var_names[2] : var2\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.reactive_power_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{St}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{St},DeviceModel{St,D},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S<:PowerModels.AbstractPowerModel where D<:PowerSimulations.AbstractStorageFormulation where St<:PowerSystems.Storage","page":"PowerSimulations","title":"PowerSimulations.reactive_power_constraints!","text":"This function adds the reactive  power limits of generators when there are CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.reactivepower_constraints!-Union{Tuple{L}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{L},DeviceModel{L,#s531} where #s531<:PowerSimulations.AbstractControllablePowerLoadFormulation,Type{#s109} where #s109<:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where L<:PowerSystems.ElectricLoad","page":"PowerSimulations","title":"PowerSimulations.reactivepower_constraints!","text":"Reactive Power Constraints on Controllable Loads Assume Constant PowerFactor\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.reactivepower_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,#s531} where #s531<:PowerSimulations.AbstractThermalDispatchFormulation,Type{#s109} where #s109<:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.reactivepower_constraints!","text":"This function adds the reactive  power limits of generators when there are CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.reactivepower_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,#s531} where #s531<:PowerSimulations.AbstractThermalFormulation,Type{#s109} where #s109<:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.reactivepower_constraints!","text":"This function adds the reactive power limits of generators when there CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.reactivepower_variables!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.reactivepower_variables!","text":"This function add the variables for power generation output to the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_json-Tuple{AbstractString}","page":"PowerSimulations","title":"PowerSimulations.read_json","text":"Return a decoded JSON file.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.remove_chars-Tuple{String,String}","page":"PowerSimulations","title":"PowerSimulations.remove_chars","text":"Removes the string char from the original string\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.replace_chars-Tuple{String,String,String}","page":"PowerSimulations","title":"PowerSimulations.replace_chars","text":"Replaces the string in char with the stringreplacement\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.reserve_device_semicontinuousrange-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRange,1},Symbol,Symbol,Symbol}","page":"PowerSimulations","title":"PowerSimulations.reserve_device_semicontinuousrange","text":"reserve_device_semicontinuousrange(psi_container::PSIContainer,\n                                range_data::Vector{DeviceRange},\n                                cons_name::Symbol,\n                                var_name::Symbol,\n                                binvar_name::Symbol)\n\nConstructs min/max range constraint from device variable and on/off decision variable.\n\nConstraints\n\nIf device min = 0:\n\nvarcts[name, t] <= limits.max * (1 - varbin[name, t])\n\nvarcts[name, t] >= 0.0\n\nOtherwise:\n\nvarcts[name, t] <= limits.max * (1 - varbin[name, t])\n\nvarcts[name, t] >= limits.min * (1 - varbin[name, t])\n\nwhere limits in range_data.\n\nLaTeX\n\n0 leq x^cts leq limits^max (1 - x^bin ) text for  limits^min = 0\n\nlimits^min (1 - x^bin ) leq x^cts leq limits^max (1 - x^bin ) text otherwise \n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nrange_data::Vector{DeviceRange} : contains names and vector of min/max\ncons_name::Symbol : name of the constraint\nvar_name::Symbol : the name of the continuous variable\nbinvar_name::Symbol : the name of the binary variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.semicontinuousrange_ff-Tuple{PowerSimulations.PSIContainer,Symbol,PowerSimulations.UpdateRef,Symbol}","page":"PowerSimulations","title":"PowerSimulations.semicontinuousrange_ff","text":"        semicontinuousrange_ff(psi_container::PSIContainer,\n                                cons_name::Symbol,\n                                var_name::Symbol,\n                                param_reference::UpdateRef)\n\nConstructs min/max range constraint from device variable with parameter setting.\n\nConstraints\n\nIf device min = 0:\n\nvariable[var_name, t] <= r[2].max*param_reference[var_name]\n\nOtherwise:\n\nvariable[var_name, t] <= r[2].max*param_reference[var_name]\n\nvariable[var_name, t] >= r[2].min*param_reference[var_name]\n\nwhere r in range_data.\n\nLaTeX\n\n00 leq x^var leq r^max x^param text for  r^min = 0\n\nr^min x^param leq x^var leq r^min x^param text otherwise \n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\ncons_name::Symbol : name of the constraint\nvar_name::Symbol : the name of the continuous variable\nparam_reference::UpdateRef : UpdateRef of the parameter\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.serialize-Tuple{Simulation}","page":"PowerSimulations","title":"PowerSimulations.serialize","text":"serialize(simulation::Simulation, path = \".\")\n\nSerialize the simulation to a directory in path.\n\nReturn the serialized simulation directory name that is created.\n\nArguments\n\nsimulation::Simulation: simulation to serialize\npath = \".\": path in which to create the serialzed directory\nforce = false: If true, delete the directory if it already exists. Otherwise, it will  throw an exception.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.set_variable_bounds!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRange,1},AbstractString,Type{T}}} where T<:PowerSystems.Device","page":"PowerSimulations","title":"PowerSimulations.set_variable_bounds!","text":"set_variable_bounds!(\n    psi_container::PSIContainer,\n    bounds::DeviceRange,\n    var_type::AbstractString,\n    device_type::Type{PSY.Device},\n)\n\nAdds a bounds to a variable in the optimization model.\n\nBounds\n\nbounds.min <= varstart[name, t] <= bounds.max\n\nLaTeX\n\nx^device_t = bound^min forall t\n\nx^device_t = bound^max forall t\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nbounds::DeviceRange : contains names and vector of min / max\nvar_type::AbstractString : type of the variable\nT: type of the device\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.status_init-Union{Tuple{T}, Tuple{PowerSimulations.InitialConditions,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.status_init","text":"Status Init is always calculated based on the Power Output of the device This is to make it easier to calculate when the previous model doesn't contain binaries. For instance, looking back on an ED model to find the IC of the UC model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.ub_ff-Tuple{PowerSimulations.PSIContainer,Symbol,PowerSimulations.UpdateRef,Symbol}","page":"PowerSimulations","title":"PowerSimulations.ub_ff","text":"    ub_ff(psi_container::PSIContainer,\n          cons_name::Symbol,\n          param_reference::UpdateRef,\n          var_name::Symbol)\n\nConstructs a parametrized upper bound constraint to implement feedforward from other models. The Parameters are initialized using the uppper boundary values of the provided variables.\n\nConstraints\n\nvariable[var_name, t] <= param_reference[var_name]\n\nLaTeX\n\nx leq param^max\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\ncons_name::Symbol : name of the constraint\nparam_reference : Reference to the PJ.ParameterRef used to determine the upperbound\nvar_name::Symbol : the name of the continuous variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.update_parameter!-Tuple{PowerSimulations.UpdateRef{JuMP.VariableRef},PowerSimulations.ParameterContainer,Stage,Simulation}","page":"PowerSimulations","title":"PowerSimulations.update_parameter!","text":"Updates the forecast parameter value\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.update_stage!-Union{Tuple{M}, Tuple{Stage{M},Simulation}} where M<:PowerSimulations.PowerSimulationsOperationsProblem","page":"PowerSimulations","title":"PowerSimulations.update_stage!","text":"Generic Stage update function for most problems with no customization\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.variable_active_net_injection-Tuple{PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.variable_active_net_injection","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.variable_net_injection-Tuple{PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.variable_net_injection","text":"generates variables for both active and reactive net injection\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.variable_reactive_net_injection-Tuple{PowerModels.AbstractActivePowerModel}","page":"PowerSimulations","title":"PowerSimulations.variable_reactive_net_injection","text":"active power only models ignore reactive power variables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.variable_reactive_net_injection-Tuple{PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.variable_reactive_net_injection","text":"\n\n\n\n","category":"method"},{"location":"man/logging/#Logging-1","page":"Logging","title":"Logging","text":"","category":"section"},{"location":"man/logging/#","page":"Logging","title":"Logging","text":"PowerSimulations will output many log messages when building systems and running simulations. You may want to customize what gets logged to the console and, optionally, a file.","category":"page"},{"location":"man/logging/#","page":"Logging","title":"Logging","text":"By default all log messages of level Logging.Info or higher will get displayed to the console.  When you run a simulation a simulation-specific logger will take over and log its messages to a file in the logs directory in the simulation output directory. When finished it will relinquish control back to the global logger.","category":"page"},{"location":"man/logging/#Configuring-the-global-logger-1","page":"Logging","title":"Configuring the global logger","text":"","category":"section"},{"location":"man/logging/#","page":"Logging","title":"Logging","text":"To configure the global logger in a Jupyter Notebook or REPL you may configure your own logger with the Julia Logging standard library or use the convenience function provided by PowerSimulations.  This example will log messages of level Logging.Error to console and Logging.Info and higher to the file power-simulations.log in the current directory.","category":"page"},{"location":"man/logging/#","page":"Logging","title":"Logging","text":"import Logging\nusing PowerSimulations\nlogger = configure_logging(\n    console_level = Logging.Error,\n    file_level = Logging.Info,\n    filename = \"power-simulations.log\"\n)","category":"page"},{"location":"man/logging/#Configuring-the-simulation-logger-1","page":"Logging","title":"Configuring the simulation logger","text":"","category":"section"},{"location":"man/logging/#","page":"Logging","title":"Logging","text":"You can configure the logging level used by the simulation logger when you call build!(simulation).  Here is an example that increases logging verbosity:","category":"page"},{"location":"man/logging/#","page":"Logging","title":"Logging","text":"import Logging\nusing PowerSimulations\nsimulation = Simulation(...)\nbuild!(simulation, console_level = Logging.Info, file_level = Logging.Debug)","category":"page"},{"location":"man/logging/#","page":"Logging","title":"Logging","text":"The log file will be located at <your-output-path>/<simulation-name>/<run-output-dir>/logs/simulation.log.","category":"page"},{"location":"man/logging/#Solver-logs-1","page":"Logging","title":"Solver logs","text":"","category":"section"},{"location":"man/logging/#","page":"Logging","title":"Logging","text":"You can configure logging for the solver you use.  Refer to the solver documentation.  PowerSimulations does not redirect or intercept prints to stdout or stderr from other libraries.","category":"page"},{"location":"man/logging/#Recorder-events-1","page":"Logging","title":"Recorder events","text":"","category":"section"},{"location":"man/logging/#","page":"Logging","title":"Logging","text":"PowerSimulations uses the InfrastructureSystems.Recorder to store simulation events in a log file.  Refer to this link for more information.","category":"page"},{"location":"glossary/#Glossary-1","page":"Glossary","title":"Glossary","text":"","category":"section"},{"location":"glossary/#Simulation-Sequence-Components-1","page":"Glossary","title":"Simulation Sequence Components","text":"","category":"section"},{"location":"glossary/#","page":"Glossary","title":"Glossary","text":"cache: Cache is used to store quantities resulting from the solutions of a stage.","category":"page"},{"location":"glossary/#","page":"Glossary","title":"Glossary","text":"chronology: The vertical inter-stage relationship dictating how variable results impact the next stage's variable parameters.","category":"page"},{"location":"glossary/#","page":"Glossary","title":"Glossary","text":"Example: feedforward_chronologies = Dict((\"stage-1\" => \"stage-2\") => Synchronize(periods = 24)) This chronology uses the first 24 solutions in the horizon to synchronize with 24 executions of stage 2.","category":"page"},{"location":"glossary/#","page":"Glossary","title":"Glossary","text":"feedforward: The variable that is used as a parameter for a later stage.","category":"page"},{"location":"glossary/#","page":"Glossary","title":"Glossary","text":"Example: feedforward = Dict((\"stage-2\", :devices, :Generators) => SemiContinuousFF(binary_from_stage = PSI.ON, affected_variables = [PSI.ACTIVE_POWER]) This semi-continuous feedforward passes binary results from the first stage to parameters of the active power of the second stage.","category":"page"},{"location":"glossary/#","page":"Glossary","title":"Glossary","text":"horizons: The integer count of resolution time periods for a full step resolution of the simulation. (Horizon = 12) x (resolution = 1 Hour) = 12 Hours","category":"page"},{"location":"glossary/#","page":"Glossary","title":"Glossary","text":"Example: horizons = Dict(\"stage-1\" => 24, \"stage-2\" => 12) The first stage has a horizon of 24, representing 24 1-hour increments. The second stage has a horizon of 12, representing 12 5-min increments","category":"page"},{"location":"glossary/#","page":"Glossary","title":"Glossary","text":"initial condition chronology: The structure dictating how initial conditions get updated from previous results in the simulation.","category":"page"},{"location":"glossary/#","page":"Glossary","title":"Glossary","text":"Examples: ini_cond_chronology = InterStageChronology()","category":"page"},{"location":"glossary/#","page":"Glossary","title":"Glossary","text":"1\n|\n2                   2 ... (x04)\n|             ┌----/|\n|             |     |\n3 --> 3 ... (x12)   3 --> 3 ... (x12)","category":"page"},{"location":"glossary/#","page":"Glossary","title":"Glossary","text":"This represents an inter-stage chronology where the results of each stage feed back into the initial conditions of the stage above it.","category":"page"},{"location":"glossary/#","page":"Glossary","title":"Glossary","text":"ini_cond_chronology = IntraStageChronology()","category":"page"},{"location":"glossary/#","page":"Glossary","title":"Glossary","text":"1\n\n2 ----------------> 2 ... (x04)\n\n3 --> 3 ... (x12)   3 --> 3 ... (x12)","category":"page"},{"location":"glossary/#","page":"Glossary","title":"Glossary","text":"This represents an intra-stage chronology where the results of each simulation run feed back into the initial conditions of the next simulation for that stage.","category":"page"},{"location":"glossary/#","page":"Glossary","title":"Glossary","text":"intervals: The increment of time per stage in each simulation solve, and how results get fed forward into initial conditions between intervals.","category":"page"},{"location":"glossary/#","page":"Glossary","title":"Glossary","text":"Example: intervals = Dict(\"UC\" => (Hour(24), Consecutive()), \"ED\" => (Hour(1), Consecutive()))","category":"page"},{"location":"glossary/#","page":"Glossary","title":"Glossary","text":"Operations Problem A single-step optimization problem.","category":"page"},{"location":"glossary/#","page":"Glossary","title":"Glossary","text":"Simulations Problem: A multi-step and/or multi-stage optimization problem.","category":"page"},{"location":"glossary/#","page":"Glossary","title":"Glossary","text":"Simulation Sequence: Simulation Sequence formulates the structure and flow of results through the simulation. It sets up the feedforward and initial condition chronologies, the horizon, intervals, and order.","category":"page"},{"location":"glossary/#","page":"Glossary","title":"Glossary","text":"Stage: Each stage represents a formulation of a problem to be solved, such as unit commitment or economic dispatch. Each stage has its own system with a specified time-scale.","category":"page"},{"location":"glossary/#","page":"Glossary","title":"Glossary","text":"Example:","category":"page"},{"location":"glossary/#","page":"Glossary","title":"Glossary","text":"\"UC\" => Stage(GenericOpProblem, template, system, optimizer)","category":"page"},{"location":"glossary/#","page":"Glossary","title":"Glossary","text":"problem: The optimization problem populated with the specific system to be solved.","category":"page"},{"location":"glossary/#","page":"Glossary","title":"Glossary","text":"step resolution: The time period representing the time length of the whole simulation before it repeats.","category":"page"},{"location":"glossary/#","page":"Glossary","title":"Glossary","text":"Example: step_resolution = Hour(24)","category":"page"},{"location":"glossary/#","page":"Glossary","title":"Glossary","text":"template: The structure of the problem to be solved, without the actual system data that makes it a populated problem.","category":"page"},{"location":"glossary/#","page":"Glossary","title":"Glossary","text":"Time Increments: ***Resolution ≤ Interval ≤ Step Resolution***","category":"page"},{"location":"#PowerSimulations.jl-1","page":"Introduction","title":"PowerSimulations.jl","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"CurrentModule = PowerSimulations","category":"page"},{"location":"#Overview-1","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"PowerSimulations.jl is a Julia/JuMP package designed to develop and study power system operation models in steady-state. It uses the data model implemented in PowerSystems.jl to construct optimization models.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The package supports to major analysis tools.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Operational Models: Meant to study and analyze multiperiod operational model formulations that can specified by the combination of device formulations and network models.\nSimulations Models: Developed to run equences of operational models to study model interactions sucha as cost-production-modeling.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The documentation is still work in progress.","category":"page"},{"location":"#Installation-1","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The latest stable release of PowerModels can be installed using the Julia package manager with","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"] add PowerSimulations","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"For the current development version, \"checkout\" this package with","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"] add PowerSimulations#master","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"An appropiate optimization solver is required for running PowerSimulations models. Refer to JuMP.jl solver's page to select the most appropiate for the application of interest.","category":"page"},{"location":"man/op_problem/#Operational-Model-1","page":"Operation Model","title":"Operational Model","text":"","category":"section"},{"location":"man/op_problem/#","page":"Operation Model","title":"Operation Model","text":"An operational model is defined as the combination of an objective function (\\refeq{gpsimulations}) in terms of state x and control u variables. Equations (\\refeq{dpsimulations}) describe the device model formulations as a function of variables, parameters eta and uncertainty terms omega. Further, equations (\\refeq{n_psimulations}) represents the network modeling and finally the system services.","category":"page"},{"location":"man/op_problem/#","page":"Operation Model","title":"Operation Model","text":"In the same fashion as in PowerSystems.jl, the objective is not to list all possible formulations for devices, network, and services in a power system model. Rather, the contribution is to develop a type hierarchy that enables developers to create new formulations and allow analysts a  natural way to describe the functional assumptions used in the model.","category":"page"}]
}
