var documenterSearchIndex = {"docs":
[{"location":"api/PowerSimulations/#PowerSimulations","page":"PowerSimulations","title":"PowerSimulations","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"PowerSimulations","title":"PowerSimulations","text":"CurrentModule = PowerSimulations\nDocTestSetup  = quote\n    using PowerSimulations\nend","category":"page"},{"location":"api/PowerSimulations/","page":"PowerSimulations","title":"PowerSimulations","text":"API documentation","category":"page"},{"location":"api/PowerSimulations/","page":"PowerSimulations","title":"PowerSimulations","text":"Pages = [\"PowerSimulations.md\"]","category":"page"},{"location":"api/PowerSimulations/#Index","page":"PowerSimulations","title":"Index","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"PowerSimulations","title":"PowerSimulations","text":"Pages = [\"PowerSimulations.md\"]","category":"page"},{"location":"api/PowerSimulations/#Exported","page":"PowerSimulations","title":"Exported","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"PowerSimulations","title":"PowerSimulations","text":"Modules = [PowerSimulations]\nPrivate = false","category":"page"},{"location":"api/PowerSimulations/#PowerSimulations.AGCReserveDeployment-Tuple{System}","page":"PowerSimulations","title":"PowerSimulations.AGCReserveDeployment","text":"AGCReserveDeployment(system::System; kwargs...) -> DecisionModel{UnitCommitmentProblem}\n\n\nAGCReserveDeployment(system::PSY.System; kwargs...)\n\nCreates a ProblemTemplate with default DeviceModels for an AGC Reserve Deplyoment Problem. Uses the template to create an DecisionProblem.\n\nExample\n\nagc_problem = AGCReserveDeployment(system)\n\n\n# Accepted Key Words\n- Key word arguments supported by `DecisionProblem`\n\nAGCReserveDeployment(system; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/decision_problems.jl:90.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.ActivePowerInVariable","page":"PowerSimulations","title":"PowerSimulations.ActivePowerInVariable","text":"Struct to dispatch the creation of Active Power Input Variables for 2-directional devices. For instance storage or pump-hydro\n\nActivePowerInVariable()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/variables.jl:47.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ActivePowerOutVariable","page":"PowerSimulations","title":"PowerSimulations.ActivePowerOutVariable","text":"Struct to dispatch the creation of Active Power Output Variables for 2-directional devices. For instance storage or pump-hydro\n\nActivePowerOutVariable()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/variables.jl:52.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ActivePowerVariable","page":"PowerSimulations","title":"PowerSimulations.ActivePowerVariable","text":"Struct to dispatch the creation of Active Power Variables\n\nActivePowerVariable()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/variables.jl:37.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.DecisionModel","page":"PowerSimulations","title":"PowerSimulations.DecisionModel","text":"DecisionModel(::Type{M},\ntemplate::ProblemTemplate,\nsys::PSY.System,\njump_model::Union{Nothing, JuMP.Model}=nothing;\nkwargs...) where {M<:DecisionProblem,\n                  T<:PM.AbstractPowerFormulation}\n\nThis builds the optimization problem of type M with the specific system and template.\n\nArguments\n\n::Type{M} where M<:DecisionProblem: The abstract operation model type\ntemplate::ProblemTemplate: The model reference made up of transmission, devices, branches, and services.\nsys::PSY.System: the system created using Power Systems\njump_model::Union{Nothing, JuMP.Model}: Enables passing a custom JuMP model. Use with care\n\nOutput\n\nmodel::DecisionModel: The operation model containing the model type, built JuMP model, Power Systems system.\n\nExample\n\ntemplate = ProblemTemplate(CopperPlatePowerModel, devices, branches, services)\nOpModel = DecisionModel(MockOperationProblem, template, system)\n\nAccepted Key Words\n\noptimizer: The optimizer that will be used in the optimization model.\nhorizon::Int: Manually specify the length of the forecast Horizon\nwarm_start::Bool: True will use the current operation point in the system to initialize variable values. False initializes all variables to zero. Default is true\nsystem_to_file::Bool:: True to create a copy of the system used in the model. Default true.\nexport_pwl_vars::Bool: True to export all the pwl intermediate variables. It can slow down significantly the solve time. Default is false.\nallow_fails::Bool: True to allow the simulation to continue even if the optimization step fails. Use with care, default to false.\noptimizer_solve_log_print::Bool: True to print the optimizer solve log. Default is false.\ndirect_mode_optimizer::Bool True to use the solver in direct mode. Creates a JuMP.direct_model. Default is false.\ninitial_time::Dates.DateTime: Initial Time for the model solve\ntime_series_cache_size::Int: Size in bytes to cache for each time array. Default is 1 MiB. Set to 0 to disable.\n\nDecisionModel(, template, sys)\nDecisionModel(, template, sys, jump_model; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/decision_model.jl:171.\n\nDecisionModel(template, sys)\nDecisionModel(template, sys, jump_model; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/decision_model.jl:181.\n\nDecisionModel(directory, optimizer; jump_model, system)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/decision_model.jl:206.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.DecisionModel-Tuple{AbstractString, MathOptInterface.OptimizerWithAttributes}","page":"PowerSimulations","title":"PowerSimulations.DecisionModel","text":"DecisionModel(directory::AbstractString, optimizer::MathOptInterface.OptimizerWithAttributes; jump_model, system) -> Any\n\n\nDecisionModel(directory::AbstractString)\n\nConstruct an DecisionProblem from a serialized file.\n\nArguments\n\ndirectory::AbstractString: Directory containing a serialized model\njump_model::Union{Nothing, JuMP.Model} = nothing: The JuMP model does not get serialized. Callers should pass whatever they passed to the original problem.\noptimizer::Union{Nothing,MOI.OptimizerWithAttributes} = nothing: The optimizer does not get serialized. Callers should pass whatever they passed to the original problem.\nsystem::Union{Nothing, PSY.System}: Optionally, the system used for the model. If nothing and systofile was set to true when the model was created, the system will be deserialized from a file.\n\nDecisionModel(directory, optimizer; jump_model, system)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/decision_model.jl:206.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.DecisionModel-Union{Tuple{M}, Tuple{Type{M}, ProblemTemplate, System}, Tuple{Type{M}, ProblemTemplate, System, Union{Nothing, JuMP.Model}}} where M<:PowerSimulations.DecisionProblem","page":"PowerSimulations","title":"PowerSimulations.DecisionModel","text":"DecisionModel(::Type{M<:PowerSimulations.DecisionProblem}, template::ProblemTemplate, sys::System) -> Any\nDecisionModel(::Type{M<:PowerSimulations.DecisionProblem}, template::ProblemTemplate, sys::System, jump_model::Union{Nothing, JuMP.Model}; kwargs...) -> Any\n\n\nDecisionModel(::Type{M},\ntemplate::ProblemTemplate,\nsys::PSY.System,\noptimizer::MOI.OptimizerWithAttributes,\njump_model::Union{Nothing, JuMP.Model}=nothing;\nkwargs...) where {M <: DecisionProblem}\n\nThis builds the optimization problem of type M with the specific system and template\n\nArguments\n\n::Type{M} where M<:DecisionProblem: The abstract operation model type\ntemplate::ProblemTemplate: The model reference made up of transmission, devices, branches, and services.\nsys::PSY.System: the system created using Power Systems\njump_model::Union{Nothing, JuMP.Model}: Enables passing a custom JuMP model. Use with care\n\nOutput\n\nStage::DecisionProblem: The operation model containing the model type, unbuilt JuMP model, Power Systems system.\n\nExample\n\ntemplate = ProblemTemplate(CopperPlatePowerModel, devices, branches, services) problem = DecisionModel(MyOpProblemType template, system, optimizer)\n\n# Accepted Key Words\n- `initial_time::Dates.DateTime`: Initial Time for the model solve\n- `warm_start::Bool` True will use the current operation point in the system to initialize variable values. False initializes all variables to zero. Default is true\n- `export_pwl_vars::Bool` True will write the results of the piece-wise-linear intermediate variables. Slows down the simulation process significantly\n- `allow_fails::Bool` True will allow the simulation to continue if the optimizer can't find a solution. Use with care, can lead to unwanted behaviour or results\n- `optimizer_solve_log_print::Bool` Uses JuMP.unset_silent() to print the optimizer's log. By default all solvers are set to `MOI.Silent()`\n- `name`: name of model, string or symbol; defaults to the type of template converted to a symbol\n\nDecisionModel(, template, sys)\nDecisionModel(, template, sys, jump_model; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/decision_model.jl:171.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.DeviceModel","page":"PowerSimulations","title":"PowerSimulations.DeviceModel","text":"Establishes the model for a particular device specified by type. Uses the keyword argument feedforward to enable passing values between operation model at simulation time\n\nArguments\n\n-::Type{D}: Power System Device Type -::Type{B}: Abstract Device Formulation\n\nAccepted Key Words\n\nfeedforward::Array{<:AbstractAffectFeedforward} : use to pass parameters between models\n\nExample\n\nthermal_gens = DeviceModel(ThermalStandard, ThermalBasicUnitCommitment),\n\nDeviceModel(, ; feedforwards, use_slacks, duals, time_series_names, attributes)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/device_model.jl:40.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.EconomicDispatchProblem-Tuple{System}","page":"PowerSimulations","title":"PowerSimulations.EconomicDispatchProblem","text":"EconomicDispatchProblem(system::System; kwargs...) -> DecisionModel{EconomicDispatchProblem}\n\n\nEconomicDispatchProblem(system::PSY.System; kwargs...)\n\nCreates a ProblemTemplate with default DeviceModels for an EconomicDispatch problem. Uses the template to create an DecisionProblem.\n\nExample\n\ned_problem = EconomicDispatchProblem(system)\n\n\n# Accepted Key Words\n- `network::Type{<:PM.AbstractPowerModel}` : override default network model settings\n- `devices::Dict{String, DeviceModel}` : override default `DeviceModel` settings\n- `services::Dict{String, ServiceModel}` : override default `ServiceModel` settings\n- Key word arguments supported by `DecisionProblem`\n\nEconomicDispatchProblem(system; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/decision_problems.jl:31.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.EmulationModel","page":"PowerSimulations","title":"PowerSimulations.EmulationModel","text":"EmulationModel(::Type{M},\ntemplate::ProblemTemplate,\nsys::PSY.System,\njump_model::Union{Nothing, JuMP.Model}=nothing;\nkwargs...) where {M<:EmulationProblem,\n                  T<:PM.AbstractPowerFormulation}\n\nThis builds the optimization problem of type M with the specific system and template.\n\nArguments\n\n::Type{M} where M<:EmulationProblem: The abstract Emulation model type\ntemplate::ProblemTemplate: The model reference made up of transmission, devices, branches, and services.\nsys::PSY.System: the system created using Power Systems\njump_model::Union{Nothing, JuMP.Model}: Enables passing a custom JuMP model. Use with care\n\nOutput\n\nmodel::EmulationModel: The Emulation model containing the model type, built JuMP model, Power Systems system.\n\nExample\n\ntemplate = ProblemTemplate(CopperPlatePowerModel, devices, branches, services) OpModel = EmulationModel(MockEmulationProblem, template, system)\n\nAccepted Key Words\n\noptimizer: The optimizer that will be used in the optimization model.\nwarm_start::Bool: True will use the current Emulation point in the system to initialize variable values. False initializes all variables to zero. Default is true\nsystem_to_file::Bool:: True to create a copy of the system used in the model. Default true.\nexport_pwl_vars::Bool: True to export all the pwl intermediate variables. It can slow down significantly the solve time. Default is false.\nallow_fails::Bool: True to allow the simulation to continue even if the optimization step fails. Use with care, default to false.\noptimizer_solve_log_print::Bool: True to print the optimizer solve log. Default is false.\ndirect_mode_optimizer::Bool True to use the solver in direct mode. Creates a JuMP.direct_model. Default is false.\ninitial_time::Dates.DateTime: Initial Time for the model solve\ntime_series_cache_size::Int: Size in bytes to cache for each time array. Default is 1 MiB. Set to 0 to disable.\n\nEmulationModel(, template, sys)\nEmulationModel(, template, sys, jump_model; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/emulation_model.jl:159.\n\nEmulationModel(template, sys)\nEmulationModel(template, sys, jump_model; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/emulation_model.jl:169.\n\nEmulationModel(directory, optimizer; jump_model, system, kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/emulation_model.jl:194.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.EmulationModel-Tuple{AbstractString, MathOptInterface.OptimizerWithAttributes}","page":"PowerSimulations","title":"PowerSimulations.EmulationModel","text":"EmulationModel(directory::AbstractString, optimizer::MathOptInterface.OptimizerWithAttributes; jump_model, system, kwargs...) -> Any\n\n\nEmulationModel(directory::AbstractString)\n\nConstruct an EmulationProblem from a serialized file.\n\nArguments\n\ndirectory::AbstractString: Directory containing a serialized model.\noptimizer::MOI.OptimizerWithAttributes: The optimizer does not get serialized. Callers should pass whatever they passed to the original problem.\njump_model::Union{Nothing, JuMP.Model} = nothing: The JuMP model does not get serialized. Callers should pass whatever they passed to the original problem.\nsystem::Union{Nothing, PSY.System}: Optionally, the system used for the model. If nothing and systofile was set to true when the model was created, the system will be deserialized from a file.\n\nEmulationModel(directory, optimizer; jump_model, system, kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/emulation_model.jl:194.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.EmulationModel-Union{Tuple{M}, Tuple{Type{M}, ProblemTemplate, System}, Tuple{Type{M}, ProblemTemplate, System, Union{Nothing, JuMP.Model}}} where M<:PowerSimulations.EmulationProblem","page":"PowerSimulations","title":"PowerSimulations.EmulationModel","text":"EmulationModel(::Type{M<:PowerSimulations.EmulationProblem}, template::ProblemTemplate, sys::System) -> Any\nEmulationModel(::Type{M<:PowerSimulations.EmulationProblem}, template::ProblemTemplate, sys::System, jump_model::Union{Nothing, JuMP.Model}; kwargs...) -> Any\n\n\nEmulationModel(::Type{M},\ntemplate::ProblemTemplate,\nsys::PSY.System,\noptimizer::MOI.OptimizerWithAttributes,\njump_model::Union{Nothing, JuMP.Model}=nothing;\nkwargs...) where {M <: EmulationProblem}\n\nThis builds the optimization problem of type M with the specific system and template\n\nArguments\n\n::Type{M} where M<:EmulationProblem: The abstract Emulation model type\ntemplate::ProblemTemplate: The model reference made up of transmission, devices, branches, and services.\nsys::PSY.System: the system created using Power Systems\njump_model::Union{Nothing, JuMP.Model}: Enables passing a custom JuMP model. Use with care\n\nOutput\n\nStage::EmulationProblem: The Emulation model containing the model type, unbuilt JuMP model, Power Systems system.\n\nExample\n\ntemplate = ProblemTemplate(CopperPlatePowerModel, devices, branches, services) problem = EmulationModel(MyOpProblemType template, system, optimizer)\n\nAccepted Key Words\n\ninitial_time::Dates.DateTime: Initial Time for the model solve\nwarm_start::Bool True will use the current Emulation point in the system to initialize variable values. False initializes all variables to zero. Default is true\nexport_pwl_vars::Bool True will write the results of the piece-wise-linear intermediate variables. Slows down the simulation process significantly\nallow_fails::Bool True will allow the simulation to continue if the optimizer can't find a solution. Use with care, can lead to unwanted behaviour or results\noptimizer_solve_log_print::Bool Uses JuMP.unset_silent() to print the optimizer's log. By default all solvers are set to MOI.Silent()\nname: name of model, string or symbol; defaults to the type of template converted to a symbol\n\nEmulationModel(, template, sys)\nEmulationModel(, template, sys, jump_model; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/emulation_model.jl:159.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.EnergyLimitFeedforward","page":"PowerSimulations","title":"PowerSimulations.EnergyLimitFeedforward","text":"Adds a constraint to limit the sum of a variable over the number of periods to the source value\n\nEnergyLimitFeedforward(; component_type, source, affected_values, number_of_periods, meta)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/feedforward/feedforwards.jl:141.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.EnergyOutput","page":"PowerSimulations","title":"PowerSimulations.EnergyOutput","text":"Auxiliary Variable for Hydro and Storage Models that solve for total energy output\n\nEnergyOutput()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/auxiliary_variables.jl:29.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.EnergyTargetFeedforward","page":"PowerSimulations","title":"PowerSimulations.EnergyTargetFeedforward","text":"Adds a constraint to enforce a minimum energy level target with a slack variable associated witha penalty term.\n\nEnergyTargetFeedforward(; component_type, source, affected_values, target_period, penalty_cost, meta)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/feedforward/feedforwards.jl:210.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.FixValueFeedforward","page":"PowerSimulations","title":"PowerSimulations.FixValueFeedforward","text":"Fixes a Variable or Parameter Value in the model. Is the only Feed Forward that can be used with a Parameter or a Variable as the affected value.\n\nFixValueFeedforward(; component_type, source, affected_values, meta)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/feedforward/feedforwards.jl:178.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.FlowActivePowerVariable","page":"PowerSimulations","title":"PowerSimulations.FlowActivePowerVariable","text":"Struct to dispatch the creation of Flow Active Power Variables\n\nFlowActivePowerVariable()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/variables.jl:115.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.GenericOpProblem","page":"PowerSimulations","title":"PowerSimulations.GenericOpProblem","text":"Default PowerSimulations Operation Problem Type\n\nGenericOpProblem()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/decision_model.jl:4.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.InitialCondition","page":"PowerSimulations","title":"PowerSimulations.InitialCondition","text":"Container for the initial condition data\n\nInitialCondition(_, component, value)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/initial_conditions.jl:27.\n\nInitialCondition(_, component, value)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/initial_conditions.jl:35.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.IntraProblemChronology","page":"PowerSimulations","title":"PowerSimulations.IntraProblemChronology","text":"InterProblemChronology()\n\nType struct to select an information sharing model between stages that uses results from the same recent stage to calculate the initial conditions. This model ignores solutions from stages defined finer resolutions.\n\nIntraProblemChronology()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/initial_conditions/initial_condition_chronologies.jl:16.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.LowerBoundFeedforward","page":"PowerSimulations","title":"PowerSimulations.LowerBoundFeedforward","text":"Adds a lower bound constraint to a variable.\n\nLowerBoundFeedforward(; component_type, source, affected_values, meta)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/feedforward/feedforwards.jl:56.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.NetworkModel","page":"PowerSimulations","title":"PowerSimulations.NetworkModel","text":"Establishes the model for a particular device specified by type.\n\nArguments\n\n-::Type{T}: PowerModels AbstractPowerModel\n\nAccepted Key Words\n\nuse_slacks::Bool: Adds slacks to the network modelings\nPTDF::PSY.PTDF: PTDF Array calculated using PowerSystems\nduals::Vector{DataType}: Constraint types to calculate the duals\n\nExample\n\nptdfarray = PSY.PTDF(system) thermalgens = NetworkModel(StandardPTDFModel, ptdf = ptdf_array),\n\nNetworkModel(; use_slacks, PTDF, duals)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/network_model.jl:34.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.PowerAboveMinimumVariable","page":"PowerSimulations","title":"PowerSimulations.PowerAboveMinimumVariable","text":"Struct to dispatch the creation of Active Power Variables above minimum power for Thermal Compact formulations\n\nPowerAboveMinimumVariable()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/variables.jl:42.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.PowerOutput","page":"PowerSimulations","title":"PowerSimulations.PowerOutput","text":"Auxiliary Variable for Thermal Generation Models that solve for power above min\n\nPowerOutput()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/auxiliary_variables.jl:25.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ProblemResults-Tuple{AbstractString}","page":"PowerSimulations","title":"PowerSimulations.ProblemResults","text":"ProblemResults(directory::AbstractString) -> Any\n\n\nConstruct a ProblemResults instance from a serialized directory.\n\nIf the directory contains a serialized PowerSystems.System then it will deserialize that system and add it to the results. Otherwise, it is up to the caller to call set_system! on the returned instance to restore it.\n\nProblemResults(directory)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:260.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.ProblemResults-Tuple{DecisionModel}","page":"PowerSimulations","title":"PowerSimulations.ProblemResults","text":"ProblemResults(model::DecisionModel) -> ProblemResults\n\n\nConstruct ProblemResults from a solved DecisionModel.\n\nProblemResults(model)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:51.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.ProblemResults-Tuple{EmulationModel}","page":"PowerSimulations","title":"PowerSimulations.ProblemResults","text":"ProblemResults(model::EmulationModel) -> ProblemResults\n\n\nConstruct ProblemResults from a solved EmulationModel.\n\nProblemResults(model)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:95.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.ProblemTemplate","page":"PowerSimulations","title":"PowerSimulations.ProblemTemplate","text":"ProblemTemplate(::Type{T}) where {T<:PM.AbstractPowerFormulation}\n\nCreates a model reference of the PowerSimulations Optimization Problem.\n\nArguments\n\nmodel::Type{T<:PM.AbstractPowerFormulation}:\n\nExample\n\ntemplate = ProblemTemplate(CopperPlatePowerModel)\n\nProblemTemplate(network)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_template.jl:23.\n\nProblemTemplate(_)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_template.jl:33.\n\nProblemTemplate()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_template.jl:35.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.SemiContinuousFeedforward","page":"PowerSimulations","title":"PowerSimulations.SemiContinuousFeedforward","text":"Adds a constraint to make the bounds of a variable 0.0. Effectively allows to \"turn off\" a value.\n\nSemiContinuousFeedforward(; component_type, source, affected_values, meta)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/feedforward/feedforwards.jl:86.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ServiceModel","page":"PowerSimulations","title":"PowerSimulations.ServiceModel","text":"Establishes the model for a particular services specified by type. Uses the keyword argument use_service_name to assign the model to a service with the same name as the name in the template. Uses the keyword argument feedforward to enable passing values between operation model at simulation time\n\nArguments\n\n-::Type{D}: Power System Service Type -::Type{B}: Abstract Service Formulation\n\nAccepted Key Words\n\nfeedforward::Array{<:AbstractAffectFeedforward} : use to pass parameters between models\nuse_service_name::Bool : use the name as the name for the service\n\nExample\n\nreserves = ServiceModel(PSY.VariableReserve{PSY.ReserveUp}, RangeReserve)\n\nServiceModel(, , service_name; use_slacks, feedforwards, duals, time_series_names, attributes, contributing_devices_map)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/service_model.jl:53.\n\nServiceModel(service_type, formulation_type; use_slacks, feedforwards, duals, time_series_names, attributes)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/service_model.jl:99.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.Simulation","page":"PowerSimulations","title":"PowerSimulations.Simulation","text":"Simulation(\n    steps::Int\n    models::SimulationModels,\n    sequence::Union{Nothing, SimulationSequence},\n    simulation_folder::String,\n    name::String,\n    internal::Union{Nothing, SimulationInternal},\n)\n\nSimulation(; sequence, name, steps, models, simulation_folder, initial_time)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation.jl:20.\n\nSimulation(directory, model_info)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation.jl:67.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.Simulation-Tuple{AbstractString, Dict}","page":"PowerSimulations","title":"PowerSimulations.Simulation","text":"Simulation(directory::AbstractString, model_info::Dict)\n\n\nSimulation(directory::AbstractString)\n\nConstructs Simulation from a serialized directory. Callers should pass any kwargs here that they passed to the original Simulation.\n\nArguments\n\ndirectory::AbstractString: the directory returned from the call to serialize\nmodel_info::Dict: Two-level dictionary containing model parameters that cannot be serialized. The outer dict should be keyed by the problem name. The inner dict must contain 'optimizer' and may contain 'jump_model'. These should be the same values used for the original simulation.\n\nSimulation(directory, model_info)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation.jl:67.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.SimulationModels","page":"PowerSimulations","title":"PowerSimulations.SimulationModels","text":"Stores the OperationProblem definitions to be used in the simulation. When creating the SimulationModels, the order in which the models are created determines the order on which the simulation is executed.\n\nSimulationModels(decision_models)\nSimulationModels(decision_models, emulation_model)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_models.jl:10.\n\nSimulationModels(decision_models)\nSimulationModels(decision_models, emulation_model)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_models.jl:27.\n\nSimulationModels(; decision_models, emulation_model)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_models.jl:34.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.SimulationResults","page":"PowerSimulations","title":"PowerSimulations.SimulationResults","text":"SimulationResults(path::AbstractString) -> SimulationResults\nSimulationResults(path::AbstractString, execution; ignore_status) -> SimulationResults\n\n\nConstruct SimulationResults from a simulation output directory.\n\nArguments\n\npath::AbstractString: Simulation output directory\nexecution::AbstractString: Execution number. Default is the most recent.\nignore_status::Bool: If true, return results even if the simulation failed.\n\nSimulationResults(path)\nSimulationResults(path, execution; ignore_status)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_results.jl:37.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.SimulationResults-Tuple{Simulation}","page":"PowerSimulations","title":"PowerSimulations.SimulationResults","text":"SimulationResults(sim::Simulation; ignore_status, kwargs...) -> SimulationResults\n\n\nConstruct SimulationResults from a simulation.\n\nSimulationResults(sim; ignore_status, kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_results.jl:110.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.SimulationSequence","page":"PowerSimulations","title":"PowerSimulations.SimulationSequence","text":"SimulationSequence(\n                    models::SimulationModels,\n                    feedforward::Dict{Symbol, <:AbstractAffectFeedforward}\n                    ini_cond_chronology::Dict{Symbol, <:FeedforwardChronology}\n                    )\n\nSimulationSequence(; models, feedforwards, ini_cond_chronology)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_sequence.jl:169.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.StaticBranch","page":"PowerSimulations","title":"PowerSimulations.StaticBranch","text":"Branch type to add unbounded flow variables and use flow constraints\n\nStaticBranch()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:90.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.StaticBranchBounds","page":"PowerSimulations","title":"PowerSimulations.StaticBranchBounds","text":"Branch type to add bounded flow variables and use flow constraints\n\nStaticBranchBounds()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:94.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.StaticBranchUnbounded","page":"PowerSimulations","title":"PowerSimulations.StaticBranchUnbounded","text":"Branch type to avoid flow constraints\n\nStaticBranchUnbounded()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/formulations.jl:98.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.UnitCommitmentProblem-Tuple{System}","page":"PowerSimulations","title":"PowerSimulations.UnitCommitmentProblem","text":"UnitCommitmentProblem(system::System; kwargs...) -> DecisionModel{UnitCommitmentProblem}\n\n\nUnitCommitmentProblem(system::PSY.System; kwargs...)\n\nCreates a ProblemTemplate with default DeviceModels for a Unit Commitment problem. Uses the template to create an DecisionProblem.\n\nExample\n\nuc_problem = UnitCommitmentProblem(system)\n\n\n# Accepted Key Words\n- `network::Type{<:PM.AbstractPowerModel}` : override default network model settings\n- `devices::Dict{String, DeviceModel}` : override default `DeviceModel` settings\n- `services::Dict{String, ServiceModel}` : override default `ServiceModel` settings\n- Key word arguments supported by `DecisionProblem`\n\nUnitCommitmentProblem(system; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/decision_problems.jl:62.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.UpperBoundFeedforward","page":"PowerSimulations","title":"PowerSimulations.UpperBoundFeedforward","text":"Adds an upper bound constraint to a variable.\n\nUpperBoundFeedforward(; component_type, source, affected_values, meta)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/feedforward/feedforwards.jl:26.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.build!-Tuple{DecisionModel}","page":"PowerSimulations","title":"PowerSimulations.build!","text":"build!(model::DecisionModel; output_dir, recorders, console_level, file_level, disable_timer_outputs)\n\n\nImplementation of build for any DecisionProblem\n\nbuild!(model; output_dir, recorders, console_level, file_level, disable_timer_outputs)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/decision_model.jl:283.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.build!-Tuple{EmulationModel}","page":"PowerSimulations","title":"PowerSimulations.build!","text":"build!(model::EmulationModel; executions, output_dir, recorders, console_level, file_level, disable_timer_outputs)\n\n\nImplementation of build for any EmulationProblem\n\nbuild!(model; executions, output_dir, recorders, console_level, file_level, disable_timer_outputs)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/emulation_model.jl:268.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.build!-Tuple{Simulation}","page":"PowerSimulations","title":"PowerSimulations.build!","text":"build!(sim::Simulation; output_dir, recorders, console_level, file_level, serialize, initialize_problem) -> BuildStatus\n\n\nbuild!(sim::Simulation)\n\nBuild the Simulation, problems and the related folder structure\n\nArguments\n\nsim::Simulation: simulation object\noutput_dir = nothing: Name of the output directory for the simulation. If nothing, the folder will have the same name as the simulation\nserialize::Bool = true: serializes the simulation objects in the simulation\nrecorders::Vector{Symbol} = []: recorder names to register\nconsole_level = Logging.Error:\nfile_level = Logging.Info:\n\nThrows an exception if name is passed and the directory already exists.\n\nbuild!(sim; output_dir, recorders, console_level, file_level, serialize, initialize_problem)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation.jl:528.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.execute!-Tuple{Simulation}","page":"PowerSimulations","title":"PowerSimulations.execute!","text":"execute!(sim::Simulation; kwargs...) -> RunStatus\n\n\nexecute!(sim::Simulation; kwargs...)\n\nSolves the simulation model for sequential Simulations.\n\nArguments\n\nsim::Simulation=sim: simulation object created by Simulation()\n\nThe optional keyword argument exports controls exporting of results to CSV files as the simulation runs. Refer to export_results for a description of this argument.\n\nExample\n\nsim = Simulation(\"Test\", 7, problems, \"/Users/folder\") execute!(sim::Simulation; kwargs...)\n\nexecute!(sim; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation.jl:855.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.export_optimizer_stats-Tuple{Union{ProblemResults, PowerSimulations.SimulationProblemResults}, AbstractString}","page":"PowerSimulations","title":"PowerSimulations.export_optimizer_stats","text":"export_optimizer_stats(res::Union{ProblemResults, PowerSimulations.SimulationProblemResults}, directory::AbstractString; format) -> Any\n\n\nSave the optimizer statistics to CSV or JSON\n\nArguments\n\nres::Union{ProblemResults, SimulationProblmeResults: Results\ndirectory::AbstractString : target directory\nformat = \"CSV\" : can be \"csv\" or \"json\n\nexport_optimizer_stats(res, directory; format)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:688.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.export_realized_results-Tuple{PowerSimulations.SimulationProblemResults}","page":"PowerSimulations","title":"PowerSimulations.export_realized_results","text":"export_realized_results(res::PowerSimulations.SimulationProblemResults) -> String\n\n\nSave the realized results to CSV files for all variables, paramaters, duals, auxiliary variables, expressions, and optimizer statistics.\n\nArguments\n\nres::Union{ProblemResults, SimulationProblmeResults: Results\nsave_path::AbstractString : path to save results (defaults to simulation path)\n\nexport_realized_results(res)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:642.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.export_results-Tuple{ProblemResults}","page":"PowerSimulations","title":"PowerSimulations.export_results","text":"export_results(results::ProblemResults; kwargs...)\n\n\nExports all results from the operations problem.\n\nexport_results(results; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:136.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.export_results-Tuple{SimulationResults, Any}","page":"PowerSimulations","title":"PowerSimulations.export_results","text":"export_results(results::SimulationResults, exports)\n\n\nExport results to files in the results directory.\n\nArguments\n\nresults::SimulationResults: simulation results\nexports: SimulationResultsExport or anything that can be passed to its constructor. (such as Dict or path to JSON file)\n\nAn example JSON file demonstrating possible options is below. Note that start_time, end_time, path, and format are optional.\n\n{\n  \"decision_models\": [\n    {\n      \"name\": \"ED\",\n      \"variables\": [\n        \"P__ThermalStandard\",\n        \"E__HydroEnergyReservoir\"\n      ],\n      \"parameters\": [\n        \"all\"\n      ]\n    },\n    {\n      \"name\": \"UC\",\n      \"variables\": [\n        \"On__ThermalStandard\"\n      ],\n      \"parameters\": [\n        \"all\"\n      ],\n      \"duals\": [\n        \"all\"\n      ]\n    }\n  ],\n  \"start_time\": \"2020-01-01T04:00:00\",\n  \"end_time\": null,\n  \"path\": null,\n  \"format\": \"csv\"\n}\n\n\nexport_results(results, exports)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_results.jl:230.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_all_constraint_index-Tuple{PowerSimulations.OperationModel}","page":"PowerSimulations","title":"PowerSimulations.get_all_constraint_index","text":"get_all_constraint_index(model::PowerSimulations.OperationModel) -> Vector{Tuple{PowerSimulations.ConstraintKey, Int64, Int64}}\n\n\nEach Tuple corresponds to (conname, internalindex, moi_index)\n\nget_all_constraint_index(model)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/optimization_debugging.jl:4.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_all_variable_index-Tuple{PowerSimulations.OperationModel}","page":"PowerSimulations","title":"PowerSimulations.get_all_variable_index","text":"get_all_variable_index(model::PowerSimulations.OperationModel) -> Vector{Tuple{Symbol, Int64, Int64}}\n\n\nEach Tuple corresponds to (conname, internalindex, moi_index)\n\nget_all_variable_index(model)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/optimization_debugging.jl:19.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_system!-Tuple{PowerSimulations.SimulationProblemResults}","page":"PowerSimulations","title":"PowerSimulations.get_system!","text":"get_system!(results::PowerSimulations.SimulationProblemResults) -> Union{Nothing, System}\n\n\nReturn the system used for the problem. If the system hasn't already been deserialized or set with set_system! then deserialize and store it.\n\nget_system!(results)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:146.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_timestamps-Tuple{PowerSimulations.SimulationProblemResults}","page":"PowerSimulations","title":"PowerSimulations.get_timestamps","text":"get_timestamps(result::PowerSimulations.SimulationProblemResults) -> StepRange{Dates.DateTime, Dates.Millisecond}\n\n\nReturn a reference to a StepRange of available timestamps.\n\nget_timestamps(result)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:140.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.list_aux_variable_keys-Tuple{PowerSimulations.SimulationProblemResults}","page":"PowerSimulations","title":"PowerSimulations.list_aux_variable_keys","text":"list_aux_variable_keys(res::PowerSimulations.SimulationProblemResults) -> Any\n\n\nReturn an array of AuxVarKeys that are available for reads.\n\nlist_aux_variable_keys(res)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:129.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.list_aux_variable_names-Tuple{PowerSimulations.SimulationProblemResults}","page":"PowerSimulations","title":"PowerSimulations.list_aux_variable_names","text":"list_aux_variable_names(res::PowerSimulations.SimulationProblemResults) -> Any\n\n\nReturn an array of auxillary variable names (strings) that are available for reads.\n\nlist_aux_variable_names(res)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:102.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.list_decision_problems-Tuple{SimulationResults}","page":"PowerSimulations","title":"PowerSimulations.list_decision_problems","text":"list_decision_problems(results::SimulationResults) -> Vector{String}\n\n\nReturn the problem names in the simulation.\n\nlist_decision_problems(results)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_results.jl:181.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.list_dual_keys-Tuple{PowerSimulations.SimulationProblemResults}","page":"PowerSimulations","title":"PowerSimulations.list_dual_keys","text":"list_dual_keys(res::PowerSimulations.SimulationProblemResults) -> Any\n\n\nReturn an array of ConstraintKeys that are available for reading duals.\n\nlist_dual_keys(res)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:119.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.list_dual_names-Tuple{PowerSimulations.SimulationProblemResults}","page":"PowerSimulations","title":"PowerSimulations.list_dual_names","text":"list_dual_names(res::PowerSimulations.SimulationProblemResults) -> Any\n\n\nReturn an array of dual names (strings) that are available for reads.\n\nlist_dual_names(res)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:90.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.list_expression_keys-Tuple{PowerSimulations.SimulationProblemResults}","page":"PowerSimulations","title":"PowerSimulations.list_expression_keys","text":"list_expression_keys(res::PowerSimulations.SimulationProblemResults) -> Any\n\n\nReturn an array of ExpressionKeys that are available for reads.\n\nlist_expression_keys(res)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:135.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.list_expression_names-Tuple{PowerSimulations.SimulationProblemResults}","page":"PowerSimulations","title":"PowerSimulations.list_expression_names","text":"list_expression_names(res::PowerSimulations.SimulationProblemResults) -> Any\n\n\nReturn an array of expression names (strings) that are available for reads.\n\nlist_expression_names(res)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:108.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.list_parameter_keys-Tuple{PowerSimulations.SimulationProblemResults}","page":"PowerSimulations","title":"PowerSimulations.list_parameter_keys","text":"list_parameter_keys(res::PowerSimulations.SimulationProblemResults) -> Any\n\n\nReturn an array of ParameterKeys that are available for reads.\n\nlist_parameter_keys(res)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:124.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.list_parameter_names-Tuple{PowerSimulations.SimulationProblemResults}","page":"PowerSimulations","title":"PowerSimulations.list_parameter_names","text":"list_parameter_names(res::PowerSimulations.SimulationProblemResults) -> Any\n\n\nReturn an array of parmater names (strings) that are available for reads.\n\nlist_parameter_names(res)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:96.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.list_simulation_events-Union{Tuple{T}, Tuple{Type{T}, AbstractString}, Tuple{Type{T}, AbstractString, Union{Nothing, Function}}} where T<:InfrastructureSystems.AbstractRecorderEvent","page":"PowerSimulations","title":"PowerSimulations.list_simulation_events","text":"list_simulation_events(\n    ::Type{T},\n    output_dir::AbstractString,\n    filter_func::Union{Nothing, Function} = nothing;\n    step = nothing,\n    model = nothing,\n) where {T <: IS.AbstractRecorderEvent}\n\nList simulation events of type T in a simulation output directory.\n\nArguments\n\noutput_dir::AbstractString: Simulation output directory\nfilter_func::Union{Nothing, Function} = nothing: Refer to show_simulation_events.\nstep::Int = nothing: Filter events by step. Required if model is passed.\nmodel::Int = nothing: Filter events by model.\n\nlist_simulation_events(, output_dir)\nlist_simulation_events(, output_dir, filter_func; step, model_name)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/recorder_events.jl:253.\n\nlist_simulation_events(, output_dir)\nlist_simulation_events(, output_dir, filter_func; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/recorder_events.jl:282.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.list_variable_keys-Tuple{PowerSimulations.SimulationProblemResults}","page":"PowerSimulations","title":"PowerSimulations.list_variable_keys","text":"list_variable_keys(res::PowerSimulations.SimulationProblemResults) -> Any\n\n\nReturn an array of VariableKeys that are available for reads.\n\nlist_variable_keys(res)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:114.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.list_variable_names-Tuple{PowerSimulations.SimulationProblemResults}","page":"PowerSimulations","title":"PowerSimulations.list_variable_names","text":"list_variable_names(res::PowerSimulations.SimulationProblemResults) -> Any\n\n\nReturn an array of variable names (strings) that are available for reads.\n\nlist_variable_names(res)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:84.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.load_results!-Tuple{PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults}, Int64}","page":"PowerSimulations","title":"PowerSimulations.load_results!","text":"load_results!(res::PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults}, count::Int64; initial_time, variables, duals, parameters, aux_variables, expressions)\n\n\nLoad the simulation results into memory for repeated reads. Running this function twice overwrites the previously loaded results. This is useful when loading results from remote locations over network connections.\n\nFor each variable/parameter/dual, etc., each element must be the name encoded as a string, like \"ActivePowerVariable__ThermalStandard\" or a Tuple with its constituent types, like (ActivePowerVariable, ThermalStandard).\n\nArguments\n\ncount::Int: Number of windows to load.\ninitial_time::Dates.DateTime : Initial time of first window to load. Defaults to first.\naux_variables::Vector{Union{String, Tuple}}: Optional list of aux variables to load.\nduals::Vector{Union{String, Tuple}}: Optional list of duals to load.\nexpressions::Vector{Union{String, Tuple}}: Optional list of expressions to load.\nparameters::Vector{Union{String, Tuple}}: Optional list of parameters to load.\nvariables::Vector{Union{String, Tuple}}: Optional list of variables to load.\n\nload_results!(res, count; initial_time, variables, duals, parameters, aux_variables, expressions)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/decision_model_simulation_results.jl:480.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.load_results!-Tuple{PowerSimulations.SimulationProblemResults{PowerSimulations.EmulationModelSimulationResults}}","page":"PowerSimulations","title":"PowerSimulations.load_results!","text":"load_results!(res::PowerSimulations.SimulationProblemResults{PowerSimulations.EmulationModelSimulationResults}; aux_variables, duals, expressions, parameters, variables)\n\n\nLoad the simulation results into memory for repeated reads. Running this function twice overwrites the previously loaded results. This is useful when loading results from remote locations over network connections.\n\nFor each variable/parameter/dual, etc., each element must be the name encoded as a string, like \"ActivePowerVariable__ThermalStandard\"or a Tuple with its constituent types, like(ActivePowerVariable, ThermalStandard)`.\n\nArguments\n\naux_variables::Vector{Union{String, Tuple}}: Optional list of aux variables to load.\nduals::Vector{Union{String, Tuple}}: Optional list of duals to load.\nexpressions::Vector{Union{String, Tuple}}: Optional list of expressions to load.\nparameters::Vector{Union{String, Tuple}}: Optional list of parameters to load.\nvariables::Vector{Union{String, Tuple}}: Optional list of variables to load.\n\nload_results!(res; aux_variables, duals, expressions, parameters, variables)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/emulation_model_simulation_results.jl:343.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_aux_variable-Tuple{PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults}, Vararg{Any}}","page":"PowerSimulations","title":"PowerSimulations.read_aux_variable","text":"read_aux_variable(res::PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults}, args...; time_series_name, initial_time, count, store) -> SortedDict{Dates.DateTime, DataFrames.DataFrame}\n\n\nReturn the values for the requested auxillary variables. It keeps requests when performing multiple retrievals.\n\nArguments\n\nargs: Can be a string returned from list_aux_variable_names or args that can be splatted into a AuxVarKey.\ninitial_time::Dates.DateTime : initial of the requested results\ncount::Int: Number of results\n\nread_aux_variable(res, args; time_series_name, initial_time, count, store)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/decision_model_simulation_results.jl:312.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_aux_variable-Tuple{ProblemResults, Vararg{Any}}","page":"PowerSimulations","title":"PowerSimulations.read_aux_variable","text":"read_aux_variable(res::ProblemResults, args...; kwargs...) -> DataFrames.DataFrame\n\n\nReturn the values for the requested auxvariable key for a problem. Accepts a vector of keys for the return of the values. If the time stamps and keys are loaded using the [loadresults!](@ref) function it will read from memory.\n\nArguments\n\naux_variable::Tuple{Type{<:AuxVariableType}, Type{<:PSY.Component} : Tuple with aux_variable type and device type for the desired results\nstart_time::Dates.DateTime : initial time of the requested results\nlen::Int: length of results\n\nread_aux_variable(res, args; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:617.\n\nread_aux_variable(res, key; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:622.\n\nread_aux_variable(res, key; start_time, len)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:626.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_aux_variables-Tuple{InfrastructureSystems.Results}","page":"PowerSimulations","title":"PowerSimulations.read_aux_variables","text":"read_aux_variables(res::InfrastructureSystems.Results) -> Dict\n\n\nReturn the values for all auxiliary variables.\n\nread_aux_variables(res)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:676.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_aux_variables-Tuple{ProblemResults, Any}","page":"PowerSimulations","title":"PowerSimulations.read_aux_variables","text":"read_aux_variables(res::ProblemResults, aux_variables; kwargs...) -> Dict{String, DataFrames.DataFrame}\n\n\nReturn the values for the requested auxvariable keys for a problem. Accepts a vector of keys for the return of the values. If the time stamps and keys are loaded using the [loadresults!](@ref) function it will read from memory.\n\nArguments\n\naux_variables::Vector{Tuple{Type{<:AuxVariableType}, Type{<:PSY.Component}} : Tuple with aux_variable type and device type for the desired results\nstart_time::Dates.DateTime : initial time of the requested results\nlen::Int: length of results\n\nread_aux_variables(res, aux_variables; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:646.\n\nread_aux_variables(res, aux_variables; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:650.\n\nread_aux_variables(res, aux_variables; start_time, len)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:662.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_dual-Tuple{PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults}, Vararg{Any}}","page":"PowerSimulations","title":"PowerSimulations.read_dual","text":"read_dual(res::PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults}, args...; initial_time, count, store) -> SortedDict{Dates.DateTime, DataFrames.DataFrame}\n\n\nReturn the values for the requested dual. It keeps requests when performing multiple retrievals.\n\nArguments\n\nargs: Can be a string returned from list_dual_names or args that can be splatted into a ConstraintKey.\ninitial_time::Dates.DateTime : initial of the requested results\ncount::Int: Number of results\nstore::SimulationStore: a store that has been opened for reading\n\nread_dual(res, args; initial_time, count, store)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/decision_model_simulation_results.jl:222.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_dual-Tuple{ProblemResults, Vararg{Any}}","page":"PowerSimulations","title":"PowerSimulations.read_dual","text":"read_dual(res::ProblemResults, args...; kwargs...) -> DataFrames.DataFrame\n\n\nReturn the values for the requested dual key for a problem. Accepts a vector of keys for the return of the values. If the time stamps and keys are loaded using the load_results! function it will read from memory.\n\nArguments\n\ndual::Tuple{Type{<:ConstraintType}, Type{<:PSY.Component} : Tuple with dual type and device type for the desired results\nstart_time::Dates.DateTime : initial time of the requested results\nlen::Int: length of results\n\nread_dual(res, args; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:442.\n\nread_dual(res, key; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:447.\n\nread_dual(res, key; start_time, len)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:451.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_duals-Tuple{InfrastructureSystems.Results}","page":"PowerSimulations","title":"PowerSimulations.read_duals","text":"read_duals(res::InfrastructureSystems.Results) -> Dict\n\n\nReturn the values for all duals.\n\nread_duals(res)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:496.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_duals-Tuple{ProblemResults, Any}","page":"PowerSimulations","title":"PowerSimulations.read_duals","text":"read_duals(res::ProblemResults, duals; kwargs...) -> Dict{String, DataFrames.DataFrame}\n\n\nReturn the values for the requested dual keys for a problem. Accepts a vector of keys for the return of the values. If the time stamps and keys are loaded using the load_results! function it will read from memory.\n\nArguments\n\nduals::Vector{Tuple{Type{<:ConstraintType}, Type{<:PSY.Component}} : Tuple with dual type and device type for the desired results\nstart_time::Dates.DateTime : initial time of the requested results\nlen::Int: length of results\n\nread_duals(res, duals; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:471.\n\nread_duals(res, duals; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:475.\n\nread_duals(res, duals; start_time, len)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:483.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_expression-Tuple{PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults}, Vararg{Any}}","page":"PowerSimulations","title":"PowerSimulations.read_expression","text":"read_expression(res::PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults}, args...; time_series_name, initial_time, count, store) -> SortedDict{Dates.DateTime, DataFrames.DataFrame}\n\n\nReturn the values for the requested auxillary variables. It keeps requests when performing multiple retrievals.\n\nArguments\n\nargs: Can be a string returned from list_expression_names or args that can be splatted into a ExpressionKey.\ninitial_time::Dates.DateTime : initial of the requested results\ncount::Int: Number of results\n\nread_expression(res, args; time_series_name, initial_time, count, store)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/decision_model_simulation_results.jl:360.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_expression-Tuple{ProblemResults, Vararg{Any}}","page":"PowerSimulations","title":"PowerSimulations.read_expression","text":"read_expression(res::ProblemResults, args...; kwargs...) -> DataFrames.DataFrame\n\n\nReturn the values for the requested expression key for a problem. Accepts a vector of keys for the return of the values. If the time stamps and keys are loaded using the load_results! function it will read from memory.\n\nArguments\n\nexpression::Tuple{Type{<:ExpressionType}, Type{<:PSY.Component} : Tuple with expression type and device type for the desired results\nstart_time::Dates.DateTime : initial time of the requested results\nlen::Int: length of results\n\nread_expression(res, args; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:707.\n\nread_expression(res, key; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:712.\n\nread_expression(res, key; start_time, len)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:716.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_expressions-Tuple{InfrastructureSystems.Results}","page":"PowerSimulations","title":"PowerSimulations.read_expressions","text":"read_expressions(res::InfrastructureSystems.Results) -> Dict{String, DataFrames.DataFrame}\n\n\nReturn the values for all expressions.\n\nread_expressions(res; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:736.\n\nread_expressions(res)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:770.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_expressions-Tuple{ProblemResults}","page":"PowerSimulations","title":"PowerSimulations.read_expressions","text":"read_expressions(res::ProblemResults; kwargs...) -> Dict{String, DataFrames.DataFrame}\n\n\nReturn the values for the requested expression keys for a problem. Accepts a vector of keys for the return of the values. If the time stamps and keys are loaded using the load_results! function it will read from memory.\n\nArguments\n\nexpressions::Vector{Tuple{Type{<:ExpressionType}, Type{<:PSY.Component}} : Tuple with expression type and device type for the desired results\nstart_time::Dates.DateTime : initial time of the requested results\nlen::Int: length of results\n\nread_expressions(res; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:736.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_optimizer_stats-Tuple{PowerSimulations.HdfSimulationStore, Any}","page":"PowerSimulations","title":"PowerSimulations.read_optimizer_stats","text":"read_optimizer_stats(store::PowerSimulations.HdfSimulationStore, model_name) -> Any\n\n\nReturn the optimizer stats for a problem as a DataFrame.\n\nread_optimizer_stats(store, model_name)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/hdf_simulation_store.jl:231.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_optimizer_stats-Tuple{PowerSimulations.HdfSimulationStore, Int64, Symbol, Int64}","page":"PowerSimulations","title":"PowerSimulations.read_optimizer_stats","text":"read_optimizer_stats(store::PowerSimulations.HdfSimulationStore, simulation_step::Int64, model_name::Symbol, execution_index::Int64) -> Any\n\n\nRead the optimizer stats for a problem execution.\n\nread_optimizer_stats(store, simulation_step, model_name, execution_index)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/hdf_simulation_store.jl:215.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_optimizer_stats-Tuple{PowerSimulations.SimulationProblemResults}","page":"PowerSimulations","title":"PowerSimulations.read_optimizer_stats","text":"read_optimizer_stats(res::PowerSimulations.SimulationProblemResults; store) -> Any\n\n\nReturn the optimizer stats for the problem as a DataFrame.\n\nAccepted keywords\n\nstore::SimulationStore: a store that has been opened for reading\n\nread_optimizer_stats(res; store)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:615.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_parameter-Tuple{PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults}, Vararg{Any}}","page":"PowerSimulations","title":"PowerSimulations.read_parameter","text":"read_parameter(res::PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults}, args...; time_series_name, initial_time, count, store) -> SortedDict{Dates.DateTime, DataFrames.DataFrame}\n\n\nReturn the values for the requested parameter. It keeps requests when performing multiple retrievals.\n\nArguments\n\nargs: Can be a string returned from list_parameter_names or args that can be splatted into a ParameterKey.\ninitial_time::Dates.DateTime : initial of the requested results\ncount::Int: Number of results\n\nread_parameter(res, args; time_series_name, initial_time, count, store)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/decision_model_simulation_results.jl:264.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_parameter-Tuple{ProblemResults, Vararg{Any}}","page":"PowerSimulations","title":"PowerSimulations.read_parameter","text":"read_parameter(res::ProblemResults, args...; kwargs...) -> DataFrames.DataFrame\n\n\nReturn the values for the requested parameter key for a problem. Accepts a vector of keys for the return of the values. If the time stamps and keys are loaded using the load_results! function it will read from memory.\n\nArguments\n\nparameter::Tuple{Type{<:ParameterType}, Type{<:PSY.Component} : Tuple with parameter type and device type for the desired results\nstart_time::Dates.DateTime : initial time of the requested results\nlen::Int: length of results\n\nread_parameter(res, args; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:527.\n\nread_parameter(res, key; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:532.\n\nread_parameter(res, key; start_time, len)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:536.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_parameters-Tuple{InfrastructureSystems.Results}","page":"PowerSimulations","title":"PowerSimulations.read_parameters","text":"read_parameters(res::InfrastructureSystems.Results) -> Dict\n\n\nReturn the values for all parameters.\n\nread_parameters(res)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:586.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_parameters-Tuple{ProblemResults, Any}","page":"PowerSimulations","title":"PowerSimulations.read_parameters","text":"read_parameters(res::ProblemResults, parameters; kwargs...) -> Dict{String, DataFrames.DataFrame}\n\n\nReturn the values for the requested parameter keys for a problem. Accepts a vector of keys for the return of the values. If the time stamps and keys are loaded using the load_results! function it will read from memory.\n\nArguments\n\nparameters::Vector{Tuple{Type{<:ParameterType}, Type{<:PSY.Component}} : Tuple with parameter type and device type for the desired results\nstart_time::Dates.DateTime : initial time of the requested results\nlen::Int: length of results\n\nread_parameters(res, parameters; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:556.\n\nread_parameters(res, parameters; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:560.\n\nread_parameters(res, parameters; start_time, len)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:572.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_realized_aux_variable-Tuple{PowerSimulations.SimulationProblemResults, AbstractString}","page":"PowerSimulations","title":"PowerSimulations.read_realized_aux_variable","text":"read_realized_aux_variable(res::PowerSimulations.SimulationProblemResults, aux_variable::AbstractString; kwargs...) -> DataFrames.DataFrame\n\n\nReturn the final values for the requested auxiliary variable for each time step for a problem.\n\nRefer to read_realized_variable for help and examples.\n\nread_realized_aux_variable(res, aux_variable; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:395.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_realized_aux_variables-Tuple{PowerSimulations.SimulationProblemResults}","page":"PowerSimulations","title":"PowerSimulations.read_realized_aux_variables","text":"read_realized_aux_variables(res::PowerSimulations.SimulationProblemResults; kwargs...) -> Dict{String, DataFrames.DataFrame}\n\n\nReturn the final values for the requested auxiliary variables for each time step for a problem.\n\nRefer to read_realized_variables for help and examples.\n\nread_realized_aux_variables(res; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:349.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_realized_dual-Tuple{PowerSimulations.SimulationProblemResults, AbstractString}","page":"PowerSimulations","title":"PowerSimulations.read_realized_dual","text":"read_realized_dual(res::PowerSimulations.SimulationProblemResults, dual::AbstractString; kwargs...) -> DataFrames.DataFrame\n\n\nReturn the final values for the requested dual for each time step for a problem.\n\nRefer to read_realized_variable for help and examples.\n\nread_realized_dual(res, dual; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:527.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_realized_duals-Tuple{PowerSimulations.SimulationProblemResults}","page":"PowerSimulations","title":"PowerSimulations.read_realized_duals","text":"read_realized_duals(res::PowerSimulations.SimulationProblemResults; kwargs...) -> Dict{String, DataFrames.DataFrame}\n\n\nReturn the final values for the requested duals for each time step for a problem.\n\nRefer to read_realized_variables for help and examples.\n\nread_realized_duals(res; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:493.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_realized_expression-Tuple{PowerSimulations.SimulationProblemResults, AbstractString}","page":"PowerSimulations","title":"PowerSimulations.read_realized_expression","text":"read_realized_expression(res::PowerSimulations.SimulationProblemResults, expression::AbstractString; kwargs...) -> DataFrames.DataFrame\n\n\nReturn the final values for the requested expression for each time step for a problem.\n\nRefer to read_realized_variable for help and examples.\n\nread_realized_expression(res, expression; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:586.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_realized_expressions-Tuple{PowerSimulations.SimulationProblemResults}","page":"PowerSimulations","title":"PowerSimulations.read_realized_expressions","text":"read_realized_expressions(res::PowerSimulations.SimulationProblemResults; kwargs...) -> Dict{String, DataFrames.DataFrame}\n\n\nReturn the final values for the requested expressions for each time step for a problem.\n\nRefer to read_realized_variables for help and examples.\n\nread_realized_expressions(res; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:548.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_realized_parameter-Tuple{PowerSimulations.SimulationProblemResults, AbstractString}","page":"PowerSimulations","title":"PowerSimulations.read_realized_parameter","text":"read_realized_parameter(res::PowerSimulations.SimulationProblemResults, parameter::AbstractString; kwargs...) -> DataFrames.DataFrame\n\n\nReturn the final values for the requested parameter for each time step for a problem.\n\nRefer to read_realized_variable for help and examples.\n\nread_realized_parameter(res, parameter; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:466.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_realized_parameters-Tuple{PowerSimulations.SimulationProblemResults}","page":"PowerSimulations","title":"PowerSimulations.read_realized_parameters","text":"read_realized_parameters(res::PowerSimulations.SimulationProblemResults; kwargs...) -> Dict{String, DataFrames.DataFrame}\n\n\nReturn the final values for the requested parameters for each time step for a problem.\n\nRefer to read_realized_variables for help and examples.\n\nread_realized_parameters(res; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:428.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_realized_variable-Tuple{PowerSimulations.SimulationProblemResults, AbstractString}","page":"PowerSimulations","title":"PowerSimulations.read_realized_variable","text":"read_realized_variable(res::PowerSimulations.SimulationProblemResults, variable::AbstractString; kwargs...) -> DataFrames.DataFrame\n\n\nReturn the final values for the requested variable for each time step for a problem.\n\nDecision problem results are returned in a Dict{DateTime, DataFrame}.\n\nEmulation problem results are returned in a DataFrame.\n\nLimit the data sizes returned by specifying initial_time and count for decision problems or start_time and len for emulation problems.\n\nSee also load_results! to preload data into memory.\n\nArguments\n\nvariable::Union{String, Tuple}: Variable name as a string or a Tuple with variable type and device type.\ninitial_time::Dates.DateTime: Initial time of the requested results. Decision problems only.\ncount::Int: Number of results. Decision problems only.\nstart_time::Dates.DateTime: Start time of the requested results. Emulation problems only.\nlen::Int: Number of rows in each DataFrame. Emulation problems only.\n\nExamples\n\njulia > read_realized_variable(results, \"ActivePowerVariable__ThermalStandard\")\njulia > read_realized_variable(results, (ActivePowerVariable, ThermalStandard))\n\nread_realized_variable(res, variable; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:322.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_realized_variables-Tuple{PowerSimulations.SimulationProblemResults}","page":"PowerSimulations","title":"PowerSimulations.read_realized_variables","text":"read_realized_variables(res::PowerSimulations.SimulationProblemResults; kwargs...) -> Dict{String, DataFrames.DataFrame}\n\n\nReturn the final values for the requested variables for each time step for a problem.\n\nDecision problem results are returned in a Dict{String, Dict{DateTime, DataFrame}}.\n\nEmulation problem results are returned in a Dict{String, DataFrame}.\n\nLimit the data sizes returned by specifying initial_time and count for decision problems or start_time and len for emulation problems.\n\nSee also load_results! to preload data into memory.\n\nArguments\n\nvariables::Vector{Union{String, Tuple}}: Variable name as a string or a Tuple with variable type and device type. If not provided then return all variables.\ninitial_time::Dates.DateTime: Initial time of the requested results. Decision problems only.\ncount::Int: Number of results. Decision problems only.\nstart_time::Dates.DateTime: Start time of the requested results. Emulation problems only.\nlen::Int: Number of rows in each DataFrame. Emulation problems only.\n\nExamples\n\njulia > variables_as_strings =\n    [\"ActivePowerVariable__ThermalStandard\", \"ActivePowerVariable__RenewableDispatch\"]\njulia > variables_as_types =\n    [(ActivePowerVariable, ThermalStandard), (ActivePowerVariable, RenewableDispatch)]\njulia > read_realized_variables(results, variables_as_strings)\njulia > read_realized_variables(results, variables_as_types)\n\nread_realized_variables(res; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:263.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_variable-Tuple{PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults}, Vararg{Any}}","page":"PowerSimulations","title":"PowerSimulations.read_variable","text":"read_variable(res::PowerSimulations.SimulationProblemResults{PowerSimulations.DecisionModelSimulationResults}, args...; initial_time, count, store) -> SortedDict{Dates.DateTime, DataFrames.DataFrame}\n\n\nReturn the values for the requested variable. It keeps requests when performing multiple retrievals.\n\nArguments\n\nargs: Can be a string returned from list_variable_names or args that can be splatted into a VariableKey.\ninitial_time::Dates.DateTime : initial of the requested results\ncount::Int: Number of results\nstore::SimulationStore: a store that has been opened for reading\n\nExamples\n\nread_variable(results, ActivePowerVariable, ThermalStandard)\nread_variable(results, \"ActivePowerVariable__ThermalStandard\")\n\nread_variable(res, args; initial_time, count, store)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/decision_model_simulation_results.jl:179.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_variable-Tuple{ProblemResults, Vararg{Any}}","page":"PowerSimulations","title":"PowerSimulations.read_variable","text":"read_variable(res::ProblemResults, args...; kwargs...) -> DataFrames.DataFrame\n\n\nReturn the values for the requested variable key for a problem. Accepts a vector of keys for the return of the values. If the time stamps and keys are loaded using the load_results! function it will read from memory.\n\nArguments\n\nvariable::Tuple{Type{<:VariableType}, Type{<:PSY.Component} : Tuple with variable type and device type for the desired results\nstart_time::Dates.DateTime : start time of the requested results\nlen::Int: length of results\n\nread_variable(res, args; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:357.\n\nread_variable(res, key; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:362.\n\nread_variable(res, key; start_time, len)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:366.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_variables-Tuple{InfrastructureSystems.Results}","page":"PowerSimulations","title":"PowerSimulations.read_variables","text":"read_variables(res::InfrastructureSystems.Results) -> Dict\n\n\nReturn the values for all variables.\n\nread_variables(res)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:411.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_variables-Tuple{ProblemResults, Any}","page":"PowerSimulations","title":"PowerSimulations.read_variables","text":"read_variables(res::ProblemResults, variables; kwargs...) -> Dict{String, DataFrames.DataFrame}\n\n\nReturn the values for the requested variable keys for a problem. Accepts a vector of keys for the return of the values. If the time stamps and keys are loaded using the load_results! function it will read from memory.\n\nArguments\n\nvariables::Vector{Tuple{Type{<:VariableType}, Type{<:PSY.Component}} : Tuple with variable type and device type for the desired results\nstart_time::Dates.DateTime : initial time of the requested results\nlen::Int: length of results\n\nread_variables(res, variables; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:386.\n\nread_variables(res, variables; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:390.\n\nread_variables(res, variables; start_time, len)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:398.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.run!-Tuple{EmulationModel}","page":"PowerSimulations","title":"PowerSimulations.run!","text":"run!(model::EmulationModel; export_problem_results, console_level, file_level, disable_timer_outputs, serialize, kwargs...) -> RunStatus\n\n\nDefault run method for problems that conform to the requirements of EmulationModel{<: EmulationProblem}\n\nThis will call build! on the model if it is not already built. It will forward all keyword arguments to that function.\n\nArguments\n\nmodel::EmulationModel = model: Emulation model\noptimizer::MOI.OptimizerWithAttributes: The optimizer that is used to solve the model\nexecutions::Int: Number of executions for the emulator run\nexport_problem_results::Bool: If true, export ProblemResults DataFrames to CSV files.\noutput_dir::String: Required if the model is not already built, otherwise ignored\nenable_progress_bar::Bool: Enables/Disable progress bar printing\nserialize::Bool: If true, serialize the model to a file to allow re-execution later.\n\nExamples\n\nstatus = run!(model; optimizer = GLPK.Optimizer, executions = 10) status = run!(model; outputdir = ./modeloutput, optimizer = GLPK.Optimizer, executions = 10)\n\nrun!(model; export_problem_results, console_level, file_level, disable_timer_outputs, serialize, kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/emulation_model.jl:435.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.run_economic_dispatch-Tuple{System}","page":"PowerSimulations","title":"PowerSimulations.run_economic_dispatch","text":"run_economic_dispatch(sys::System; kwargs...) -> RunStatus\n\n\nrun_economic_dispatch(system::PSY.System; kwargs...)\n\nCreates a ProblemTemplate with default DeviceModels for an EconomicDispatch problem. Uses the template to create an DecisionProblem.\n\nExample\n\nresults = runeconomicdispatch(system; optimizer = optimizer)\n\n\n# Accepted Key Words\n- `network::Type{<:PM.AbstractPowerModel}` : override default network model settings\n- `devices::Dict{String, DeviceModel}` : override default `DeviceModel` settings\n- `services::Dict{String, ServiceModel}` : override default `ServiceModel` settings\n- `optimizer::JuMP optimizer` : a JuMP optimizer is a required key word\n- `output_dir::AbstractString`  : Path to save outputs\n- Key word arguments supported by `DecisionProblem`\n\nrun_economic_dispatch(sys; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/decision_problems.jl:148.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.serialize_optimization_model-Tuple{JuMP.Model, String}","page":"PowerSimulations","title":"PowerSimulations.serialize_optimization_model","text":"serialize_optimization_model(jump_model::JuMP.Model, save_path::String)\n\n\nExports the JuMP object in MathOptFormat\n\nserialize_optimization_model(jump_model, save_path)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/jump_utils.jl:305.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.serialize_optimization_model-Tuple{PowerSimulations.OptimizationContainer, String}","page":"PowerSimulations","title":"PowerSimulations.serialize_optimization_model","text":"serialize_optimization_model(container::PowerSimulations.OptimizationContainer, save_path::String)\n\n\nExports the OpModel JuMP object in MathOptFormat\n\nserialize_optimization_model(container, save_path)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/optimization_container.jl:652.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.serialize_results-Tuple{ProblemResults, AbstractString}","page":"PowerSimulations","title":"PowerSimulations.serialize_results","text":"serialize_results(res::ProblemResults, directory::AbstractString)\n\n\nSerialize the results to a binary file.\n\nIt is recommended that directory be the directory that contains a serialized OperationModel. That will allow automatic deserialization of the PowerSystems.System. The ProblemResults instance can be deserialized with ProblemResults(directory).\n\nserialize_results(res, directory)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:245.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.set_device_model!-Tuple{ProblemTemplate, DeviceModel}","page":"PowerSimulations","title":"PowerSimulations.set_device_model!","text":"set_device_model!(template::ProblemTemplate, model::DeviceModel)\n\n\nSets the device model in a template using a DeviceModel instance\n\nset_device_model!(template, model)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_template.jl:85.\n\nset_device_model!(template, model)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_template.jl:93.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.set_device_model!-Tuple{ProblemTemplate, Type{<:Device}, Type{<:PowerSimulations.AbstractDeviceFormulation}}","page":"PowerSimulations","title":"PowerSimulations.set_device_model!","text":"set_device_model!(template::ProblemTemplate, component_type::Type{<:Device}, formulation::Type{<:PowerSimulations.AbstractDeviceFormulation})\n\n\nSets the device model in a template using the component type and formulation. Builds a default DeviceModel\n\nset_device_model!(template, component_type, formulation)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_template.jl:73.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.set_network_model!-Tuple{ProblemTemplate, NetworkModel}","page":"PowerSimulations","title":"PowerSimulations.set_network_model!","text":"set_network_model!(template::ProblemTemplate, model::NetworkModel)\n\n\nSets the network model in a template.\n\nset_network_model!(template, model)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_template.jl:61.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.set_service_model!-Tuple{ProblemTemplate, String, Type{<:Service}, Type{<:PowerSimulations.AbstractServiceFormulation}}","page":"PowerSimulations","title":"PowerSimulations.set_service_model!","text":"set_service_model!(template::ProblemTemplate, service_name::String, service_type::Type{<:Service}, formulation::Type{<:PowerSimulations.AbstractServiceFormulation})\n\n\nSets the service model in a template using a name and the service type and formulation. Builds a default ServiceModel with useservicename set to true.\n\nset_service_model!(template, service_name, service_type, formulation)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_template.jl:105.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.set_service_model!-Tuple{ProblemTemplate, Type{<:Service}, Type{<:PowerSimulations.AbstractServiceFormulation}}","page":"PowerSimulations","title":"PowerSimulations.set_service_model!","text":"set_service_model!(template::ProblemTemplate, service_type::Type{<:Service}, formulation::Type{<:PowerSimulations.AbstractServiceFormulation})\n\n\nSets the service model in a template using a ServiceModel instance.\n\nset_service_model!(template, service_type, formulation)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_template.jl:122.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.set_system!-Tuple{PowerSimulations.SimulationProblemResults, AbstractString}","page":"PowerSimulations","title":"PowerSimulations.set_system!","text":"set_system!(results::PowerSimulations.SimulationProblemResults, system::AbstractString)\n\n\nSet the system in the results instance.\n\nThrows InvalidValue if the system UUID is incorrect.\n\nArguments\n\nresults::SimulationProblemResults: Results object\nsystem::AbstractString: Path to the system json file\n\nExamples\n\njulia > set_system!(res, \"my_path/system_data.json\")\n\nset_system!(results, system)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:173.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.set_system!-Tuple{ProblemResults, System}","page":"PowerSimulations","title":"PowerSimulations.set_system!","text":"set_system!(res::ProblemResults, system::System)\n\n\nSet the system in the results instance.\n\nThrows InvalidValue if the system UUID is incorrect.\n\nset_system!(res, system)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/problem_results.jl:222.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.show_recorder_events-Union{Tuple{T}, Tuple{Type{T}, AbstractString}, Tuple{Type{T}, AbstractString, Union{Nothing, Function}}} where T<:InfrastructureSystems.AbstractRecorderEvent","page":"PowerSimulations","title":"PowerSimulations.show_recorder_events","text":"show_recorder_events(\n    ::Type{T},\n    filename::AbstractString,\n    filter_func::Union{Nothing, Function} = nothing;\n    wall_time = false,\n    kwargs...,\n) where {T <: IS.AbstractRecorderEvent}\n\nShow the events of type T in a recorder file.\n\nArguments\n\n::Type{T}: Recorder event type\nfilename::AbstractString: recorder filename\nfilter_func::Union{Nothing, Function} = nothing: Optional function that accepts an event of type T and returns a Bool. Apply this function to each event and only return events where the result is true.\nwall_time = false: If true, show the wall_time timestamp.\n\nshow_recorder_events(, filename)\nshow_recorder_events(, filename, filter_func; wall_time, kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/recorder_events.jl:399.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.show_simulation_events-Union{Tuple{T}, Tuple{Type{T}, AbstractString}, Tuple{Type{T}, AbstractString, Union{Nothing, Function}}} where T<:InfrastructureSystems.AbstractRecorderEvent","page":"PowerSimulations","title":"PowerSimulations.show_simulation_events","text":"show_simulation_events(::Type{T<:InfrastructureSystems.AbstractRecorderEvent}, output_dir::AbstractString)\nshow_simulation_events(::Type{T<:InfrastructureSystems.AbstractRecorderEvent}, output_dir::AbstractString, filter_func::Union{Nothing, Function}; step, model, wall_time, kwargs...)\n\n\nshow_simulation_events(\n    ::Type{T},\n    output_dir::AbstractString,\n    filter_func::Union{Nothing,Function} = nothing;\n    step = nothing,\n    model = nothing,\n    wall_time = false,\n    kwargs...,\n) where { T <: IS.AbstractRecorderEvent}\n\nShow all simulation events of type T in a simulation output directory.\n\nArguments\n\n::Type{T}: Recorder event type\noutput_dir::AbstractString: Simulation output directory\nfilter_func::Union{Nothing, Function} = nothing: Refer to show_recorder_events.\nstep::Int = nothing: Filter events by step. Required if model is passed.\nmodel::Int = nothing: Filter events by model.\nwall_time = false: If true, show the wall_time timestamp.\n\nshow_simulation_events(, output_dir)\nshow_simulation_events(, output_dir, filter_func; step, model, wall_time, kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/recorder_events.jl:314.\n\nshow_simulation_events(, output_dir)\nshow_simulation_events(, output_dir, filter_func; wall_time, kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/recorder_events.jl:335.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.solve!-Tuple{DecisionModel}","page":"PowerSimulations","title":"PowerSimulations.solve!","text":"solve!(model::DecisionModel; export_problem_results, console_level, file_level, disable_timer_outputs, serialize, kwargs...) -> RunStatus\n\n\nDefault solve method for models that conform to the requirements of DecisionModel{<: DecisionProblem}.\n\nThis will call build! on the model if it is not already built. It will forward all keyword arguments to that function.\n\nArguments\n\nmodel::OperationModel = model: operation model\noptimizer::MOI.OptimizerWithAttributes: The optimizer that is used to solve the model\nexport_problem_results::Bool: If true, export ProblemResults DataFrames to CSV files.\nserialize::Bool: If true, serialize the model to a file to allow re-execution later.\n\nExamples\n\nresults = solve!(OpModel)\nresults = solve!(OpModel, output_dir=\"output\")\n\nsolve!(model; export_problem_results, console_level, file_level, disable_timer_outputs, serialize, kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/decision_model.jl:372.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.solve!-Tuple{Int64, DecisionModel, Dates.DateTime, PowerSimulations.SimulationStore}","page":"PowerSimulations","title":"PowerSimulations.solve!","text":"solve!(step::Int64, model::DecisionModel, start_time::Dates.DateTime, store::PowerSimulations.SimulationStore; exports) -> RunStatus\n\n\nDefault solve method for a DecisionModel used inside of a Simulation. Solves problems that conform to the requirements of DecisionModel{<: DecisionProblem}\n\nArguments\n\nstep::Int: Simulation Step\nmodel::OperationModel: operation model\nstart_time::Dates.DateTime: Initial Time of the simulation step in Simulation time.\nstore::SimulationStore: Simulation output store\n\nAccepted Key Words\n\nexports: realtime export of output. Use wisely, it can have negative impacts in the simulation times\n\nsolve!(step, model, start_time, store; exports)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/decision_model.jl:456.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.solve!-Tuple{Int64, EmulationModel, Dates.DateTime, PowerSimulations.SimulationStore}","page":"PowerSimulations","title":"PowerSimulations.solve!","text":"solve!(step::Int64, model::EmulationModel, start_time::Dates.DateTime, store::PowerSimulations.SimulationStore; exports) -> RunStatus\n\n\nDefault solve method for an EmulationModel used inside of a Simulation. Solves problems that conform to the requirements of DecisionModel{<: DecisionProblem}\n\nArguments\n\nstep::Int: Simulation Step\nmodel::OperationModel: operation model\nstart_time::Dates.DateTime: Initial Time of the simulation step in Simulation time.\nstore::SimulationStore: Simulation output store\n\nAccepted Key Words\n\nexports: realtime export of output. Use wisely, it can have negative impacts in the simulation times\n\nsolve!(step, model, start_time, store; exports)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/emulation_model.jl:509.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.template_agc_reserve_deployment-Tuple{}","page":"PowerSimulations","title":"PowerSimulations.template_agc_reserve_deployment","text":"template_agc_reserve_deployment(; kwargs...) -> ProblemTemplate\n\n\ntemplate_agc_reserve_deployment(; kwargs...)\n\nCreates a ProblemTemplate with default DeviceModels for an AGC Reserve Deplyment Problem. This model doesn't support customization\n\nExample\n\ntemplate = agcreservedeployment()\n\ntemplate_agc_reserve_deployment(; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/operation_problem_templates.jl:107.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.template_economic_dispatch-Tuple{}","page":"PowerSimulations","title":"PowerSimulations.template_economic_dispatch","text":"template_economic_dispatch(; kwargs...) -> ProblemTemplate\n\n\ntemplate_economic_dispatch(; kwargs...)\n\nCreates a ProblemTemplate with default DeviceModels for an Economic Dispatch problem.\n\nExample\n\ntemplate = templateeconomicdispatch()\n\n\n# Accepted Key Words\n- `network::Type{<:PM.AbstractPowerModel}` : override default network model settings\n- `devices::Vector{DeviceModel}` : override default `DeviceModel` settings\n- `services::Vector{ServiceModel}` : override default `ServiceModel` settings\n\ntemplate_economic_dispatch(; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/operation_problem_templates.jl:84.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.template_unit_commitment-Tuple{}","page":"PowerSimulations","title":"PowerSimulations.template_unit_commitment","text":"template_unit_commitment(; kwargs...) -> ProblemTemplate\n\n\ntemplate_unit_commitment(; kwargs...)\n\nCreates a ProblemTemplate with default DeviceModels for a Unit Commitment problem.\n\nExample\n\ntemplate = templateunitcommitment()\n\n\n# Accepted Key Words\n- `network::Type{<:PM.AbstractPowerModel}` : override default network model settings\n- `devices::Vector{DeviceModel}` : override default `DeviceModel` settings\n- `services::Vector{ServiceModel}` : override default `ServiceModel` settings\n\ntemplate_unit_commitment(; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/operation_problem_templates.jl:53.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#Internal","page":"PowerSimulations","title":"Internal","text":"","category":"section"},{"location":"api/PowerSimulations/","page":"PowerSimulations","title":"PowerSimulations","text":"Modules = [PowerSimulations]\nPublic = false","category":"page"},{"location":"api/PowerSimulations/#PowerSimulations.AbstractDeviceFormulation","page":"PowerSimulations","title":"PowerSimulations.AbstractDeviceFormulation","text":"Abstract type for Device Formulations (a.k.a Models)\n\nExample\n\nimport PowerSimulations const PSI = PowerSimulations struct MyCustomDeviceFormulation <: PSI.AbstractDeviceFormulation\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.AbstractServiceFormulation","page":"PowerSimulations","title":"PowerSimulations.AbstractServiceFormulation","text":"Abstract type for Service Formulations (a.k.a Models)\n\nExample\n\nimport PowerSimulations const PSI = PowerSimulations struct MyServiceFormulation <: PSI.AbstractServiceFormulation\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.AbstractSimulationStatusEvent","page":"PowerSimulations","title":"PowerSimulations.AbstractSimulationStatusEvent","text":"All events subtyped from this need to be recorded under :simulation_status.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.CacheFlushRules","page":"PowerSimulations","title":"PowerSimulations.CacheFlushRules","text":"Informs the flusher on what data to keep in cache.\n\nCacheFlushRules(data, min_flush_size, max_size)\nCacheFlushRules(data, min_flush_size, max_size)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/cache_utils.jl:22.\n\nCacheFlushRules(; max_size, min_flush_size)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/cache_utils.jl:27.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.ConstructStage","page":"PowerSimulations","title":"PowerSimulations.ConstructStage","text":"Optimization Container construction stage\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.DecisionModelStore","page":"PowerSimulations","title":"PowerSimulations.DecisionModelStore","text":"Stores results data for one DecisionModel\n\nDecisionModelStore(duals, parameters, variables, aux_variables, expressions, optimizer_stats)\nDecisionModelStore(duals, parameters, variables, aux_variables, expressions, optimizer_stats)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/decision_model_store.jl:5.\n\nDecisionModelStore()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/decision_model_store.jl:13.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.DecisionProblem","page":"PowerSimulations","title":"PowerSimulations.DecisionProblem","text":"Abstract type for Decision Problems\n\nExample\n\nimport PowerSimulations const PSI = PowerSimulations struct MyCustomProblem <: PSI.DecisionProblem\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.EmulationModelStore","page":"PowerSimulations","title":"PowerSimulations.EmulationModelStore","text":"Stores results data for one EmulationModel\n\nEmulationModelStore(data_container, optimizer_stats)\nEmulationModelStore(data_container, optimizer_stats)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/emulation_model_store.jl:5.\n\nEmulationModelStore()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/emulation_model_store.jl:12.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.EmulationProblem","page":"PowerSimulations","title":"PowerSimulations.EmulationProblem","text":"Abstract type for Emulation Problems\n\nExample\n\nimport PowerSimulations const PSI = PowerSimulations struct MyCustomEmulator <: PSI.EmulationProblem\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.GenericEmulationProblem","page":"PowerSimulations","title":"PowerSimulations.GenericEmulationProblem","text":"Default PowerSimulations Emulation Problem Type\n\nGenericEmulationProblem()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/emulation_model.jl:4.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.HdfSimulationStore","page":"PowerSimulations","title":"PowerSimulations.HdfSimulationStore","text":"Stores simulation data in an HDF file.\n\nHdfSimulationStore(file, params, dm_data, em_data, optimizer_stats_datasets, optimizer_stats_write_index, cache)\nHdfSimulationStore(file, params, dm_data, em_data, optimizer_stats_datasets, optimizer_stats_write_index, cache)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/hdf_simulation_store.jl:22.\n\nHdfSimulationStore(file_path, mode)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/hdf_simulation_store.jl:35.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.InMemorySimulationStore","page":"PowerSimulations","title":"PowerSimulations.InMemorySimulationStore","text":"Stores simulation data in memory\n\nInMemorySimulationStore(params, dm_data, em_data, container_key_lookup)\nInMemorySimulationStore(params, dm_data, em_data, container_key_lookup)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/in_memory_simulation_store.jl:5.\n\nInMemorySimulationStore()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/in_memory_simulation_store.jl:11.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.InitialConditionsData","page":"PowerSimulations","title":"PowerSimulations.InitialConditionsData","text":"Stores data to populate initial conditions before the build call\n\nInitialConditionsData(duals, parameters, variables, aux_variables)\nInitialConditionsData(duals, parameters, variables, aux_variables)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/initial_conditions.jl:72.\n\nInitialConditionsData()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/initial_conditions.jl:78.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.OperationModel","page":"PowerSimulations","title":"PowerSimulations.OperationModel","text":"Abstract type for Decision Model and Emulation Model. OperationModel structs are parameterized with DecisionProblem or Emulation Problem structs\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.OptimizationOutputCache","page":"PowerSimulations","title":"PowerSimulations.OptimizationOutputCache","text":"Cache for a single parameter/variable/dual. Stores arrays chronologically by simulation timestamp.\n\nOptimizationOutputCache(key, data, dirty_timestamps, stats, size_per_entry, flush_rule)\nOptimizationOutputCache(key, data, dirty_timestamps, stats, size_per_entry, flush_rule)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/optimization_output_cache.jl:6.\n\nOptimizationOutputCache(key, flush_rule)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/optimization_output_cache.jl:17.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.OptimizationOutputCaches","page":"PowerSimulations","title":"PowerSimulations.OptimizationOutputCaches","text":"Cache for all model results\n\nOptimizationOutputCaches(data, max_size, min_flush_size)\nOptimizationOutputCaches(data, max_size, min_flush_size)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/optimization_output_caches.jl:5.\n\nOptimizationOutputCaches()\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/optimization_output_caches.jl:10.\n\nOptimizationOutputCaches(rules)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/optimization_output_caches.jl:18.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.OptimizerStats-Tuple{Vector{Float64}}","page":"PowerSimulations","title":"PowerSimulations.OptimizerStats","text":"OptimizerStats(data::Vector{Float64}) -> Any\n\n\nConstruct OptimizerStats from a vector that was serialized to HDF5.\n\nOptimizerStats(data)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/optimizer_stats.jl:55.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.RightHandSideParameter","page":"PowerSimulations","title":"PowerSimulations.RightHandSideParameter","text":"Parameters implemented through ParameterJuMP\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.SimulationProblemResults","page":"PowerSimulations","title":"PowerSimulations.SimulationProblemResults","text":"Holds the results of a simulation problem for plotting or exporting.\n\nSimulationProblemResults(, store, model_name, problem_params, sim_params, path, container_key_lookup; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/decision_model_simulation_results.jl:12.\n\nSimulationProblemResults(, store, model_name, problem_params, sim_params, path, container_key_lookup; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/emulation_model_simulation_results.jl:10.\n\nSimulationProblemResults(problem, base_power, execution_path, results_output_folder, timestamps, results_timestamps, values, system, system_uuid, resolution, store)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_problem_results.jl:18.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.SimulationStore","page":"PowerSimulations","title":"PowerSimulations.SimulationStore","text":"Provides storage of simulation data\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations._add_pwl_term!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Vector{Tuple{Float64, Float64}}, U, V}} where {T<:Component, U<:PowerSimulations.VariableType, V<:PowerSimulations.AbstractDeviceFormulation}","page":"PowerSimulations","title":"PowerSimulations._add_pwl_term!","text":"_add_pwl_term!(container::PowerSimulations.OptimizationContainer, component::Component, data::Vector{Tuple{Float64, Float64}}, _::PowerSimulations.VariableType, _::PowerSimulations.AbstractDeviceFormulation) -> Vector{JuMP.AffExpr}\n\n\nAdd PWL cost terms for data coming from a constant PWL cost function\n\n_add_pwl_term!(container, component, data, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/objective_functions.jl:705.\n\n_add_pwl_term!(container, component, data, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/objective_functions.jl:753.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._add_pwl_term!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Vector{VariableCost{Vector{Tuple{Float64, Float64}}}}, U, V}} where {T<:Component, U<:PowerSimulations.VariableType, V<:PowerSimulations.AbstractDeviceFormulation}","page":"PowerSimulations","title":"PowerSimulations._add_pwl_term!","text":"_add_pwl_term!(container::PowerSimulations.OptimizationContainer, component::Component, cost_data::Vector{VariableCost{Vector{Tuple{Float64, Float64}}}}, _::PowerSimulations.VariableType, _::PowerSimulations.AbstractDeviceFormulation) -> Vector{JuMP.AffExpr}\n\n\nAdd PWL cost terms for data coming from the MarketBidCost\n\n_add_pwl_term!(container, component, cost_data, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/objective_functions.jl:623.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, VariableCost{Float64}, U}} where {T<:PowerSimulations.VariableType, U<:PowerSimulations.AbstractDeviceFormulation}","page":"PowerSimulations","title":"PowerSimulations._add_variable_cost_to_objective!","text":"_add_variable_cost_to_objective!(container::PowerSimulations.OptimizationContainer, _::PowerSimulations.VariableType, component::Component, cost_component::VariableCost{Float64}, _::PowerSimulations.AbstractDeviceFormulation)\n\n\nAdds to the cost function cost terms for sum of variables with common factor to be used for cost expression for optimization_container model.\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nvar_key::VariableKey: The variable name\ncomponentname::String: The componentname of the variable container\ncost_component::PSY.VariableCost{Float64} : container for cost to be associated with variable\n\n_add_variable_cost_to_objective!(container, _, component, cost_component, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/objective_functions.jl:409.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, VariableCost{Tuple{Float64, Float64}}, U}} where {T<:PowerSimulations.VariableType, U<:PowerSimulations.AbstractDeviceFormulation}","page":"PowerSimulations","title":"PowerSimulations._add_variable_cost_to_objective!","text":"_add_variable_cost_to_objective!(container::PowerSimulations.OptimizationContainer, _::PowerSimulations.VariableType, component::Component, cost_component::VariableCost{Tuple{Float64, Float64}}, _::PowerSimulations.AbstractDeviceFormulation)\n\n\nAdds to the cost function cost terms for sum of variables with common factor to be used for cost expression for optimization_container model.\n\nEquation\n\ngen_cost = dt*sign*(sum(variable.^2)*cost_data[1] + sum(variable)*cost_data[2])\n\nLaTeX\n\ncost = dttimes sign (sum_iin I c_1 v_i^2 + sum_iin I c_2 v_i )\n\nfor quadratic factor large enough. If the first term of the quadratic objective is 0.0, adds a linear cost term sum(variable)*cost_data[2]\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nvar_key::VariableKey: The variable name\ncomponentname::String: The componentname of the variable container\ncost_component::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors\n\n_add_variable_cost_to_objective!(container, _, component, cost_component, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/objective_functions.jl:461.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._add_variable_cost_to_objective!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, T, Component, VariableCost{Vector{Tuple{Float64, Float64}}}, U}} where {T<:PowerSimulations.VariableType, U<:PowerSimulations.AbstractDeviceFormulation}","page":"PowerSimulations","title":"PowerSimulations._add_variable_cost_to_objective!","text":"_add_variable_cost_to_objective!(container::PowerSimulations.OptimizationContainer, _::PowerSimulations.VariableType, component::Component, cost_component::VariableCost{Vector{Tuple{Float64, Float64}}}, _::PowerSimulations.AbstractDeviceFormulation)\n\n\nCreates piecewise linear cost function using a sum of variables and expression with sign and time step included.\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nvar_key::VariableKey: The variable name\ncomponentname::String: The componentname of the variable container\ncost_component::PSY.VariableCost{Vector{NTuple{2, Float64}}}\n\n_add_variable_cost_to_objective!(container, _, component, cost_component, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/objective_functions.jl:514.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._allocate_execution_order-Tuple{Vector{Int64}}","page":"PowerSimulations","title":"PowerSimulations._allocate_execution_order","text":"_allocate_execution_order(interval_run_counts::Vector{Int64}) -> Vector{Int64}\n\n\nFunction calculates the total number of problem executions in the simulation and allocates the appropiate vector\n\n_allocate_execution_order(interval_run_counts)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_sequence.jl:71.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._calculate_interval_inner_counts-Tuple{OrderedDict{Symbol, Dates.Millisecond}}","page":"PowerSimulations","title":"PowerSimulations._calculate_interval_inner_counts","text":"_calculate_interval_inner_counts(intervals::OrderedDict{Symbol, Dates.Millisecond}) -> Vector{Int64}\n\n\ncalculateintervalinnercounts(intervals::OrderedDict{String,<:Dates.TimePeriod})\n\nCalculates how many times a problem is executed for every interval of the previous problem\n\n_calculate_interval_inner_counts(intervals)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation_sequence.jl:44.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._get_data_for_tdc-Union{Tuple{U}, Tuple{T}, Tuple{Vector{T}, Vector{U}, Dates.TimePeriod}} where {T<:InitialCondition, U<:InitialCondition}","page":"PowerSimulations","title":"PowerSimulations._get_data_for_tdc","text":"_get_data_for_tdc(initial_conditions_on::Array{T<:InitialCondition, 1}, initial_conditions_off::Array{U<:InitialCondition, 1}, resolution::Dates.TimePeriod) -> Tuple{Matrix{InitialCondition}, Vector{NamedTuple{(:up, :down), Tuple{Float64, Float64}}}}\n\n\nIf the fraction of hours that a generator has a duration constraint is less than the fraction of hours that a single time_step represents then it is not binding.\n\n_get_data_for_tdc(initial_conditions_on, initial_conditions_off, resolution)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:1128.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._get_initial_condition_type-Tuple{Type{RampConstraint}, Type{<:ThermalGen}, Type{<:PowerSimulations.AbstractThermalFormulation}}","page":"PowerSimulations","title":"PowerSimulations._get_initial_condition_type","text":"_get_initial_condition_type(_::Type{RampConstraint}, _::Type{<:ThermalGen}, _::Type{<:PowerSimulations.AbstractThermalFormulation}) -> Type{PowerSimulations.DeviceAboveMinPower}\n\n\nThis function gets the data for the generators for ramping constraints of thermal generators\n\n_get_initial_condition_type(_, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:799.\n\n_get_initial_condition_type(_, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:804.\n\n_get_initial_condition_type(_, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:809.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._slope_convexity_check-Tuple{Vector{Float64}}","page":"PowerSimulations","title":"PowerSimulations._slope_convexity_check","text":"_slope_convexity_check(slopes::Vector{Float64}) -> Bool\n\n\nReturns True/False depending on compatibility of the cost data with the convex implementation method\n\n_slope_convexity_check(slopes)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/objective_functions.jl:547.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._summary_to_dict!-Tuple{PowerSimulations.OptimizerStats, JuMP.Model}","page":"PowerSimulations","title":"PowerSimulations._summary_to_dict!","text":"_summary_to_dict!(optimizer_stats::PowerSimulations.OptimizerStats, jump_model::JuMP.Model)\n\n\nRun this function only when getting detailed solver stats\n\n_summary_to_dict!(optimizer_stats, jump_model)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/jump_utils.jl:231.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{SR}, Tuple{PowerSimulations.OptimizationContainer, Type{RequirementConstraint}, SR, Vector{<:Service}, ServiceModel{SR, GroupReserve}}} where SR<:StaticReserveGroup","page":"PowerSimulations","title":"PowerSimulations.add_constraints!","text":"add_constraints!(container::PowerSimulations.OptimizationContainer, _::Type{RequirementConstraint}, service::StaticReserveGroup, contributing_services::Vector{<:Service}, model::ServiceModel{SR<:StaticReserveGroup, GroupReserve})\n\n\nThis function creates the requirement constraint that will be attained by the apropriate services\n\nadd_constraints!(container, _, service, contributing_services, model)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/services_models/group_reserve.jl:25.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{S}, Tuple{B}, Tuple{PowerSimulations.OptimizationContainer, Type{NetworkFlowConstraint}, InfrastructureSystems.FlattenIteratorWrapper{B}, DeviceModel{B, <:PowerSimulations.AbstractBranchFormulation}, NetworkModel{S}}} where {B<:ACBranch, S<:StandardPTDFModel}","page":"PowerSimulations","title":"PowerSimulations.add_constraints!","text":"add_constraints!(container::PowerSimulations.OptimizationContainer, cons_type::Type{NetworkFlowConstraint}, devices::InfrastructureSystems.FlattenIteratorWrapper{B<:ACBranch}, model::DeviceModel{B<:ACBranch, <:PowerSimulations.AbstractBranchFormulation}, network_model::NetworkModel{S<:StandardPTDFModel})\n\n\nAdd network flow constraints for ACBranch and NetworkModel with StandardPTDFModel\n\nadd_constraints!(container, cons_type, devices, model, network_model)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:196.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{MustRunConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, S}, Type{<:PowerModels.AbstractPowerModel}}} where {T<:ThermalGen, S<:PowerSimulations.AbstractThermalUnitCommitment}","page":"PowerSimulations","title":"PowerSimulations.add_constraints!","text":"add_constraints!(container::PowerSimulations.OptimizationContainer, _::Type{MustRunConstraint}, devices::InfrastructureSystems.FlattenIteratorWrapper{T<:ThermalGen}, model::DeviceModel{T<:ThermalGen, S<:PowerSimulations.AbstractThermalUnitCommitment}, W::Type{<:PowerModels.AbstractPowerModel})\n\n\nThis function creates constraints that keep must run devices online\n\nadd_constraints!(container, _, devices, model, W)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:1104.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{B}, Tuple{PowerSimulations.OptimizationContainer, Type{RateLimitConstraintFromTo}, InfrastructureSystems.FlattenIteratorWrapper{B}, DeviceModel{B, <:PowerSimulations.AbstractBranchFormulation}, Type{T}}} where {B<:ACBranch, T<:PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.add_constraints!","text":"add_constraints!(container::PowerSimulations.OptimizationContainer, cons_type::Type{RateLimitConstraintFromTo}, devices::InfrastructureSystems.FlattenIteratorWrapper{B<:ACBranch}, model::DeviceModel{B<:ACBranch, <:PowerSimulations.AbstractBranchFormulation}, _::Type{T<:PowerModels.AbstractPowerModel})\n\n\nAdd rate limit from to constraints for ACBranch with AbstractPowerModel\n\nadd_constraints!(container, cons_type, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:128.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{B}, Tuple{PowerSimulations.OptimizationContainer, Type{RateLimitConstraintToFrom}, InfrastructureSystems.FlattenIteratorWrapper{B}, DeviceModel{B, <:PowerSimulations.AbstractBranchFormulation}, Type{T}}} where {B<:ACBranch, T<:PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.add_constraints!","text":"add_constraints!(container::PowerSimulations.OptimizationContainer, cons_type::Type{RateLimitConstraintToFrom}, devices::InfrastructureSystems.FlattenIteratorWrapper{B<:ACBranch}, model::DeviceModel{B<:ACBranch, <:PowerSimulations.AbstractBranchFormulation}, _::Type{T<:PowerModels.AbstractPowerModel})\n\n\nAdd rate limit to from constraints for ACBranch with AbstractPowerModel\n\nadd_constraints!(container, cons_type, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:162.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{StartTypeConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, ThermalMultiStartUnitCommitment}, Type{<:PowerModels.AbstractPowerModel}}} where T<:ThermalMultiStart","page":"PowerSimulations","title":"PowerSimulations.add_constraints!","text":"add_constraints!(container::PowerSimulations.OptimizationContainer, _::Type{StartTypeConstraint}, devices::InfrastructureSystems.FlattenIteratorWrapper{T<:ThermalMultiStart}, model::DeviceModel{T<:ThermalMultiStart, ThermalMultiStartUnitCommitment}, _::Type{<:PowerModels.AbstractPowerModel})\n\n\nConstructs contraints that restricts devices to one type of start at a time\n\nEquations\n\nsum(var_starts[name, s, t] for s in starts) = var_start[name, t]\n\nLaTeX\n\nsum^S_g_s=1 δ^s(t)  eq  x^start(t)\n\nadd_constraints!(container, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:981.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{StartupInitialConditionConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, ThermalMultiStartUnitCommitment}, Type{<:PowerModels.AbstractPowerModel}}} where T<:ThermalMultiStart","page":"PowerSimulations","title":"PowerSimulations.add_constraints!","text":"add_constraints!(container::PowerSimulations.OptimizationContainer, _::Type{StartupInitialConditionConstraint}, devices::InfrastructureSystems.FlattenIteratorWrapper{T<:ThermalMultiStart}, model::DeviceModel{T<:ThermalMultiStart, ThermalMultiStartUnitCommitment}, _::Type{<:PowerModels.AbstractPowerModel})\n\n\nConstructs contraints that restricts devices to one type of start at a time\n\nEquations\n\nub: (time_limits[st+1]-1)*δ^{s}(t) + (1 - δ^{s}(t)) * M_VALUE >= sum(1-varbin[name, i]) for i in 1:t) + initial_condition_offtime lb: (time_limits[st]-1)*δ^{s}(t) =< sum(1-varbin[name, i]) for i in 1:t) + initial_condition_offtime\n\nLaTeX\n\nTS^s+1_g δ^s(t) + (1-δ^s(t)) M_VALUE   geq  sum^t_i=1 x^status(i)  +  DT_g^0  forall t in 1 ldots  TS^s+1_g\n\nTS^s_g δ^s(t) leq  sum^t_i=1 x^status(i)  +  DT_g^0  forall t in 1 ldots  TS^s+1_g\n\nadd_constraints!(container, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:1032.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{StartupTimeLimitTemperatureConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, ThermalMultiStartUnitCommitment}, Type{<:PowerModels.AbstractPowerModel}}} where T<:ThermalMultiStart","page":"PowerSimulations","title":"PowerSimulations.add_constraints!","text":"add_constraints!(container::PowerSimulations.OptimizationContainer, _::Type{StartupTimeLimitTemperatureConstraint}, devices::InfrastructureSystems.FlattenIteratorWrapper{T<:ThermalMultiStart}, model::DeviceModel{T<:ThermalMultiStart, ThermalMultiStartUnitCommitment}, _::Type{<:PowerModels.AbstractPowerModel})\n\n\nConstructs contraints for different types of starts based on generator down-time\n\nEquations\n\nfor t in time_limits[s+1]:T\n\nvar_starts[name, s, t] <= sum( var_stop[name, t-i] for i in time_limits[s]:(time_limits[s+1]-1)\n\nLaTeX\n\nδ^s(t)  leq sum_i=TS^s_g^TS^s+1_g x^stop(t-i)\n\nadd_constraints!(container, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:909.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{RateLimitConstraint}, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, U}, Type{<:PowerModels.AbstractActivePowerModel}}} where {T<:ACBranch, U<:PowerSimulations.AbstractBranchFormulation}","page":"PowerSimulations","title":"PowerSimulations.add_constraints!","text":"add_constraints!(container::PowerSimulations.OptimizationContainer, cons_type::Type{RateLimitConstraint}, devices::InfrastructureSystems.FlattenIteratorWrapper{T<:ACBranch}, model::DeviceModel{T<:ACBranch, U<:PowerSimulations.AbstractBranchFormulation}, X::Type{<:PowerModels.AbstractActivePowerModel})\n\n\nAdd branch rate limit constraints for ACBranch with AbstractActivePowerModel\n\nadd_constraints!(container, cons_type, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:114.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{V}, Tuple{U}, Tuple{PowerSimulations.OptimizationContainer, Type{RampConstraint}, InfrastructureSystems.FlattenIteratorWrapper{U}, DeviceModel{U, V}, Type{<:PowerModels.AbstractPowerModel}}} where {U<:ThermalGen, V<:PowerSimulations.AbstractThermalUnitCommitment}","page":"PowerSimulations","title":"PowerSimulations.add_constraints!","text":"add_constraints!(container::PowerSimulations.OptimizationContainer, T::Type{RampConstraint}, devices::InfrastructureSystems.FlattenIteratorWrapper{U<:ThermalGen}, model::DeviceModel{U<:ThermalGen, V<:PowerSimulations.AbstractThermalUnitCommitment}, W::Type{<:PowerModels.AbstractPowerModel})\n\n\nThis function adds the ramping limits of generators when there are CommitmentVariables\n\nadd_constraints!(container, T, devices, model, W)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:814.\n\nadd_constraints!(container, T, devices, model, W)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:832.\n\nadd_constraints!(container, T, devices, model, W)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:872.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{SteadyStateFrequencyDeviation}, InfrastructureSystems.FlattenIteratorWrapper{U}, ServiceModel{AGC, V}, System}} where {T<:FrequencyResponseConstraint, U<:Area, V<:PIDSmoothACE}","page":"PowerSimulations","title":"PowerSimulations.add_constraints!","text":"add_constraints!(container::PowerSimulations.OptimizationContainer, _::Type{T<:FrequencyResponseConstraint}, _::Type{SteadyStateFrequencyDeviation}, areas::InfrastructureSystems.FlattenIteratorWrapper{U<:Area}, _::ServiceModel{AGC, V<:PIDSmoothACE}, sys::System)\n\n\nExpression for the power deviation given deviation in the frequency. This expression allows updating the response of the frequency depending on commitment decisions\n\nadd_constraints!(container, _, _, areas, _, sys)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/services_models/agc.jl:101.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{<:ActivePowerVariableLimitsConstraint}, Type{<:PowerSimulations.VariableType}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{<:PowerModels.AbstractPowerModel}}} where {V<:ThermalMultiStart, W<:ThermalMultiStartUnitCommitment}","page":"PowerSimulations","title":"PowerSimulations.add_constraints!","text":"add_constraints!(container::PowerSimulations.OptimizationContainer, T::Type{<:ActivePowerVariableLimitsConstraint}, U::Type{<:PowerSimulations.VariableType}, devices::InfrastructureSystems.FlattenIteratorWrapper{V<:ThermalMultiStart}, model::DeviceModel{V<:ThermalMultiStart, W<:ThermalMultiStartUnitCommitment}, X::Type{<:PowerModels.AbstractPowerModel})\n\n\nThis function adds range constraint for the first time period. Constraint (10) from PGLIB formulation\n\nadd_constraints!(container, T, U, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:65.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:91.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:111.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:293.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:206.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:246.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:258.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:312.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:327.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:365.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:64.\n\nadd_constraints!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:79.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:102.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:122.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:196.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:345.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{<:PowerSimulations.PowerVariableLimitsConstraint}, Type{<:Union{PowerAboveMinimumVariable, PowerSimulations.ExpressionType}}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{<:PowerModels.AbstractPowerModel}}} where {V<:ThermalGen, W<:ThermalCompactDispatch}","page":"PowerSimulations","title":"PowerSimulations.add_constraints!","text":"add_constraints!(container::PowerSimulations.OptimizationContainer, T::Type{<:PowerSimulations.PowerVariableLimitsConstraint}, U::Type{<:Union{PowerAboveMinimumVariable, PowerSimulations.ExpressionType}}, devices::InfrastructureSystems.FlattenIteratorWrapper{V<:ThermalGen}, model::DeviceModel{V<:ThermalGen, W<:ThermalCompactDispatch}, X::Type{<:PowerModels.AbstractPowerModel}) -> Any\n\n\nRange constraints for thermal compact dispatch\n\nadd_constraints!(container, T, U, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:65.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:91.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:111.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:293.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:305.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:327.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:340.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:206.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:229.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:246.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:258.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:312.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:327.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:365.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:64.\n\nadd_constraints!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:79.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:102.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:122.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:196.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:271.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:345.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:420.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:456.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{<:PowerSimulations.PowerVariableLimitsConstraint}, Type{<:Union{PowerSimulations.ExpressionType, PowerSimulations.VariableType}}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{<:PowerModels.AbstractPowerModel}}} where {V<:HydroGen, W<:PowerSimulations.AbstractHydroDispatchFormulation}","page":"PowerSimulations","title":"PowerSimulations.add_constraints!","text":"add_constraints!(container::PowerSimulations.OptimizationContainer, T::Type{<:PowerSimulations.PowerVariableLimitsConstraint}, U::Type{<:Union{PowerSimulations.ExpressionType, PowerSimulations.VariableType}}, devices::InfrastructureSystems.FlattenIteratorWrapper{V<:HydroGen}, model::DeviceModel{V<:HydroGen, W<:PowerSimulations.AbstractHydroDispatchFormulation}, X::Type{<:PowerModels.AbstractPowerModel}) -> Any\n\n\nAdd power variable limits constraints for hydro dispatch formulation\n\nadd_constraints!(container, T, U, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:65.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:91.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:111.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:293.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:305.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:327.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:340.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:361.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:377.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:393.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:206.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:229.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:246.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:258.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:312.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:327.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:344.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:365.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:64.\n\nadd_constraints!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:79.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:102.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:122.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:196.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:239.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:271.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:345.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:420.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:456.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{<:PowerSimulations.PowerVariableLimitsConstraint}, Type{<:Union{PowerSimulations.ExpressionType, PowerSimulations.VariableType}}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{<:PowerModels.AbstractPowerModel}}} where {V<:HydroGen, W<:PowerSimulations.AbstractHydroUnitCommitment}","page":"PowerSimulations","title":"PowerSimulations.add_constraints!","text":"add_constraints!(container::PowerSimulations.OptimizationContainer, T::Type{<:PowerSimulations.PowerVariableLimitsConstraint}, U::Type{<:Union{PowerSimulations.ExpressionType, PowerSimulations.VariableType}}, devices::InfrastructureSystems.FlattenIteratorWrapper{V<:HydroGen}, model::DeviceModel{V<:HydroGen, W<:PowerSimulations.AbstractHydroUnitCommitment}, X::Type{<:PowerModels.AbstractPowerModel}) -> Any\n\n\nAdd power variable limits constraints for hydro unit commitment formulation\n\nadd_constraints!(container, T, U, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:65.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:91.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:111.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:293.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:305.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:327.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:340.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:361.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:377.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:393.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:206.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:229.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:246.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:258.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:312.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:327.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:344.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:365.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:64.\n\nadd_constraints!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:79.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:102.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:122.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:196.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:239.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:271.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:345.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:420.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:456.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{<:PowerSimulations.PowerVariableLimitsConstraint}, Type{<:Union{PowerSimulations.ExpressionType, PowerSimulations.VariableType}}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{<:PowerModels.AbstractPowerModel}}} where {V<:HydroPumpedStorage, W<:PowerSimulations.AbstractHydroReservoirFormulation}","page":"PowerSimulations","title":"PowerSimulations.add_constraints!","text":"add_constraints!(container::PowerSimulations.OptimizationContainer, T::Type{<:PowerSimulations.PowerVariableLimitsConstraint}, U::Type{<:Union{PowerSimulations.ExpressionType, PowerSimulations.VariableType}}, devices::InfrastructureSystems.FlattenIteratorWrapper{V<:HydroPumpedStorage}, model::DeviceModel{V<:HydroPumpedStorage, W<:PowerSimulations.AbstractHydroReservoirFormulation}, X::Type{<:PowerModels.AbstractPowerModel}) -> Any\n\n\nAdd output power variable limits constraints for hydro dispatch formulation\n\nadd_constraints!(container, T, U, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:65.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:91.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:111.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:293.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:305.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:327.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:340.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:361.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:377.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:393.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:206.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:229.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:246.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:258.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:344.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:365.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:64.\n\nadd_constraints!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:79.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:102.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:122.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:196.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:239.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:271.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:345.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:420.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:456.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{<:PowerSimulations.PowerVariableLimitsConstraint}, Type{<:Union{PowerSimulations.ExpressionType, PowerSimulations.VariableType}}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{<:PowerModels.AbstractPowerModel}}} where {V<:ThermalGen, W<:PowerSimulations.AbstractThermalDispatchFormulation}","page":"PowerSimulations","title":"PowerSimulations.add_constraints!","text":"add_constraints!(container::PowerSimulations.OptimizationContainer, T::Type{<:PowerSimulations.PowerVariableLimitsConstraint}, U::Type{<:Union{PowerSimulations.ExpressionType, PowerSimulations.VariableType}}, devices::InfrastructureSystems.FlattenIteratorWrapper{V<:ThermalGen}, model::DeviceModel{V<:ThermalGen, W<:PowerSimulations.AbstractThermalDispatchFormulation}, X::Type{<:PowerModels.AbstractPowerModel}) -> Any\n\n\nSemicontinuous range constraints for thermal dispatch formulations\n\nadd_constraints!(container, T, U, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:65.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:91.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:111.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:293.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:305.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:327.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:340.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:361.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:377.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:393.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:206.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:229.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:246.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:258.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:312.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:327.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:344.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:365.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:64.\n\nadd_constraints!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:79.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:102.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:122.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:196.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:239.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:271.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:345.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:420.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:456.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{<:PowerSimulations.PowerVariableLimitsConstraint}, Type{<:Union{PowerSimulations.ExpressionType, PowerSimulations.VariableType}}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{<:PowerModels.AbstractPowerModel}}} where {V<:ThermalGen, W<:PowerSimulations.AbstractThermalUnitCommitment}","page":"PowerSimulations","title":"PowerSimulations.add_constraints!","text":"add_constraints!(container::PowerSimulations.OptimizationContainer, T::Type{<:PowerSimulations.PowerVariableLimitsConstraint}, U::Type{<:Union{PowerSimulations.ExpressionType, PowerSimulations.VariableType}}, devices::InfrastructureSystems.FlattenIteratorWrapper{V<:ThermalGen}, model::DeviceModel{V<:ThermalGen, W<:PowerSimulations.AbstractThermalUnitCommitment}, X::Type{<:PowerModels.AbstractPowerModel}) -> Any\n\n\nSemicontinuous range constraints for unit commitment formulations\n\nadd_constraints!(container, T, U, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:65.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:91.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:111.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:293.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:305.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:327.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:340.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:361.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:377.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:393.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:206.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:229.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:246.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:258.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:312.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:327.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:344.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:365.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:64.\n\nadd_constraints!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:79.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:102.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:122.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:196.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:239.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:271.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:345.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:420.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:456.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{<:ReactivePowerVariableLimitsConstraint}, Type{<:ReactivePowerVariable}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{<:PowerModels.AbstractPowerModel}}} where {V<:ElectricLoad, W<:PowerSimulations.AbstractControllablePowerLoadFormulation}","page":"PowerSimulations","title":"PowerSimulations.add_constraints!","text":"add_constraints!(container::PowerSimulations.OptimizationContainer, T::Type{<:ReactivePowerVariableLimitsConstraint}, U::Type{<:ReactivePowerVariable}, devices::InfrastructureSystems.FlattenIteratorWrapper{V<:ElectricLoad}, _::DeviceModel{V<:ElectricLoad, W<:PowerSimulations.AbstractControllablePowerLoadFormulation}, _::Type{<:PowerModels.AbstractPowerModel})\n\n\nReactive Power Constraints on Controllable Loads Assume Constant power_factor\n\nadd_constraints!(container, T, U, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:65.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:293.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:312.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:327.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:365.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:64.\n\nadd_constraints!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:79.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:122.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:196.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:239.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:271.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:345.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{<:ReactivePowerVariableLimitsConstraint}, Type{<:ReactivePowerVariable}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{<:PowerModels.AbstractPowerModel}}} where {V<:RenewableGen, W<:RenewableConstantPowerFactor}","page":"PowerSimulations","title":"PowerSimulations.add_constraints!","text":"add_constraints!(container::PowerSimulations.OptimizationContainer, _::Type{<:ReactivePowerVariableLimitsConstraint}, _::Type{<:ReactivePowerVariable}, devices::InfrastructureSystems.FlattenIteratorWrapper{V<:RenewableGen}, _::DeviceModel{V<:RenewableGen, W<:RenewableConstantPowerFactor}, _::Type{<:PowerModels.AbstractPowerModel})\n\n\nReactive Power Constraints on Renewable Gen Constant power_factor\n\nadd_constraints!(container, T, U, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:65.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:293.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:312.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:327.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:365.\n\nadd_constraints!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:79.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:122.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:196.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:239.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:271.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:345.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{ActivePowerVariableLimitsConstraint}, Type{<:Union{PowerSimulations.ExpressionType, PowerSimulations.VariableType}}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{<:PowerModels.AbstractPowerModel}}} where {V<:HydroGen, W<:HydroDispatchRunOfRiver}","page":"PowerSimulations","title":"PowerSimulations.add_constraints!","text":"add_constraints!(container::PowerSimulations.OptimizationContainer, T::Type{ActivePowerVariableLimitsConstraint}, U::Type{<:Union{PowerSimulations.ExpressionType, PowerSimulations.VariableType}}, devices::InfrastructureSystems.FlattenIteratorWrapper{V<:HydroGen}, model::DeviceModel{V<:HydroGen, W<:HydroDispatchRunOfRiver}, X::Type{<:PowerModels.AbstractPowerModel})\n\n\nTime series constraints\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:91.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:111.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:293.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:206.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:229.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:246.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:258.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:312.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:365.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:102.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:122.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:196.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:239.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:271.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:345.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{ActivePowerVariableLimitsConstraint}, Type{<:Union{PowerSimulations.VariableType, var\"#s877\"} where var\"#s877\"<:RangeConstraintLBExpressions}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{<:PowerModels.AbstractPowerModel}}} where {V<:HydroGen, W<:HydroCommitmentRunOfRiver}","page":"PowerSimulations","title":"PowerSimulations.add_constraints!","text":"add_constraints!(container::PowerSimulations.OptimizationContainer, T::Type{ActivePowerVariableLimitsConstraint}, U::Type{<:Union{PowerSimulations.VariableType, var\"#s877\"} where var\"#s877\"<:RangeConstraintLBExpressions}, devices::InfrastructureSystems.FlattenIteratorWrapper{V<:HydroGen}, model::DeviceModel{V<:HydroGen, W<:HydroCommitmentRunOfRiver}, X::Type{<:PowerModels.AbstractPowerModel})\n\n\nAdd semicontinuous range constraints for Hydro Unit Commitment formulation\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:91.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/electric_loads.jl:111.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:293.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:206.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:229.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:246.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:327.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:365.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:102.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:122.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:196.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:239.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:271.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:345.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{InputActivePowerVariableLimitsConstraint}, Type{<:Union{PowerSimulations.ExpressionType, PowerSimulations.VariableType}}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{<:PowerModels.AbstractPowerModel}}} where {V<:HydroPumpedStorage, W<:PowerSimulations.AbstractHydroReservoirFormulation}","page":"PowerSimulations","title":"PowerSimulations.add_constraints!","text":"add_constraints!(container::PowerSimulations.OptimizationContainer, T::Type{InputActivePowerVariableLimitsConstraint}, U::Type{<:Union{PowerSimulations.ExpressionType, PowerSimulations.VariableType}}, devices::InfrastructureSystems.FlattenIteratorWrapper{V<:HydroPumpedStorage}, model::DeviceModel{V<:HydroPumpedStorage, W<:PowerSimulations.AbstractHydroReservoirFormulation}, X::Type{<:PowerModels.AbstractPowerModel})\n\n\nAdd input power variable limits constraints for hydro dispatch formulation\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:293.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:361.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:344.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:122.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:239.\n\nadd_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:271.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{EnergyBalanceConstraint}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {V<:HydroEnergyReservoir, W<:PowerSimulations.AbstractHydroFormulation, X<:PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.add_constraints!","text":"add_constraints!(container::PowerSimulations.OptimizationContainer, _::Type{EnergyBalanceConstraint}, devices::InfrastructureSystems.FlattenIteratorWrapper{V<:HydroEnergyReservoir}, model::DeviceModel{V<:HydroEnergyReservoir, W<:PowerSimulations.AbstractHydroFormulation}, _::Type{X<:PowerModels.AbstractPowerModel})\n\n\nThis function defines the constraints for the water level (or state of charge) for the Hydro Reservoir.\n\nadd_constraints!(container, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:411.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{EnergyBalanceConstraint}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {V<:Storage, W<:PowerSimulations.AbstractStorageFormulation, X<:PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.add_constraints!","text":"add_constraints!(container::PowerSimulations.OptimizationContainer, _::Type{EnergyBalanceConstraint}, devices::InfrastructureSystems.FlattenIteratorWrapper{V<:Storage}, model::DeviceModel{V<:Storage, W<:PowerSimulations.AbstractStorageFormulation}, _::Type{X<:PowerModels.AbstractPowerModel})\n\n\nAdd Energy Balance Constraints for AbstractStorageFormulation\n\nadd_constraints!(container, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:186.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{EnergyCapacityConstraint}, Type{<:PowerSimulations.VariableType}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {V<:Storage, W<:PowerSimulations.AbstractStorageFormulation, X<:PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.add_constraints!","text":"add_constraints!(container::PowerSimulations.OptimizationContainer, T::Type{EnergyCapacityConstraint}, U::Type{<:PowerSimulations.VariableType}, devices::InfrastructureSystems.FlattenIteratorWrapper{V<:Storage}, model::DeviceModel{V<:Storage, W<:PowerSimulations.AbstractStorageFormulation}, _::Type{X<:PowerModels.AbstractPowerModel})\n\n\nAdd Energy Capacity Constraints for AbstractStorageFormulation\n\nadd_constraints!(container, T, U, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:162.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{EnergyCapacityDownConstraint}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {V<:HydroPumpedStorage, W<:PowerSimulations.AbstractHydroFormulation, X<:PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.add_constraints!","text":"add_constraints!(container::PowerSimulations.OptimizationContainer, _::Type{EnergyCapacityDownConstraint}, devices::InfrastructureSystems.FlattenIteratorWrapper{V<:HydroPumpedStorage}, model::DeviceModel{V<:HydroPumpedStorage, W<:PowerSimulations.AbstractHydroFormulation}, _::Type{X<:PowerModels.AbstractPowerModel})\n\n\nAdd energy capacity down constraints for hydro pumped storage\n\nadd_constraints!(container, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:533.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{EnergyCapacityUpConstraint}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {V<:HydroPumpedStorage, W<:PowerSimulations.AbstractHydroFormulation, X<:PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.add_constraints!","text":"add_constraints!(container::PowerSimulations.OptimizationContainer, _::Type{EnergyCapacityUpConstraint}, devices::InfrastructureSystems.FlattenIteratorWrapper{V<:HydroPumpedStorage}, model::DeviceModel{V<:HydroPumpedStorage, W<:PowerSimulations.AbstractHydroFormulation}, _::Type{X<:PowerModels.AbstractPowerModel})\n\n\nThis function defines the constraints for the water level (or state of charge) for the HydroPumpedStorage.\n\nadd_constraints!(container, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:469.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{EnergyTargetConstraint}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {V<:HydroGen, W<:PowerSimulations.AbstractHydroFormulation, X<:PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.add_constraints!","text":"add_constraints!(container::PowerSimulations.OptimizationContainer, _::Type{EnergyTargetConstraint}, devices::InfrastructureSystems.FlattenIteratorWrapper{V<:HydroGen}, model::DeviceModel{V<:HydroGen, W<:PowerSimulations.AbstractHydroFormulation}, _::Type{X<:PowerModels.AbstractPowerModel})\n\n\nAdd energy target constraints for hydro gen\n\nadd_constraints!(container, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:598.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Type{EnergyTargetConstraint}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {V<:Storage, W<:EnergyTarget, X<:PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.add_constraints!","text":"add_constraints!(container::PowerSimulations.OptimizationContainer, _::Type{EnergyTargetConstraint}, devices::InfrastructureSystems.FlattenIteratorWrapper{V<:Storage}, model::DeviceModel{V<:Storage, W<:EnergyTarget}, _::Type{X<:PowerModels.AbstractPowerModel})\n\n\nAdd Energy Target Constraints for EnergyTarget formulation\n\nadd_constraints!(container, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:335.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_feedforward_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, DeviceModel, InfrastructureSystems.FlattenIteratorWrapper{T}, EnergyLimitFeedforward}} where T<:Component","page":"PowerSimulations","title":"PowerSimulations.add_feedforward_constraints!","text":"add_feedforward_constraints!(container::PowerSimulations.OptimizationContainer, _::DeviceModel, devices::InfrastructureSystems.FlattenIteratorWrapper{T<:Component}, ff::EnergyLimitFeedforward)\n\n\n    add_feedforward_constraints(container::OptimizationContainer,\n                    cons_name::Symbol,\n                    param_reference,\n                    var_key::VariableKey)\n\nConstructs a parameterized integral limit constraint to implement feedforward from other models. The Parameters are initialized using the upper boundary values of the provided variables.\n\nsum(variable[var_name, t] for t in 1:affected_periods)/affected_periods <= param_reference[var_name]\n\nLaTeX\n\nsum_t x leq param^max\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nmodel::DeviceModel : the device model\ndevices::IS.FlattenIteratorWrapper{T} : list of devices\nff::FixValueFeedforward : a instance of the FixValue Feedforward\n\nadd_feedforward_constraints!(container, _, devices, ff)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/feedforward/feedforward_constraints.jl:366.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_feedforward_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, DeviceModel, InfrastructureSystems.FlattenIteratorWrapper{T}, EnergyTargetFeedforward}} where T<:Component","page":"PowerSimulations","title":"PowerSimulations.add_feedforward_constraints!","text":"add_feedforward_constraints!(container::PowerSimulations.OptimizationContainer, _::DeviceModel, devices::InfrastructureSystems.FlattenIteratorWrapper{T<:Component}, ff::EnergyTargetFeedforward)\n\n\n    add_feedforward_constraints(\n        container::OptimizationContainer,\n        ::DeviceModel,\n        devices::IS.FlattenIteratorWrapper{T},\n        ff::EnergyTargetFeedforward,\n    ) where {T <: PSY.Component}\n\nConstructs a equality constraint to a fix a variable in one model using the variable value from other model results.\n\nvariable[var_name, t] + slack[var_name, t] >= param[var_name, t]\n\nLaTeX\n\nx + slack = param\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nmodel::DeviceModel : the device model\ndevices::IS.FlattenIteratorWrapper{T} : list of devices\nff::EnergyTargetFeedforward : a instance of the FixValue Feedforward\n\nadd_feedforward_constraints!(container, _, devices, ff)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/feedforward/feedforward_constraints.jl:484.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_feedforward_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, DeviceModel, InfrastructureSystems.FlattenIteratorWrapper{T}, FixValueFeedforward}} where T<:Component","page":"PowerSimulations","title":"PowerSimulations.add_feedforward_constraints!","text":"add_feedforward_constraints!(container::PowerSimulations.OptimizationContainer, _::DeviceModel, devices::InfrastructureSystems.FlattenIteratorWrapper{T<:Component}, ff::FixValueFeedforward)\n\n\n    add_feedforward_constraints(\n        container::OptimizationContainer,\n        ::DeviceModel,\n        devices::IS.FlattenIteratorWrapper{T},\n        ff::FixValueFeedforward,\n    ) where {T <: PSY.Component}\n\nConstructs a equality constraint to a fix a variable in one model using the variable value from other model results.\n\nvariable[var_name, t] == param[var_name, t]\n\nLaTeX\n\nx == param\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nmodel::DeviceModel : the device model\ndevices::IS.FlattenIteratorWrapper{T} : list of devices\nff::FixValueFeedforward : a instance of the FixValue Feedforward\n\nadd_feedforward_constraints!(container, _, devices, ff)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/feedforward/feedforward_constraints.jl:438.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_feedforward_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, DeviceModel, InfrastructureSystems.FlattenIteratorWrapper{T}, LowerBoundFeedforward}} where T<:Component","page":"PowerSimulations","title":"PowerSimulations.add_feedforward_constraints!","text":"add_feedforward_constraints!(container::PowerSimulations.OptimizationContainer, _::DeviceModel, devices::InfrastructureSystems.FlattenIteratorWrapper{T<:Component}, ff::LowerBoundFeedforward)\n\n\n    lb_ff(container::OptimizationContainer,\n          cons_name::Symbol,\n          constraint_infos,\n          param_reference,\n          var_key::VariableKey)\n\nConstructs a parameterized upper bound constraint to implement feedforward from other models. The Parameters are initialized using the uppper boundary values of the provided variables.\n\nvariable[var_name, t] <= param_reference[var_name]\n\nLaTeX\n\nx leq param^max\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\ncons_name::Symbol : name of the constraint\nparam_reference : Reference to the PJ.ParameterRef used to determine the upperbound\nvar_key::VariableKey : the name of the continuous variable\n\nadd_feedforward_constraints!(container, _, devices, ff)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/feedforward/feedforward_constraints.jl:272.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_feedforward_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, DeviceModel, InfrastructureSystems.FlattenIteratorWrapper{T}, UpperBoundFeedforward}} where T<:Component","page":"PowerSimulations","title":"PowerSimulations.add_feedforward_constraints!","text":"add_feedforward_constraints!(container::PowerSimulations.OptimizationContainer, _::DeviceModel, devices::InfrastructureSystems.FlattenIteratorWrapper{T<:Component}, ff::UpperBoundFeedforward)\n\n\n    ub_ff(container::OptimizationContainer,\n          cons_name::Symbol,\n          constraint_infos,\n          param_reference,\n          var_key::VariableKey)\n\nConstructs a parameterized upper bound constraint to implement feedforward from other models. The Parameters are initialized using the uppper boundary values of the provided variables.\n\nvariable[var_name, t] <= param_reference[var_name]\n\nLaTeX\n\nx leq param^max\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\ncons_name::Symbol : name of the constraint\nparam_reference : Reference to the PJ.ParameterRef used to determine the upperbound\nvar_key::VariableKey : the name of the continuous variable\n\nadd_feedforward_constraints!(container, _, devices, ff)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/feedforward/feedforward_constraints.jl:213.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_linear_ramp_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, Type{<:PowerSimulations.ConstraintType}, Type{S}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{<:PowerModels.AbstractPowerModel}}} where {S<:Union{ActivePowerVariable, PowerAboveMinimumVariable}, V<:Component, W<:PowerSimulations.AbstractDeviceFormulation}","page":"PowerSimulations","title":"PowerSimulations.add_linear_ramp_constraints!","text":"Constructs allowed rate-of-change constraints from variables, initial condtions, and rate data.\n\nIf t = 1:\n\nvariable[name, 1] - initial_conditions[ix].value <= rate_data[1][ix].up\n\ninitial_conditions[ix].value - variable[name, 1] <= rate_data[1][ix].down\n\nIf t > 1:\n\nvariable[name, t] - variable[name, t-1] <= rate_data[1][ix].up\n\nvariable[name, t-1] - variable[name, t] <= rate_data[1][ix].down\n\nLaTeX\n\nr^down leq x_1 - x_init leq r^up text for  t = 1\n\nr^down leq x_t - x_t-1 leq r^up forall t geq 2\n\nadd_linear_ramp_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/rateofchange_constraints.jl:59.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_range_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {T<:PowerSimulations.ConstraintType, U<:PowerSimulations.VariableType, V<:Component, W<:PowerSimulations.AbstractDeviceFormulation, X<:PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.add_range_constraints!","text":"Constructs min/max range constraint from device variable.\n\nIf min and max within an epsilon width:\n\nvariable[name, t] == limits.max\n\nOtherwise:\n\nlimits.min <= variable[name, t] <= limits.max\n\nwhere limits in constraint_infos.\n\nLaTeX\n\nx = limits^max text for  limits^max - limits^min  varepsilon\n\nlimits^min leq x leq limits^max text otherwise \n\nadd_range_constraints!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:40.\n\nadd_range_constraints!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:60.\n\nadd_range_constraints!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:79.\n\nadd_range_constraints!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:98.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_reserve_range_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {T<:InputActivePowerVariableLimitsConstraint, U<:PowerSimulations.VariableType, V<:Component, W<:PowerSimulations.AbstractDeviceFormulation, X<:PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.add_reserve_range_constraints!","text":"add_reserve_range_constraints!(container::PowerSimulations.OptimizationContainer, _::Type{T<:InputActivePowerVariableLimitsConstraint}, _::Type{U<:PowerSimulations.VariableType}, devices::InfrastructureSystems.FlattenIteratorWrapper{V<:Component}, model::DeviceModel{V<:Component, W<:PowerSimulations.AbstractDeviceFormulation}, _::Type{X<:PowerModels.AbstractPowerModel})\n\n\nConstructs min/max range constraint from device variable and reservation decision variable.\n\nvarcts[name, t] <= limits.max * (1 - varbin[name, t])\n\nvarcts[name, t] >= limits.min * (1 - varbin[name, t])\n\nwhere limits in constraint_infos.\n\nLaTeX\n\n0 leq x^cts leq limits^max (1 - x^bin) text for  limits^min = 0\n\nlimits^min (1 - x^bin) leq x^cts leq limits^max (1 - x^bin) text otherwise \n\nadd_reserve_range_constraints!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:347.\n\nadd_reserve_range_constraints!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:367.\n\nadd_reserve_range_constraints!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:470.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_reserve_range_constraints!-Union{Tuple{Y}, Tuple{X}, Tuple{W}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{W}, DeviceModel{W, X}, Type{Y}}} where {T<:Union{OutputActivePowerVariableLimitsConstraint, ReactivePowerVariableLimitsConstraint}, U<:PowerSimulations.ExpressionType, W<:Component, X<:PowerSimulations.AbstractDeviceFormulation, Y<:PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.add_reserve_range_constraints!","text":"add_reserve_range_constraints!(container::PowerSimulations.OptimizationContainer, _::Type{T<:Union{OutputActivePowerVariableLimitsConstraint, ReactivePowerVariableLimitsConstraint}}, _::Type{U<:PowerSimulations.ExpressionType}, devices::InfrastructureSystems.FlattenIteratorWrapper{W<:Component}, model::DeviceModel{W<:Component, X<:PowerSimulations.AbstractDeviceFormulation}, _::Type{Y<:PowerModels.AbstractPowerModel})\n\n\nConstructs min/max range constraint from device variable and reservation decision variable.\n\nvarcts[name, t] <= limits.max * varbin[name, t]\n\nvarcts[name, t] >= limits.min * varbin[name, t]\n\nwhere limits in constraint_infos.\n\nLaTeX\n\nlimits^min x^bin leq x^cts leq limits^max x^bin\n\nadd_reserve_range_constraints!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:367.\n\nadd_reserve_range_constraints!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:470.\n\nadd_reserve_range_constraints!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:506.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_reserve_range_constraints!-Union{Tuple{Y}, Tuple{X}, Tuple{W}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{W}, DeviceModel{W, X}, Type{Y}}} where {T<:Union{OutputActivePowerVariableLimitsConstraint, ReactivePowerVariableLimitsConstraint}, U<:PowerSimulations.VariableType, W<:Component, X<:PowerSimulations.AbstractDeviceFormulation, Y<:PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.add_reserve_range_constraints!","text":"add_reserve_range_constraints!(container::PowerSimulations.OptimizationContainer, _::Type{T<:Union{OutputActivePowerVariableLimitsConstraint, ReactivePowerVariableLimitsConstraint}}, _::Type{U<:PowerSimulations.VariableType}, devices::InfrastructureSystems.FlattenIteratorWrapper{W<:Component}, model::DeviceModel{W<:Component, X<:PowerSimulations.AbstractDeviceFormulation}, _::Type{Y<:PowerModels.AbstractPowerModel})\n\n\nConstructs min/max range constraint from device variable and reservation decision variable.\n\nvarcts[name, t] <= limits.max * varbin[name, t]\n\nvarcts[name, t] >= limits.min * varbin[name, t]\n\nwhere limits in constraint_infos.\n\nLaTeX\n\nlimits^min x^bin leq x^cts leq limits^max x^bin\n\nadd_reserve_range_constraints!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:347.\n\nadd_reserve_range_constraints!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:470.\n\nadd_reserve_range_constraints!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:506.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_result!-Tuple{PowerSimulations.OptimizationOutputCache, Any, Any, Any}","page":"PowerSimulations","title":"PowerSimulations.add_result!","text":"add_result!(cache::PowerSimulations.OptimizationOutputCache, timestamp, array, system_cache_is_full) -> Int64\n\n\nAdd result to the cache.\n\nadd_result!(cache, timestamp, array, system_cache_is_full)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/optimization_output_cache.jl:55.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_semicontinuous_ramp_constraints!-Union{Tuple{W}, Tuple{V}, Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, Type{<:PowerSimulations.ConstraintType}, Type{S}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{<:PowerModels.AbstractPowerModel}}} where {S<:Union{ActivePowerVariable, PowerAboveMinimumVariable}, V<:Component, W<:PowerSimulations.AbstractDeviceFormulation}","page":"PowerSimulations","title":"PowerSimulations.add_semicontinuous_ramp_constraints!","text":"add_semicontinuous_ramp_constraints!(container::PowerSimulations.OptimizationContainer, T::Type{<:PowerSimulations.ConstraintType}, U::Type{S<:Union{ActivePowerVariable, PowerAboveMinimumVariable}}, devices::InfrastructureSystems.FlattenIteratorWrapper{V<:Component}, model::DeviceModel{V<:Component, W<:PowerSimulations.AbstractDeviceFormulation}, X::Type{<:PowerModels.AbstractPowerModel})\n\n\nConstructs allowed rate-of-change constraints from variables, initial condtions, start/stop status, and rate data\n\nEquations\n\nIf t = 1:\n\nvariable[name, 1] - initial_conditions[ix].value <= rate_data[1][ix].up + rate_data[2][ix].max*varstart[name, 1]\n\ninitial_conditions[ix].value - variable[name, 1] <= rate_data[1][ix].down + rate_data[2][ix].min*varstop[name, 1]\n\nIf t > 1:\n\nvariable[name, t] - variable[name, t-1] <= rate_data[1][ix].up + rate_data[2][ix].max*varstart[name, t]\n\nvariable[name, t-1] - variable[name, t] <= rate_data[1][ix].down + rate_data[2][ix].min*varstop[name, t]\n\nLaTeX\n\nr^down + r^min x^stop_1 leq x_1 - x_init leq r^up + r^max x^start_1 text for  t = 1\n\nr^down + r^min x^stop_t leq x_t - x_t-1 leq r^up + r^max x^start_t forall t geq 2\n\nadd_semicontinuous_ramp_constraints!(container, T, U, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/rateofchange_constraints.jl:193.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_semicontinuous_range_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {T<:PowerSimulations.ConstraintType, U<:PowerSimulations.VariableType, V<:Component, W<:PowerSimulations.AbstractDeviceFormulation, X<:PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.add_semicontinuous_range_constraints!","text":"add_semicontinuous_range_constraints!(container::PowerSimulations.OptimizationContainer, _::Type{T<:PowerSimulations.ConstraintType}, _::Type{U<:PowerSimulations.VariableType}, devices::InfrastructureSystems.FlattenIteratorWrapper{V<:Component}, model::DeviceModel{V<:Component, W<:PowerSimulations.AbstractDeviceFormulation}, _::Type{X<:PowerModels.AbstractPowerModel})\n\n\nConstructs min/max range constraint from device variable and on/off decision variable.\n\nIf device min = 0:\n\nvarcts[name, t] <= limits.max*varbin[name, t])\n\nvarcts[name, t] >= 0.0\n\nOtherwise:\n\nvarcts[name, t] <= limits.max*varbin[name, t]\n\nvarcts[name, t] >= limits.min*varbin[name, t]\n\nwhere limits in constraint_infos.\n\nLaTeX\n\n0 leq x^cts leq limits^max x^bin text for  limits^min = 0\n\nlimits^min x^bin leq x^cts leq limits^max x^bin text otherwise \n\nadd_semicontinuous_range_constraints!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:194.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {T<:ActivePowerBalance, U<:FlowActivePowerVariable, V<:Branch, W<:PowerSimulations.AbstractBranchFormulation, X<:PowerModels.AbstractActivePowerModel}","page":"PowerSimulations","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(container::PowerSimulations.OptimizationContainer, _::Type{T<:ActivePowerBalance}, _::Type{U<:FlowActivePowerVariable}, devices::InfrastructureSystems.FlattenIteratorWrapper{V<:Branch}, _::DeviceModel{V<:Branch, W<:PowerSimulations.AbstractBranchFormulation}, _::Type{X<:PowerModels.AbstractActivePowerModel})\n\n\nImplementation of addtoexpression! for lossless branch/network models\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:111.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:139.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:199.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:230.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:257.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:287.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:314.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:344.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:375.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:405.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:439.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:476.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:509.\n\nadd_to_expression!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:537.\n\nadd_to_expression!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:563.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {T<:ActivePowerBalance, U<:PowerSimulations.VariableType, V<:StaticInjection, W<:PowerSimulations.AbstractDeviceFormulation, X<:CopperPlatePowerModel}","page":"PowerSimulations","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(container::PowerSimulations.OptimizationContainer, _::Type{T<:ActivePowerBalance}, _::Type{U<:PowerSimulations.VariableType}, devices::InfrastructureSystems.FlattenIteratorWrapper{V<:StaticInjection}, _::DeviceModel{V<:StaticInjection, W<:PowerSimulations.AbstractDeviceFormulation}, _::Type{X<:CopperPlatePowerModel})\n\n\nDefault implementation to add variables to SystemBalanceExpressions\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:111.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:139.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:199.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:230.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:257.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:287.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:314.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:344.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:375.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:405.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:439.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:476.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:509.\n\nadd_to_expression!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:537.\n\nadd_to_expression!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:563.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {T<:ActivePowerBalance, U<:PowerSimulations.VariableType, V<:StaticInjection, W<:PowerSimulations.AbstractDeviceFormulation, X<:Union{PTDFPowerModel, StandardPTDFModel}}","page":"PowerSimulations","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(container::PowerSimulations.OptimizationContainer, _::Type{T<:ActivePowerBalance}, _::Type{U<:PowerSimulations.VariableType}, devices::InfrastructureSystems.FlattenIteratorWrapper{V<:StaticInjection}, _::DeviceModel{V<:StaticInjection, W<:PowerSimulations.AbstractDeviceFormulation}, _::Type{X<:Union{PTDFPowerModel, StandardPTDFModel}})\n\n\nDefault implementation to add variables to SystemBalanceExpressions\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:111.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:139.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:199.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:230.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:257.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:287.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:314.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:344.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:375.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:405.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:439.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:476.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:509.\n\nadd_to_expression!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:537.\n\nadd_to_expression!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:563.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {T<:SystemBalanceExpressions, U<:PowerSimulations.TimeSeriesParameter, V<:Device, W<:PowerSimulations.AbstractDeviceFormulation, X<:PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(container::PowerSimulations.OptimizationContainer, _::Type{T<:SystemBalanceExpressions}, _::Type{U<:PowerSimulations.TimeSeriesParameter}, devices::InfrastructureSystems.FlattenIteratorWrapper{V<:Device}, _::DeviceModel{V<:Device, W<:PowerSimulations.AbstractDeviceFormulation}, _::Type{X<:PowerModels.AbstractPowerModel})\n\n\nDefault implementation to add parameters to SystemBalanceExpressions\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:111.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:139.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:171.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:199.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:230.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:257.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:287.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:314.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:344.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:375.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:405.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:439.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:476.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:509.\n\nadd_to_expression!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:537.\n\nadd_to_expression!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:563.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {T<:SystemBalanceExpressions, U<:PowerSimulations.TimeSeriesParameter, V<:StaticInjection, W<:PowerSimulations.AbstractDeviceFormulation, X<:CopperPlatePowerModel}","page":"PowerSimulations","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(container::PowerSimulations.OptimizationContainer, _::Type{T<:SystemBalanceExpressions}, _::Type{U<:PowerSimulations.TimeSeriesParameter}, devices::InfrastructureSystems.FlattenIteratorWrapper{V<:StaticInjection}, _::DeviceModel{V<:StaticInjection, W<:PowerSimulations.AbstractDeviceFormulation}, _::Type{X<:CopperPlatePowerModel})\n\n\nDefault implementation to add parameters to SystemBalanceExpressions\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:139.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:171.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:199.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:230.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:257.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:287.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:314.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:344.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:375.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:405.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:439.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:476.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:509.\n\nadd_to_expression!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:537.\n\nadd_to_expression!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:563.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {T<:SystemBalanceExpressions, U<:PowerSimulations.TimeSeriesParameter, V<:StaticInjection, W<:PowerSimulations.AbstractDeviceFormulation, X<:Union{PTDFPowerModel, StandardPTDFModel}}","page":"PowerSimulations","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(container::PowerSimulations.OptimizationContainer, _::Type{T<:SystemBalanceExpressions}, _::Type{U<:PowerSimulations.TimeSeriesParameter}, devices::InfrastructureSystems.FlattenIteratorWrapper{V<:StaticInjection}, _::DeviceModel{V<:StaticInjection, W<:PowerSimulations.AbstractDeviceFormulation}, _::Type{X<:Union{PTDFPowerModel, StandardPTDFModel}})\n\n\nDefault implementation to add parameters to SystemBalanceExpressions\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:139.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:171.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:199.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:230.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:257.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:287.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:314.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:344.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:375.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:405.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:439.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:476.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:509.\n\nadd_to_expression!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:537.\n\nadd_to_expression!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:563.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_to_expression!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}}} where {T<:SystemBalanceExpressions, U<:PowerSimulations.VariableType, V<:Device, W<:PowerSimulations.AbstractDeviceFormulation, X<:PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.add_to_expression!","text":"add_to_expression!(container::PowerSimulations.OptimizationContainer, _::Type{T<:SystemBalanceExpressions}, _::Type{U<:PowerSimulations.VariableType}, devices::InfrastructureSystems.FlattenIteratorWrapper{V<:Device}, _::DeviceModel{V<:Device, W<:PowerSimulations.AbstractDeviceFormulation}, _::Type{X<:PowerModels.AbstractPowerModel})\n\n\nDefault implementation to add variables to SystemBalanceExpressions\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:111.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:139.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:171.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:199.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:230.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:257.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:287.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:314.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:344.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:375.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:405.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:439.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:476.\n\nadd_to_expression!(container, _, _, devices, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:509.\n\nadd_to_expression!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:537.\n\nadd_to_expression!(container, _, _, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_to_expression.jl:563.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_variable!-Union{Tuple{U}, Tuple{D}, Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AuxVariableType, U, Any}} where {D<:Component, U<:Union{InfrastructureSystems.FlattenIteratorWrapper{D}, Vector{D}}}","page":"PowerSimulations","title":"PowerSimulations.add_variable!","text":"add_variable!(container::PowerSimulations.OptimizationContainer, var_type::PowerSimulations.AuxVariableType, devices::Union{Array{D<:Component, 1}, InfrastructureSystems.FlattenIteratorWrapper{D<:Component}}, formulation)\n\n\nDefault implementation of adding auxiliary variable to the model.\n\nadd_variable!(container, var_type, devices, formulation)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_auxiliary_variable.jl:17.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_variable!-Union{Tuple{U}, Tuple{T}, Tuple{D}, Tuple{PowerSimulations.OptimizationContainer, T, U, Any}} where {D<:Component, T<:PowerSimulations.VariableType, U<:Union{InfrastructureSystems.FlattenIteratorWrapper{D}, Vector{D}}}","page":"PowerSimulations","title":"PowerSimulations.add_variable!","text":"add_variable!(container::PowerSimulations.OptimizationContainer, variable_type::PowerSimulations.VariableType, devices::Union{Array{D<:Component, 1}, InfrastructureSystems.FlattenIteratorWrapper{D<:Component}}, formulation)\n\n\nAdds a variable to the optimization model and to the affine expressions contained in the optimization_container model according to the specified sign. Based on the inputs, the variable can be specified as binary.\n\nBounds\n\nlb_value_function <= varstart[name, t] <= ub_value_function\n\nIf binary = true:\n\nvarstart[name, t] in {0,1}\n\nLaTeX\n\nlb ge x^device_t le ub forall t\n\nx^device_t in 01 forall t iff textbinary = true\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\ndevices : Vector or Iterator with the devices\nvar_key::VariableKey : Base Name for the variable\nbinary::Bool : Select if the variable is binary\nexpressionname::Symbol : Expressionname name stored in container.expressions to add the variable\nsign::Float64 : sign of the addition of the variable to the expression_name. Default Value is 1.0\n\nAccepted Keyword Arguments\n\nubvalue : Provides the function over device to obtain the value for a upperbound\nlbvalue : Provides the function over device to obtain the value for a lowerbound. If the variable is meant to be positive define lb = x -> 0.0\ninitial_value : Provides the function over device to obtain the warm start value\n\nadd_variable!(container, variable_type, devices, formulation)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_variable.jl:83.\n\nadd_variable!(container, variable_type, devices, formulation)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_variable.jl:173.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_variables!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}}} where T<:SteadyStateFrequencyDeviation","page":"PowerSimulations","title":"PowerSimulations.add_variables!","text":"add_variables!(container::PowerSimulations.OptimizationContainer, _::Type{T<:SteadyStateFrequencyDeviation})\n\n\nSteady State deviation of the frequency\n\nadd_variables!(container, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/services_models/agc.jl:51.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_variables!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Union{InfrastructureSystems.FlattenIteratorWrapper{U}, Vector{U}}, PowerSimulations.AbstractDeviceFormulation}} where {T<:PowerSimulations.SubComponentVariableType, U<:Component}","page":"PowerSimulations","title":"PowerSimulations.add_variables!","text":"add_variables!(container::PowerSimulations.OptimizationContainer, _::Type{T<:PowerSimulations.SubComponentVariableType}, devices::Union{Array{U<:Component, 1}, InfrastructureSystems.FlattenIteratorWrapper{U<:Component}}, formulation::PowerSimulations.AbstractDeviceFormulation)\n\n\nAdd variables to the OptimizationContainer for a Sub-Component of a hybrid systems.\n\nadd_variables!(container, _, devices, formulation)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_auxiliary_variable.jl:4.\n\nadd_variables!(container, _, devices, formulation)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_variable.jl:31.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_variables!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Union{InfrastructureSystems.FlattenIteratorWrapper{U}, Vector{U}}, Union{PowerSimulations.AbstractDeviceFormulation, PowerSimulations.AbstractServiceFormulation}}} where {T<:PowerSimulations.AuxVariableType, U<:Component}","page":"PowerSimulations","title":"PowerSimulations.add_variables!","text":"add_variables!(container::PowerSimulations.OptimizationContainer, _::Type{T<:PowerSimulations.AuxVariableType}, devices::Union{Array{U<:Component, 1}, InfrastructureSystems.FlattenIteratorWrapper{U<:Component}}, formulation::Union{PowerSimulations.AbstractDeviceFormulation, PowerSimulations.AbstractServiceFormulation})\n\n\nAdd variables to the OptimizationContainer for any component.\n\nadd_variables!(container, _, devices, formulation)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_auxiliary_variable.jl:4.\n\nadd_variables!(container, _, devices, formulation)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_variable.jl:4.\n\nadd_variables!(container, _, devices, formulation)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_variable.jl:31.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_variables!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Union{InfrastructureSystems.FlattenIteratorWrapper{U}, Vector{U}}, Union{PowerSimulations.AbstractDeviceFormulation, PowerSimulations.AbstractServiceFormulation}}} where {T<:PowerSimulations.VariableType, U<:Component}","page":"PowerSimulations","title":"PowerSimulations.add_variables!","text":"add_variables!(container::PowerSimulations.OptimizationContainer, _::Type{T<:PowerSimulations.VariableType}, devices::Union{Array{U<:Component, 1}, InfrastructureSystems.FlattenIteratorWrapper{U<:Component}}, formulation::Union{PowerSimulations.AbstractDeviceFormulation, PowerSimulations.AbstractServiceFormulation})\n\n\nAdd variables to the OptimizationContainer for any component.\n\nadd_variables!(container, _, devices, formulation)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_auxiliary_variable.jl:4.\n\nadd_variables!(container, _, devices, formulation)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_variable.jl:4.\n\nadd_variables!(container, _, devices, formulation)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_variable.jl:31.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_variables!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, U, Union{InfrastructureSystems.FlattenIteratorWrapper{V}, Vector{V}}, PowerSimulations.AbstractReservesFormulation}} where {T<:PowerSimulations.VariableType, U<:AbstractReserve, V<:Component}","page":"PowerSimulations","title":"PowerSimulations.add_variables!","text":"add_variables!(container::PowerSimulations.OptimizationContainer, _::Type{T<:PowerSimulations.VariableType}, service::AbstractReserve, contributing_devices::Union{Array{V<:Component, 1}, InfrastructureSystems.FlattenIteratorWrapper{V<:Component}}, formulation::PowerSimulations.AbstractReservesFormulation)\n\n\nAdd variables to the OptimizationContainer for a service.\n\nadd_variables!(container, _, service, contributing_devices, formulation)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/add_variable.jl:17.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.axis_array_to_dataframe-Tuple{Union{JuMP.Containers.DenseAxisArray, JuMP.Containers.SparseAxisArray}, PowerSimulations.OptimizationContainerKey}","page":"PowerSimulations","title":"PowerSimulations.axis_array_to_dataframe","text":"axis_array_to_dataframe(array::Union{JuMP.Containers.DenseAxisArray, JuMP.Containers.SparseAxisArray}, key::PowerSimulations.OptimizationContainerKey) -> Any\n\n\nCreates a DataFrame from a JuMP DenseAxisArray or SparseAxisArray.\n\nArguments\n\narray: JuMP DenseAxisArray or SparseAxisArray to convert\nkey::OptimizationContainerKey:\n\naxis_array_to_dataframe(array, key)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/dataframes_utils.jl:10.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.branch_flow_constraints!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, U}, Type{<:PowerModels.AbstractDCPModel}}} where {T<:MonitoredLine, U<:PowerSimulations.AbstractBranchFormulation}","page":"PowerSimulations","title":"PowerSimulations.branch_flow_constraints!","text":"branch_flow_constraints!(container::PowerSimulations.OptimizationContainer, devices::InfrastructureSystems.FlattenIteratorWrapper{T<:MonitoredLine}, model::DeviceModel{T<:MonitoredLine, U<:PowerSimulations.AbstractBranchFormulation}, X::Type{<:PowerModels.AbstractDCPModel})\n\n\nAdd branch flow constraints for monitored lines with DC Power Model\n\nbranch_flow_constraints!(container, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:259.\n\nbranch_flow_constraints!(container, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:279.\n\nbranch_flow_constraints!(container, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:357.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.branch_flow_constraints!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, U}, Type{<:PowerModels.AbstractDCPModel}}} where {T<:MonitoredLine, U<:StaticBranchUnbounded}","page":"PowerSimulations","title":"PowerSimulations.branch_flow_constraints!","text":"branch_flow_constraints!(container::PowerSimulations.OptimizationContainer, devices::InfrastructureSystems.FlattenIteratorWrapper{T<:MonitoredLine}, model::DeviceModel{T<:MonitoredLine, U<:StaticBranchUnbounded}, _::Type{<:PowerModels.AbstractDCPModel})\n\n\nDon't add branch flow constraints for monitored lines if formulation is StaticBranchUnbounded\n\nbranch_flow_constraints!(container, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:279.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.branch_flow_constraints!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, U}, Type{<:PowerModels.AbstractPowerModel}}} where {T<:MonitoredLine, U<:PowerSimulations.AbstractBranchFormulation}","page":"PowerSimulations","title":"PowerSimulations.branch_flow_constraints!","text":"branch_flow_constraints!(container::PowerSimulations.OptimizationContainer, devices::InfrastructureSystems.FlattenIteratorWrapper{T<:MonitoredLine}, model::DeviceModel{T<:MonitoredLine, U<:PowerSimulations.AbstractBranchFormulation}, _::Type{<:PowerModels.AbstractPowerModel})\n\n\nAdd branch flow constraints for monitored lines\n\nbranch_flow_constraints!(container, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:259.\n\nbranch_flow_constraints!(container, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:279.\n\nbranch_flow_constraints!(container, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:329.\n\nbranch_flow_constraints!(container, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:357.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.branch_flow_constraints!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, U}, Type{<:PowerModels.AbstractPowerModel}}} where {T<:MonitoredLine, U<:StaticBranchUnbounded}","page":"PowerSimulations","title":"PowerSimulations.branch_flow_constraints!","text":"branch_flow_constraints!(container::PowerSimulations.OptimizationContainer, devices::InfrastructureSystems.FlattenIteratorWrapper{T<:MonitoredLine}, model::DeviceModel{T<:MonitoredLine, U<:StaticBranchUnbounded}, _::Type{<:PowerModels.AbstractPowerModel})\n\n\nDon't add branch flow constraints for monitored lines if formulation is StaticBranchUnbounded\n\nbranch_flow_constraints!(container, devices, model, X)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:259.\n\nbranch_flow_constraints!(container, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:279.\n\nbranch_flow_constraints!(container, devices, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:357.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.build_model!-Tuple{DecisionModel}","page":"PowerSimulations","title":"PowerSimulations.build_model!","text":"build_model!(model::DecisionModel)\n\n\nDefault implementation of build method for Operational Problems for models conforming with DecisionProblem specification. Overload this function to implement a custom build method\n\nbuild_model!(model)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/decision_model.jl:326.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.build_model!-Tuple{EmulationModel}","page":"PowerSimulations","title":"PowerSimulations.build_model!","text":"build_model!(model::EmulationModel)\n\n\nDefault implementation of build method for Emulation Problems for models conforming with  DecisionProblem specification. Overload this function to implement a custom build method\n\nbuild_model!(model)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/operation/emulation_model.jl:312.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.check_activeservice_variables-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Vector{T}}} where T<:Service","page":"PowerSimulations","title":"PowerSimulations.check_activeservice_variables","text":"check_activeservice_variables(container::PowerSimulations.OptimizationContainer, contributing_services::Array{T<:Service, 1})\n\n\nThis function checks if the variables for reserves were created\n\ncheck_activeservice_variables(container, contributing_services)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/services_models/group_reserve.jl:6.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.check_file_integrity-Tuple{String}","page":"PowerSimulations","title":"PowerSimulations.check_file_integrity","text":"check_file_integrity(path::String)\n\n\ncheck_file_integrity(path::String)\n\nChecks the hash value for each file made with the file is written with the new hash_value to verify the file hasn't been tampered with since written\n\nArguments\n\npath::String: this is the folder path that contains the results and the check.sha256 file\n\ncheck_file_integrity(path)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/file_utils.jl:78.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.compute_sha256-Tuple{AbstractString}","page":"PowerSimulations","title":"PowerSimulations.compute_sha256","text":"compute_sha256(filename::AbstractString) -> String\n\n\nReturn the SHA 256 hash of a file.\n\ncompute_sha256(filename)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/file_utils.jl:22.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{H, D}, Type{S}}} where {H<:HydroGen, D<:HydroCommitmentReservoirBudget, S<:PowerModels.AbstractActivePowerModel}","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"construct_device!(container::PowerSimulations.OptimizationContainer, sys::System, _::PowerSimulations.ArgumentConstructStage, model::DeviceModel{H<:HydroGen, D<:HydroCommitmentReservoirBudget}, _::Type{S<:PowerModels.AbstractActivePowerModel})\n\n\nConstruct model for HydroGen with ReservoirBudget Commitment Formulation with only Active Power.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:74.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:182.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:707.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:809.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:1002.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{H, D}, Type{S}}} where {H<:HydroGen, D<:HydroCommitmentReservoirBudget, S<:PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"construct_device!(container::PowerSimulations.OptimizationContainer, sys::System, _::PowerSimulations.ArgumentConstructStage, model::DeviceModel{H<:HydroGen, D<:HydroCommitmentReservoirBudget}, _::Type{S<:PowerModels.AbstractPowerModel})\n\n\nConstruct model for HydroGen with ReservoirBudget Commitment Formulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hybridgeneration_constructor.jl:156.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hybridgeneration_constructor.jl:485.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:74.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:182.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:707.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:809.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:899.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:1002.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/load_constructor.jl:1.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/load_constructor.jl:328.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/renewablegeneration_constructor.jl:1.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/storage_constructor.jl:1.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:36.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:636.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{H, D}, Type{S}}} where {H<:HydroGen, D<:HydroCommitmentRunOfRiver, S<:PowerModels.AbstractActivePowerModel}","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"construct_device!(container::PowerSimulations.OptimizationContainer, sys::System, _::PowerSimulations.ArgumentConstructStage, model::DeviceModel{H<:HydroGen, D<:HydroCommitmentRunOfRiver}, _::Type{S<:PowerModels.AbstractActivePowerModel})\n\n\nConstruct model for HydroGen with RunOfRiver Commitment Formulation with only Active Power.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:74.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:182.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:809.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:899.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:1002.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{H, D}, Type{S}}} where {H<:HydroGen, D<:HydroCommitmentRunOfRiver, S<:PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"construct_device!(container::PowerSimulations.OptimizationContainer, sys::System, _::PowerSimulations.ArgumentConstructStage, model::DeviceModel{H<:HydroGen, D<:HydroCommitmentRunOfRiver}, _::Type{S<:PowerModels.AbstractPowerModel})\n\n\nConstruct model for HydroGen with RunOfRiver Commitment Formulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hybridgeneration_constructor.jl:156.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hybridgeneration_constructor.jl:485.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:74.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:182.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:707.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:809.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:899.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:1002.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/load_constructor.jl:1.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/load_constructor.jl:328.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/renewablegeneration_constructor.jl:1.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/storage_constructor.jl:1.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:36.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:636.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{H, D}, Type{S}}} where {H<:HydroGen, D<:PowerSimulations.AbstractHydroDispatchFormulation, S<:PowerModels.AbstractActivePowerModel}","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"construct_device!(container::PowerSimulations.OptimizationContainer, sys::System, _::PowerSimulations.ArgumentConstructStage, model::DeviceModel{H<:HydroGen, D<:PowerSimulations.AbstractHydroDispatchFormulation}, _::Type{S<:PowerModels.AbstractActivePowerModel})\n\n\nConstruct model for HydroGen with RunOfRiver Dispatch Formulation with only Active Power.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:182.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:271.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:378.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:462.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:595.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:707.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:809.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:899.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:1002.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:1353.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{H, D}, Type{S}}} where {H<:HydroGen, D<:PowerSimulations.AbstractHydroDispatchFormulation, S<:PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"construct_device!(container::PowerSimulations.OptimizationContainer, sys::System, _::PowerSimulations.ArgumentConstructStage, model::DeviceModel{H<:HydroGen, D<:PowerSimulations.AbstractHydroDispatchFormulation}, _::Type{S<:PowerModels.AbstractPowerModel})\n\n\nConstruct model for HydroGen with RunOfRiver Dispatch Formulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hybridgeneration_constructor.jl:156.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hybridgeneration_constructor.jl:485.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:74.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:182.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:271.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:378.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:462.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:595.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:707.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:809.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:899.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:1002.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:1353.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/load_constructor.jl:1.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/load_constructor.jl:328.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/renewablegeneration_constructor.jl:1.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/storage_constructor.jl:1.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:36.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:636.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{T, D}, Type{S}}} where {T<:ThermalGen, D<:PowerSimulations.AbstractStandardUnitCommitment, S<:PowerModels.AbstractActivePowerModel}","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"construct_device!(container::PowerSimulations.OptimizationContainer, sys::System, _::PowerSimulations.ArgumentConstructStage, model::DeviceModel{T<:ThermalGen, D<:PowerSimulations.AbstractStandardUnitCommitment}, _::Type{S<:PowerModels.AbstractActivePowerModel})\n\n\nThis function creates the arguments model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:153.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:361.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:636.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:738.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{T, D}, Type{S}}} where {T<:ThermalGen, D<:PowerSimulations.AbstractStandardUnitCommitment, S<:PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"construct_device!(container::PowerSimulations.OptimizationContainer, sys::System, _::PowerSimulations.ArgumentConstructStage, model::DeviceModel{T<:ThermalGen, D<:PowerSimulations.AbstractStandardUnitCommitment}, _::Type{S<:PowerModels.AbstractPowerModel})\n\n\nThis function creates the arguments for the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hybridgeneration_constructor.jl:156.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hybridgeneration_constructor.jl:485.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:74.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:707.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:899.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/load_constructor.jl:1.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/load_constructor.jl:328.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/renewablegeneration_constructor.jl:1.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/storage_constructor.jl:1.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:36.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:153.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:255.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:361.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:636.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:738.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ModelConstructStage, DeviceModel{T, D}, Type{S}}} where {T<:ThermalGen, D<:PowerSimulations.AbstractStandardUnitCommitment, S<:PowerModels.AbstractActivePowerModel}","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"construct_device!(container::PowerSimulations.OptimizationContainer, sys::System, _::PowerSimulations.ModelConstructStage, model::DeviceModel{T<:ThermalGen, D<:PowerSimulations.AbstractStandardUnitCommitment}, _::Type{S<:PowerModels.AbstractActivePowerModel})\n\n\nThis function creates the constraints for the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:211.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:412.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:692.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:785.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ModelConstructStage, DeviceModel{T, D}, Type{S}}} where {T<:ThermalGen, D<:PowerSimulations.AbstractStandardUnitCommitment, S<:PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"construct_device!(container::PowerSimulations.OptimizationContainer, sys::System, _::PowerSimulations.ModelConstructStage, model::DeviceModel{T<:ThermalGen, D<:PowerSimulations.AbstractStandardUnitCommitment}, _::Type{S<:PowerModels.AbstractPowerModel})\n\n\nThis function creates the constraints for the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hybridgeneration_constructor.jl:243.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hybridgeneration_constructor.jl:572.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:132.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:762.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:953.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/load_constructor.jl:42.\n\nconstruct_device!(container, sys, ccs, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/load_constructor.jl:388.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/renewablegeneration_constructor.jl:58.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/storage_constructor.jl:48.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:102.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:211.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:315.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:412.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:692.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:785.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{H, FixedOutput}, Type{S}}} where {H<:HydroGen, S<:PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"construct_device!(container::PowerSimulations.OptimizationContainer, sys::System, _::PowerSimulations.ArgumentConstructStage, model::DeviceModel{H<:HydroGen, FixedOutput}, _::Type{S<:PowerModels.AbstractPowerModel})\n\n\nConstruct model for HydroGen with FixedOutput Formulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:4.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:48.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/renewablegeneration_constructor.jl:196.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{H, HydroCommitmentReservoirStorage}, Type{S}}} where {H<:HydroEnergyReservoir, S<:PowerModels.AbstractActivePowerModel}","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"construct_device!(container::PowerSimulations.OptimizationContainer, sys::System, _::PowerSimulations.ArgumentConstructStage, model::DeviceModel{H<:HydroEnergyReservoir, HydroCommitmentReservoirStorage}, _::Type{S<:PowerModels.AbstractActivePowerModel})\n\n\nConstruct model for HydroGen with ReservoirStorage Dispatch Formulation with only Active Power\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:1235.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{H, HydroCommitmentReservoirStorage}, Type{S}}} where {H<:HydroEnergyReservoir, S<:PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"construct_device!(container::PowerSimulations.OptimizationContainer, sys::System, _::PowerSimulations.ArgumentConstructStage, model::DeviceModel{H<:HydroEnergyReservoir, HydroCommitmentReservoirStorage}, _::Type{S<:PowerModels.AbstractPowerModel})\n\n\nConstruct model for HydroGen with ReservoirStorage Commitment Formulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:1095.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:1235.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{H, HydroDispatchPumpedStorage}, Type{S}}} where {H<:HydroPumpedStorage, S<:PowerModels.AbstractActivePowerModel}","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"construct_device!(container::PowerSimulations.OptimizationContainer, sys::System, _::PowerSimulations.ArgumentConstructStage, model::DeviceModel{H<:HydroPumpedStorage, HydroDispatchPumpedStorage}, _::Type{S<:PowerModels.AbstractActivePowerModel})\n\n\nConstruct model for HydroPumpedStorage with PumpedStorage Dispatch Formulation with only Active Power\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:1353.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{H, HydroDispatchReservoirBudget}, Type{S}}} where {H<:HydroEnergyReservoir, S<:PowerModels.AbstractActivePowerModel}","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"construct_device!(container::PowerSimulations.OptimizationContainer, sys::System, _::PowerSimulations.ArgumentConstructStage, model::DeviceModel{H<:HydroEnergyReservoir, HydroDispatchReservoirBudget}, _::Type{S<:PowerModels.AbstractActivePowerModel})\n\n\nConstruct model for HydroGen with ReservoirBudget Dispatch Formulation with only Active Power.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:378.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{H, HydroDispatchReservoirBudget}, Type{S}}} where {H<:HydroEnergyReservoir, S<:PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"construct_device!(container::PowerSimulations.OptimizationContainer, sys::System, _::PowerSimulations.ArgumentConstructStage, model::DeviceModel{H<:HydroEnergyReservoir, HydroDispatchReservoirBudget}, _::Type{S<:PowerModels.AbstractPowerModel})\n\n\nConstruct model for HydroGen with ReservoirBudget Dispatch Formulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:182.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:271.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:378.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{H, HydroDispatchReservoirStorage}, Type{S}}} where {H<:HydroEnergyReservoir, S<:PowerModels.AbstractActivePowerModel}","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"construct_device!(container::PowerSimulations.OptimizationContainer, sys::System, _::PowerSimulations.ArgumentConstructStage, model::DeviceModel{H<:HydroEnergyReservoir, HydroDispatchReservoirStorage}, _::Type{S<:PowerModels.AbstractActivePowerModel})\n\n\nConstruct model for HydroGen with ReservoirStorage Dispatch Formulation with only Active Power\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:595.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{H, HydroDispatchReservoirStorage}, Type{S}}} where {H<:HydroEnergyReservoir, S<:PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"construct_device!(container::PowerSimulations.OptimizationContainer, sys::System, _::PowerSimulations.ArgumentConstructStage, model::DeviceModel{H<:HydroEnergyReservoir, HydroDispatchReservoirStorage}, _::Type{S<:PowerModels.AbstractPowerModel})\n\n\nConstruct model for HydroGen with ReservoirStorage Dispatch Formulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:182.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:462.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/hydrogeneration_constructor.jl:595.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{T, ThermalBasicUnitCommitment}, Type{S}}} where {T<:ThermalGen, S<:PowerModels.AbstractActivePowerModel}","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"construct_device!(container::PowerSimulations.OptimizationContainer, sys::System, _::PowerSimulations.ArgumentConstructStage, model::DeviceModel{T<:ThermalGen, ThermalBasicUnitCommitment}, _::Type{S<:PowerModels.AbstractActivePowerModel})\n\n\nThis function creates the arguments for the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:361.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{T, ThermalBasicUnitCommitment}, Type{S}}} where {T<:ThermalGen, S<:PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"construct_device!(container::PowerSimulations.OptimizationContainer, sys::System, _::PowerSimulations.ArgumentConstructStage, model::DeviceModel{T<:ThermalGen, ThermalBasicUnitCommitment}, _::Type{S<:PowerModels.AbstractPowerModel})\n\n\nThis function creates the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:153.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:255.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:361.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{T, ThermalStandardDispatch}, Type{S}}} where {T<:ThermalGen, S<:PowerModels.AbstractActivePowerModel}","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"construct_device!(container::PowerSimulations.OptimizationContainer, sys::System, _::PowerSimulations.ArgumentConstructStage, model::DeviceModel{T<:ThermalGen, ThermalStandardDispatch}, _::Type{S<:PowerModels.AbstractActivePowerModel})\n\n\nThis function creates the arguments for the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:553.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, DeviceModel{T, ThermalStandardDispatch}, Type{S}}} where {T<:ThermalGen, S<:PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"construct_device!(container::PowerSimulations.OptimizationContainer, sys::System, _::PowerSimulations.ArgumentConstructStage, model::DeviceModel{T<:ThermalGen, ThermalStandardDispatch}, _::Type{S<:PowerModels.AbstractPowerModel})\n\n\nThis function creates the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:450.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:553.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:738.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ModelConstructStage, DeviceModel{T, ThermalBasicUnitCommitment}, Type{S}}} where {T<:ThermalGen, S<:PowerModels.AbstractActivePowerModel}","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"construct_device!(container::PowerSimulations.OptimizationContainer, sys::System, _::PowerSimulations.ModelConstructStage, model::DeviceModel{T<:ThermalGen, ThermalBasicUnitCommitment}, _::Type{S<:PowerModels.AbstractActivePowerModel})\n\n\nThis function creates the constraints for the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:412.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ModelConstructStage, DeviceModel{T, ThermalBasicUnitCommitment}, Type{S}}} where {T<:ThermalGen, S<:PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"construct_device!(container::PowerSimulations.OptimizationContainer, sys::System, _::PowerSimulations.ModelConstructStage, model::DeviceModel{T<:ThermalGen, ThermalBasicUnitCommitment}, _::Type{S<:PowerModels.AbstractPowerModel})\n\n\nThis function creates the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:211.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:315.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:412.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ModelConstructStage, DeviceModel{T, ThermalStandardDispatch}, Type{S}}} where {T<:ThermalGen, S<:PowerModels.AbstractActivePowerModel}","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"construct_device!(container::PowerSimulations.OptimizationContainer, sys::System, _::PowerSimulations.ModelConstructStage, model::DeviceModel{T<:ThermalGen, ThermalStandardDispatch}, _::Type{S<:PowerModels.AbstractActivePowerModel})\n\n\nThis function creates the constraints for the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:601.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ModelConstructStage, DeviceModel{T, ThermalStandardDispatch}, Type{S}}} where {T<:ThermalGen, S<:PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"construct_device!(container::PowerSimulations.OptimizationContainer, sys::System, _::PowerSimulations.ModelConstructStage, model::DeviceModel{T<:ThermalGen, ThermalStandardDispatch}, _::Type{S<:PowerModels.AbstractPowerModel})\n\n\nThis function creates the model for a full thermal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:507.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:601.\n\nconstruct_device!(container, sys, _, model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/device_constructors/thermalgeneration_constructor.jl:785.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.construct_service!-Union{Tuple{SR}, Tuple{PowerSimulations.OptimizationContainer, System, PowerSimulations.ArgumentConstructStage, ServiceModel{SR, GroupReserve}, Dict{Symbol, DeviceModel}, Set{<:DataType}}} where SR<:StaticReserveGroup","page":"PowerSimulations","title":"PowerSimulations.construct_service!","text":"construct_service!(container::PowerSimulations.OptimizationContainer, sys::System, _::PowerSimulations.ArgumentConstructStage, model::ServiceModel{SR<:StaticReserveGroup, GroupReserve}, _::Dict{Symbol, DeviceModel}, _::Set{<:DataType})\n\n\nConstructs a service for StaticReserveGroup.\n\nconstruct_service!(container, sys, _, model, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/services_models/services_constructor.jl:383.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.container_spec-Tuple{Type{Float64}, Vararg{Any}}","page":"PowerSimulations","title":"PowerSimulations.container_spec","text":"container_spec(_::Type{Float64}, axs...) -> JuMP.Containers.DenseAxisArray\n\n\nReturns the correct container specification for the selected type of JuMP Model\n\ncontainer_spec(_, axs)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/jump_utils.jl:156.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.container_spec-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any}}} where T","page":"PowerSimulations","title":"PowerSimulations.container_spec","text":"container_spec(_::Type{T}, axs...) -> JuMP.Containers.DenseAxisArray\n\n\nReturns the correct container specification for the selected type of JuMP Model\n\ncontainer_spec(_, axs)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/jump_utils.jl:149.\n\ncontainer_spec(_, axs)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/jump_utils.jl:156.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.create_time_series_multiplier_index-Union{Tuple{T}, Tuple{Any, Type{T}}} where T<:PowerSimulations.TimeSeriesParameter","page":"PowerSimulations","title":"PowerSimulations.create_time_series_multiplier_index","text":"create_time_series_multiplier_index(model, _::Type{T<:PowerSimulations.TimeSeriesParameter}) -> Union{Nothing, Int64}\n\n\nFunction to create a unique index of time series names for each device model. For example, if two parameters each reference the same time series name, this function will return a different value for each parameter entry\n\ncreate_time_series_multiplier_index(model, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/parameters/add_parameters.jl:6.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_duration_compact_retrospective!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Vector{NamedTuple{(:up, :down), Tuple{Float64, Float64}}}, Matrix{InitialCondition}, PowerSimulations.ConstraintType, Tuple{PowerSimulations.VariableType, PowerSimulations.VariableType, PowerSimulations.VariableType}, Type{T}}} where T<:Component","page":"PowerSimulations","title":"PowerSimulations.device_duration_compact_retrospective!","text":"device_duration_compact_retrospective!(container::PowerSimulations.OptimizationContainer, duration_data::Vector{NamedTuple{(:up, :down), Tuple{Float64, Float64}}}, initial_duration::Matrix{InitialCondition}, cons_type::PowerSimulations.ConstraintType, var_types::Tuple{PowerSimulations.VariableType, PowerSimulations.VariableType, PowerSimulations.VariableType}, _::Type{T<:Component})\n\n\nThis formulation of the duration constraints adds over the start times looking backwards.\n\nLaTeX\n\nMinimum up-time constraint:\n\nsum_i=t-min(d_min^up T)+ 1^t x_i^start - x_t^on leq 0\n\nfor i in the set of time steps.\n\nMinimum down-time constraint:\n\nsum_i=t-min(d_min^down T) + 1^t x_i^stop + x_t^on leq 1\n\nfor i in the set of time steps.\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nduration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down\ninitial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)\ncons_name::Symbol : name of the constraint\nvar_keys::Tuple{VariableKey, VariableKey, VariableKey}) : names of the variables\n: var_keys[1] : varon\n: var_keys[2] : varstart\n: var_keys[3] : varstop\n\ndevice_duration_compact_retrospective!(container, duration_data, initial_duration, cons_type, var_types, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/duration_constraints.jl:363.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_duration_look_ahead!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Vector{NamedTuple{(:up, :down), Tuple{Float64, Float64}}}, Matrix{InitialCondition}, PowerSimulations.ConstraintType, PowerSimulations.ConstraintType, Tuple{PowerSimulations.VariableType, PowerSimulations.VariableType, PowerSimulations.VariableType}, Type{T}}} where T<:Component","page":"PowerSimulations","title":"PowerSimulations.device_duration_look_ahead!","text":"device_duration_look_ahead!(container::PowerSimulations.OptimizationContainer, duration_data::Vector{NamedTuple{(:up, :down), Tuple{Float64, Float64}}}, initial_duration::Matrix{InitialCondition}, cons_type_up::PowerSimulations.ConstraintType, cons_type_down::PowerSimulations.ConstraintType, var_types::Tuple{PowerSimulations.VariableType, PowerSimulations.VariableType, PowerSimulations.VariableType}, _::Type{T<:Component})\n\n\nThis formulation of the duration constraints looks ahead in the time frame of the model.\n\nLaTeX\n\nMinimum up-time constraint:\n\nIf t leq d_min^up\n\nd_min^downx_t^stop - sum_i=t-d_min^up + 1^t x_i^on - x_init^up leq 0\n\nfor i in the set of time steps. Otherwise:\n\nd_min^downx_t^stop - sum_i=t-d_min^up + 1^t x_i^on leq 0\n\nfor i in the set of time steps.\n\nMinimum down-time constraint:\n\nIf t leq d_min^down\n\nd_min^upx_t^start - sum_i=t-d_min^down + 1^t (1 - x_i^on) - x_init^down leq 0\n\nfor i in the set of time steps. Otherwise:\n\nd_min^upx_t^start - sum_i=t-d_min^down + 1^t (1 - x_i^on) leq 0\n\nfor i in the set of time steps.\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nduration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down\ninitial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)\ncons_name::Symbol : name of the constraint\nvar_keys::Tuple{VariableKey, VariableKey, VariableKey}) : names of the variables\n: var_keys[1] : varon\n: var_keys[2] : varstart\n: var_keys[3] : varstop\n\ndevice_duration_look_ahead!(container, duration_data, initial_duration, cons_type_up, cons_type_down, var_types, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/duration_constraints.jl:148.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_duration_parameters!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Vector{NamedTuple{(:up, :down), Tuple{Float64, Float64}}}, Matrix{InitialCondition}, PowerSimulations.ConstraintType, Tuple{PowerSimulations.VariableType, PowerSimulations.VariableType, PowerSimulations.VariableType}, Type{T}}} where T<:Component","page":"PowerSimulations","title":"PowerSimulations.device_duration_parameters!","text":"This formulation of the duration constraints considers parameters.\n\nLaTeX\n\nMinimum up-time constraint:\n\nIf t leq d_min^up\n\nd_min^downx_t^stop - sum_i=t-d_min^up + 1^t x_i^on - x_init^up leq 0\n\nfor i in the set of time steps. Otherwise:\n\nsum_i=t-d_min^up + 1^t x_i^start - x_t^on leq 0\n\nfor i in the set of time steps.\n\nMinimum down-time constraint:\n\nIf t leq d_min^down\n\nd_min^upx_t^start - sum_i=t-d_min^down + 1^t (1 - x_i^on) - x_init^down leq 0\n\nfor i in the set of time steps. Otherwise:\n\nsum_i=t-d_min^down + 1^t x_i^stop + x_t^on leq 1\n\nfor i in the set of time steps.\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nduration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down\ninitialdurationon::Vector{InitialCondition} : gives initial number of time steps variable is up\ninitialdurationoff::Vector{InitialCondition} : gives initial number of time steps variable is down\ncons_name::Symbol : name of the constraint\nvar_keys::Tuple{VariableKey, VariableKey, VariableKey}) : names of the variables\n: var_keys[1] : varon\n: var_keys[2] : varstart\n: var_keys[3] : varstop\n\ndevice_duration_parameters!(container, duration_data, initial_duration, cons_type, var_types, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/duration_constraints.jl:247.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_duration_retrospective!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Vector{NamedTuple{(:up, :down), Tuple{Float64, Float64}}}, Matrix{InitialCondition}, PowerSimulations.ConstraintType, Tuple{PowerSimulations.VariableType, PowerSimulations.VariableType, PowerSimulations.VariableType}, Type{T}}} where T<:Component","page":"PowerSimulations","title":"PowerSimulations.device_duration_retrospective!","text":"This formulation of the duration constraints adds over the start times looking backwards.\n\nLaTeX\n\nMinimum up-time constraint:\n\nIf t leq d_min^up - d_init^up and d_init^up  0\n\n1 + sum_i=t-d_min^up + 1^t x_i^start - x_t^on leq 0\n\nfor i in the set of time steps. Otherwise:\n\nsum_i=t-d_min^up + 1^t x_i^start - x_t^on leq 0\n\nfor i in the set of time steps.\n\nMinimum down-time constraint:\n\nIf t leq d_min^down - d_init^down and d_init^down  0\n\n1 + sum_i=t-d_min^down + 1^t x_i^stop + x_t^on leq 1\n\nfor i in the set of time steps. Otherwise:\n\nsum_i=t-d_min^down + 1^t x_i^stop + x_t^on leq 1\n\nfor i in the set of time steps.\n\nArguments\n\ncontainer::OptimizationContainer : the optimization_container model built in PowerSimulations\nduration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down\ninitial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)\ncons_name::Symbol : name of the constraint\nvar_keys::Tuple{VariableKey, VariableKey, VariableKey}) : names of the variables\n: var_keys[1] : varon\n: var_keys[2] : varstart\n: var_keys[3] : varstop\n\ndevice_duration_retrospective!(container, duration_data, initial_duration, cons_type, var_types, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/duration_constraints.jl:41.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.find_key_with_value-Tuple{Any, Any}","page":"PowerSimulations","title":"PowerSimulations.find_key_with_value","text":"find_key_with_value(d, value) -> Any\n\n\nReturn the key for the given value\n\nfind_key_with_value(d, value)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/file_utils.jl:31.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.find_timestamp_index-Tuple{Union{StepRange{Dates.DateTime, Dates.Millisecond}, Vector{Dates.DateTime}}, Dates.DateTime}","page":"PowerSimulations","title":"PowerSimulations.find_timestamp_index","text":"find_timestamp_index(dates::Union{StepRange{Dates.DateTime, Dates.Millisecond}, Vector{Dates.DateTime}}, date::Dates.DateTime) -> Int64\n\n\ncalculates the index in the time series corresponding to the data. Assumes that the dates vector is sorted.\n\nfind_timestamp_index(dates, date)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/datetime_utils.jl:4.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_dirty_data_to_flush!-Tuple{PowerSimulations.OptimizationOutputCache}","page":"PowerSimulations","title":"PowerSimulations.get_dirty_data_to_flush!","text":"get_dirty_data_to_flush!(cache::PowerSimulations.OptimizationOutputCache) -> Tuple{Vector{Dates.DateTime}, Any}\n\n\nReturn all dirty data from the cache. Mark the timestamps as clean.\n\nget_dirty_data_to_flush!(cache)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/optimization_output_cache.jl:98.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_enum_value-Tuple{Any, String}","page":"PowerSimulations","title":"PowerSimulations.get_enum_value","text":"get_enum_value(enum, value::String) -> Any\n\n\nGet the enum value for the string. Case insensitive.\n\nget_enum_value(enum, value)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/definitions.jl:103.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_last_updated_timestamp-Tuple{PowerSimulations.DataFrameDataset}","page":"PowerSimulations","title":"PowerSimulations.get_last_updated_timestamp","text":"get_last_updated_timestamp(s::PowerSimulations.DataFrameDataset) -> Dates.DateTime\n\n\nReturn the timestamp from most recent data row updated in the dataset. This value may not be the same as the result from get_update_timestamp\n\nget_last_updated_timestamp(s)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/dataset.jl:96.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_last_updated_timestamp-Tuple{PowerSimulations.DatasetContainer, PowerSimulations.OptimizationContainerKey}","page":"PowerSimulations","title":"PowerSimulations.get_last_updated_timestamp","text":"get_last_updated_timestamp(container::PowerSimulations.DatasetContainer, key::PowerSimulations.OptimizationContainerKey) -> Dates.DateTime\n\n\nReturn the timestamp from most recent data row updated in the dataset. This value may not be the same as the result from get_update_timestamp\n\nget_last_updated_timestamp(container, key)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/dataset_container.jl:195.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_last_updated_timestamp-Tuple{PowerSimulations.HDF5Dataset}","page":"PowerSimulations","title":"PowerSimulations.get_last_updated_timestamp","text":"get_last_updated_timestamp(s::PowerSimulations.HDF5Dataset) -> Dates.DateTime\n\n\nReturn the timestamp from most recent data row updated in the dataset. This value may not be the same as the result from get_update_timestamp\n\nget_last_updated_timestamp(s)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/dataset.jl:144.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{Any, Type{<:PowerSimulations.ConstraintType}, Type{<:PowerSimulations.AbstractBranchFormulation}}","page":"PowerSimulations","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(device, _::Type{<:PowerSimulations.ConstraintType}, _::Type{<:PowerSimulations.AbstractBranchFormulation}) -> NamedTuple{(:min, :max), Tuple{Float64, Float64}}\n\n\nMin and max limits for Abstract Branch Formulation\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:103.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:235.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:291.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:310.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:12.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hybrid_generation.jl:124.\n\nget_min_max_limits(x, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:282.\n\nget_min_max_limits(x, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:293.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:37.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:105.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:110.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:115.\n\nget_min_max_limits(d, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:151.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:173.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:185.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:256.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:297.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:556.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:567.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{<:PowerSimulations.AbstractCompactUnitCommitment}}","page":"PowerSimulations","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(device, _::Type{ActivePowerVariableLimitsConstraint}, _::Type{<:PowerSimulations.AbstractCompactUnitCommitment}) -> Any\n\n\nMin and Max active power limits for Compact Unit Commitment\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:103.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:173.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:256.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:297.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{<:PowerSimulations.AbstractThermalDispatchFormulation}}","page":"PowerSimulations","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(device, _::Type{ActivePowerVariableLimitsConstraint}, _::Type{<:PowerSimulations.AbstractThermalDispatchFormulation}) -> NamedTuple{(:min, :max), _A} where _A<:Tuple{Float64, Any}\n\n\nMin and max active power limits of generators for thermal dispatch formulations\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:103.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:173.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:185.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:213.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:228.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:256.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:297.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{<:PowerSimulations.AbstractThermalUnitCommitment}}","page":"PowerSimulations","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(device, _::Type{ActivePowerVariableLimitsConstraint}, _::Type{<:PowerSimulations.AbstractThermalUnitCommitment}) -> Any\n\n\nMin and max active power limits of generators for thermal unit commitment formulations\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:103.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:173.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:185.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:256.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:297.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{<:ThermalMultiStartUnitCommitment}}","page":"PowerSimulations","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(device, _::Type{ActivePowerVariableLimitsConstraint}, _::Type{<:ThermalMultiStartUnitCommitment}) -> Any\n\n\nMin and max active power limits for multi-start unit commitment formulations\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:103.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:173.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:256.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{ThermalCompactDispatch}}","page":"PowerSimulations","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(device, _::Type{ActivePowerVariableLimitsConstraint}, _::Type{ThermalCompactDispatch}) -> NamedTuple{(:min, :max), _A} where _A<:Tuple{Float64, Any}\n\n\nMin and max active power limits of generators for thermal dispatch compact formulations\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:213.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{ThermalDispatchNoMin}}","page":"PowerSimulations","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(device, _::Type{ActivePowerVariableLimitsConstraint}, _::Type{ThermalDispatchNoMin}) -> NamedTuple{(:min, :max), _A} where _A<:Tuple{Float64, Any}\n\n\nMin and max active power limits of generators for thermal dispatch no minimum formulations\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:228.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{Any, Type{EnergyCapacityConstraint}, Type{<:PowerSimulations.AbstractStorageFormulation}}","page":"PowerSimulations","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(d, _::Type{EnergyCapacityConstraint}, _::Type{<:PowerSimulations.AbstractStorageFormulation}) -> NamedTuple{(:min, :max), _A} where _A<:Tuple{Any, Any}\n\n\nMin and max limits for Energy Capacity Constraint and AbstractStorageFormulation\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:103.\n\nget_min_max_limits(d, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/storage.jl:151.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{Any, Type{ReactivePowerVariableLimitsConstraint}, Type{<:PowerSimulations.AbstractThermalDispatchFormulation}}","page":"PowerSimulations","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(device, _::Type{ReactivePowerVariableLimitsConstraint}, _::Type{<:PowerSimulations.AbstractThermalDispatchFormulation}) -> Any\n\n\nReactive power limits of generators for all dispatch formulations\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:103.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:37.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:556.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:567.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{Any, Type{ReactivePowerVariableLimitsConstraint}, Type{<:PowerSimulations.AbstractThermalUnitCommitment}}","page":"PowerSimulations","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(device, _::Type{ReactivePowerVariableLimitsConstraint}, _::Type{<:PowerSimulations.AbstractThermalUnitCommitment}) -> Any\n\n\nReactive power limits of generators when there CommitmentVariables\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:103.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/renewable_generation.jl:37.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:556.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:567.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{HydroGen, Type{<:ActivePowerVariableLimitsConstraint}, Type{<:PowerSimulations.AbstractHydroFormulation}}","page":"PowerSimulations","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(x::HydroGen, _::Type{<:ActivePowerVariableLimitsConstraint}, _::Type{<:PowerSimulations.AbstractHydroFormulation}) -> NamedTuple{(:min, :max), Tuple{Float64, Float64}}\n\n\nMin and max active Power Variable limits\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:103.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:12.\n\nget_min_max_limits(x, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:282.\n\nget_min_max_limits(x, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:293.\n\nget_min_max_limits(x, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:301.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{HydroGen, Type{<:InputActivePowerVariableLimitsConstraint}, Type{HydroDispatchPumpedStorage}}","page":"PowerSimulations","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(x::HydroGen, _::Type{<:InputActivePowerVariableLimitsConstraint}, _::Type{HydroDispatchPumpedStorage}) -> NamedTuple{(:min, :max), _A} where _A<:Tuple{Any, Any}\n\n\nMin and max input active power variable limits for hydro dispatch pumped storage\n\nget_min_max_limits(x, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:397.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{HydroGen, Type{<:OutputActivePowerVariableLimitsConstraint}, Type{HydroDispatchPumpedStorage}}","page":"PowerSimulations","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(x::HydroGen, _::Type{<:OutputActivePowerVariableLimitsConstraint}, _::Type{HydroDispatchPumpedStorage}) -> Any\n\n\nMin and max output active power variable limits for hydro dispatch pumped storage\n\nget_min_max_limits(x, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:386.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{HydroGen, Type{<:ReactivePowerVariableLimitsConstraint}, Type{<:PowerSimulations.AbstractHydroFormulation}}","page":"PowerSimulations","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(x::HydroGen, _::Type{<:ReactivePowerVariableLimitsConstraint}, _::Type{<:PowerSimulations.AbstractHydroFormulation}) -> NamedTuple{(:min, :max), Tuple{Float64, Float64}}\n\n\nMin and max reactive Power Variable limits\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:103.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/range_constraint.jl:12.\n\nget_min_max_limits(x, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:282.\n\nget_min_max_limits(x, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/hydro_generation.jl:293.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{MonitoredLine, Type{<:PowerSimulations.ConstraintType}, Type{<:PowerSimulations.AbstractBranchFormulation}}","page":"PowerSimulations","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(device::MonitoredLine, _::Type{<:PowerSimulations.ConstraintType}, _::Type{<:PowerSimulations.AbstractBranchFormulation}) -> NamedTuple{(:min, :max), _A} where _A<:Tuple{Any, Any}\n\n\nMin and max limits for monitored line\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:235.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:291.\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:310.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{MonitoredLine, Type{FlowLimitFromToConstraint}, Type{<:PowerSimulations.AbstractBranchFormulation}}","page":"PowerSimulations","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(device::MonitoredLine, _::Type{FlowLimitFromToConstraint}, _::Type{<:PowerSimulations.AbstractBranchFormulation}) -> NamedTuple{(:min, :max), _A} where _A<:Tuple{Any, Any}\n\n\nMin and max limits for flow limit from-to constraint\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:291.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_min_max_limits-Tuple{MonitoredLine, Type{FlowLimitToFromConstraint}, Type{<:PowerSimulations.AbstractBranchFormulation}}","page":"PowerSimulations","title":"PowerSimulations.get_min_max_limits","text":"get_min_max_limits(device::MonitoredLine, _::Type{FlowLimitToFromConstraint}, _::Type{<:PowerSimulations.AbstractBranchFormulation}) -> NamedTuple{(:min, :max), _A} where _A<:Tuple{Any, Any}\n\n\nMin and max limits for flow limit to-from constraint\n\nget_min_max_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/AC_branches.jl:310.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_startup_shutdown_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{<:PowerSimulations.AbstractCompactUnitCommitment}}","page":"PowerSimulations","title":"PowerSimulations.get_startup_shutdown_limits","text":"get_startup_shutdown_limits(device, _::Type{ActivePowerVariableLimitsConstraint}, _::Type{<:PowerSimulations.AbstractCompactUnitCommitment}) -> Union{Nothing, NamedTuple{(:startup, :shutdown), _A} where _A<:Tuple{Any, Any}}\n\n\nStartup shutdown limits for Compact Unit Commitment\n\nget_startup_shutdown_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:286.\n\nget_startup_shutdown_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:312.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_startup_shutdown_limits-Tuple{Any, Type{ActivePowerVariableLimitsConstraint}, Type{<:ThermalMultiStartUnitCommitment}}","page":"PowerSimulations","title":"PowerSimulations.get_startup_shutdown_limits","text":"get_startup_shutdown_limits(device, _::Type{ActivePowerVariableLimitsConstraint}, _::Type{<:ThermalMultiStartUnitCommitment}) -> Union{Nothing, NamedTuple{(:startup, :shutdown), _A} where _A<:Tuple{Any, Any}}\n\n\nStartup and shutdown active power limits for Compact Unit Commitment\n\nget_startup_shutdown_limits(device, _, _)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/thermal_generation.jl:286.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_update_timestamp-Tuple{PowerSimulations.AbstractDataset}","page":"PowerSimulations","title":"PowerSimulations.get_update_timestamp","text":"get_update_timestamp(s::PowerSimulations.AbstractDataset) -> Any\n\n\nReturn the timestamp from the data used in the last update\n\nget_update_timestamp(s)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/dataset.jl:10.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_update_timestamp-Tuple{PowerSimulations.DatasetContainer, PowerSimulations.OptimizationContainerKey}","page":"PowerSimulations","title":"PowerSimulations.get_update_timestamp","text":"get_update_timestamp(container::PowerSimulations.DatasetContainer, key::PowerSimulations.OptimizationContainerKey) -> Any\n\n\nReturn the timestamp from the data used in the last update\n\nget_update_timestamp(container, key)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/dataset_container.jl:188.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.has_dirty-Tuple{PowerSimulations.OptimizationOutputCaches}","page":"PowerSimulations","title":"PowerSimulations.has_dirty","text":"has_dirty(cache::PowerSimulations.OptimizationOutputCaches) -> Bool\n\n\nReturn true if the cache has data that has not been flushed to storage.\n\nhas_dirty(cache)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/optimization_output_caches.jl:57.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.is_cached-Tuple{PowerSimulations.OptimizationOutputCaches, Any, Any, Any}","page":"PowerSimulations","title":"PowerSimulations.is_cached","text":"is_cached(cache::PowerSimulations.OptimizationOutputCaches, model_name, key, index) -> Bool\n\n\nReturn true if the data for timestamp is stored in cache.\n\nis_cached(cache, model_name, key, index)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/optimization_output_caches.jl:82.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.list_decision_model_keys-Tuple{PowerSimulations.HdfSimulationStore, Symbol, Symbol}","page":"PowerSimulations","title":"PowerSimulations.list_decision_model_keys","text":"list_decision_model_keys(store::PowerSimulations.HdfSimulationStore, model::Symbol, container_type::Symbol) -> Base.KeySet\n\n\nReturn the fields stored for the problem and container_type (duals/parameters/variables).\n\nlist_decision_model_keys(store, model, container_type)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/hdf_simulation_store.jl:172.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.list_decision_models-Tuple{PowerSimulations.HdfSimulationStore}","page":"PowerSimulations","title":"PowerSimulations.list_decision_models","text":"list_decision_models(store::PowerSimulations.HdfSimulationStore) -> Base.KeySet{Symbol, OrderedDict{Symbol, PowerSimulations.DatasetContainer{PowerSimulations.HDF5Dataset}}}\n\n\nReturn the problem names in order of execution.\n\nlist_decision_models(store)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/hdf_simulation_store.jl:167.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.log_cache_hit_percentages-Tuple{PowerSimulations.OptimizationOutputCaches}","page":"PowerSimulations","title":"PowerSimulations.log_cache_hit_percentages","text":"log_cache_hit_percentages(cache::PowerSimulations.OptimizationOutputCaches)\n\n\nLog the cache hit percentages for all caches.\n\nlog_cache_hit_percentages(cache)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/optimization_output_caches.jl:95.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.open_store","page":"PowerSimulations","title":"PowerSimulations.open_store","text":"open_store(::Type{PowerSimulations.HdfSimulationStore}, directory::AbstractString) -> PowerSimulations.HdfSimulationStore\nopen_store(::Type{PowerSimulations.HdfSimulationStore}, directory::AbstractString, mode; filename) -> PowerSimulations.HdfSimulationStore\n\n\nConstruct and open an HdfSimulationStore.\n\nWhen reading or writing results in a program you should use the method that accepts a function in order to guarantee that the file handle gets closed.\n\nArguments\n\ndirectory::AbstractString: Directory containing the store file\nmode::AbstractString: Mode to use to open the store file\nfilename::AbstractString: Base name of the store file\n\nExamples\n\n# Assumes a simulation has been executed in the './rts' directory with these parameters.\npath = \"./rts\"\nproblem = :ED\nvar_name = :P__ThermalStandard\ntimestamp = DateTime(\"2020-01-01T05:00:00\")\nstore = open_store(HdfSimulationStore, path)\ndf = PowerSimulations.read_result(DataFrame, store, model, :variables, var_name, timestamp)\n\nopen_store(, directory)\nopen_store(, directory, mode; filename)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/hdf_simulation_store.jl:89.\n\n\n\n\n\n","category":"function"},{"location":"api/PowerSimulations/#PowerSimulations.read_dataframe-Tuple{AbstractString}","page":"PowerSimulations","title":"PowerSimulations.read_dataframe","text":"read_dataframe(filename::AbstractString) -> DataFrames.DataFrame\n\n\nReturn a DataFrame from a CSV file.\n\nread_dataframe(filename)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/file_utils.jl:13.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_json-Tuple{AbstractString}","page":"PowerSimulations","title":"PowerSimulations.read_json","text":"read_json(filename::AbstractString) -> Any\n\n\nReturn a decoded JSON file.\n\nread_json(filename)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/file_utils.jl:4.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_result-Tuple{PowerSimulations.OptimizationOutputCaches, Any, Any, Any}","page":"PowerSimulations","title":"PowerSimulations.read_result","text":"read_result(cache::PowerSimulations.OptimizationOutputCaches, model_name, key, timestamp) -> Array\n\n\nRead the result from cache. Callers must first call is_cached to check if the timestamp is present.\n\nread_result(cache, model_name, key, timestamp)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/optimization_output_caches.jl:108.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.read_result-Tuple{Type{DataFrames.DataFrame}, PowerSimulations.HdfSimulationStore, Symbol, PowerSimulations.OptimizationContainerKey, Union{Int64, Dates.DateTime}}","page":"PowerSimulations","title":"PowerSimulations.read_result","text":"read_result(_::Type{DataFrames.DataFrame}, store::PowerSimulations.HdfSimulationStore, model_name::Symbol, key::PowerSimulations.OptimizationContainerKey, index::Union{Int64, Dates.DateTime}) -> Any\n\n\nReturn DataFrame, DenseAxisArray, or Array for a model result at a timestamp.\n\nread_result(_, store, model_name, key, index)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/hdf_simulation_store.jl:336.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.serialize_simulation-Tuple{Simulation}","page":"PowerSimulations","title":"PowerSimulations.serialize_simulation","text":"serialize_simulation(sim::Simulation; path, force) -> String\n\n\nserialize_simulation(sim::Simulation, path = \".\")\n\nSerialize the simulation to a directory in path.\n\nReturn the serialized simulation directory name that is created.\n\nArguments\n\nsim::Simulation: simulation to serialize\npath = \".\": path in which to create the serialzed directory\nforce = false: If true, delete the directory if it already exists. Otherwise, it will throw an exception.\n\nserialize_simulation(sim; path, force)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation.jl:931.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.set_expression!-Union{Tuple{T}, Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, Type{S}, JuMP.AbstractJuMPScalar, T, Int64}} where {S<:CostExpressions, T<:Component}","page":"PowerSimulations","title":"PowerSimulations.set_expression!","text":"set_expression!(container::PowerSimulations.OptimizationContainer, _::Type{S<:CostExpressions}, cost_expression::JuMP.AbstractJuMPScalar, component::Component, time_period::Int64)\n\n\nReplaces an expression value in the expression container if the key exists\n\nset_expression!(container, _, cost_expression, component, time_period)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/devices_models/devices/common/set_expression.jl:4.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.set_ic_quantity!-Union{Tuple{T}, Tuple{InitialCondition{T, Float64}, Float64}} where T<:PowerSimulations.InitialConditionType","page":"PowerSimulations","title":"PowerSimulations.set_ic_quantity!","text":"set_ic_quantity!(ic::InitialCondition{T<:PowerSimulations.InitialConditionType, Float64}, var_value::Float64)\n\n\nDefault implementation of setinitialcondition_value\n\nset_ic_quantity!(ic, var_value)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/initial_conditions/calculate_initial_condition.jl:16.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.set_ic_quantity!-Union{Tuple{T}, Tuple{InitialCondition{T, ParameterJuMP.ParameterRef}, Float64}} where T<:PowerSimulations.InitialConditionType","page":"PowerSimulations","title":"PowerSimulations.set_ic_quantity!","text":"set_ic_quantity!(ic::InitialCondition{T<:PowerSimulations.InitialConditionType, ParameterJuMP.ParameterRef}, var_value::Float64)\n\n\nDefault implementation of setinitialcondition_value\n\nset_ic_quantity!(ic, var_value)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/initial_conditions/calculate_initial_condition.jl:4.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.solve_impl!-Tuple{PowerSimulations.OptimizationContainer, System}","page":"PowerSimulations","title":"PowerSimulations.solve_impl!","text":"solve_impl!(container::PowerSimulations.OptimizationContainer, system::System) -> RunStatus\n\n\nDefault solve method for OptimizationContainer\n\nsolve_impl!(container, system)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/optimization_container.jl:582.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.sparse_container_spec-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any}}} where T<:JuMP.AbstractJuMPScalar","page":"PowerSimulations","title":"PowerSimulations.sparse_container_spec","text":"sparse_container_spec(_::Type{T<:JuMP.AbstractJuMPScalar}, axs...) -> JuMP.Containers.SparseAxisArray{Any, N} where N\n\n\nReturns the correct container specification for the selected type of JuMP Model\n\nsparse_container_spec(_, axs)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/utils/jump_utils.jl:165.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.to_matrix-Tuple{T} where T<:PowerSimulations.OptimizerStats","page":"PowerSimulations","title":"PowerSimulations.to_matrix","text":"to_matrix(stats::PowerSimulations.OptimizerStats) -> Matrix{Float64}\n\n\nConvert OptimizerStats to a matrix of floats that can be serialized to HDF5.\n\nto_matrix(stats)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/core/optimizer_stats.jl:79.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.update_model!-Tuple{PowerSimulations.OperationModel, Simulation}","page":"PowerSimulations","title":"PowerSimulations.update_model!","text":"update_model!(model::PowerSimulations.OperationModel, sim::Simulation)\n\n\nDefault problem update function for most problems with no customization\n\nupdate_model!(model, sim)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/simulation.jl:712.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.update_parameter_values!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OperationModel, PowerSimulations.ParameterKey{T, U}, PowerSimulations.DatasetContainer{PowerSimulations.DataFrameDataset}}} where {T<:PowerSimulations.ParameterType, U<:Component}","page":"PowerSimulations","title":"PowerSimulations.update_parameter_values!","text":"update_parameter_values!(model::PowerSimulations.OperationModel, key::PowerSimulations.ParameterKey{T<:PowerSimulations.ParameterType, U<:Component}, input::PowerSimulations.DatasetContainer{PowerSimulations.DataFrameDataset})\n\n\nUpdate parameter function an OperationModel\n\nupdate_parameter_values!(model, key, input)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/parameters/update_parameters.jl:285.\n\nupdate_parameter_values!(model, key, input)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/parameters/update_parameters.jl:309.\n\nupdate_parameter_values!(model, key, input)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/parameters/update_parameters.jl:383.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.update_parameter_values!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OperationModel, PowerSimulations.ParameterKey{T, U}, PowerSimulations.DatasetContainer{PowerSimulations.DataFrameDataset}}} where {T<:PowerSimulations.ParameterType, U<:Service}","page":"PowerSimulations","title":"PowerSimulations.update_parameter_values!","text":"update_parameter_values!(model::PowerSimulations.OperationModel, key::PowerSimulations.ParameterKey{T<:PowerSimulations.ParameterType, U<:Service}, input::PowerSimulations.DatasetContainer{PowerSimulations.DataFrameDataset})\n\n\nUpdate parameter function an OperationModel\n\nupdate_parameter_values!(model, key, input)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/parameters/update_parameters.jl:309.\n\nupdate_parameter_values!(model, key, input)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/parameters/update_parameters.jl:383.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.variable_reactive_net_injection-Tuple{PowerModels.AbstractActivePowerModel}","page":"PowerSimulations","title":"PowerSimulations.variable_reactive_net_injection","text":"variable_reactive_net_injection(pm::PowerModels.AbstractActivePowerModel; kwargs...)\n\n\nactive power only models ignore reactive power variables\n\nvariable_reactive_net_injection(pm; kwargs...)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/network_models/powermodels_interface.jl:257.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.write_result!-Tuple{PowerSimulations.HdfSimulationStore, Symbol, PowerSimulations.OptimizationContainerKey, Dates.DateTime, Dates.DateTime, Any}","page":"PowerSimulations","title":"PowerSimulations.write_result!","text":"write_result!(store::PowerSimulations.HdfSimulationStore, model_name::Symbol, key::PowerSimulations.OptimizationContainerKey, index::Dates.DateTime, _::Dates.DateTime, data)\n\n\nWrite a decision model result for a timestamp to the store.\n\nwrite_result!(store, model_name, key, index, _, data)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/hdf_simulation_store.jl:489.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.write_result!-Tuple{PowerSimulations.HdfSimulationStore, Symbol, PowerSimulations.OptimizationContainerKey, Int64, Dates.DateTime, Matrix{Float64}}","page":"PowerSimulations","title":"PowerSimulations.write_result!","text":"write_result!(store::PowerSimulations.HdfSimulationStore, _::Symbol, key::PowerSimulations.OptimizationContainerKey, index::Int64, simulation_time::Dates.DateTime, data::Matrix{Float64})\n\n\nWrite an emulation model result for an execution index value and the timestamp of the update\n\nwrite_result!(store, _, key, index, simulation_time, data)\n\ndefined at /home/runner/work/PowerSimulations.jl/PowerSimulations.jl/src/simulation/hdf_simulation_store.jl:524.\n\n\n\n\n\n","category":"method"},{"location":"ref/hydro/#Hydro-Generation-Models","page":"Hydro Generation Models","title":"Hydro Generation Models","text":"","category":"section"},{"location":"ref/hydro/","page":"Hydro Generation Models","title":"Hydro Generation Models","text":"Here we present the mathematical formulation of the different models for Hydro Generation.","category":"page"},{"location":"ref/hydro/#Dispatch-Run-of-River-[HydroDispatchRunOfRiver]","page":"Hydro Generation Models","title":"Dispatch Run of River [HydroDispatchRunOfRiver]","text":"","category":"section"},{"location":"ref/hydro/","page":"Hydro Generation Models","title":"Hydro Generation Models","text":"The following model provides upper bounds for the active power based on run of the river inflow, modeled as a eta_t in 01 coefficient of the maximum active power. Additional bounds for reactive power are considered.","category":"page"},{"location":"ref/hydro/","page":"Hydro Generation Models","title":"Hydro Generation Models","text":"beginalign\n  P^textmin le P_t le eta_t P^textmax \n  Q^textmin le Q_t le Q^textmax\nendalign","category":"page"},{"location":"ref/hydro/#Dispatch-Energy-Budget-[HydroDispatchReservoirBudget]","page":"Hydro Generation Models","title":"Dispatch Energy Budget [HydroDispatchReservoirBudget]","text":"","category":"section"},{"location":"ref/hydro/","page":"Hydro Generation Models","title":"Hydro Generation Models","text":"The following model provides an energy budget over the time horizon for the active power.","category":"page"},{"location":"ref/hydro/","page":"Hydro Generation Models","title":"Hydro Generation Models","text":"beginalign\n  sum_t = 1^N P_t cdot Delta T le E^textbudget \n  P^textmin le P_t le P^textmax \n  Q^textmin le Q_t le Q^textmax\nendalign","category":"page"},{"location":"ref/hydro/#Dispatch-Storage-[HydroDispatchReservoirStorage]","page":"Hydro Generation Models","title":"Dispatch Storage [HydroDispatchReservoirStorage]","text":"","category":"section"},{"location":"ref/hydro/","page":"Hydro Generation Models","title":"Hydro Generation Models","text":"The following model includes a energy level E_t to handle the storage energy. Inflow powerI_t can also be included as time series into the balance equation. Spillage S_t is also considered:","category":"page"},{"location":"ref/hydro/","page":"Hydro Generation Models","title":"Hydro Generation Models","text":"beginalign\n  E_t+1 = E_t + (I_t - S_t - P_t)Delta T \n  P^textmin le P_t le P^textmax \n  Q^textmin le Q_t le Q^textmax\nendalign","category":"page"},{"location":"ref/hydro/","page":"Hydro Generation Models","title":"Hydro Generation Models","text":"Future releases will also implement a requirement of the energy at the last time point N:","category":"page"},{"location":"ref/hydro/","page":"Hydro Generation Models","title":"Hydro Generation Models","text":"beginalign\n E_N ge E^textrequirement\nendalign","category":"page"},{"location":"ref/hydro/#Commitment-Run-of-River-[HydroCommitmentRunOfRiver]","page":"Hydro Generation Models","title":"Commitment Run of River [HydroCommitmentRunOfRiver]","text":"","category":"section"},{"location":"ref/hydro/","page":"Hydro Generation Models","title":"Hydro Generation Models","text":"Similar to the dispatch formulation, but considering a binary variable u_t in 0 1 with semi continuous constraints for both active and reactive power:","category":"page"},{"location":"ref/hydro/","page":"Hydro Generation Models","title":"Hydro Generation Models","text":"beginalign\n  P_t le eta_t P^textmax\n  P_t - u_t P^textmax le 0 \n  P_t - u_t P^textmin ge 0 \n  Q_t - u_t Q^textmax le 0 \n  Q_t - u_t Q^textmin ge 0\nendalign","category":"page"},{"location":"ref/hydro/#Commitment-Energy-Budget-[HydroCommitmentReservoirBudget]","page":"Hydro Generation Models","title":"Commitment Energy Budget [HydroCommitmentReservoirBudget]","text":"","category":"section"},{"location":"ref/hydro/","page":"Hydro Generation Models","title":"Hydro Generation Models","text":"Similar to the dispatch formulation, but considering a binary variable u_t in 0 1 with semi continuous constraints for both active and reactive power:","category":"page"},{"location":"ref/hydro/","page":"Hydro Generation Models","title":"Hydro Generation Models","text":"beginalign\n  sum_t = 1^N P_t cdot Delta T le E^textbudget \n  P_t - u_t P^textmax le 0 \n  P_t - u_t P^textmin ge 0 \n  Q_t - u_t Q^textmax le 0 \n  Q_t - u_t Q^textmin ge 0\nendalign","category":"page"},{"location":"ref/hydro/#Commitment-Energy-Budget-[HydroCommitmentReservoirStorage]","page":"Hydro Generation Models","title":"Commitment Energy Budget [HydroCommitmentReservoirStorage]","text":"","category":"section"},{"location":"ref/hydro/","page":"Hydro Generation Models","title":"Hydro Generation Models","text":"Similar to the dispatch formulation, but considering a binary variable u_t in 0 1 with semi continuous constraints for both active and reactive power:","category":"page"},{"location":"ref/hydro/","page":"Hydro Generation Models","title":"Hydro Generation Models","text":"beginalign\n  E_t+1 = E_t + (I_t - S_t - P_t)Delta T \n  P_t - u_t P^textmax le 0 \n  P_t - u_t P^textmin ge 0 \n  Q_t - u_t Q^textmax le 0 \n  Q_t - u_t Q^textmin ge 0\nendalign","category":"page"},{"location":"man/logging/#Logging","page":"-","title":"Logging","text":"","category":"section"},{"location":"man/logging/","page":"-","title":"-","text":"PowerSimulations will output many log messages when building systems and running simulations. You may want to customize what gets logged to the console and, optionally, a file.","category":"page"},{"location":"man/logging/","page":"-","title":"-","text":"By default all log messages of level Logging.Info or higher will get displayed to the console.  When you run a simulation a simulation-specific logger will take over and log its messages to a file in the logs directory in the simulation output directory. When finished it will relinquish control back to the global logger.","category":"page"},{"location":"man/logging/#Configuring-the-global-logger","page":"-","title":"Configuring the global logger","text":"","category":"section"},{"location":"man/logging/","page":"-","title":"-","text":"To configure the global logger in a Jupyter Notebook or REPL you may configure your own logger with the Julia Logging standard library or use the convenience function provided by PowerSimulations.  This example will log messages of level Logging.Error to console and Logging.Info and higher to the file power-simulations.log in the current directory.","category":"page"},{"location":"man/logging/","page":"-","title":"-","text":"import Logging\nusing PowerSimulations\nlogger = configure_logging(\n    console_level = Logging.Error,\n    file_level = Logging.Info,\n    filename = \"power-simulations.log\"\n)","category":"page"},{"location":"man/logging/#Configuring-the-simulation-logger","page":"-","title":"Configuring the simulation logger","text":"","category":"section"},{"location":"man/logging/","page":"-","title":"-","text":"You can configure the logging level used by the simulation logger when you call build!(simulation).  Here is an example that increases logging verbosity:","category":"page"},{"location":"man/logging/","page":"-","title":"-","text":"import Logging\nusing PowerSimulations\nsimulation = Simulation(...)\nbuild!(simulation, console_level = Logging.Info, file_level = Logging.Debug)","category":"page"},{"location":"man/logging/","page":"-","title":"-","text":"The log file will be located at <your-output-path>/<simulation-name>/<run-output-dir>/logs/simulation.log.","category":"page"},{"location":"man/logging/#Solver-logs","page":"-","title":"Solver logs","text":"","category":"section"},{"location":"man/logging/","page":"-","title":"-","text":"You can configure logging for the solver you use.  Refer to the solver documentation.  PowerSimulations does not redirect or intercept prints to stdout or stderr from other libraries.","category":"page"},{"location":"man/logging/#Recorder-events","page":"-","title":"Recorder events","text":"","category":"section"},{"location":"man/logging/","page":"-","title":"-","text":"PowerSimulations uses the InfrastructureSystems.Recorder to store simulation events in a log file.  Refer to this link for more information.","category":"page"},{"location":"man/storage_energy_target/#Energy-Target-Storage-Formulation","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"","category":"section"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"This formulation provides a way for user to tackle the end of horizon effect in battery operation by adding a constraint on stored energy at the end of period. The target constraint includes a slack variable which is associated with a penalty for any violation of the constraints, this ensure feasibility of the model for scenarios where it is not optimal to exactly meet the target.","category":"page"},{"location":"man/storage_energy_target/#Formulation-Overview","page":"Energy Target Storage Formulation","title":"Formulation Overview","text":"","category":"section"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"The features of this model are:","category":"page"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"Standard Battery Operation Constraint\nEnergy balance constraint\nEnergy range constraint\nCharging and discharging limit constraint\nPower Contribution in eligible services \nStored Energy Target Constraint ","category":"page"},{"location":"man/storage_energy_target/#Formulations","page":"Energy Target Storage Formulation","title":"Formulations","text":"","category":"section"},{"location":"man/storage_energy_target/#Indices-and-Sets","page":"Energy Target Storage Formulation","title":"Indices and Sets","text":"","category":"section"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"beginitemize\n\titemt in cT Hourly time steps 1 ldots T T = tt time_periods\n    itemb in cB - Set of battery device\n    itemh in cH- Set of hydro reservoir device\nenditemize","category":"page"},{"location":"man/storage_energy_target/#Parameters","page":"Energy Target Storage Formulation","title":"Parameters","text":"","category":"section"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"beginitemize\n\titemC  Value of energypenalty cost for device b (MW)\n    itemC^value(b) or C^value(h)  - EnergyWater value cost for batteryhydro devices at end of period\n    itemC^penalty(b) or  C^penalty(h) - Penalty cost associated with unsatisfied energy target for batteryhydro devices\n    itemC^var(b) or C^var(h) - Variable cost of generation\n\titemoP_in(b)   Maximum charging power input for device b (MW) tt power_input_maximum\n\titemuP_in(b)   Minimum charging power input for device b (MW) tt power_input_minimum\n    itemoP_out(b)   Maximum discharging power output for device b (MW) tt power_output_maximum\n\titemuP_out(b)   Minimum discharging power output for device b (MW) tt power_output_minimum\n    itemoE(b) Maximum state of charge limt for device b (MWh) tt energy_maximum\n    itemuE(b) Minimum state of charge limt for device b (MWh) tt energy_minimum\n\titemI(bt)) - EnergyWater inflow in the hydro reservoir at timestep (t) for hydro devices\n    itemhatE(bt))  or hatE(ht)) - Energy target at timestep (t) for batteryhydro devices for t in hatT\n\titemE(b)^0   Energy stored in device b (MWh) in the time period prior to t=1 tt energy_stored_t0\nenditemize","category":"page"},{"location":"man/storage_energy_target/#Variables","page":"Energy Target Storage Formulation","title":"Variables","text":"","category":"section"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"beginitemize\n\titemp_in(bt) Active power variable for charging  b at time t geq 0\n\titemp_out(b t)  Active power variable for discharging b at time t geq 0\n\titeme(b t) Stored energy variable for b at time t geq 0\n\titeme_slack(b t) Slack variable for energy target constraint for b at time t  geq 0\n    items(ht) - EnergyWater Spilled from a hydro reservoir devices\n    iteme^-_slack(bt)  or  e^-_slack(ht) - Slack variable for energy target constraint for excess\n    iteme^+_slack(bt)  or  e^+_slack(ht) - Slack variable for energy target constraint for shortage\nenditemize","category":"page"},{"location":"man/storage_energy_target/#Model-Description","page":"Energy Target Storage Formulation","title":"Model Description","text":"","category":"section"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"This first model is for Power Systems Storage devices (e.g. GenericBattery, BatteryEMS) with StorageManagementCost.","category":"page"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"Objective Function","category":"page"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"allowdisplaybreaks\nbeginalign\n     textmin sum_b t in hatcT quad e^+_slack(bt)*C^penalty(b) - e^-_slack(bt)* C^value(b) labeleqobj tagOBJ \nendalign\n","category":"page"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"subject to:\n Active power constraints","category":"page"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"beginalign\n\t\t p_in(bt) + r_g(t) leq  oP_in(b)  forall t in cT  forall b in cB labeleqMaxInput \n\t\t p_in(bt) + r_g(t) geq  uP_in(b)  forall t in cT  forall b in cB labeleqMinInput \n         p_out(bt) + r_g(t) leq  oP_out(b) forall t in cT  forall b in cB labeleqMaxOutput \n\t\t p_out(bt) + r_g(t) geq  uP_out(b) forall t in cT  forall b in cB labeleqMinOutput \nendalign","category":"page"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"Energy Limit constraints","category":"page"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"beginalign\n\t\t e(bt) leq  oE(b)  forall t in cT  forall b in cB labeleqMaxEnergyLimit \n\t\t e(bt) geq  uE(b)  forall t in cT  forall b in cB labeleqMinEnergyLimit \nendalign","category":"page"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"Energy Balance/State of Charge constraint","category":"page"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"beginalign\n\t\t e(b1) - E(b)^0 = p_in(b1) - p_out(b1)  forall b in cB labeleqEnergyBalance0 \n\t\t e(bt) -e(bt-1) = p_in(bt) - p_out(bt)  forall t in cTsetminus1  forall b in cB labeleqEnergyBalance \nendalign","category":"page"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"Energy Target constraint","category":"page"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"beginalign\n         e(bt) + e^+_slack(bt) + e^-_slack(bt) = hatE(bt) quad forall b in cB t in hatcT labeleqEnergyTarget \nendalign","category":"page"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"Energy slacks constraint","category":"page"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"beginalign\n\t\t e^-_slack(bt) leq 00  forall t in cT  forall b in cB labeleqShortageSlackBound \n\t\t e^+_slack(bt) geq 00  forall t in cT  forall b in cB labeleqSurplusSlackBound \nendalign","category":"page"},{"location":"man/storage_energy_target/#Hydro-Storage-Target-Model-Description","page":"Energy Target Storage Formulation","title":"Hydro Storage Target Model Description","text":"","category":"section"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"This model is for Power Systems HydroEnergyReservoir and HydroPumpedStorage devices with StorageManagementCost.","category":"page"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"Objective Function","category":"page"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"allowdisplaybreaks\nbeginalign\n     textmin   sum_ht p(ht) cdot C^var(h) + C^fixed(h) \n    + sum_h t in hatcT quad e^+_slack(ht) * C^penalty(h) - e^-_slack(ht) * C^value(h)   labeleqobj tagOBJ \nendalign\n","category":"page"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"subject to:\n Active power constraints","category":"page"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"beginalign\n\t\t p(ht)  leq  oP(h)  forall t in cT  forall h in cH labeleqMinOutput \n\t\t p(ht)  geq  uP(h)  forall t in cT  forall h in cH labeleqMinOutput \n         s(ht) leq  cS^max(h) forall t in cT  forall h in cH labeleqMaxSpillage \n\t\t s(ht) geq  0  forall t in cT  forall h in cH labeleqMinSpillage \nendalign","category":"page"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"Energy Limit constraints","category":"page"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"beginalign\n\t\t e(bt) leq  oE(b)  forall t in cT  forall b in cB labeleqMaxEnergyLimit \n\t\t e(bt) geq  uE(b)  forall t in cT  forall b in cB labeleqMinEnergyLimit \nendalign","category":"page"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"Energy Balance/State of Charge constraint","category":"page"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"beginalign\n\t\t e(h1) - E(h)^0 = I(h1) - p(h1) - s(h1)  forall h in cH labeleqEnergyBalance0 \n\t\t e(ht) -e(ht-1) = I(ht) - p(ht) - s(ht)  forall t in cTsetminus1  forall h in cH labeleqEnergyBalance \nendalign","category":"page"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"Energy Target constraint","category":"page"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"beginalign\n         e(ht) + e^+_slack(ht) + e^-_slack(ht) = hatE(ht) quad forall h in cH t in hatcT labeleqEnergyTarget \nendalign","category":"page"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"Energy slacks constraint","category":"page"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"beginalign\n\t\t e^-_slack(ht) leq 00  forall t in cT  forall h in cH labeleqShortageSlackBound \n\t\t e^+_slack(ht) geq 00  forall t in cT  forall h in cH labeleqSurplusSlackBound \nendalign","category":"page"},{"location":"man/storage_energy_target/#Impact-of-different-cost-configurations","page":"Energy Target Storage Formulation","title":"Impact of different cost configurations","text":"","category":"section"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"In the table we describe all possible configuration of the StorageManagementCost with the target constraint in hydro or storage device models. Cases 1(a) & 2(a) will have no impact of the models operations and the target constraint will be rendered useless. In most cases that have no energy target and a non-zero value for C^value, if this cost is too high (C^value  0) or too low (C^value 0) can result in either the model holding on to stored energy till the end or the model not storing any energy in the device. This is caused by the fact that when energy target is zero, we have e(t) = - e^-_shortage(t), and  - e^-_shortage * C^value in the objective function is replaced by e(t) * C^value, thus resulting in C^value to be seen as the cost of stored energy.","category":"page"},{"location":"man/storage_energy_target/","page":"Energy Target Storage Formulation","title":"Energy Target Storage Formulation","text":"begintable\n caption\nbegintabular p15cmp15cmp2cmp2cmp5cm \n hline\n multicolumn5cScenario List \n hline\nCase  Energy Target  Energy Shortage Cost  Energy Value  Energy Surplus cost Effect \n hline\n Case 1(a)  hatE=0     C^penalty=0    C^value=0 no change-15ex\n hline-15ex\n Case 1(b)  hatE=0     C^penalty=0    C^value0 penalty for storing energy\n Case 1(c)  hatE=0     C^penalty0    C^value=0 no penalties or incentives applied\n Case 1(d)  hatE=0     C^penalty=0    C^value0 incentive for storing energy \n Case 1(e)  hatE=0     C^penalty0    C^value0 penalty for storing energy \n Case 1(f)  hatE=0     C^penalty0    C^value0 incentive for storing energy \n hline\n Case 2(a)  hatE0     C^penalty=0    C^value=0 no change-15ex\n hline-15ex\n Case 2(b)  hatE0     C^penalty=0    C^value0 penalty on energy storage in excess of target  \n Case 2(c)  hatE0     C^penalty0    C^value=0 penalty on energy storage short of target\n Case 2(d)  hatE0     C^penalty=0    C^value0 incentive on excess energy \n Case 2(e)  hatE0     C^penalty0    C^value0 penalty on both  excessshortage of energy\n Case 2(f)  hatE0     C^penalty0    C^value0 penalty for shortage incentive for excess energy \n hline\nendtabular\ncaptionlabeltabtable-name Table above describes the different effects that can be induced into the model using the target constraint formulation\nendtable","category":"page"},{"location":"man/multistart_formulation/#Power-Grid-Lib-Unit-Commitment-/-Multi-Start-Unit-Commitment","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"","category":"section"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"This formulation is from the benchmark library maintained by the IEEE PES Task Force on Benchmarks for Validation of Emerging Power System Algorithms and is designed to evaluate a well established version of the Unit Commitment problem.","category":"page"},{"location":"man/multistart_formulation/#Formulation-Overview","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Formulation Overview","text":"","category":"section"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"The features of this model are:","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"A global load requirement with time series\nAn optional global spinning reserve requirement with time series\nThermal generators with technical parameters, including\nMinimum and maximum power output\nHourly ramp-up and ramp-down rates\nStart-up and shut-down ramp rates\nMinimum run-times and off-times\nUp to 3 types of startup types (hot, warm, cold)\nOff time dependent start-up costs\nStartup & Shutdown lag/power trajectory constraint\nPiecewise linear convex production costs\nMust run constraints\nNo-load costs\nOptional renewable generators with time series for minimum and maximum production.","category":"page"},{"location":"man/multistart_formulation/#Formulations","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Formulations","text":"","category":"section"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"A detailed description of this mathematical model is available here. This model does have some augmentation to constraints but is mathematically equivalent to the formulation found here.","category":"page"},{"location":"man/multistart_formulation/#Indices-and-Sets","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Indices and Sets","text":"","category":"section"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"beginitemize\n\titemg in cG Set of thermal generators\n\titemg in cG_textiton^0 Set of thermal generators which are initially committed (on)\n\titemg in cG_textitoff^0 Set of thermal generators which are not initially committed (off)\n\titemt in cT Hourly time steps 1 ldots T T = tt time_periods\n\titeml in cL_g Piecewise production cost intervals for thermal generator g 1 ldots L_g\n\titems in cS_g Startup categories for thermal generator g from hottest (1) to coldest (S_g) 1 ldots S_g\nenditemize","category":"page"},{"location":"man/multistart_formulation/#Thermal-Generator-Parameters","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Thermal Generator Parameters","text":"","category":"section"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"beginitemize\n\titemCS_g^s  Startup cost in category s for generator g () tt startupcost\n\titemCP_g^l  Cost of operating at piecewise generation point l for generator g (MW) tt piecewise_productioncost\n\titemDT_g    Minimum down time for generator g (h) tt time_down_minimum\n\titemDT^0_g Number of time periods the unit has been off prior to the first time period for generator g tt time_down_t0\n\titemoP_g   Maximum power output for generator g (MW) tt power_output_maximum\n\titemuP_g   Minimum power output for generator g (MW) tt power_output_minimum\n\titemP_g^0   Power output for generator g (MW) in the time period prior to t=1 tt power_output_t0\n\titemP_g^l   Power level for piecewise generation point l for generator g (MW) P^1_g = uP_g and P^L_g_g = oP_g tt piecewise_productionmw\n\titemRD_g    Ramp-down rate for generator g (MWh) tt ramp_down_limit\n\titemRU_g    Ramp-up rate for generator g (MWh) tt ramp_up_limit\n\titemSD_g    Shutdown capability for generator g (MW) tt ramp_shutdown_limit\n\titemSU_g    Startup capability for generator g (MW) tt ramp_startup_limit\n\titemTS^s_g Time offline after which the startup category s becomes active (h) tt startuplag\n\titemUT_g    Minimum up time for generator g (h) tt time_up_minimum\n\titemUT^0_g Number of time periods the unit has been on prior to the first time period for generator g tt time_up_t0\n\titemU_g^0  Initial onoff status for generator g U_g^0=1 for g in cG_textiton^0 U_g^0=0 for g in cG_textitoff^0  tt unit_on_t0\n\titemU_g \tMust-run status for generator g tt must_run\nenditemize","category":"page"},{"location":"man/multistart_formulation/#Variables","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Variables","text":"","category":"section"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"beginitemize\n\titemc_g(t)    Cost of power produced above minimum for thermal generator g at time t (MW) in bbR\n\titemp_g(t)    Power above minimum for thermal generator g at time t (MW) geq 0\n\titemp_w(t)  Renewable generation used from renewable generator w at time t (MW) geq 0\n\titemu_g(t)    Commitment status of thermal generator g at time t in 01\n\titemv_g(t)    Startup status of thermal generator g at time t in 01\n\titemw_g(t)    Shutdown status of thermal generator g at time t in 01 \n\titemdelta^s_g(t) Startup in category s for thermal generator g at time t in 01\n\titemlambda_g^l(t)  Fraction of power from piecewise generation point l for generator g at time t (MW) in 01\n\nenditemize","category":"page"},{"location":"man/multistart_formulation/#Model-Description","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Model Description","text":"","category":"section"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"Below we describe the unit commitment model given by~\\cite{morales2013tight}, with the piecewise production cost description from~\\cite{sridhar2013locally}. The unit commitment problem can then be formulated as:\nObjective Function","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"allowdisplaybreaks\nbeginalign\n     textmin  sum_g in cG sum_t in cT left( c_g(t) + CP_g^1  u_g(t) + sum_s = 1^S_g left( CS^s_g delta^s(t) right) right) labeleqobj tagUC \nendalign\n","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"subject to:\n Active power constraints with Startup/Shutdown lag","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"beginalign\n\t\t U_g^0(P_g^0-uP_g) leq (oP_g - uP_g) U_g^0 - max(oP_g - SD_g)0 w_g(1)  forall g in cG labeleqMaxOutput2Init\n\t\t p_g(t) + r_g(t) leq (oP_g - uP_g) u_g(t) - max(oP_g - SU_g)0 v_g(t)  forall t in cT  forall g in cG labeleqMaxOutput1 \n\t\t p_g(t) + r_g(t) leq (oP_g - uP_g) u_g(t) - max(oP_g - SD_g)0 w_g(t+1)  forall t in cTsetminus T  forall g in cG labeleqMaxOutput2\nendalign","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"Ramp constraints","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"beginalign\n\t\t p_g(1) + r_g(1) - U_g^0(P_g^0-uP_g) leq RU_g  forall g in cG labeleqRampUpInit \n\t\t U_g^0(P_g^0-uP_g) - p_g(1) leq RD_g  forall g in cG labeleqRampDownInit \n\t\t p_g(t) + r_g(t) - p_g(t-1) leq RU_g  forall t in cTsetminus1  forall g in cG labeleqRampUp \n\t\t p_g(t-1) - p_g(t) leq RD_g  forall t in cTsetminus1  forall g in cG labeleqRampDown\nendalign","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"Unit Commitment constraint","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"beginalign\n\t\t u_g(1) - U_g^0 = v_g(1) - w_g(1)  forall g in cG labeleqLogicalInitial \n\t\t u_g(t) - u_g(t-1) = v_g(t) - w_g(t)  forall t in cTsetminus1  forall g in cG labeleqLogical \nendalign","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"Minimum Uptime constraints","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"beginalign\n\t\t UT_g w_g(t) - sum_i=t-UT_g + 1^t u_g(i) - UT_g^0 leq 0  forall t in 1 ldots minUT_gT  forall g in cG labeleqStartupInit \n\t\t sum_i= t-minUT_gT + 1^t v_g(i) leq u_g(t)  forall t in minUT_gT ldots T  forall g in cG labeleqStartup\nendalign","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"Minimum Downtime constraints","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"beginalign\n\t\t DT_g v_g(t) - sum_i=t-DT_g + 1^t u_g(i) - DT_g^0 leq 0  forall t in 1 ldots minDT_gT  forall g in cG labeleqShutdownInit \n\t\t sum_i= t-minDT_gT + 1^t w_g(i) leq 1 - u_g(t)  forall t in minDT_g T ldots T  forall g in cG labeleqShutdown\nendalign","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"Must run constraint","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"beginalign\n\t\t u_g(t) geq U_g  hspace1cm forall t in cT  forall g in cG labeleqMustRun\nendalign","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"Start-up time_limits constraints","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"beginalign\n\t\t delta^s_g(t) leq sum_i = TS^s_g^TS^s+1_g-1 w_g(t-i)  forall t in TS^s+1_gldotsTforall s in cS_gsetminusS_g  forall g in cG labeleqSTISelect\nendalign","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"Start-up type selection constraint","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"beginalign\n\t\t v_g(t) = sum_s = 1^S_g delta^s_g(t)  forall t in cT forall g in cG labeleqSTILink\nendalign","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"Start-up initial condition constraints","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"beginalign\n\t\t (TS^s+1_g - 1)delta^s_g(t) + (1 - delta^s_g(t)) M geq sum_i = 1^t u_g(i) + DT_g^0  forall t in 1ldotsTS^s+1_g -1 forall g in cG labeleqSTInitUB\n\t\t TS^s_g delta^s_g(t)  leq sum_i = 1^t u_g(i) + DT_g^0  forall t in 1ldotsTS^s+1_g-1 forall g in cG labeleqSTInitLB\nendalign","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"Piecewise Cost Constraint","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"beginalign\n\t\t p_g(t) = sum_l in cL_g (P_g^l - P_g^1) lambda_g^l(t) hspace5cm forall t in cT  forall g in cG labeleqPiecewiseParts \n\t\t c_g(t) = sum_l in cL_g (CP_g^l - CP_g^1) lambda_g^l(t)  forall t in cT  forall g in cG labeleqPiecewisePartsCost \n\t\t u_g(t) = sum_l in cL_g lambda_g^l(t)  forall t in cT forall g in cG labeleqPiecewiseLimits\nendalign","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"Active power limits","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"beginalign\n\t\t uP_w(t) leq p_w(t) leq oP_w(t) hspace6cm forall t in cT  forall w in cW labeleqWindLimit\nendalign","category":"page"},{"location":"man/multistart_formulation/#References","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"References","text":"","category":"section"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"[1] Knueven, Bernard, James Ostrowski, and Jean-Paul Watson. \"On mixed integer programming formulations for the unit commitment problem.\" Pre-print available at http://www.optimization-online.org/DB_HTML/2018/11/6930.pdf (2018).","category":"page"},{"location":"man/multistart_formulation/","page":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","title":"Power Grid Lib - Unit Commitment / Multi-Start Unit Commitment","text":"[2] Krall, Eric, Michael Higgins, and Richard P. O’Neill. \"RTO unit commitment test system.\" Federal Energy Regulatory Commission. Available: http://ferc.gov/legal/staff-reports/rto-COMMITMENT-TEST.pdf (2012).","category":"page"},{"location":"#PowerSimulations.jl","page":"Introduction","title":"PowerSimulations.jl","text":"","category":"section"},{"location":"#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"PowerSimulations.jl is a Julia/JuMP package designed to develop and study power system operation models in steady-state. It uses the data model implemented in PowerSystems.jl to construct optimization models.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The package supports two major analysis tools:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Operational Models: Meant to study and analyze multi-period operational model formulations that can be specified by the combination of device formulations and network models.\nSimulations Models: Developed to run sequences of operational models to study model interactions such as cost-production-modeling.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The documentation is still work in progress.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The latest stable release of PowerModels can be installed using the Julia package manager with","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"] add PowerSimulations","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For the current development version, \"checkout\" this package with","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"] add PowerSimulations#master","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"An appropriate optimization solver is required for running PowerSimulations models. Refer to JuMP.jl solver's page to select the most appropriate for the application of interest.","category":"page"},{"location":"man/op_problem/#Operational-Model","page":"-","title":"Operational Model","text":"","category":"section"},{"location":"man/op_problem/","page":"-","title":"-","text":"An operational model is defined as the combination of an objective function (\\refeq{gpsimulations}) in terms of state x and control u variables. Equations (\\refeq{dpsimulations}) describe the device model formulations as a function of variables, parameters eta and uncertainty terms omega. Further, equations (\\refeq{n_psimulations}) represents the network modeling and finally the system services.","category":"page"},{"location":"man/op_problem/","page":"-","title":"-","text":"In the same fashion as in PowerSystems.jl, the objective is not to list all possible formulations for devices, network, and services in a power system model. Rather, the contribution is to develop a type hierarchy that enables developers to create new formulations and allow analysts a  natural way to describe the functional assumptions used in the model.","category":"page"},{"location":"man/simulation_recorder/#Simulation-Recorder","page":"-","title":"Simulation Recorder","text":"","category":"section"},{"location":"man/simulation_recorder/","page":"-","title":"-","text":"PowerSimulations provides the ability to record structured data as events during a simulation. These events can be post-processed to help debug problems.","category":"page"},{"location":"man/simulation_recorder/","page":"-","title":"-","text":"By default only SimulationStepEvent and ProblemExecutionEvent are recorded.  Here is an example.","category":"page"},{"location":"man/simulation_recorder/","page":"-","title":"-","text":"Suppose a simulation is run in the directory ./output.","category":"page"},{"location":"man/simulation_recorder/","page":"-","title":"-","text":"Assume that setup commands have been run:","category":"page"},{"location":"man/simulation_recorder/","page":"-","title":"-","text":"using PowerSimulations\nconst PSI = PowerSimulations","category":"page"},{"location":"man/simulation_recorder/","page":"-","title":"-","text":"Note that for all functions below you can optionally specify a function to filter events. The function must accept the event type and return true or false.","category":"page"},{"location":"man/simulation_recorder/#Show-all-events-of-type-PSI.SimulationStepEvent","page":"-","title":"Show all events of type PSI.SimulationStepEvent","text":"","category":"section"},{"location":"man/simulation_recorder/","page":"-","title":"-","text":"julia> show_simulation_events(PSI.SimulationStepEvent, \"./output/aggregation/1\")\n┌─────────────────────┬─────────────────────┬──────┬────────┐\n│                name │     simulation_time │ step │ status │\n├─────────────────────┼─────────────────────┼──────┼────────┤\n│ SimulationStepEvent │ 2024-01-01T00:00:00 │    1 │  start │\n│ SimulationStepEvent │ 2024-01-01T23:00:00 │    1 │   done │\n│ SimulationStepEvent │ 2024-01-01T23:00:00 │    2 │  start │\n│ SimulationStepEvent │ 2024-01-02T23:00:00 │    2 │   done │\n└─────────────────────┴─────────────────────┴──────┴────────┘","category":"page"},{"location":"man/simulation_recorder/#Show-events-of-type-PSI.ProblemExecutionEvent-for-a-specific-step-and-stage.","page":"-","title":"Show events of type PSI.ProblemExecutionEvent for a specific step and stage.","text":"","category":"section"},{"location":"man/simulation_recorder/","page":"-","title":"-","text":"show_simulation_events(\n    PSI.ProblemExecutionEvent,\n    \"./output/aggregation/1\",\n    x -> x.step == 1 && x.stage == 2 && x.status == \"start\"\n)\n┌──────────────────────┬─────────────────────┬──────┬───────┬────────┐\n│                 name │     simulation_time │ step │ stage │ status │\n├──────────────────────┼─────────────────────┼──────┼───────┼────────┤\n│ ProblemExecutionEvent │ 2024-01-01T00:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T00:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T01:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T02:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T03:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T04:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T05:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T06:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T07:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T08:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T09:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T10:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T11:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T12:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T13:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T14:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T15:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T16:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T17:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T18:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T19:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T20:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T21:00:00 │    1 │     2 │  start │\n│ ProblemExecutionEvent │ 2024-01-01T22:00:00 │    1 │     2 │  start │\n└──────────────────────┴─────────────────────┴──────┴───────┴────────┘","category":"page"},{"location":"man/simulation_recorder/#Enable-other-recorder-events","page":"-","title":"Enable other recorder events","text":"","category":"section"},{"location":"man/simulation_recorder/","page":"-","title":"-","text":"Other types of recorder events can be enabled with a possible performance impact. To do this pass in the specific recorder names to be enabled when you call build.","category":"page"},{"location":"man/simulation_recorder/","page":"-","title":"-","text":"sim = Simulation(...)\nrecorders = [:execution]\nbuild!(sim; recorders = recorders)\nexecute!(sim)","category":"page"},{"location":"man/simulation_recorder/","page":"-","title":"-","text":"Now we can examine InitialConditionUpdateEvents for specific steps and stages.","category":"page"},{"location":"man/simulation_recorder/","page":"-","title":"-","text":"show_simulation_events(\n    PSI.InitialConditionUpdateEvent,\n    \"./output/aggregation/1\",\n    x -> x.initial_condition_type == \"DeviceStatus\";\n    step = 2,\n    stage = 1\n)\n┌─────────────────────────────┬─────────────────────┬────────────────────────┬─────────────────┬─────────────┬─────┬──────────────┐\n│                        name │     simulation_time │ initial_condition_type │     device_type │ device_name │ val │ stage_number │\n├─────────────────────────────┼─────────────────────┼────────────────────────┼─────────────────┼─────────────┼─────┼──────────────┤\n│ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Solitude │ 0.0 │            1 │\n│ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │   Park City │ 1.0 │            1 │\n│ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │        Alta │ 1.0 │            1 │\n│ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Brighton │ 1.0 │            1 │\n│ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Sundance │ 0.0 │            1 │\n└─────────────────────────────┴─────────────────────┴────────────────────────┴─────────────────┴─────────────┴─────┴──────────────┘","category":"page"},{"location":"man/simulation_recorder/#Show-the-wall-time-with-your-events","page":"-","title":"Show the wall time with your events","text":"","category":"section"},{"location":"man/simulation_recorder/","page":"-","title":"-","text":"Sometimes you might want to see how the events line up with the wall time.","category":"page"},{"location":"man/simulation_recorder/","page":"-","title":"-","text":"show_simulation_events(\n    PSI.InitialConditionUpdateEvent,\n    \"./output/aggregation/1\",\n    x -> x.initial_condition_type == \"DeviceStatus\";\n    step = 2,\n    stage = 1,\n    wall_time = true\n)\n┌─────────────────────────┬─────────────────────────────┬─────────────────────┬────────────────────────┬─────────────────┬─────────────┬─────┬──────────────┐\n│               timestamp │                        name │     simulation_time │ initial_condition_type │     device_type │ device_name │ val │ stage_number │\n├─────────────────────────┼─────────────────────────────┼─────────────────────┼────────────────────────┼─────────────────┼─────────────┼─────┼──────────────┤\n│ 2020-04-07T15:08:32.711 │ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Solitude │ 0.0 │            1 │\n│ 2020-04-07T15:08:32.711 │ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │   Park City │ 1.0 │            1 │\n│ 2020-04-07T15:08:32.711 │ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │        Alta │ 1.0 │            1 │\n│ 2020-04-07T15:08:32.711 │ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Brighton │ 1.0 │            1 │\n│ 2020-04-07T15:08:32.711 │ InitialConditionUpdateEvent │ 2024-01-02T00:00:00 │           DeviceStatus │ ThermalStandard │    Sundance │ 0.0 │            1 │\n└─────────────────────────┴─────────────────────────────┴─────────────────────┴────────────────────────┴─────────────────┴─────────────┴─────┴──────────────┘","category":"page"}]
}
