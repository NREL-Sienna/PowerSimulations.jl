<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>PowerSimulations · PowerSimulations.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="PowerSimulations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">PowerSimulations.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../man/logging/">Logging</a></li><li><a class="tocitem" href="../../man/op_problem/">Operation Model</a></li><li><a class="tocitem" href="../../man/simulation_recorder/">Simulation Recorder</a></li><li><span class="tocitem">Model References</span><ul><li><a class="tocitem" href="../../ref/hydro/">Hydro Models</a></li></ul></li><li><span class="tocitem">API</span><ul><li class="is-active"><a class="tocitem" href>PowerSimulations</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Exported"><span>Exported</span></a></li><li><a class="tocitem" href="#Internal"><span>Internal</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>PowerSimulations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>PowerSimulations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/master/docs/src/api/PowerSimulations.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="PowerSimulations"><a class="docs-heading-anchor" href="#PowerSimulations">PowerSimulations</a><a id="PowerSimulations-1"></a><a class="docs-heading-anchor-permalink" href="#PowerSimulations" title="Permalink"></a></h1><p>API documentation</p><ul><li><a href="#PowerSimulations">PowerSimulations</a></li><ul><li><a href="#Index">Index</a></li><li><a href="#Exported">Exported</a></li><li><a href="#Internal">Internal</a></li></ul></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#PowerSimulations.AGCReserveDeployment-Tuple{System}"><code>PowerSimulations.AGCReserveDeployment</code></a></li><li><a href="#PowerSimulations.AbstractSimulationStatusEvent"><code>PowerSimulations.AbstractSimulationStatusEvent</code></a></li><li><a href="#PowerSimulations.ActivePowerInVariable"><code>PowerSimulations.ActivePowerInVariable</code></a></li><li><a href="#PowerSimulations.ActivePowerOutVariable"><code>PowerSimulations.ActivePowerOutVariable</code></a></li><li><a href="#PowerSimulations.ActivePowerVariable"><code>PowerSimulations.ActivePowerVariable</code></a></li><li><a href="#PowerSimulations.CacheFlushRules"><code>PowerSimulations.CacheFlushRules</code></a></li><li><a href="#PowerSimulations.DeviceModel"><code>PowerSimulations.DeviceModel</code></a></li><li><a href="#PowerSimulations.DeviceRangeConstraintInfo"><code>PowerSimulations.DeviceRangeConstraintInfo</code></a></li><li><a href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ReactivePowerVariable},Type{T},Type{#s118} where #s118&lt;:PowerSimulations.AbstractThermalDispatchFormulation,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward},Bool,Bool}} where T&lt;:ThermalGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a></li><li><a href="#PowerSimulations.DeviceRangeConstraintSpec-Tuple{}"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a></li><li><a href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ReactivePowerVariable},Type{T},Type{#s118} where #s118&lt;:PowerSimulations.AbstractThermalUnitCommitment,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward},Bool,Bool}} where T&lt;:ThermalGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a></li><li><a href="#PowerSimulations.DeviceRangeConstraintSpec-Tuple{Type{#s118} where #s118&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ReactivePowerVariable},Type{#s117} where #s117&lt;:ElectricLoad,Type{#s116} where #s116&lt;:PowerSimulations.AbstractControllablePowerLoadFormulation,Type{#s115} where #s115&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward},Bool,Bool}"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a></li><li><a href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ActivePowerVariable},Type{T},Type{#s118} where #s118&lt;:PowerSimulations.AbstractCompactUnitCommitment,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Nothing,Bool,Bool}} where T&lt;:ThermalMultiStart"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a></li><li><a href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ActivePowerVariable},Type{T},Type{#s118} where #s118&lt;:PowerSimulations.AbstractHydroReservoirFormulation,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward},Bool,Bool}} where T&lt;:HydroGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a></li><li><a href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ActivePowerVariable},Type{T},Type{#s118} where #s118&lt;:ThermalDispatchNoMin,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Nothing,Bool,Bool}} where T&lt;:ThermalGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a></li><li><a href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ActivePowerVariable},Type{T},Type{#s118} where #s118&lt;:PowerSimulations.AbstractHydroDispatchFormulation,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward},Bool,Bool}} where T&lt;:HydroGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a></li><li><a href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ActivePowerVariable},Type{T},Type{#s118} where #s118&lt;:PowerSimulations.AbstractThermalDispatchFormulation,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Nothing,Bool,Bool}} where T&lt;:ThermalGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a></li><li><a href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ActivePowerVariable},Type{T},Type{#s118} where #s118&lt;:PowerSimulations.AbstractHydroUnitCommitment,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Nothing,Bool,Bool}} where T&lt;:HydroGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a></li><li><a href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ActivePowerVariable},Type{T},Type{#s118} where #s118&lt;:PowerSimulations.AbstractThermalUnitCommitment,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Nothing,Bool,Bool}} where T&lt;:ThermalGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a></li><li><a href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ReactivePowerVariable},Type{T},Type{#s118} where #s118&lt;:PowerSimulations.AbstractHydroUnitCommitment,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Nothing,Bool,Bool}} where T&lt;:HydroGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a></li><li><a href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ReactivePowerVariable},Type{T},Type{#s118} where #s118&lt;:PowerSimulations.AbstractHydroDispatchFormulation,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward},Bool,Bool}} where T&lt;:HydroGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a></li><li><a href="#PowerSimulations.FlowActivePowerVariable"><code>PowerSimulations.FlowActivePowerVariable</code></a></li><li><a href="#PowerSimulations.HdfSimulationStore"><code>PowerSimulations.HdfSimulationStore</code></a></li><li><a href="#PowerSimulations.IntraStageChronology"><code>PowerSimulations.IntraStageChronology</code></a></li><li><a href="#PowerSimulations.NodalExpressionSpec-Union{Tuple{U}, Tuple{T}, Tuple{Type{T},Type{U},Bool}} where U&lt;:PowerModels.AbstractPowerModel where T&lt;:Device"><code>PowerSimulations.NodalExpressionSpec</code></a></li><li><a href="#PowerSimulations.OperationsProblem-Union{Tuple{T}, Tuple{M}, Tuple{Type{M},Type{T},System}, Tuple{Type{M},Type{T},System,Union{Nothing, JuMP.AbstractModel}}} where T&lt;:PowerModels.AbstractPowerModel where M&lt;:PowerSimulations.AbstractOperationsProblem"><code>PowerSimulations.OperationsProblem</code></a></li><li><a href="#PowerSimulations.OperationsProblem-Union{Tuple{T}, Tuple{Type{T},System}, Tuple{Type{T},System,Union{Nothing, JuMP.AbstractModel}}} where T&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.OperationsProblem</code></a></li><li><a href="#PowerSimulations.OperationsProblem-Union{Tuple{M}, Tuple{Type{M},OperationsProblemTemplate,System}, Tuple{Type{M},OperationsProblemTemplate,System,Union{Nothing, JuMP.AbstractModel}}} where M&lt;:PowerSimulations.AbstractOperationsProblem"><code>PowerSimulations.OperationsProblem</code></a></li><li><a href="#PowerSimulations.OperationsProblem-Tuple{AbstractString}"><code>PowerSimulations.OperationsProblem</code></a></li><li><a href="#PowerSimulations.OperationsProblemTemplate-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.OperationsProblemTemplate</code></a></li><li><a href="#PowerSimulations.ParamResultCache"><code>PowerSimulations.ParamResultCache</code></a></li><li><a href="#PowerSimulations.RecedingHorizon"><code>PowerSimulations.RecedingHorizon</code></a></li><li><a href="#PowerSimulations.ResultCache"><code>PowerSimulations.ResultCache</code></a></li><li><a href="#PowerSimulations.Simulation"><code>PowerSimulations.Simulation</code></a></li><li><a href="#PowerSimulations.Simulation-Tuple{AbstractString,Dict}"><code>PowerSimulations.Simulation</code></a></li><li><a href="#PowerSimulations.SimulationResults-Tuple{Simulation}"><code>PowerSimulations.SimulationResults</code></a></li><li><a href="#PowerSimulations.SimulationResults"><code>PowerSimulations.SimulationResults</code></a></li><li><a href="#PowerSimulations.SimulationSequence"><code>PowerSimulations.SimulationSequence</code></a></li><li><a href="#PowerSimulations.SimulationStore"><code>PowerSimulations.SimulationStore</code></a></li><li><a href="#PowerSimulations.Stage"><code>PowerSimulations.Stage</code></a></li><li><a href="#PowerSimulations.Stage-Union{Tuple{M}, Tuple{Type{M},OperationsProblemTemplate,System,MathOptInterface.OptimizerWithAttributes}, Tuple{Type{M},OperationsProblemTemplate,System,MathOptInterface.OptimizerWithAttributes,Union{Nothing, JuMP.AbstractModel}}} where M&lt;:PowerSimulations.AbstractOperationsProblem"><code>PowerSimulations.Stage</code></a></li><li><a href="#PowerSimulations.StageDatasets"><code>PowerSimulations.StageDatasets</code></a></li><li><a href="#PowerSimulations.StageResults"><code>PowerSimulations.StageResults</code></a></li><li><a href="#PowerSimulations.Synchronize"><code>PowerSimulations.Synchronize</code></a></li><li><a href="#PowerSimulations.TimeStatusChange"><code>PowerSimulations.TimeStatusChange</code></a></li><li><a href="#PowerSimulations.UnitCommitmentProblem-Tuple{System}"><code>PowerSimulations.UnitCommitmentProblem</code></a></li><li><a href="#PowerSimulations.UpdateRef"><code>PowerSimulations.UpdateRef</code></a></li><li><a href="#Base.show-Tuple{IO,MIME{Symbol(&quot;text/plain&quot;)},OperationsProblem}"><code>Base.show</code></a></li><li><a href="#PowerSimulations._allocate_execution_order-Tuple{Dict{Int64,Int64}}"><code>PowerSimulations._allocate_execution_order</code></a></li><li><a href="#PowerSimulations._calculate_interval_inner_counts-Tuple{Dict{Int64,String},Dict{String,Tuple{Dates.TimePeriod,#s122} where #s122&lt;:PowerSimulations.FeedForwardChronology},Dates.TimePeriod}"><code>PowerSimulations._calculate_interval_inner_counts</code></a></li><li><a href="#PowerSimulations._get_data_for_rocc-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,Type{T}}} where T&lt;:ThermalGen"><code>PowerSimulations._get_data_for_rocc</code></a></li><li><a href="#PowerSimulations._get_data_for_tdc-Tuple{Array{InitialCondition,1},Array{InitialCondition,1},Dates.TimePeriod}"><code>PowerSimulations._get_data_for_tdc</code></a></li><li><a href="#PowerSimulations._get_data_startup_ic-Tuple{Array{InitialCondition,1}}"><code>PowerSimulations._get_data_startup_ic</code></a></li><li><a href="#PowerSimulations._update_stage!-Tuple{Stage,Simulation}"><code>PowerSimulations._update_stage!</code></a></li><li><a href="#PowerSimulations.add_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{St}, Tuple{PowerSimulations.PSIContainer,Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ReactivePowerVariable},InfrastructureSystems.FlattenIteratorWrapper{St},DeviceModel{St,D},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractStorageFormulation where St&lt;:Storage"><code>PowerSimulations.add_constraints!</code></a></li><li><a href="#PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,Type{T},Type{U},InfrastructureSystems.FlattenIteratorWrapper{V},DeviceModel{V,W},Type{X},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where X&lt;:PowerModels.AbstractPowerModel where W&lt;:PowerSimulations.AbstractDeviceFormulation where V&lt;:Device where U&lt;:PowerSimulations.VariableType where T&lt;:PowerSimulations.RangeConstraint"><code>PowerSimulations.add_constraints!</code></a></li><li><a href="#PowerSimulations.add_result!-Tuple{PowerSimulations.ParamResultCache,Any,Any,Any}"><code>PowerSimulations.add_result!</code></a></li><li><a href="#PowerSimulations.add_to_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,MarketBidCost,ThermalMultiStart}"><code>PowerSimulations.add_to_cost!</code></a></li><li><a href="#PowerSimulations.add_to_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,TwoPartCost,Component}"><code>PowerSimulations.add_to_cost!</code></a></li><li><a href="#PowerSimulations.add_to_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,ThreePartCost,Component}"><code>PowerSimulations.add_to_cost!</code></a></li><li><a href="#PowerSimulations.add_to_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,MultiStartCost,Component}"><code>PowerSimulations.add_to_cost!</code></a></li><li><a href="#PowerSimulations.add_to_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,MarketBidCost,Component}"><code>PowerSimulations.add_to_cost!</code></a></li><li><a href="#PowerSimulations.add_variable!-Union{Tuple{U}, Tuple{D}, Tuple{PowerSimulations.PSIContainer,PowerSimulations.VariableType,U}} where U&lt;:Union{Array{D,1}, InfrastructureSystems.FlattenIteratorWrapper{D}} where D&lt;:Component"><code>PowerSimulations.add_variable!</code></a></li><li><a href="#PowerSimulations.add_variables!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,Type{T},U,Array{V,1}}} where V&lt;:Device where U&lt;:Reserve where T&lt;:PowerSimulations.VariableType"><code>PowerSimulations.add_variables!</code></a></li><li><a href="#PowerSimulations.add_variables!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,Type{T},Union{Array{U,1}, InfrastructureSystems.FlattenIteratorWrapper{U}}}} where U&lt;:Component where T&lt;:PowerSimulations.VariableType"><code>PowerSimulations.add_variables!</code></a></li><li><a href="#PowerSimulations.add_variables!-Tuple{PowerSimulations.PSIContainer,Type{PowerSimulations.SteadyStateFrequencyDeviation}}"><code>PowerSimulations.add_variables!</code></a></li><li><a href="#PowerSimulations.build!-Tuple{Simulation}"><code>PowerSimulations.build!</code></a></li><li><a href="#PowerSimulations.check_activeservice_variables-Tuple{PowerSimulations.PSIContainer,Array{#s120,1} where #s120&lt;:Service}"><code>PowerSimulations.check_activeservice_variables</code></a></li><li><a href="#PowerSimulations.check_file_integrity-Tuple{String}"><code>PowerSimulations.check_file_integrity</code></a></li><li><a href="#PowerSimulations.commit_hydro_active_power_ub!-Union{Tuple{W}, Tuple{V}, Tuple{PowerSimulations.PSIContainer,Any,DeviceModel{V,W},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where W&lt;:PowerSimulations.AbstractHydroUnitCommitment where V&lt;:HydroGen"><code>PowerSimulations.commit_hydro_active_power_ub!</code></a></li><li><a href="#PowerSimulations.commitment_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,D},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalUnitCommitment where T&lt;:ThermalGen"><code>PowerSimulations.commitment_constraints!</code></a></li><li><a href="#PowerSimulations.compute_sha256-Tuple{AbstractString}"><code>PowerSimulations.compute_sha256</code></a></li><li><a href="#PowerSimulations.constraint_current_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel,Int64}"><code>PowerSimulations.constraint_current_balance_ni_expr</code></a></li><li><a href="#PowerSimulations.constraint_current_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel,Int64,Int64,Any,Any,Any,Any}"><code>PowerSimulations.constraint_current_balance_ni_expr</code></a></li><li><a href="#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractActivePowerModel,Int64,Int64,Any,Any,Any,Any}"><code>PowerSimulations.constraint_power_balance_ni_expr</code></a></li><li><a href="#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel,Int64,Int64,Any,Any,Any,Any}"><code>PowerSimulations.constraint_power_balance_ni_expr</code></a></li><li><a href="#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel,Int64}"><code>PowerSimulations.constraint_power_balance_ni_expr</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,HydroCommitmentReservoirStorage},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where H&lt;:HydroEnergyReservoir"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,D},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where D&lt;:HydroCommitmentReservoirBudget where H&lt;:HydroGen"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,HydroDispatchReservoirBudget},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where H&lt;:HydroEnergyReservoir"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,HydroDispatchReservoirStorage},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where H&lt;:HydroEnergyReservoir"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,D},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where D&lt;:HydroCommitmentRunOfRiver where H&lt;:HydroGen"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:HydroCommitmentReservoirBudget where H&lt;:HydroGen"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{T,D},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where D&lt;:PowerSimulations.AbstractThermalUnitCommitment where T&lt;:ThermalGen"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{T,D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalUnitCommitment where T&lt;:ThermalGen"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:HydroCommitmentRunOfRiver where H&lt;:HydroGen"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{T,ThermalRampLimited},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where T&lt;:ThermalGen"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{T,ThermalBasicUnitCommitment},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where T&lt;:ThermalGen"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,D},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where D&lt;:PowerSimulations.AbstractHydroDispatchFormulation where H&lt;:HydroGen"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,HydroDispatchReservoirBudget},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where H&lt;:HydroEnergyReservoir"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,HydroDispatchPumpedStoragewReservation},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where H&lt;:HydroPumpedStorage"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractHydroDispatchFormulation where H&lt;:HydroGen"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,HydroCommitmentReservoirStorage},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where H&lt;:HydroEnergyReservoir"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{RegulationDevice{T},ReserveLimitedRegulation},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where T&lt;:StaticInjection"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,HydroDispatchPumpedStorage},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where H&lt;:HydroPumpedStorage"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{T,ThermalBasicUnitCommitment},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where T&lt;:ThermalGen"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{RegulationDevice{T},FixedOutput},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where T&lt;:StaticInjection"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,HydroDispatchReservoirStorage},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where H&lt;:HydroEnergyReservoir"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,FixedOutput},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where H&lt;:HydroGen"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{T,ThermalRampLimited},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where T&lt;:ThermalGen"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{RegulationDevice{T},DeviceLimitedRegulation},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where T&lt;:StaticInjection"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_service!-Union{Tuple{SR}, Tuple{PowerSimulations.PSIContainer,Array{SR,1},System,ServiceModel{SR,GroupReserve},Dict{Symbol,DeviceModel},Array{#s120,1} where #s120&lt;:DataType}} where SR&lt;:StaticReserveGroup"><code>PowerSimulations.construct_service!</code></a></li><li><a href="#PowerSimulations.container_spec-Union{Tuple{M}, Tuple{M,Vararg{Any,N} where N}} where M&lt;:JuMP.AbstractModel"><code>PowerSimulations.container_spec</code></a></li><li><a href="#PowerSimulations.cost_function!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,U},Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,U},Type{#s116} where #s116&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where U&lt;:PowerSimulations.AbstractStorageFormulation where T&lt;:Storage"><code>PowerSimulations.cost_function!</code></a></li><li><a href="#PowerSimulations.cost_function!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,U},Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,U},Type{#s116} where #s116&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where U&lt;:PowerSimulations.AbstractDeviceFormulation where T&lt;:Component"><code>PowerSimulations.cost_function!</code></a></li><li><a href="#PowerSimulations.cost_function!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,ThermalDispatchNoMin},Type{#s119} where #s119&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where T&lt;:ThermalGen"><code>PowerSimulations.cost_function!</code></a></li><li><a href="#PowerSimulations.device_commitment!-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_commitment!</code></a></li><li><a href="#PowerSimulations.device_duration_compact_retrospective!-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_duration_compact_retrospective!</code></a></li><li><a href="#PowerSimulations.device_duration_look_ahead!-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_duration_look_ahead!</code></a></li><li><a href="#PowerSimulations.device_duration_parameters!-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_duration_parameters!</code></a></li><li><a href="#PowerSimulations.device_duration_retrospective!-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_duration_retrospective!</code></a></li><li><a href="#PowerSimulations.device_energy_budget_param_ub-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1},Symbol,PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.device_energy_budget_param_ub</code></a></li><li><a href="#PowerSimulations.device_energy_budget_ub-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1},Symbol,Symbol}"><code>PowerSimulations.device_energy_budget_ub</code></a></li><li><a href="#PowerSimulations.device_linear_rateofchange!-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRampConstraintInfo,1},Symbol,Symbol}"><code>PowerSimulations.device_linear_rateofchange!</code></a></li><li><a href="#PowerSimulations.device_mixedinteger_rateofchange!-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRampConstraintInfo,1},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_mixedinteger_rateofchange!</code></a></li><li><a href="#PowerSimulations.device_multistart_range!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.RangeConstraintSpecInternal}"><code>PowerSimulations.device_multistart_range!</code></a></li><li><a href="#PowerSimulations.device_multistart_range_ic!-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceMultiStartRangeConstraintsInfo,1},Array{InitialCondition,2},Symbol,Symbol}"><code>PowerSimulations.device_multistart_range_ic!</code></a></li><li><a href="#PowerSimulations.device_multistart_rateofchange!-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRampConstraintInfo,1},Symbol,Symbol}"><code>PowerSimulations.device_multistart_rateofchange!</code></a></li><li><a href="#PowerSimulations.device_range!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.RangeConstraintSpecInternal}"><code>PowerSimulations.device_range!</code></a></li><li><a href="#PowerSimulations.device_semicontinuousrange!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.RangeConstraintSpecInternal}"><code>PowerSimulations.device_semicontinuousrange!</code></a></li><li><a href="#PowerSimulations.device_start_type_constraint-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceStartTypesConstraintInfo,1},Symbol,Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_start_type_constraint</code></a></li><li><a href="#PowerSimulations.device_startup_initial_condition-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceStartUpConstraintInfo,1},Array{InitialCondition,1},Symbol,Tuple{Symbol,Symbol},Symbol}"><code>PowerSimulations.device_startup_initial_condition</code></a></li><li><a href="#PowerSimulations.device_timeseries_lb!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.TimeSeriesConstraintSpecInternal}"><code>PowerSimulations.device_timeseries_lb!</code></a></li><li><a href="#PowerSimulations.device_timeseries_param_lb!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.TimeSeriesConstraintSpecInternal}"><code>PowerSimulations.device_timeseries_param_lb!</code></a></li><li><a href="#PowerSimulations.device_timeseries_param_ub!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.TimeSeriesConstraintSpecInternal}"><code>PowerSimulations.device_timeseries_param_ub!</code></a></li><li><a href="#PowerSimulations.device_timeseries_ub!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.TimeSeriesConstraintSpecInternal}"><code>PowerSimulations.device_timeseries_ub!</code></a></li><li><a href="#PowerSimulations.device_timeseries_ub_bigM!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.TimeSeriesConstraintSpecInternal}"><code>PowerSimulations.device_timeseries_ub_bigM!</code></a></li><li><a href="#PowerSimulations.device_timeseries_ub_bin!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.TimeSeriesConstraintSpecInternal}"><code>PowerSimulations.device_timeseries_ub_bin!</code></a></li><li><a href="#PowerSimulations.energy_balance-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Tuple{Array{String,1},Array{NamedTuple{(:in, :out),Tuple{Float64,Float64}},1}},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.energy_balance</code></a></li><li><a href="#PowerSimulations.energy_balance_constraint!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{H},DeviceModel{H,S},Type{#s119} where #s119&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:Union{HydroCommitmentReservoirStorage, HydroDispatchReservoirStorage} where H&lt;:HydroEnergyReservoir"><code>PowerSimulations.energy_balance_constraint!</code></a></li><li><a href="#PowerSimulations.energy_balance_constraint!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{H},DeviceModel{H,S},Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:Union{HydroDispatchPumpedStorage, HydroDispatchPumpedStoragewReservation} where H&lt;:HydroPumpedStorage"><code>PowerSimulations.energy_balance_constraint!</code></a></li><li><a href="#PowerSimulations.energy_balance_hydro!-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Tuple{Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1},Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1}},Tuple{Symbol,Symbol},Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.energy_balance_hydro!</code></a></li><li><a href="#PowerSimulations.energy_balance_hydro!-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Tuple{Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1},Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1}},Tuple{Symbol,Symbol},NTuple{5,Symbol}}"><code>PowerSimulations.energy_balance_hydro!</code></a></li><li><a href="#PowerSimulations.energy_balance_hydro_param!-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Tuple{Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1},Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1}},Tuple{Symbol,Symbol},NTuple{5,Symbol},Tuple{PowerSimulations.UpdateRef,PowerSimulations.UpdateRef}}"><code>PowerSimulations.energy_balance_hydro_param!</code></a></li><li><a href="#PowerSimulations.energy_balance_hydro_param!-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Tuple{Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1},Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1}},Tuple{Symbol,Symbol},Tuple{Symbol,Symbol,Symbol},Tuple{PowerSimulations.UpdateRef,PowerSimulations.UpdateRef}}"><code>PowerSimulations.energy_balance_hydro_param!</code></a></li><li><a href="#PowerSimulations.energy_budget_constraints!-Union{Tuple{H}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{H},DeviceModel{H,#s118} where #s118&lt;:PowerSimulations.AbstractHydroFormulation,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where H&lt;:HydroGen"><code>PowerSimulations.energy_budget_constraints!</code></a></li><li><a href="#PowerSimulations.energy_soft_target-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceEnergyTargetConstraintInfo,1},Symbol,Tuple{Symbol,Symbol}}"><code>PowerSimulations.energy_soft_target</code></a></li><li><a href="#PowerSimulations.execute!-Tuple{Simulation}"><code>PowerSimulations.execute!</code></a></li><li><a href="#PowerSimulations.export_operations_model-Tuple{OperationsProblem,String}"><code>PowerSimulations.export_operations_model</code></a></li><li><a href="#PowerSimulations.export_results-Tuple{SimulationResults,Any}"><code>PowerSimulations.export_results</code></a></li><li><a href="#PowerSimulations.find_key_with_value-Tuple{Any,Any}"><code>PowerSimulations.find_key_with_value</code></a></li><li><a href="#PowerSimulations.frequency_response_constraint!-Tuple{PowerSimulations.PSIContainer,System}"><code>PowerSimulations.frequency_response_constraint!</code></a></li><li><a href="#PowerSimulations.get_all_constraint_index-Tuple{OperationsProblem}"><code>PowerSimulations.get_all_constraint_index</code></a></li><li><a href="#PowerSimulations.get_all_var_index-Tuple{OperationsProblem}"><code>PowerSimulations.get_all_var_index</code></a></li><li><a href="#PowerSimulations.h5_store_open"><code>PowerSimulations.h5_store_open</code></a></li><li><a href="#PowerSimulations.has_dirty-Tuple{PowerSimulations.ResultCache}"><code>PowerSimulations.has_dirty</code></a></li><li><a href="#PowerSimulations.initial_condition_update!-Tuple{Stage,PowerSimulations.ICKey,Array{InitialCondition,1},InterStageChronology,Simulation}"><code>PowerSimulations.initial_condition_update!</code></a></li><li><a href="#PowerSimulations.initial_condition_update!-Tuple{Stage,PowerSimulations.ICKey,Array{InitialCondition,1},IntraStageChronology,Simulation}"><code>PowerSimulations.initial_condition_update!</code></a></li><li><a href="#PowerSimulations.initial_range_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,D},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractCompactUnitCommitment where T&lt;:ThermalMultiStart"><code>PowerSimulations.initial_range_constraints!</code></a></li><li><a href="#PowerSimulations.instantiate_bfp_expr-Tuple{PowerModels.AbstractPowerModel}"><code>PowerSimulations.instantiate_bfp_expr</code></a></li><li><a href="#PowerSimulations.instantiate_nip_expr-Tuple{PowerModels.AbstractPowerModel}"><code>PowerSimulations.instantiate_nip_expr</code></a></li><li><a href="#PowerSimulations.instantiate_nip_expr_model-Tuple{Dict{String,Any},Any}"><code>PowerSimulations.instantiate_nip_expr_model</code></a></li><li><a href="#PowerSimulations.integral_limit_ff-Tuple{PowerSimulations.PSIContainer,Symbol,PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.integral_limit_ff</code></a></li><li><a href="#PowerSimulations.is_cached-Tuple{PowerSimulations.ResultCache,Any,Any,Any,Any}"><code>PowerSimulations.is_cached</code></a></li><li><a href="#PowerSimulations.iterate_initial_conditions-Tuple{PowerSimulations.InitialConditions}"><code>PowerSimulations.iterate_initial_conditions</code></a></li><li><a href="#PowerSimulations.list_fields-Tuple{PowerSimulations.HdfSimulationStore,Symbol,Symbol}"><code>PowerSimulations.list_fields</code></a></li><li><a href="#PowerSimulations.list_simulation_events-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent"><code>PowerSimulations.list_simulation_events</code></a></li><li><a href="#PowerSimulations.list_stages-Tuple{PowerSimulations.HdfSimulationStore}"><code>PowerSimulations.list_stages</code></a></li><li><a href="#PowerSimulations.list_stages-Tuple{SimulationResults}"><code>PowerSimulations.list_stages</code></a></li><li><a href="#PowerSimulations.load_results!-Tuple{StageResults,Int64}"><code>PowerSimulations.load_results!</code></a></li><li><a href="#PowerSimulations.log_cache_hit_percentages-Tuple{PowerSimulations.ResultCache}"><code>PowerSimulations.log_cache_hit_percentages</code></a></li><li><a href="#PowerSimulations.must_run_constraints!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{ThermalMultiStart},DeviceModel{ThermalMultiStart,ThermalMultiStartUnitCommitment},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.must_run_constraints!</code></a></li><li><a href="#PowerSimulations.nodal_expression!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},Type{U}}} where U&lt;:PowerModels.AbstractPowerModel where T&lt;:Device"><code>PowerSimulations.nodal_expression!</code></a></li><li><a href="#PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,Type{S},System}, Tuple{PowerSimulations.PSIContainer,Type{S},System,Any}} where S&lt;:PowerModels.AbstractActivePowerModel"><code>PowerSimulations.powermodels_network!</code></a></li><li><a href="#PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,Type{S},System}, Tuple{PowerSimulations.PSIContainer,Type{S},System,Any}} where S&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.powermodels_network!</code></a></li><li><a href="#PowerSimulations.pwl_gencost_linear!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,String,Array{Tuple{Float64,Float64},1},Int64}"><code>PowerSimulations.pwl_gencost_linear!</code></a></li><li><a href="#PowerSimulations.pwl_gencost_sos!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,String,Array{Tuple{Float64,Float64},1},Int64}"><code>PowerSimulations.pwl_gencost_sos!</code></a></li><li><a href="#PowerSimulations.pwlparamcheck-Tuple{Any}"><code>PowerSimulations.pwlparamcheck</code></a></li><li><a href="#PowerSimulations.ramp_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,D},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalUnitCommitment where T&lt;:ThermalGen"><code>PowerSimulations.ramp_constraints!</code></a></li><li><a href="#PowerSimulations.range_ff-Tuple{PowerSimulations.PSIContainer,Symbol,Array{PowerSimulations.DeviceRangeConstraintInfo,1},Tuple{PowerSimulations.UpdateRef,PowerSimulations.UpdateRef},Symbol}"><code>PowerSimulations.range_ff</code></a></li><li><a href="#PowerSimulations.rating_constraint!-Tuple{PowerSimulations.PSIContainer,Array{Tuple{String,Float64},1},Symbol,Tuple{Symbol,Symbol}}"><code>PowerSimulations.rating_constraint!</code></a></li><li><a href="#PowerSimulations.read_dataframe-Tuple{AbstractString}"><code>PowerSimulations.read_dataframe</code></a></li><li><a href="#PowerSimulations.read_dual-Tuple{StageResults,Symbol}"><code>PowerSimulations.read_dual</code></a></li><li><a href="#PowerSimulations.read_duals-Tuple{StageResults}"><code>PowerSimulations.read_duals</code></a></li><li><a href="#PowerSimulations.read_json-Tuple{AbstractString}"><code>PowerSimulations.read_json</code></a></li><li><a href="#PowerSimulations.read_parameter-Tuple{StageResults,Symbol}"><code>PowerSimulations.read_parameter</code></a></li><li><a href="#PowerSimulations.read_parameters-Tuple{StageResults}"><code>PowerSimulations.read_parameters</code></a></li><li><a href="#PowerSimulations.read_realized_duals-Tuple{StageResults}"><code>PowerSimulations.read_realized_duals</code></a></li><li><a href="#PowerSimulations.read_realized_parameters-Tuple{StageResults}"><code>PowerSimulations.read_realized_parameters</code></a></li><li><a href="#PowerSimulations.read_realized_variables-Tuple{StageResults}"><code>PowerSimulations.read_realized_variables</code></a></li><li><a href="#PowerSimulations.read_result-Tuple{Type{DataFrames.DataFrame},PowerSimulations.HdfSimulationStore,Any,Any,Any,Dates.DateTime}"><code>PowerSimulations.read_result</code></a></li><li><a href="#PowerSimulations.read_result-Tuple{PowerSimulations.ResultCache,Any,Any,Any,Any}"><code>PowerSimulations.read_result</code></a></li><li><a href="#PowerSimulations.read_variable-Tuple{StageResults,Symbol}"><code>PowerSimulations.read_variable</code></a></li><li><a href="#PowerSimulations.read_variables-Tuple{StageResults}"><code>PowerSimulations.read_variables</code></a></li><li><a href="#PowerSimulations.remove_chars-Tuple{String,String}"><code>PowerSimulations.remove_chars</code></a></li><li><a href="#PowerSimulations.replace_chars-Tuple{String,String,String}"><code>PowerSimulations.replace_chars</code></a></li><li><a href="#PowerSimulations.reserve_device_semicontinuousrange!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.RangeConstraintSpecInternal}"><code>PowerSimulations.reserve_device_semicontinuousrange!</code></a></li><li><a href="#PowerSimulations.semicontinuousrange_ff-Tuple{PowerSimulations.PSIContainer,Symbol,Array{PowerSimulations.DeviceRangeConstraintInfo,1},PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.semicontinuousrange_ff</code></a></li><li><a href="#PowerSimulations.serialize_simulation-Tuple{Simulation}"><code>PowerSimulations.serialize_simulation</code></a></li><li><a href="#PowerSimulations.service_requirement_constraint!-Union{Tuple{SR}, Tuple{PowerSimulations.PSIContainer,SR,ServiceModel{SR,GroupReserve},Array{#s119,1} where #s119&lt;:Service}} where SR&lt;:StaticReserveGroup"><code>PowerSimulations.service_requirement_constraint!</code></a></li><li><a href="#PowerSimulations.set_variable_bounds!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRangeConstraintInfo,1},AbstractString,Type{T}}} where T&lt;:Component"><code>PowerSimulations.set_variable_bounds!</code></a></li><li><a href="#PowerSimulations.show_recorder_events-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent"><code>PowerSimulations.show_recorder_events</code></a></li><li><a href="#PowerSimulations.show_simulation_events-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent"><code>PowerSimulations.show_simulation_events</code></a></li><li><a href="#PowerSimulations.solve!-Union{Tuple{OperationsProblem{T}}, Tuple{T}} where T&lt;:PowerSimulations.AbstractOperationsProblem"><code>PowerSimulations.solve!</code></a></li><li><a href="#PowerSimulations.sparse_container_spec-Union{Tuple{M}, Tuple{M,Vararg{Any,N} where N}} where M&lt;:JuMP.AbstractModel"><code>PowerSimulations.sparse_container_spec</code></a></li><li><a href="#PowerSimulations.startup_initial_condition_constraints!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{ThermalMultiStart},DeviceModel{ThermalMultiStart,ThermalMultiStartUnitCommitment},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.startup_initial_condition_constraints!</code></a></li><li><a href="#PowerSimulations.startup_time_constraints!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{ThermalMultiStart},DeviceModel{ThermalMultiStart,ThermalMultiStartUnitCommitment},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.startup_time_constraints!</code></a></li><li><a href="#PowerSimulations.startup_type_constraints!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{ThermalMultiStart},DeviceModel{ThermalMultiStart,ThermalMultiStartUnitCommitment},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.startup_type_constraints!</code></a></li><li><a href="#PowerSimulations.status_init-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:ThermalGen"><code>PowerSimulations.status_init</code></a></li><li><a href="#PowerSimulations.template_agc_reserve_deployment-Tuple{}"><code>PowerSimulations.template_agc_reserve_deployment</code></a></li><li><a href="#PowerSimulations.template_economic_dispatch-Tuple{}"><code>PowerSimulations.template_economic_dispatch</code></a></li><li><a href="#PowerSimulations.template_unit_commitment-Tuple{}"><code>PowerSimulations.template_unit_commitment</code></a></li><li><a href="#PowerSimulations.turbine_temperature-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceStartUpConstraintInfo,1},Symbol,Symbol,Tuple{Symbol,Symbol}}"><code>PowerSimulations.turbine_temperature</code></a></li><li><a href="#PowerSimulations.ub_ff-Tuple{PowerSimulations.PSIContainer,Symbol,Array{PowerSimulations.DeviceRangeConstraintInfo,1},PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.ub_ff</code></a></li><li><a href="#PowerSimulations.update_parameter!-Tuple{PowerSimulations.UpdateRef{JuMP.VariableRef},PowerSimulations.ParameterContainer,Stage,Simulation}"><code>PowerSimulations.update_parameter!</code></a></li><li><a href="#PowerSimulations.update_stage!-Union{Tuple{M}, Tuple{Stage{M},Simulation}} where M&lt;:PowerSimulations.PowerSimulationsOperationsProblem"><code>PowerSimulations.update_stage!</code></a></li><li><a href="#PowerSimulations.variable_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,String,VariableCost{Float64},Int64}"><code>PowerSimulations.variable_cost!</code></a></li><li><a href="#PowerSimulations.variable_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,String,Nothing,Int64}"><code>PowerSimulations.variable_cost!</code></a></li><li><a href="#PowerSimulations.variable_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,String,VariableCost{Array{Tuple{Float64,Float64},1}},Int64}"><code>PowerSimulations.variable_cost!</code></a></li><li><a href="#PowerSimulations.variable_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,String,VariableCost{Tuple{Float64,Float64}},Int64}"><code>PowerSimulations.variable_cost!</code></a></li><li><a href="#PowerSimulations.variable_reactive_net_injection-Tuple{PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.variable_reactive_net_injection</code></a></li><li><a href="#PowerSimulations.write_psi_container-Tuple{PowerSimulations.PSIContainer,String}"><code>PowerSimulations.write_psi_container</code></a></li><li><a href="#PowerSimulations.write_result!-Tuple{PowerSimulations.HdfSimulationStore,Any,Any,Any,Any,Any}"><code>PowerSimulations.write_result!</code></a></li></ul><h2 id="Exported"><a class="docs-heading-anchor" href="#Exported">Exported</a><a id="Exported-1"></a><a class="docs-heading-anchor-permalink" href="#Exported" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.AGCReserveDeployment-Tuple{System}" href="#PowerSimulations.AGCReserveDeployment-Tuple{System}"><code>PowerSimulations.AGCReserveDeployment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">AGCReserveDeployment(system::PSY.System; kwargs...)</code></pre><p>Creates an <code>OperationsProblemTemplate</code> with default DeviceModels for an AGC Reserve Deplyoment Problem. Uses the template to create an <code>OperationsProblem</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">agc_problem = AGCReserveDeployment(system)</code></pre><p><strong>Accepted Key Words</strong></p><ul><li>Key word arguments supported by <code>OperationsProblem</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/operations_problems_templates.jl#L215-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceModel" href="#PowerSimulations.DeviceModel"><code>PowerSimulations.DeviceModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DeviceModel(::Type{D}, ::Type{B}) where {D&lt;:PSY.Device,
                                   B&lt;:AbstractDeviceFormulation}</code></pre><p>This validates the device formulation for the Power System Device and the abstract device formulation and returns  Power System Device and the abstract device formulation if the power system device is a concrete type.</p><p><strong>Arguments</strong></p><p>-<code>::Type{D}</code>: Power System Device -<code>::Type{B}</code>: Abstract Device Formulation</p><p><strong>Outputs</strong></p><p><code>DeviceModel(D, B, nothing)</code>: D::PSY.Device, B::AbstractDeviceFormulation</p><p><strong>Example</strong></p><pre><code class="language-julia">branches = Dict{Symbol, DeviceModel}
    (:L =&gt; DeviceModel(PSY.Line, StaticLine),
    :T =&gt; DeviceModel(PSY.Transformer2W, StaticTransformer),
    :TT =&gt; DeviceModel(PSY.TapTransformer , StaticTransformer),
    :dc_line =&gt; DeviceModel(PSY.HVDCLine, HVDCDispatch))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/models.jl#L28-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.IntraStageChronology" href="#PowerSimulations.IntraStageChronology"><code>PowerSimulations.IntraStageChronology</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InterStageChronology()

Type struct to select an information sharing model between stages that uses results from the same recent stage to calculate the initial conditions. This model ignores solutions from stages defined finer resolutions.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/initial_condition_types.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.OperationsProblem-Tuple{AbstractString}" href="#PowerSimulations.OperationsProblem-Tuple{AbstractString}"><code>PowerSimulations.OperationsProblem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">OperationsProblem(filename::AbstractString)</code></pre><p>Construct an OperationsProblem from a serialized file.</p><p><strong>Arguments</strong></p><ul><li><code>filename::AbstractString</code>: path to serialized file</li><li><code>jump_model::Union{Nothing, JuMP.AbstractModel}</code> = nothing: The JuMP model does not get  serialized. Callers should pass whatever they passed to the original problem.</li><li><code>optimizer::Union{Nothing,JuMP.MOI.OptimizerWithAttributes}</code> = nothing: The optimizer does  not get serialized. Callers should pass whatever they passed to the original problem.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/operations_problem.jl#L205-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.OperationsProblem-Union{Tuple{M}, Tuple{Type{M},OperationsProblemTemplate,System}, Tuple{Type{M},OperationsProblemTemplate,System,Union{Nothing, JuMP.AbstractModel}}} where M&lt;:PowerSimulations.AbstractOperationsProblem" href="#PowerSimulations.OperationsProblem-Union{Tuple{M}, Tuple{Type{M},OperationsProblemTemplate,System}, Tuple{Type{M},OperationsProblemTemplate,System,Union{Nothing, JuMP.AbstractModel}}} where M&lt;:PowerSimulations.AbstractOperationsProblem"><code>PowerSimulations.OperationsProblem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">OperationsProblem(::Type{M},
template::OperationsProblemTemplate,
sys::PSY.System,
jump_model::Union{Nothing, JuMP.AbstractModel}=nothing;
kwargs...) where {M&lt;:AbstractOperationsProblem,
                  T&lt;:PM.AbstractPowerFormulation}</code></pre><p>This builds the optimization problem of type M with the specific system and template.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{M} where M&lt;:AbstractOperationsProblem</code>: The abstract operation model type</li><li><code>template::OperationsProblemTemplate</code>: The model reference made up of transmission, devices,                                         branches, and services.</li><li><code>sys::PSY.System</code>: the system created using Power Systems</li><li><code>jump_model::Union{Nothing, JuMP.AbstractModel}</code>: Enables passing a custom JuMP model. Use with care</li></ul><p><strong>Output</strong></p><ul><li><code>op_problem::OperationsProblem</code>: The operation model containing the model type, built JuMP model, Power</li></ul><p>Systems system.</p><p><strong>Example</strong></p><pre><code class="language-julia">template = OperationsProblemTemplate(CopperPlatePowerModel, devices, branches, services)
OpModel = OperationsProblem(TestOpProblem, template, system)</code></pre><p><strong>Accepted Key Words</strong></p><ul><li><code>horizon::Int</code>: Manually specify the length of the forecast Horizon</li><li><code>initial_time::Dates.DateTime</code>: Initial Time for the model solve</li><li><code>use_forecast_data::Bool</code>: If true uses the data in the system forecasts. If false uses the data for current operating point in the system.</li><li><code>PTDF::PTDF</code>: Passes the PTDF matrix into the optimization model for StandardPTDFModel networks.</li><li><code>optimizer::JuMP.MOI.OptimizerWithAttributes</code>: The optimizer that will be used in the optimization model.</li><li><code>use_parameters::Bool</code>: True will substitute will implement formulations using ParameterJuMP parameters. Defatul is false.</li><li><code>warm_start::Bool</code>: True will use the current operation point in the system to initialize variable values. False initializes all variables to zero. Default is true</li><li><code>balance_slack_variables::Bool</code>: True will add slacks to the system balance constraints</li><li><code>services_slack_variables::Bool</code>: True will add slacks to the services requirement constraints</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/operations_problem.jl#L9-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.OperationsProblem-Union{Tuple{T}, Tuple{M}, Tuple{Type{M},Type{T},System}, Tuple{Type{M},Type{T},System,Union{Nothing, JuMP.AbstractModel}}} where T&lt;:PowerModels.AbstractPowerModel where M&lt;:PowerSimulations.AbstractOperationsProblem" href="#PowerSimulations.OperationsProblem-Union{Tuple{T}, Tuple{M}, Tuple{Type{M},Type{T},System}, Tuple{Type{M},Type{T},System,Union{Nothing, JuMP.AbstractModel}}} where T&lt;:PowerModels.AbstractPowerModel where M&lt;:PowerSimulations.AbstractOperationsProblem"><code>PowerSimulations.OperationsProblem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">OperationsProblem(op_problem::Type{M},
                ::Type{T},
                sys::PSY.System,
                jump_model::Union{Nothing, JuMP.AbstractModel}=nothing;
                kwargs...) where {M&lt;:AbstractOperationsProblem,
                                  T&lt;:PM.AbstractPowerFormulation}</code></pre><p>Return an unbuilt operation problem of type M with the specific system and network model T.     This constructor doesn&#39;t build any device model; it is meant to built device models individually using <a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,D},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where D&lt;:HydroCommitmentReservoirBudget where H&lt;:HydroGen"><code>construct_device!</code></a></p><p><strong>Arguments</strong></p><ul><li><code>::Type{M} where M&lt;:AbstractOperationsProblem</code>: The abstract operation model type</li><li><code>::Type{T} where T&lt;:AbstractPowerModel</code>: The abstract network formulation</li><li><code>sys::PSY.System</code>: the system created using Power Systems</li><li><code>jump_model::Union{Nothing, JuMP.AbstractModel}</code>: Enables passing a custom JuMP model. Use with care</li></ul><p><strong>Output</strong></p><ul><li><code>op_problem::OperationsProblem</code>: The operation model containing the model type, unbuilt JuMP model, Power</li></ul><p>Systems system.</p><p><strong>Example</strong></p><pre><code class="language-julia">OpModel = OperationsProblem(MyCustomOpProblem, DCPPowerModel, system)
model = DeviceModel(ThermalStandard, ThermalStandardUnitCommitment)
construct_device!(op_problem, :Thermal, model)</code></pre><p><strong>Accepted Key Words</strong></p><ul><li><code>horizon::Int</code>: Manually specify the length of the forecast Horizon</li><li><code>initial_time::Dates.DateTime</code>: Initial Time for the model solve</li><li><code>use_forecast_data::Bool</code> : If true uses the data in the system forecasts. If false uses the data for current operating point in the system.</li><li><code>PTDF::PTDF</code>: Passes the PTDF matrix into the optimization model for StandardPTDFModel networks.</li><li><code>optimizer::JuMP.MOI.OptimizerWithAttributes</code>: The optimizer that will be used in the optimization model.</li><li><code>use_parameters::Bool</code>: True will substitute will implement formulations using ParameterJuMP parameters. Defatul is false.</li><li><code>warm_start::Bool</code>: True will use the current operation point in the system to initialize variable values. False initializes all variables to zero. Default is true</li><li><code>balance_slack_variables::Bool</code>: True will add slacks to the system balance constraints</li><li><code>services_slack_variables::Bool</code>: True will add slacks to the services requirement constraints</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/operations_problem.jl#L88-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.OperationsProblem-Union{Tuple{T}, Tuple{Type{T},System}, Tuple{Type{T},System,Union{Nothing, JuMP.AbstractModel}}} where T&lt;:PowerModels.AbstractPowerModel" href="#PowerSimulations.OperationsProblem-Union{Tuple{T}, Tuple{Type{T},System}, Tuple{Type{T},System,Union{Nothing, JuMP.AbstractModel}}} where T&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.OperationsProblem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">OperationsProblem(::Type{T},
                sys::PSY.System,
                jump_model::Union{Nothing, JuMP.AbstractModel}=nothing;
                kwargs...) where {M&lt;:AbstractOperationsProblem,
                                  T&lt;:PM.AbstractPowerFormulation}</code></pre><p>Return an unbuilt operation problem of type GenericOpProblem with the specific system and network model T.     This constructor doesn&#39;t build any device model; it is meant to built device models individually using <a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,D},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where D&lt;:HydroCommitmentReservoirBudget where H&lt;:HydroGen"><code>construct_device!</code></a></p><p><strong>Arguments</strong></p><ul><li><code>::Type{T} where T&lt;:AbstractPowerModel</code>: The abstract network formulation</li><li><code>sys::PSY.System</code>: the system created using Power Systems</li><li><code>jump_model::Union{Nothing, JuMP.AbstractModel}</code>: Enables passing a custom JuMP model. Use with care</li></ul><p><strong>Output</strong></p><ul><li><code>op_problem::OperationsProblem</code>: The operation model containing the model type, unbuilt JuMP model, Power Systems system.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">OpModel = OperationsProblem(DCPPowerModel, system)
model = DeviceModel(ThermalStandard, ThermalStandardUnitCommitment)
construct_device!(op_problem, :Thermal, model)</code></pre><p><strong>Accepted Key Words</strong></p><ul><li><code>horizon::Int</code>: Manually specify the length of the forecast Horizon</li><li><code>initial_time::Dates.DateTime</code>: Initial Time for the model solve</li><li><code>use_forecast_data::Bool</code> : If true uses the data in the system forecasts. If false uses the data for current operating point in the system.</li><li><code>PTDF::PTDF</code>: Passes the PTDF matrix into the optimization model for StandardPTDFModel networks.</li><li><code>optimizer::JuMP.MOI.OptimizerWithAttributes</code>: The optimizer that will be used in the optimization model.</li><li><code>use_parameters::Bool</code>: True will substitute will implement formulations using ParameterJuMP parameters. Defatul is false.</li><li><code>warm_start::Bool</code> True will use the current operation point in the system to initialize variable values. False initializes all variables to zero. Default is true</li><li><code>balance_slack_variables::Bool</code> True will add slacks to the system balance constraints</li><li><code>services_slack_variables::Bool</code> True will add slacks to the services requirement constraints</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/operations_problem.jl#L141-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.OperationsProblemTemplate-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:PowerModels.AbstractPowerModel" href="#PowerSimulations.OperationsProblemTemplate-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.OperationsProblemTemplate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">OperationsProblemTemplate(::Type{T}) where {T&lt;:PM.AbstractPowerFormulation}</code></pre><p>Creates a model reference of the Power Formulation, devices, branches, and services.</p><p><strong>Arguments</strong></p><ul><li><code>model::Type{T&lt;:PM.AbstractPowerFormulation}</code>:</li><li><code>devices::Dict{Symbol, DeviceModel}</code>: device dictionary</li><li><code>branches::Dict{Symbol, BranchModel}</code>: branch dictionary</li><li><code>services::Dict{Symbol, ServiceModel}</code>: service dictionary</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">template = OperationsProblemTemplate(CopperPlatePowerModel, devices, branches, services)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/operations_problem_template.jl#L8-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.RecedingHorizon" href="#PowerSimulations.RecedingHorizon"><code>PowerSimulations.RecedingHorizon</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RecedingHorizon(period::Int)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/feedforward.jl#L51-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.Simulation" href="#PowerSimulations.Simulation"><code>PowerSimulations.Simulation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Simulation(steps::Int
            stages::Dict{String, Stage{&lt;:AbstractOperationsProblem}}
            sequence::Union{Nothing, SimulationSequence}
            simulation_folder::String
            name::String
            internal::Union{Nothing, SimulationInternal}
            )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/simulation.jl#L214-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.Simulation-Tuple{AbstractString,Dict}" href="#PowerSimulations.Simulation-Tuple{AbstractString,Dict}"><code>PowerSimulations.Simulation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Simulation(directory::AbstractString)</code></pre><p>Constructs Simulation from a serialized directory. Callers should pass any kwargs here that they passed to the original Simulation.</p><p><strong>Arguments</strong></p><ul><li><code>directory::AbstractString</code>: the directory returned from the call to serialize</li><li><code>stage_info::Dict</code>: Two-level dictionary containing stage parameters that cannot be serialized. The outer dict should be keyed by the stage name. The inner dict must contain &#39;optimizer&#39; and may contain &#39;jump_model&#39;. These should be the same values used for the original simulation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/simulation.jl#L245-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.SimulationResults" href="#PowerSimulations.SimulationResults"><code>PowerSimulations.SimulationResults</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Construct SimulationResults from a path and optionally an execution number. By default, choose the latest execution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/simulation_results.jl#L599-L602">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.SimulationResults-Tuple{Simulation}" href="#PowerSimulations.SimulationResults-Tuple{Simulation}"><code>PowerSimulations.SimulationResults</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct SimulationResults from a simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/simulation_results.jl#L650-L652">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.SimulationSequence" href="#PowerSimulations.SimulationSequence"><code>PowerSimulations.SimulationSequence</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SimulationSequence(horizons::Dict{String, Int}
                    step_resolution::Dates.TimePeriod
                    intervals::Dict{String, &lt;:Tuple{&lt;:Dates.TimePeriod, &lt;:FeedForwardChronology}}
                    order::Dict{Int, String}
                    feedforward_chronologies::Dict{Pair{String, String}, &lt;:FeedForwardChronology}
                    feedforward::Dict{Tuple{String, Symbol, Symbol}, &lt;:AbstractAffectFeedForward}
                    ini_cond_chronology::Dict{String, &lt;:FeedForwardChronology}
                    cache::Dict{String, AbstractCache}
                    )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/simulation_sequence.jl#L178-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.Stage" href="#PowerSimulations.Stage"><code>PowerSimulations.Stage</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Stage({M&lt;:AbstractOperationsProblem}
    template::OperationsProblemTemplate
    sys::PSY.System
    optimizer::JuMP.MOI.OptimizerWithAttributes
    internal::Union{Nothing, StageInternal}
    )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/simulation_stages.jl#L45-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.Stage-Union{Tuple{M}, Tuple{Type{M},OperationsProblemTemplate,System,MathOptInterface.OptimizerWithAttributes}, Tuple{Type{M},OperationsProblemTemplate,System,MathOptInterface.OptimizerWithAttributes,Union{Nothing, JuMP.AbstractModel}}} where M&lt;:PowerSimulations.AbstractOperationsProblem" href="#PowerSimulations.Stage-Union{Tuple{M}, Tuple{Type{M},OperationsProblemTemplate,System,MathOptInterface.OptimizerWithAttributes}, Tuple{Type{M},OperationsProblemTemplate,System,MathOptInterface.OptimizerWithAttributes,Union{Nothing, JuMP.AbstractModel}}} where M&lt;:PowerSimulations.AbstractOperationsProblem"><code>PowerSimulations.Stage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Stage(::Type{M},
template::OperationsProblemTemplate,
sys::PSY.System,
optimizer::JuMP.MOI.OptimizerWithAttributes,
jump_model::Union{Nothing, JuMP.AbstractModel}=nothing;
kwargs...) where {M&lt;:AbstractOperationsProblem}</code></pre><p>This builds the optimization problem of type M with the specific system and template for the simulation stage</p><p><strong>Arguments</strong></p><ul><li><code>::Type{M} where M&lt;:AbstractOperationsProblem</code>: The abstract operation model type</li><li><code>template::OperationsProblemTemplate</code>: The model reference made up of transmission, devices,                                         branches, and services.</li><li><code>sys::PSY.System</code>: the system created using Power Systems</li><li><code>jump_model::Union{Nothing, JuMP.AbstractModel}</code>: Enables passing a custom JuMP model. Use with care</li></ul><p><strong>Output</strong></p><ul><li><code>Stage::Stage</code>: The operation model containing the model type, unbuilt JuMP model, Power</li></ul><p>Systems system.</p><p><strong>Example</strong></p><pre><code class="language-julia">template = OperationsProblemTemplate(CopperPlatePowerModel, devices, branches, services)
stage = Stage(MyOpProblemType template, system, optimizer)</code></pre><p><strong>Accepted Key Words</strong></p><ul><li><code>initial_time::Dates.DateTime</code>: Initial Time for the model solve</li><li><code>PTDF::PTDF</code>: Passes the PTDF matrix into the optimization model for StandardPTDFModel networks.</li><li><code>warm_start::Bool</code> True will use the current operation point in the system to initialize variable values. False initializes all variables to zero. Default is true</li><li><code>balance_slack_variables::Bool</code> True will add slacks to the system balance constraints</li><li><code>services_slack_variables::Bool</code> True will add slacks to the services requirement constraints</li><li><code>export_pwl_vars::Bool</code> True will write the results of the piece-wise-linear intermediate variables. Slows down the simulation process significantly</li><li><code>allow_fails::Bool</code> True will allow the simulation to continue if the optimizer can&#39;t find a solution. Use with care, can lead to unwanted behaviour or results</li><li><code>optimizer_log_print::Bool</code> Uses JuMP.unset_silent() to print the optimizer&#39;s log. By default all solvers are set to <code>MOI.Silent()</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/simulation_stages.jl#L101-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.StageResults" href="#PowerSimulations.StageResults"><code>PowerSimulations.StageResults</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Holds the results of a simulation stage for plotting or exporting</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/simulation_results.jl#L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.Synchronize" href="#PowerSimulations.Synchronize"><code>PowerSimulations.Synchronize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Synchronize(periods::Int)</code></pre><p>Defines the co-ordination of time between Two stages.</p><p><strong>Arguments</strong></p><ul><li><code>periods::Int</code>: Number of time periods to grab data from</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/feedforward.jl#L35-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.TimeStatusChange" href="#PowerSimulations.TimeStatusChange"><code>PowerSimulations.TimeStatusChange</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Tracks the last time status of a device changed in a simulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/cache.jl#L10-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.UnitCommitmentProblem-Tuple{System}" href="#PowerSimulations.UnitCommitmentProblem-Tuple{System}"><code>PowerSimulations.UnitCommitmentProblem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">UnitCommitmentProblem(system::PSY.System; kwargs...)</code></pre><p>Creates an <code>OperationsProblemTemplate</code> with default DeviceModels for a Unit Commitment problem. Uses the template to create an <code>OperationsProblem</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">uc_problem = UnitCommitmentProblem(system)</code></pre><p><strong>Accepted Key Words</strong></p><ul><li><code>network::Type{&lt;:PM.AbstractPowerModel}</code> : override default network model settings</li><li><code>devices::Dict{Symbol, DeviceModel}</code> : override default <code>DeviceModel</code> settings</li><li><code>branches::Dict{Symbol, DeviceModel}</code> : override default <code>DeviceModel</code> settings</li><li><code>services::Dict{Symbol, ServiceModel}</code> : override default <code>ServiceModel</code> settings</li><li>Key word arguments supported by <code>OperationsProblem</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/operations_problems_templates.jl#L185-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.build!-Tuple{Simulation}" href="#PowerSimulations.build!-Tuple{Simulation}"><code>PowerSimulations.build!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">build!(sim::Simulation)</code></pre><p>Build the Simulation, stages and the related folder structure</p><p><strong>Arguments</strong></p><ul><li><code>sim::Simulation</code>: simulation object</li><li><code>output_dir</code> = nothing: Name of the output directory for the simulation. If nothing, the  folder will have the same name as the simulation</li><li><code>serialize::Bool = true</code>: serializes the simulation objects in the simulation</li><li><code>recorders::Vector{Symbol} = []</code>: recorder names to register</li><li><code>console_level = Logging.Error</code>:</li><li><code>file_level = Logging.Info</code>:</li></ul><p>Throws an exception if label is passed and the directory already exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/simulation.jl#L554-L569">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,D},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where D&lt;:HydroCommitmentReservoirBudget where H&lt;:HydroGen" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,D},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where D&lt;:HydroCommitmentReservoirBudget where H&lt;:HydroGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct model for HydroGen with ReservoirBudget Commitment Formulation with only Active Power.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/device_constructors/hydrogeneration_constructor.jl#L381-L384">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,D},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where D&lt;:HydroCommitmentRunOfRiver where H&lt;:HydroGen" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,D},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where D&lt;:HydroCommitmentRunOfRiver where H&lt;:HydroGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct model for HydroGen with RunOfRiver Commitment Formulation with only Active Power.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/device_constructors/hydrogeneration_constructor.jl#L288-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,D},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where D&lt;:PowerSimulations.AbstractHydroDispatchFormulation where H&lt;:HydroGen" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,D},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where D&lt;:PowerSimulations.AbstractHydroDispatchFormulation where H&lt;:HydroGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct model for HydroGen with RunOfRiver Dispatch Formulation with only Active Power.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/device_constructors/hydrogeneration_constructor.jl#L71-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:HydroCommitmentReservoirBudget where H&lt;:HydroGen" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:HydroCommitmentReservoirBudget where H&lt;:HydroGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct model for HydroGen with ReservoirBudget Commitment Formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/device_constructors/hydrogeneration_constructor.jl#L331-L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:HydroCommitmentRunOfRiver where H&lt;:HydroGen" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:HydroCommitmentRunOfRiver where H&lt;:HydroGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct model for HydroGen with RunOfRiver Commitment Formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/device_constructors/hydrogeneration_constructor.jl#L239-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractHydroDispatchFormulation where H&lt;:HydroGen" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractHydroDispatchFormulation where H&lt;:HydroGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct model for HydroGen with RunOfRiver Dispatch Formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/device_constructors/hydrogeneration_constructor.jl#L21-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{T,D},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where D&lt;:PowerSimulations.AbstractThermalUnitCommitment where T&lt;:ThermalGen" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{T,D},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where D&lt;:PowerSimulations.AbstractThermalUnitCommitment where T&lt;:ThermalGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the model for a full thermal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/device_constructors/thermalgeneration_constructor.jl#L60-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{T,D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalUnitCommitment where T&lt;:ThermalGen" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{T,D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalUnitCommitment where T&lt;:ThermalGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the model for a full thermal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/device_constructors/thermalgeneration_constructor.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,FixedOutput},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where H&lt;:HydroGen" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,FixedOutput},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where H&lt;:HydroGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct model for HydroGen with FixedOutput Formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/device_constructors/hydrogeneration_constructor.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,HydroCommitmentReservoirStorage},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where H&lt;:HydroEnergyReservoir" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,HydroCommitmentReservoirStorage},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where H&lt;:HydroEnergyReservoir"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct model for HydroGen with ReservoirStorage Dispatch Formulation with only Active Power</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/device_constructors/hydrogeneration_constructor.jl#L481-L484">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,HydroCommitmentReservoirStorage},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where H&lt;:HydroEnergyReservoir" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,HydroCommitmentReservoirStorage},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where H&lt;:HydroEnergyReservoir"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct model for HydroGen with ReservoirStorage Commitment Formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/device_constructors/hydrogeneration_constructor.jl#L426-L428">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,HydroDispatchPumpedStoragewReservation},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where H&lt;:HydroPumpedStorage" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,HydroDispatchPumpedStoragewReservation},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where H&lt;:HydroPumpedStorage"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct model for HydroPumpedStorage with PumpedStorage Dispatch Formulation with reservation constraint with only Active Power</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/device_constructors/hydrogeneration_constructor.jl#L583-L586">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,HydroDispatchPumpedStorage},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where H&lt;:HydroPumpedStorage" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,HydroDispatchPumpedStorage},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where H&lt;:HydroPumpedStorage"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct model for HydroPumpedStorage with PumpedStorage Dispatch Formulation with only Active Power</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/device_constructors/hydrogeneration_constructor.jl#L526-L529">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,HydroDispatchReservoirBudget},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where H&lt;:HydroEnergyReservoir" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,HydroDispatchReservoirBudget},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where H&lt;:HydroEnergyReservoir"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct model for HydroGen with ReservoirBudget Dispatch Formulation with only Active Power.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/device_constructors/hydrogeneration_constructor.jl#L142-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,HydroDispatchReservoirBudget},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where H&lt;:HydroEnergyReservoir" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,HydroDispatchReservoirBudget},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where H&lt;:HydroEnergyReservoir"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct model for HydroGen with ReservoirBudget Dispatch Formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/device_constructors/hydrogeneration_constructor.jl#L112-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,HydroDispatchReservoirStorage},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where H&lt;:HydroEnergyReservoir" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,HydroDispatchReservoirStorage},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where H&lt;:HydroEnergyReservoir"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct model for HydroGen with ReservoirStorage Dispatch Formulation with only Active Power</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/device_constructors/hydrogeneration_constructor.jl#L206-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,HydroDispatchReservoirStorage},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where H&lt;:HydroEnergyReservoir" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{H,HydroDispatchReservoirStorage},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where H&lt;:HydroEnergyReservoir"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct model for HydroGen with ReservoirStorage Dispatch Formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/device_constructors/hydrogeneration_constructor.jl#L172-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{RegulationDevice{T},DeviceLimitedRegulation},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where T&lt;:StaticInjection" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{RegulationDevice{T},DeviceLimitedRegulation},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where T&lt;:StaticInjection"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the model for a full thermal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/device_constructors/regulationdevice_constructor.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{RegulationDevice{T},FixedOutput},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where T&lt;:StaticInjection" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{RegulationDevice{T},FixedOutput},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where T&lt;:StaticInjection"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the model for a full thermal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/device_constructors/regulationdevice_constructor.jl#L102-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{RegulationDevice{T},ReserveLimitedRegulation},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where T&lt;:StaticInjection" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{RegulationDevice{T},ReserveLimitedRegulation},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where T&lt;:StaticInjection"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the model for a full thermal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/device_constructors/regulationdevice_constructor.jl#L52-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{T,ThermalBasicUnitCommitment},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where T&lt;:ThermalGen" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{T,ThermalBasicUnitCommitment},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where T&lt;:ThermalGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the model for a full thermal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/device_constructors/thermalgeneration_constructor.jl#L164-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{T,ThermalBasicUnitCommitment},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where T&lt;:ThermalGen" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{T,ThermalBasicUnitCommitment},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where T&lt;:ThermalGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the model for a full thermal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/device_constructors/thermalgeneration_constructor.jl#L109-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{T,ThermalRampLimited},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where T&lt;:ThermalGen" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{T,ThermalRampLimited},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where T&lt;:ThermalGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the model for a full thermal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/device_constructors/thermalgeneration_constructor.jl#L257-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{T,ThermalRampLimited},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where T&lt;:ThermalGen" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,System,DeviceModel{T,ThermalRampLimited},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where T&lt;:ThermalGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the model for a full thermal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/device_constructors/thermalgeneration_constructor.jl#L207-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.execute!-Tuple{Simulation}" href="#PowerSimulations.execute!-Tuple{Simulation}"><code>PowerSimulations.execute!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">execute!(sim::Simulation; kwargs...)</code></pre><p>Solves the simulation model for sequential Simulations.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Simulation=sim</code>: simulation object created by Simulation()</li></ul><p>The optional keyword argument <code>exports</code> controls exporting of results to CSV files as the simulation runs. Refer to <a href="#PowerSimulations.export_results-Tuple{SimulationResults,Any}"><code>export_results</code></a> for a description of this argument.</p><p><strong>Example</strong></p><pre><code class="language-julia">sim = Simulation(&quot;Test&quot;, 7, stages, &quot;/Users/folder&quot;)
execute!(sim::Simulation; kwargs...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/simulation.jl#L959-L975">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.export_operations_model-Tuple{OperationsProblem,String}" href="#PowerSimulations.export_operations_model-Tuple{OperationsProblem,String}"><code>PowerSimulations.export_operations_model</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Exports the OpModel JuMP object in MathOptFormat</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/operations_problem.jl#L541">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.export_results-Tuple{SimulationResults,Any}" href="#PowerSimulations.export_results-Tuple{SimulationResults,Any}"><code>PowerSimulations.export_results</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Export results to files in the results directory.</p><p><strong>Arguments</strong></p><ul><li><code>results::SimulationResults</code>: simulation results</li><li><code>exports</code>: SimulationResultsExport or anything that can be passed to its constructor. (such as Dict or path to JSON file)</li></ul><p>An example JSON file demonstrating possible options is below. Note that <code>start_time</code>, <code>end_time</code>, <code>path</code>, and <code>format</code> are optional.</p><pre><code class="language-none">{
  &quot;stages&quot;: [
    {
      &quot;name&quot;: &quot;ED&quot;,
      &quot;variables&quot;: [
        &quot;P__ThermalStandard&quot;,
        &quot;E__HydroEnergyReservoir&quot;
      ],
      &quot;parameters&quot;: [
        &quot;all&quot;
      ]
    },
    {
      &quot;name&quot;: &quot;UC&quot;,
      &quot;variables&quot;: [
        &quot;On__ThermalStandard&quot;
      ],
      &quot;parameters&quot;: [
        &quot;all&quot;
      ],
      &quot;duals&quot;: [
        &quot;all&quot;
      ]
    }
  ],
  &quot;start_time&quot;: &quot;2020-01-01T04:00:00&quot;,
  &quot;end_time&quot;: null,
  &quot;path&quot;: null,
  &quot;format&quot;: &quot;csv&quot;
}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/simulation_results.jl#L674-L717">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.get_all_constraint_index-Tuple{OperationsProblem}" href="#PowerSimulations.get_all_constraint_index-Tuple{OperationsProblem}"><code>PowerSimulations.get_all_constraint_index</code></a> — <span class="docstring-category">Method</span></header><section><div><p>&quot;Each Tuple corresponds to (con<em>name, internal</em>index, moi_index)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/operations_problem.jl#L548">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.get_all_var_index-Tuple{OperationsProblem}" href="#PowerSimulations.get_all_var_index-Tuple{OperationsProblem}"><code>PowerSimulations.get_all_var_index</code></a> — <span class="docstring-category">Method</span></header><section><div><p>&quot;Each Tuple corresponds to (con<em>name, internal</em>index, moi_index)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/operations_problem.jl#L560">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.list_simulation_events-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent" href="#PowerSimulations.list_simulation_events-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent"><code>PowerSimulations.list_simulation_events</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">list_simulation_events(
    ::Type{T},
    output_dir::AbstractString,
    filter_func::Union{Nothing, Function} = nothing;
    step = nothing,
    stage = nothing,
) where {T &lt;: IS.AbstractRecorderEvent}</code></pre><p>List simulation events of type T in a simulation output directory.</p><p><strong>Arguments</strong></p><ul><li><code>output_dir::AbstractString</code>: Simulation output directory</li><li><code>filter_func::Union{Nothing, Function} = nothing</code>: Refer to <a href="#PowerSimulations.show_simulation_events-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent"><code>show_simulation_events</code></a>.</li><li><code>step::Int = nothing</code>: Filter events by step. Required if stage is passed.</li><li><code>stage::Int = nothing</code>: Filter events by stage.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/recorder_events.jl#L180-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.list_stages-Tuple{PowerSimulations.HdfSimulationStore}" href="#PowerSimulations.list_stages-Tuple{PowerSimulations.HdfSimulationStore}"><code>PowerSimulations.list_stages</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the stage names in order of execution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/hdf_simulation_store.jl#L137-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.list_stages-Tuple{SimulationResults}" href="#PowerSimulations.list_stages-Tuple{SimulationResults}"><code>PowerSimulations.list_stages</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the stage names in the simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/simulation_results.jl#L669-L671">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.load_results!-Tuple{StageResults,Int64}" href="#PowerSimulations.load_results!-Tuple{StageResults,Int64}"><code>PowerSimulations.load_results!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Loads the simulation results into memory for repeated reads. Running this function twice
overwrites the previously loaded results. This is useful when loading results from remote
locations over network connections

# Required Key Words
- `initial_time::Dates.DateTime` : initial of the requested results
- `count::Int`: Number of results
# Accepted Key Words
- `variables::Vector{Symbol}`: Variables names to load into results
- `duals::Vector{Symbol}`: Dual names to load into results
- `parameters::Vector{Symbol}`: Parameter names to load into results</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/simulation_results.jl#L525-L537">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.read_dual-Tuple{StageResults,Symbol}" href="#PowerSimulations.read_dual-Tuple{StageResults,Symbol}"><code>PowerSimulations.read_dual</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Returns the values for the requested dual name. It keeps requests when performing multiple retrievals. Accepts a dual name to return the result.
# Accepted Key Words
- `initial_time::Dates.DateTime` : initial of the requested results
- `count::Int`: Number of results
- `store::SimulationStore`: a store that has been opened for reading</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/simulation_results.jl#L333-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.read_duals-Tuple{StageResults}" href="#PowerSimulations.read_duals-Tuple{StageResults}"><code>PowerSimulations.read_duals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Returns the values for the requested dual names. It must match the duals requested in the simulation stage definition.
It keeps requests when performing multiple retrievals. Accepts a vector of names for the return of the values

# Accepted Key Words
- `names::Vector{Symbol}` : names of desired results
- `initial_time::Dates.DateTime` : initial of the requested results
- `count::Int`: Number of results
- `store::SimulationStore`: a store that has been opened for reading</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/simulation_results.jl#L258-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.read_parameter-Tuple{StageResults,Symbol}" href="#PowerSimulations.read_parameter-Tuple{StageResults,Symbol}"><code>PowerSimulations.read_parameter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Returns the values for the requested parameter name. It keeps requests when performing multiple retrievals. Accepts a parameter name to return the result.
# Accepted Key Words
- `initial_time::Dates.DateTime` : initial of the requested results
- `count::Int`: Number of results</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/simulation_results.jl#L344-L349">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.read_parameters-Tuple{StageResults}" href="#PowerSimulations.read_parameters-Tuple{StageResults}"><code>PowerSimulations.read_parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Returns the values for the parameters used in the simulation. It keeps requests when performing multiple retrievals. Accepts a vector of names for the return of the values

# Accepted Key Words
- `names::Vector{Symbol}` : names of desired results
- `initial_time::Dates.DateTime` : initial time of the requested results
- `count::Int`: Number of results
- `store::SimulationStore`: a store that has been opened for reading</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/simulation_results.jl#L299-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.read_realized_duals-Tuple{StageResults}" href="#PowerSimulations.read_realized_duals-Tuple{StageResults}"><code>PowerSimulations.read_realized_duals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Returns the final values for the requested dual names for each time step for a stage.
Accepts a vector of names for the return of the values. If the time stamps and names are
loaded using the [load_results!](@ref) function it will read from memory.

# Accepted Key Words
- `names::Vector{Symbol}` : names of desired results
- `initial_time::Dates.DateTime` : initial time of the requested results
- `len::Int`: length of results</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/simulation_results.jl#L502-L511">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.read_realized_parameters-Tuple{StageResults}" href="#PowerSimulations.read_realized_parameters-Tuple{StageResults}"><code>PowerSimulations.read_realized_parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Returns the final values for the requested parameter names for each time step for a stage.
Accepts a vector of names for the return of the values. If the time stamps and names are
loaded using the [load_results!](@ref) function it will read from memory.

# Accepted Key Words
- `names::Vector{Symbol}` : names of desired results
- `initial_time::Dates.DateTime` : initial time of the requested results
- `len::Int`: length of results</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/simulation_results.jl#L475-L484">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.read_realized_variables-Tuple{StageResults}" href="#PowerSimulations.read_realized_variables-Tuple{StageResults}"><code>PowerSimulations.read_realized_variables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Returns the final values for the requested variable names for each time step for a stage.
Accepts a vector of names for the return of the values. If the time stamps and names are
loaded using the [load_results!](@ref) function it will read from memory.

# Accepted Key Words
- `names::Vector{Symbol}` : names of desired results
- `initial_time::Dates.DateTime` : initial time of the requested results
- `len::Int`: length of results</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/simulation_results.jl#L448-L457">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.read_variable-Tuple{StageResults,Symbol}" href="#PowerSimulations.read_variable-Tuple{StageResults,Symbol}"><code>PowerSimulations.read_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Returns the values for the requested variable name. It keeps requests when performing multiple retrievals. Accepts a variable name to return the result.

# Accepted Key Words
- `initial_time::Dates.DateTime` : initial of the requested results
- `count::Int`: Number of results
- `store::SimulationStore`: a store that has been opened for reading</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/simulation_results.jl#L321-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.read_variables-Tuple{StageResults}" href="#PowerSimulations.read_variables-Tuple{StageResults}"><code>PowerSimulations.read_variables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Returns the values for the requested variable names. Accepts a vector of names for the
return of the values. If the time stamps and names are loaded using the [load_results!](@ref)
function it will read from memory.

# Accepted Key Words
- `names::Vector{Symbol}` : names of desired results
- `initial_time::Dates.DateTime` : initial of the requested results
- `count::Int`: Number of results
- `store::SimulationStore`: a store that has been opened for reading</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/simulation_results.jl#L216-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.show_recorder_events-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent" href="#PowerSimulations.show_recorder_events-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent"><code>PowerSimulations.show_recorder_events</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">show_recorder_events(
    ::Type{T},
    filename::AbstractString,
    filter_func::Union{Nothing, Function} = nothing;
    wall_time = false,
    kwargs...,
) where {T &lt;: IS.AbstractRecorderEvent}</code></pre><p>Show the events of type T in a recorder file.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Recorder event type</li><li><code>filename::AbstractString</code>: recorder filename</li><li><code>filter_func::Union{Nothing, Function} = nothing</code>: Optional function that accepts an event  of type T and returns a Bool. Apply this function to each event and only return events  where the result is true.</li><li><code>wall_time = false</code>: If true, show the wall_time timestamp.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/recorder_events.jl#L321-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.show_simulation_events-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent" href="#PowerSimulations.show_simulation_events-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent"><code>PowerSimulations.show_simulation_events</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">show_simulation_events(
    ::Type{T},
    output_dir::AbstractString,
    filter_func::Union{Nothing,Function} = nothing;
    step = nothing,
    stage = nothing,
    wall_time = false,
    kwargs...,
) where { T &lt;: IS.AbstractRecorderEvent}</code></pre><p>Show all simulation events of type T in a simulation output directory.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Recorder event type</li><li><code>output_dir::AbstractString</code>: Simulation output directory</li><li><code>filter_func::Union{Nothing, Function} = nothing</code>: Refer to <a href="#PowerSimulations.show_recorder_events-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent"><code>show_recorder_events</code></a>.</li><li><code>step::Int = nothing</code>: Filter events by step. Required if stage is passed.</li><li><code>stage::Int = nothing</code>: Filter events by stage.</li><li><code>wall_time = false</code>: If true, show the wall_time timestamp.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/recorder_events.jl#L236-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.solve!-Union{Tuple{OperationsProblem{T}}, Tuple{T}} where T&lt;:PowerSimulations.AbstractOperationsProblem" href="#PowerSimulations.solve!-Union{Tuple{OperationsProblem{T}}, Tuple{T}} where T&lt;:PowerSimulations.AbstractOperationsProblem"><code>PowerSimulations.solve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solve!(op_problem::OperationsProblem; kwargs...)</code></pre><p>This solves the operational model for a single instance and outputs results of type OperationsProblemResult</p><p><strong>Arguments</strong></p><ul><li><code>op_problem::OperationModel = op_problem</code>: operation model</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">results = solve!(OpModel)</code></pre><p><strong>Accepted Key Words</strong></p><ul><li><code>save_path::String</code>: If a file path is provided the results</li></ul><p>automatically get written to feather files</p><ul><li><code>optimizer::MOI.OptimizerWithAttributes</code>: The optimizer that is used to solve the model</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/operations_problem.jl#L441-L455">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.template_agc_reserve_deployment-Tuple{}" href="#PowerSimulations.template_agc_reserve_deployment-Tuple{}"><code>PowerSimulations.template_agc_reserve_deployment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">template_agc_reserve_deployment(; kwargs...)</code></pre><p>Creates an <code>OperationsProblemTemplate</code> with default DeviceModels for an AGC Reserve Deplyment Problem. This model doesn&#39;t support customization</p><p><strong>Example</strong></p><pre><code class="language-julia">template = agc_reserve_deployment()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/operations_problems_templates.jl#L110-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.template_economic_dispatch-Tuple{}" href="#PowerSimulations.template_economic_dispatch-Tuple{}"><code>PowerSimulations.template_economic_dispatch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">template_economic_dispatch(; kwargs...)</code></pre><p>Creates an <code>OperationsProblemTemplate</code> with default DeviceModels for an Economic Dispatch problem.</p><p><strong>Example</strong></p><pre><code class="language-julia">template = template_economic_dispatch()</code></pre><p><strong>Accepted Key Words</strong></p><ul><li><code>network::Type{&lt;:PM.AbstractPowerModel}</code> : override default network model settings</li><li><code>devices::Dict{Symbol, DeviceModel}</code> : override default <code>DeviceModel</code> settings</li><li><code>branches::Dict{Symbol, DeviceModel}</code> : override default <code>DeviceModel</code> settings</li><li><code>services::Dict{Symbol, ServiceModel}</code> : override default <code>ServiceModel</code> settings</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/operations_problems_templates.jl#L70-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.template_unit_commitment-Tuple{}" href="#PowerSimulations.template_unit_commitment-Tuple{}"><code>PowerSimulations.template_unit_commitment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">template_unit_commitment(; kwargs...)</code></pre><p>Creates an <code>OperationsProblemTemplate</code> with default DeviceModels for a Unit Commitment problem.</p><p><strong>Example</strong></p><pre><code class="language-julia">template = template_unit_commitment()</code></pre><p><strong>Accepted Key Words</strong></p><ul><li><code>network::Type{&lt;:PM.AbstractPowerModel}</code> : override default network model settings</li><li><code>devices::Dict{Symbol, DeviceModel}</code> : override default <code>DeviceModel</code> settings</li><li><code>branches::Dict{Symbol, DeviceModel}</code> : override default <code>DeviceModel</code> settings</li><li><code>services::Dict{Symbol, ServiceModel}</code> : override default <code>ServiceModel</code> settings</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/operations_problems_templates.jl#L48-L64">source</a></section></article><h2 id="Internal"><a class="docs-heading-anchor" href="#Internal">Internal</a><a id="Internal-1"></a><a class="docs-heading-anchor-permalink" href="#Internal" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.AbstractSimulationStatusEvent" href="#PowerSimulations.AbstractSimulationStatusEvent"><code>PowerSimulations.AbstractSimulationStatusEvent</code></a> — <span class="docstring-category">Type</span></header><section><div><p>All events subtyped from this need to be recorded under :simulation_status.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/recorder_events.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.ActivePowerInVariable" href="#PowerSimulations.ActivePowerInVariable"><code>PowerSimulations.ActivePowerInVariable</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Struct to dispatch the creation of Active Power Input Variables for 2-directional devices. for instance storage or pump-hydro</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/variables.jl#L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.ActivePowerOutVariable" href="#PowerSimulations.ActivePowerOutVariable"><code>PowerSimulations.ActivePowerOutVariable</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Struct to dispatch the creation of Active Power Output Variables for 2-directional devices. for instance storage or pump-hydro</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/variables.jl#L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.ActivePowerVariable" href="#PowerSimulations.ActivePowerVariable"><code>PowerSimulations.ActivePowerVariable</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Struct to dispatch the creation of Active Power Variables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/variables.jl#L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.CacheFlushRules" href="#PowerSimulations.CacheFlushRules"><code>PowerSimulations.CacheFlushRules</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Informs the flusher on what data to keep in cache.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/cache_utils.jl#L15-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceRangeConstraintInfo" href="#PowerSimulations.DeviceRangeConstraintInfo"><code>PowerSimulations.DeviceRangeConstraintInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Data Container to construct range constraints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/constraints_structs.jl#L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceRangeConstraintSpec-Tuple{Type{#s118} where #s118&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ReactivePowerVariable},Type{#s117} where #s117&lt;:ElectricLoad,Type{#s116} where #s116&lt;:PowerSimulations.AbstractControllablePowerLoadFormulation,Type{#s115} where #s115&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward},Bool,Bool}" href="#PowerSimulations.DeviceRangeConstraintSpec-Tuple{Type{#s118} where #s118&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ReactivePowerVariable},Type{#s117} where #s117&lt;:ElectricLoad,Type{#s116} where #s116&lt;:PowerSimulations.AbstractControllablePowerLoadFormulation,Type{#s115} where #s115&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward},Bool,Bool}"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Reactive Power Constraints on Controllable Loads Assume Constant power_factor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/electric_loads.jl#L38-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceRangeConstraintSpec-Tuple{}" href="#PowerSimulations.DeviceRangeConstraintSpec-Tuple{}"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct inputs for creating range constraints.</p><p><strong>Arguments</strong></p><p><code>range_constraint_spec::Vector{RangeConstraintSpec}</code>: May be emtpy. <code>timeseries_range_constraint_spec::Vector{TimeSeriesConstraintSpec}</code>: May be empty. <code>custom_psi_container_func::Union{Nothing, Function}</code>: Optional function to add custom  constraints to the internals of a PSIContainer. Must accept PSIContainer, devices iterable,  and a subtype of AbstractDeviceFormulation. <code>devices_filter_func::Union{Nothing, Function}</code>: Optional function to filter the devices on</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/device_range_constraints.jl#L98-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ActivePowerVariable},Type{T},Type{#s118} where #s118&lt;:PowerSimulations.AbstractCompactUnitCommitment,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Nothing,Bool,Bool}} where T&lt;:ThermalMultiStart" href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ActivePowerVariable},Type{T},Type{#s118} where #s118&lt;:PowerSimulations.AbstractCompactUnitCommitment,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Nothing,Bool,Bool}} where T&lt;:ThermalMultiStart"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the active power limits of generators. Constraint (17) &amp; (18) from PGLIB</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/thermal_generation.jl#L205-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ActivePowerVariable},Type{T},Type{#s118} where #s118&lt;:PowerSimulations.AbstractHydroDispatchFormulation,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward},Bool,Bool}} where T&lt;:HydroGen" href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ActivePowerVariable},Type{T},Type{#s118} where #s118&lt;:PowerSimulations.AbstractHydroDispatchFormulation,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward},Bool,Bool}} where T&lt;:HydroGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function define the range constraint specs for the active power for dispatch Run of River formulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/hydro_generation.jl#L135-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ActivePowerVariable},Type{T},Type{#s118} where #s118&lt;:PowerSimulations.AbstractHydroReservoirFormulation,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward},Bool,Bool}} where T&lt;:HydroGen" href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ActivePowerVariable},Type{T},Type{#s118} where #s118&lt;:PowerSimulations.AbstractHydroReservoirFormulation,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward},Bool,Bool}} where T&lt;:HydroGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function define the range constraint specs for the active power for dispatch Reservoir formulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/hydro_generation.jl#L178-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ActivePowerVariable},Type{T},Type{#s118} where #s118&lt;:PowerSimulations.AbstractHydroUnitCommitment,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Nothing,Bool,Bool}} where T&lt;:HydroGen" href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ActivePowerVariable},Type{T},Type{#s118} where #s118&lt;:PowerSimulations.AbstractHydroUnitCommitment,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Nothing,Bool,Bool}} where T&lt;:HydroGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function define the range constraint specs for the active power for commitment formulations (semi continuous).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/hydro_generation.jl#L203-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ActivePowerVariable},Type{T},Type{#s118} where #s118&lt;:PowerSimulations.AbstractThermalDispatchFormulation,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Nothing,Bool,Bool}} where T&lt;:ThermalGen" href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ActivePowerVariable},Type{T},Type{#s118} where #s118&lt;:PowerSimulations.AbstractThermalDispatchFormulation,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Nothing,Bool,Bool}} where T&lt;:ThermalGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the active power limits of generators when there are no CommitmentVariables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/thermal_generation.jl#L116-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ActivePowerVariable},Type{T},Type{#s118} where #s118&lt;:PowerSimulations.AbstractThermalUnitCommitment,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Nothing,Bool,Bool}} where T&lt;:ThermalGen" href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ActivePowerVariable},Type{T},Type{#s118} where #s118&lt;:PowerSimulations.AbstractThermalUnitCommitment,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Nothing,Bool,Bool}} where T&lt;:ThermalGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the active power limits of generators when there are CommitmentVariables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/thermal_generation.jl#L140-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ActivePowerVariable},Type{T},Type{#s118} where #s118&lt;:ThermalDispatchNoMin,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Nothing,Bool,Bool}} where T&lt;:ThermalGen" href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ActivePowerVariable},Type{T},Type{#s118} where #s118&lt;:ThermalDispatchNoMin,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Nothing,Bool,Bool}} where T&lt;:ThermalGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the active power limits of generators when there are no CommitmentVariables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/thermal_generation.jl#L165-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ReactivePowerVariable},Type{T},Type{#s118} where #s118&lt;:PowerSimulations.AbstractHydroDispatchFormulation,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward},Bool,Bool}} where T&lt;:HydroGen" href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ReactivePowerVariable},Type{T},Type{#s118} where #s118&lt;:PowerSimulations.AbstractHydroDispatchFormulation,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward},Bool,Bool}} where T&lt;:HydroGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function define the range constraint specs for the reactive power for dispatch formulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/hydro_generation.jl#L106-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ReactivePowerVariable},Type{T},Type{#s118} where #s118&lt;:PowerSimulations.AbstractHydroUnitCommitment,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Nothing,Bool,Bool}} where T&lt;:HydroGen" href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ReactivePowerVariable},Type{T},Type{#s118} where #s118&lt;:PowerSimulations.AbstractHydroUnitCommitment,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Nothing,Bool,Bool}} where T&lt;:HydroGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function define the range constraint specs for the reactive power for commitment formulations (semi continuous).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/hydro_generation.jl#L229-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ReactivePowerVariable},Type{T},Type{#s118} where #s118&lt;:PowerSimulations.AbstractThermalDispatchFormulation,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward},Bool,Bool}} where T&lt;:ThermalGen" href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ReactivePowerVariable},Type{T},Type{#s118} where #s118&lt;:PowerSimulations.AbstractThermalDispatchFormulation,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward},Bool,Bool}} where T&lt;:ThermalGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the reactive  power limits of generators when there are CommitmentVariables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/thermal_generation.jl#L305-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ReactivePowerVariable},Type{T},Type{#s118} where #s118&lt;:PowerSimulations.AbstractThermalUnitCommitment,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward},Bool,Bool}} where T&lt;:ThermalGen" href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ReactivePowerVariable},Type{T},Type{#s118} where #s118&lt;:PowerSimulations.AbstractThermalUnitCommitment,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward},Bool,Bool}} where T&lt;:ThermalGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the reactive power limits of generators when there CommitmentVariables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/thermal_generation.jl#L333-L335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.FlowActivePowerVariable" href="#PowerSimulations.FlowActivePowerVariable"><code>PowerSimulations.FlowActivePowerVariable</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Struct to dispatch the creation of Flow Active Power Variables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/variables.jl#L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.HdfSimulationStore" href="#PowerSimulations.HdfSimulationStore"><code>PowerSimulations.HdfSimulationStore</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Stores simulation data in an HDF file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/hdf_simulation_store.jl#L42-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.NodalExpressionSpec-Union{Tuple{U}, Tuple{T}, Tuple{Type{T},Type{U},Bool}} where U&lt;:PowerModels.AbstractPowerModel where T&lt;:Device" href="#PowerSimulations.NodalExpressionSpec-Union{Tuple{U}, Tuple{T}, Tuple{Type{T},Type{U},Bool}} where U&lt;:PowerModels.AbstractPowerModel where T&lt;:Device"><code>PowerSimulations.NodalExpressionSpec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct NodalExpressionSpec for specific types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/nodal_expression.jl#L11-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.ParamResultCache" href="#PowerSimulations.ParamResultCache"><code>PowerSimulations.ParamResultCache</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Cache for a single parameter/variable/dual. Stores arrays chronologically by simulation timestamp.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/param_result_cache.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.ResultCache" href="#PowerSimulations.ResultCache"><code>PowerSimulations.ResultCache</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Cache for all model results</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/result_cache.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.SimulationStore" href="#PowerSimulations.SimulationStore"><code>PowerSimulations.SimulationStore</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Provides storage of simulation data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/simulation_store.jl#L7-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.StageDatasets" href="#PowerSimulations.StageDatasets"><code>PowerSimulations.StageDatasets</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Stores HDF5 datasets for one stage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/hdf_simulation_store.jl#L25-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.UpdateRef" href="#PowerSimulations.UpdateRef"><code>PowerSimulations.UpdateRef</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Reference for parameters update when present</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/aux_structs.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO,MIME{Symbol(&quot;text/plain&quot;)},OperationsProblem}" href="#Base.show-Tuple{IO,MIME{Symbol(&quot;text/plain&quot;)},OperationsProblem}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.show(io::IO, ::MIME&quot;text/plain&quot;, op_problem::OperationsProblem)</code></pre><p>This function goes through the fields in OperationsProblem and then in OperationsProblemTemplate, if the field contains a Device model dictionary, it calls organize<em>device</em>model() &amp; prints the data by field, key, value. If the field is not a Device model dictionary, and a value exists for that field it prints the value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/printing.jl#L20-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations._allocate_execution_order-Tuple{Dict{Int64,Int64}}" href="#PowerSimulations._allocate_execution_order-Tuple{Dict{Int64,Int64}}"><code>PowerSimulations._allocate_execution_order</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function calculates the total number of stage executions in the simulation and allocates the appropiate vector</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/simulation_sequence.jl#L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations._calculate_interval_inner_counts-Tuple{Dict{Int64,String},Dict{String,Tuple{Dates.TimePeriod,#s122} where #s122&lt;:PowerSimulations.FeedForwardChronology},Dates.TimePeriod}" href="#PowerSimulations._calculate_interval_inner_counts-Tuple{Dict{Int64,String},Dict{String,Tuple{Dates.TimePeriod,#s122} where #s122&lt;:PowerSimulations.FeedForwardChronology},Dates.TimePeriod}"><code>PowerSimulations._calculate_interval_inner_counts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_calculate_interval_inner_counts(order::Dict{Int,String},
                                      intervals::Dict{String,&lt;:Dates.TimePeriod},
                                      step_resolution::Dates.TimePeriod)</code></pre><p>Calculates how many times a stage is executed for every interval of the previous stage</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/simulation_sequence.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations._get_data_for_rocc-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,Type{T}}} where T&lt;:ThermalGen" href="#PowerSimulations._get_data_for_rocc-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,Type{T}}} where T&lt;:ThermalGen"><code>PowerSimulations._get_data_for_rocc</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function gets the data for the generators for ramping constraints of thermal generators</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/thermal_generation.jl#L421-L423">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations._get_data_for_tdc-Tuple{Array{InitialCondition,1},Array{InitialCondition,1},Dates.TimePeriod}" href="#PowerSimulations._get_data_for_tdc-Tuple{Array{InitialCondition,1},Array{InitialCondition,1},Dates.TimePeriod}"><code>PowerSimulations._get_data_for_tdc</code></a> — <span class="docstring-category">Method</span></header><section><div><p>If the fraction of hours that a generator has a duration constraint is less than the fraction of hours that a single time_step represents then it is not binding.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/thermal_generation.jl#L921-L924">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations._get_data_startup_ic-Tuple{Array{InitialCondition,1}}" href="#PowerSimulations._get_data_startup_ic-Tuple{Array{InitialCondition,1}}"><code>PowerSimulations._get_data_startup_ic</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function gets the data for startup initial condition</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/thermal_generation.jl#L833-L835">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations._update_stage!-Tuple{Stage,Simulation}" href="#PowerSimulations._update_stage!-Tuple{Stage,Simulation}"><code>PowerSimulations._update_stage!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Required update stage function call</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/simulation.jl#L939">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.add_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{St}, Tuple{PowerSimulations.PSIContainer,Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ReactivePowerVariable},InfrastructureSystems.FlattenIteratorWrapper{St},DeviceModel{St,D},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractStorageFormulation where St&lt;:Storage" href="#PowerSimulations.add_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{St}, Tuple{PowerSimulations.PSIContainer,Type{#s119} where #s119&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ReactivePowerVariable},InfrastructureSystems.FlattenIteratorWrapper{St},DeviceModel{St,D},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractStorageFormulation where St&lt;:Storage"><code>PowerSimulations.add_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the reactive  power limits of generators when there are CommitmentVariables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/storage.jl#L148-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,Type{T},Type{U},InfrastructureSystems.FlattenIteratorWrapper{V},DeviceModel{V,W},Type{X},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where X&lt;:PowerModels.AbstractPowerModel where W&lt;:PowerSimulations.AbstractDeviceFormulation where V&lt;:Device where U&lt;:PowerSimulations.VariableType where T&lt;:PowerSimulations.RangeConstraint" href="#PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,Type{T},Type{U},InfrastructureSystems.FlattenIteratorWrapper{V},DeviceModel{V,W},Type{X},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where X&lt;:PowerModels.AbstractPowerModel where W&lt;:PowerSimulations.AbstractDeviceFormulation where V&lt;:Device where U&lt;:PowerSimulations.VariableType where T&lt;:PowerSimulations.RangeConstraint"><code>PowerSimulations.add_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Default implementation to add range constraints.</p><p>Users of this function must implement a method for <a href="#PowerSimulations.DeviceRangeConstraintSpec-Tuple{Type{#s118} where #s118&lt;:PowerSimulations.RangeConstraint,Type{PowerSimulations.ReactivePowerVariable},Type{#s117} where #s117&lt;:ElectricLoad,Type{#s116} where #s116&lt;:PowerSimulations.AbstractControllablePowerLoadFormulation,Type{#s115} where #s115&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward},Bool,Bool}"><code>DeviceRangeConstraintSpec</code></a> for their specific types. Users may also implement custom active<em>power</em>constraints! methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/device_range_constraints.jl#L68-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.add_result!-Tuple{PowerSimulations.ParamResultCache,Any,Any,Any}" href="#PowerSimulations.add_result!-Tuple{PowerSimulations.ParamResultCache,Any,Any,Any}"><code>PowerSimulations.add_result!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Adds thrame result to the cache. Return true if the cache needs to be flushed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/param_result_cache.jl#L42-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.add_to_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,MarketBidCost,Component}" href="#PowerSimulations.add_to_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,MarketBidCost,Component}"><code>PowerSimulations.add_to_cost!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Adds to the models costs represented by PowerSystems Market-Bid costs. Default implementation for any PSY.Component. Uses by default the cost in of the cold stages for start up costs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/cost_functions.jl#L606-L609">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.add_to_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,MarketBidCost,ThermalMultiStart}" href="#PowerSimulations.add_to_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,MarketBidCost,ThermalMultiStart}"><code>PowerSimulations.add_to_cost!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Adds to the models costs represented by PowerSystems Market-Bid costs. Implementation for devices PSY.ThermalMultiStart</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/cost_functions.jl#L523-L526">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.add_to_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,MultiStartCost,Component}" href="#PowerSimulations.add_to_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,MultiStartCost,Component}"><code>PowerSimulations.add_to_cost!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Adds to the models costs represented by PowerSystems Multi-Start costs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/cost_functions.jl#L435-L437">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.add_to_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,ThreePartCost,Component}" href="#PowerSimulations.add_to_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,ThreePartCost,Component}"><code>PowerSimulations.add_to_cost!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Adds to the models costs represented by PowerSystems ThreePart costs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/cost_functions.jl#L364-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.add_to_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,TwoPartCost,Component}" href="#PowerSimulations.add_to_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,TwoPartCost,Component}"><code>PowerSimulations.add_to_cost!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Adds to the models costs represented by PowerSystems TwoPart costs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/cost_functions.jl#L328-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.add_variable!-Union{Tuple{U}, Tuple{D}, Tuple{PowerSimulations.PSIContainer,PowerSimulations.VariableType,U}} where U&lt;:Union{Array{D,1}, InfrastructureSystems.FlattenIteratorWrapper{D}} where D&lt;:Component" href="#PowerSimulations.add_variable!-Union{Tuple{U}, Tuple{D}, Tuple{PowerSimulations.PSIContainer,PowerSimulations.VariableType,U}} where U&lt;:Union{Array{D,1}, InfrastructureSystems.FlattenIteratorWrapper{D}} where D&lt;:Component"><code>PowerSimulations.add_variable!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Adds a variable to the optimization model and to the affine expressions contained in the psi_container model according to the specified sign. Based on the inputs, the variable can be specified as binary.</p><p><strong>Bounds</strong></p><p><code>lb_value_function &lt;= varstart[name, t] &lt;= ub_value_function</code></p><p>If binary = true:</p><p><code>varstart[name, t] in {0,1}</code></p><p><strong>LaTeX</strong></p><p><span>$lb \ge x^{device}_t \le ub \forall t$</span></p><p><span>$x^{device}_t \in {0,1} \forall t iff \text{binary = true}$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>devices : Vector or Iterator with the devices</li><li>var_name::Symbol : Base Name for the variable</li><li>binary::Bool : Select if the variable is binary</li><li>expression<em>name::Symbol : Expression</em>name name stored in psi_container.expressions to add the variable</li><li>sign::Float64 : sign of the addition of the variable to the expression_name. Default Value is 1.0</li></ul><p><strong>Accepted Keyword Arguments</strong></p><ul><li>ub<em>value : Provides the function over device to obtain the value for a upper</em>bound</li><li>lb<em>value : Provides the function over device to obtain the value for a lower</em>bound. If the variable is meant to be positive define lb = x -&gt; 0.0</li><li>initial_value : Provides the function over device to obtain the warm start value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/add_variable.jl#L24-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.add_variables!-Tuple{PowerSimulations.PSIContainer,Type{PowerSimulations.SteadyStateFrequencyDeviation}}" href="#PowerSimulations.add_variables!-Tuple{PowerSimulations.PSIContainer,Type{PowerSimulations.SteadyStateFrequencyDeviation}}"><code>PowerSimulations.add_variables!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Steady State deviation of the frequency</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/services_models/agc.jl#L6-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.add_variables!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,Type{T},Union{Array{U,1}, InfrastructureSystems.FlattenIteratorWrapper{U}}}} where U&lt;:Component where T&lt;:PowerSimulations.VariableType" href="#PowerSimulations.add_variables!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,Type{T},Union{Array{U,1}, InfrastructureSystems.FlattenIteratorWrapper{U}}}} where U&lt;:Component where T&lt;:PowerSimulations.VariableType"><code>PowerSimulations.add_variables!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add variables to the PSIContainer for any component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/add_variable.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.add_variables!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,Type{T},U,Array{V,1}}} where V&lt;:Device where U&lt;:Reserve where T&lt;:PowerSimulations.VariableType" href="#PowerSimulations.add_variables!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,Type{T},U,Array{V,1}}} where V&lt;:Device where U&lt;:Reserve where T&lt;:PowerSimulations.VariableType"><code>PowerSimulations.add_variables!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add variables to the PSIContainer for a service.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/add_variable.jl#L12-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.check_activeservice_variables-Tuple{PowerSimulations.PSIContainer,Array{#s120,1} where #s120&lt;:Service}" href="#PowerSimulations.check_activeservice_variables-Tuple{PowerSimulations.PSIContainer,Array{#s120,1} where #s120&lt;:Service}"><code>PowerSimulations.check_activeservice_variables</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function checks if the variables for reserves were created</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/services_models/group_reserve.jl#L3-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.check_file_integrity-Tuple{String}" href="#PowerSimulations.check_file_integrity-Tuple{String}"><code>PowerSimulations.check_file_integrity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_file_integrity(path::String)</code></pre><p>Checks the hash value for each file made with the file is written with the new hash_value to verify the file hasn&#39;t been tampered with since written</p><p><strong>Arguments</strong></p><ul><li><code>path::String</code>: this is the folder path that contains the results and the check.sha256 file</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/utils.jl#L374-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.commit_hydro_active_power_ub!-Union{Tuple{W}, Tuple{V}, Tuple{PowerSimulations.PSIContainer,Any,DeviceModel{V,W},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where W&lt;:PowerSimulations.AbstractHydroUnitCommitment where V&lt;:HydroGen" href="#PowerSimulations.commit_hydro_active_power_ub!-Union{Tuple{W}, Tuple{V}, Tuple{PowerSimulations.PSIContainer,Any,DeviceModel{V,W},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where W&lt;:PowerSimulations.AbstractHydroUnitCommitment where V&lt;:HydroGen"><code>PowerSimulations.commit_hydro_active_power_ub!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function define the range constraint specs for the reactive power for Commitment Run of River formulation.     <span>$P &lt;= multiplier * P_max$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/hydro_generation.jl#L362-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.commitment_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,D},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalUnitCommitment where T&lt;:ThermalGen" href="#PowerSimulations.commitment_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,D},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalUnitCommitment where T&lt;:ThermalGen"><code>PowerSimulations.commitment_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the Commitment Status constraint when there are CommitmentVariables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/thermal_generation.jl#L363-L365">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.compute_sha256-Tuple{AbstractString}" href="#PowerSimulations.compute_sha256-Tuple{AbstractString}"><code>PowerSimulations.compute_sha256</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the SHA 256 hash of a file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/utils.jl#L21-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.constraint_current_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel,Int64,Int64,Any,Any,Any,Any}" href="#PowerSimulations.constraint_current_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel,Int64,Int64,Any,Any,Any,Any}"><code>PowerSimulations.constraint_current_balance_ni_expr</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/network_models/powermodels_interface.jl#L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.constraint_current_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel,Int64}" href="#PowerSimulations.constraint_current_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel,Int64}"><code>PowerSimulations.constraint_current_balance_ni_expr</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/network_models/powermodels_interface.jl#L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractActivePowerModel,Int64,Int64,Any,Any,Any,Any}" href="#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractActivePowerModel,Int64,Int64,Any,Any,Any,Any}"><code>PowerSimulations.constraint_power_balance_ni_expr</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/network_models/powermodels_interface.jl#L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel,Int64,Int64,Any,Any,Any,Any}" href="#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel,Int64,Int64,Any,Any,Any,Any}"><code>PowerSimulations.constraint_power_balance_ni_expr</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/network_models/powermodels_interface.jl#L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel,Int64}" href="#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel,Int64}"><code>PowerSimulations.constraint_power_balance_ni_expr</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/network_models/powermodels_interface.jl#L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_service!-Union{Tuple{SR}, Tuple{PowerSimulations.PSIContainer,Array{SR,1},System,ServiceModel{SR,GroupReserve},Dict{Symbol,DeviceModel},Array{#s120,1} where #s120&lt;:DataType}} where SR&lt;:StaticReserveGroup" href="#PowerSimulations.construct_service!-Union{Tuple{SR}, Tuple{PowerSimulations.PSIContainer,Array{SR,1},System,ServiceModel{SR,GroupReserve},Dict{Symbol,DeviceModel},Array{#s120,1} where #s120&lt;:DataType}} where SR&lt;:StaticReserveGroup"><code>PowerSimulations.construct_service!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Constructs a service for StaticReserveGroup.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/services_models/services_constructor.jl#L184-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.container_spec-Union{Tuple{M}, Tuple{M,Vararg{Any,N} where N}} where M&lt;:JuMP.AbstractModel" href="#PowerSimulations.container_spec-Union{Tuple{M}, Tuple{M,Vararg{Any,N} where N}} where M&lt;:JuMP.AbstractModel"><code>PowerSimulations.container_spec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns the correct container spec for the selected type of JuMP Model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/utils.jl#L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.cost_function!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,ThermalDispatchNoMin},Type{#s119} where #s119&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where T&lt;:ThermalGen" href="#PowerSimulations.cost_function!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,ThermalDispatchNoMin},Type{#s119} where #s119&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where T&lt;:ThermalGen"><code>PowerSimulations.cost_function!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Cost function for generators formulated as No-Min</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/thermal_generation.jl#L1195-L1197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.cost_function!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,U},Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,U},Type{#s116} where #s116&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where U&lt;:PowerSimulations.AbstractDeviceFormulation where T&lt;:Component" href="#PowerSimulations.cost_function!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,U},Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,U},Type{#s116} where #s116&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where U&lt;:PowerSimulations.AbstractDeviceFormulation where T&lt;:Component"><code>PowerSimulations.cost_function!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add variables to the PSIContainer for a service.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/cost_functions.jl#L65-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.cost_function!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,U},Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,U},Type{#s116} where #s116&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where U&lt;:PowerSimulations.AbstractStorageFormulation where T&lt;:Storage" href="#PowerSimulations.cost_function!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,U},Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,U},Type{#s116} where #s116&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where U&lt;:PowerSimulations.AbstractStorageFormulation where T&lt;:Storage"><code>PowerSimulations.cost_function!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add variables to the PSIContainer for a Storage device.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/storage.jl#L328-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_commitment!-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Symbol,Tuple{Symbol,Symbol,Symbol}}" href="#PowerSimulations.device_commitment!-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_commitment!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs multi-timestep constraint from initial conditions and binary variable tuple.</p><p><strong>Constraints</strong></p><p><code>varstart + varstop &lt;= 1.0</code></p><p>If t = 1:</p><p><code>varon[name, 1] == ic.value + varstart[name, 1] - varstop[name, 1]</code></p><p>where ic in initial_condtions.</p><p>If t &gt; 1:</p><p><code>varon[name, t] == varon[name, t-1] + varstart[name, t] - varstop[name, t]</code></p><p><strong>LaTeX</strong></p><p><span>$x^{on}_t + x^{off}_t \leq 1.0 \forall t$</span></p><p><span>$x^{on}_1 = x^{on}_{init} + x^{start}_1 - x^{stop}_1, \text{ for } t = 1$</span></p><p><span>$x^{on}_t = x^{on}_{t-1} + x^{start}_t - x^{stop}_t, \forall t \geq 2$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>initial_conditions::Vector{InitialCondition} : for time zero &#39;varon&#39;</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables</li><li>: var_names[1] : varstart</li><li>: var_names[2] : varstop</li><li>: var_names[3] : varon</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/commitment_constraint.jl#L1-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_duration_compact_retrospective!-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}" href="#PowerSimulations.device_duration_compact_retrospective!-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_duration_compact_retrospective!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This formulation of the duration constraints adds over the start times looking backwards.</p><p><strong>LaTeX</strong></p><ul><li>Minimum up-time constraint:</li></ul><p><span>$\sum_{i=t-min(d_{min}^{up}, T)+ 1}^t x_i^{start} - x_t^{on} \leq 0$</span></p><p>for i in the set of time steps.</p><ul><li>Minimum down-time constraint:</li></ul><p><span>$\sum_{i=t-min(d_{min}^{down}, T) + 1}^t x_i^{stop} + x_t^{on} \leq 1$</span></p><p>for i in the set of time steps.</p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>duration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down</li><li>initial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol}) : names of the variables</li><li>: var_names[1] : varon</li><li>: var_names[2] : varstart</li><li>: var_names[3] : varstop</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/duration_constraints.jl#L316-L343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_duration_look_ahead!-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}" href="#PowerSimulations.device_duration_look_ahead!-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_duration_look_ahead!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This formulation of the duration constraints looks ahead in the time frame of the model.</p><p><strong>LaTeX</strong></p><ul><li>Minimum up-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{up}$</span></p><p><span>$d_{min}^{down}x_t^{stop} - \sum_{i=t-d_{min}^{up} + 1}^t x_i^{on} - x_{init}^{up} \leq 0$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$d_{min}^{down}x_t^{stop} - \sum_{i=t-d_{min}^{up} + 1}^t x_i^{on} \leq 0$</span></p><p>for i in the set of time steps.</p><ul><li>Minimum down-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{down}$</span></p><p><span>$d_{min}^{up}x_t^{start} - \sum_{i=t-d_{min^{down} + 1}^t (1 - x_i^{on}) - x_{init}^{down} \leq 0$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$d_{min}^{up}x_t^{start} - \sum_{i=t-d_{min^{down} + 1}^t (1 - x_i^{on}) \leq 0$</span></p><p>for i in the set of time steps.</p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>duration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down</li><li>initial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol}) : names of the variables</li><li>: var_names[1] : varon</li><li>: var_names[2] : varstart</li><li>: var_names[3] : varstop</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/duration_constraints.jl#L96-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_duration_parameters!-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}" href="#PowerSimulations.device_duration_parameters!-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_duration_parameters!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This formulation of the duration constraints considers parameters.</p><p><strong>LaTeX</strong></p><ul><li>Minimum up-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{up}$</span></p><p><span>$d_{min}^{down}x_t^{stop} - \sum_{i=t-d_{min}^{up} + 1}^t x_i^{on} - x_{init}^{up} \leq 0$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$\sum_{i=t-d_{min}^{up} + 1}^t x_i^{start} - x_t^{on} \leq 0$</span></p><p>for i in the set of time steps.</p><ul><li>Minimum down-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{down}$</span></p><p><span>$d_{min}^{up}x_t^{start} - \sum_{i=t-d_{min^{down} + 1}^t (1 - x_i^{on}) - x_{init}^{down} \leq 0$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$\sum_{i=t-d_{min}^{down} + 1}^t x_i^{stop} + x_t^{on} \leq 1$</span></p><p>for i in the set of time steps.</p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>duration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down</li><li>initial<em>duration</em>on::Vector{InitialCondition} : gives initial number of time steps variable is up</li><li>initial<em>duration</em>off::Vector{InitialCondition} : gives initial number of time steps variable is down</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol}) : names of the variables</li><li>: var_names[1] : varon</li><li>: var_names[2] : varstart</li><li>: var_names[3] : varstop</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/duration_constraints.jl#L196-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_duration_retrospective!-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}" href="#PowerSimulations.device_duration_retrospective!-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_duration_retrospective!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This formulation of the duration constraints adds over the start times looking backwards.</p><p><strong>LaTeX</strong></p><ul><li>Minimum up-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{up} - d_{init}^{up}$</span> and <span>$d_{init}^{up} &gt; 0$</span></p><p><span>$1 + \sum_{i=t-d_{min}^{up} + 1}^t x_i^{start} - x_t^{on} \leq 0$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$\sum_{i=t-d_{min}^{up} + 1}^t x_i^{start} - x_t^{on} \leq 0$</span></p><p>for i in the set of time steps.</p><ul><li>Minimum down-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{down} - d_{init}^{down}$</span> and <span>$d_{init}^{down} &gt; 0$</span></p><p><span>$1 + \sum_{i=t-d_{min}^{down} + 1}^t x_i^{stop} + x_t^{on} \leq 1$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$\sum_{i=t-d_{min}^{down} + 1}^t x_i^{stop} + x_t^{on} \leq 1$</span></p><p>for i in the set of time steps.</p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>duration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down</li><li>initial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol}) : names of the variables</li><li>: var_names[1] : varon</li><li>: var_names[2] : varstart</li><li>: var_names[3] : varstop</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/duration_constraints.jl#L1-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_energy_budget_param_ub-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1},Symbol,PowerSimulations.UpdateRef,Symbol}" href="#PowerSimulations.device_energy_budget_param_ub-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1},Symbol,PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.device_energy_budget_param_ub</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function define the budget constraint (using params) for the active power budget formulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/hydro_generation.jl#L710-L713">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_energy_budget_ub-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1},Symbol,Symbol}" href="#PowerSimulations.device_energy_budget_ub-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1},Symbol,Symbol}"><code>PowerSimulations.device_energy_budget_ub</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function define the budget constraint for the active power budget formulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/hydro_generation.jl#L746-L749">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_linear_rateofchange!-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRampConstraintInfo,1},Symbol,Symbol}" href="#PowerSimulations.device_linear_rateofchange!-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRampConstraintInfo,1},Symbol,Symbol}"><code>PowerSimulations.device_linear_rateofchange!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs allowed rate-of-change constraints from variables, initial condtions, and rate data.</p><p><strong>Constraints</strong></p><p>If t = 1:</p><p><code>variable[name, 1] - initial_conditions[ix].value &lt;= rate_data[1][ix].up</code></p><p><code>initial_conditions[ix].value - variable[name, 1] &lt;= rate_data[1][ix].down</code></p><p>If t &gt; 1:</p><p><code>variable[name, t] - variable[name, t-1] &lt;= rate_data[1][ix].up</code></p><p><code>variable[name, t-1] - variable[name, t] &lt;= rate_data[1][ix].down</code></p><p><strong>LaTeX</strong></p><p><span>$r^{down} \leq x_1 - x_{init} \leq r^{up}, \text{ for } t = 1$</span></p><p><span>$r^{down} \leq x_t - x_{t-1} \leq r^{up}, \forall t \geq 2$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>rate_data::Tuple{Vector{String}, Vector{UpDown}} : gives name (1) and max ramp up/down rates (2)</li><li>initial_conditions::Vector{InitialCondition} : for time zero &#39;variable&#39;</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Tuple{Symbol, Symbol, Symbol} : the name of the variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/rateofchange_constraints.jl#L1-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_mixedinteger_rateofchange!-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRampConstraintInfo,1},Symbol,Tuple{Symbol,Symbol,Symbol}}" href="#PowerSimulations.device_mixedinteger_rateofchange!-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRampConstraintInfo,1},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_mixedinteger_rateofchange!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs allowed rate-of-change constraints from variables, initial condtions, start/stop status, and rate data</p><p><strong>Equations</strong></p><p>If t = 1:</p><p><code>variable[name, 1] - initial_conditions[ix].value &lt;= rate_data[1][ix].up + rate_data[2][ix].max*varstart[name, 1]</code></p><p><code>initial_conditions[ix].value - variable[name, 1] &lt;= rate_data[1][ix].down + rate_data[2][ix].min*varstop[name, 1]</code></p><p>If t &gt; 1:</p><p><code>variable[name, t] - variable[name, t-1] &lt;= rate_data[1][ix].up + rate_data[2][ix].max*varstart[name, t]</code></p><p><code>variable[name, t-1] - variable[name, t] &lt;= rate_data[1][ix].down + rate_data[2][ix].min*varstop[name, t]</code></p><p><strong>LaTeX</strong></p><p><span>$r^{down} + r^{min} x^{stop}_1 \leq x_1 - x_{init} \leq r^{up} + r^{max} x^{start}_1, \text{ for } t = 1$</span></p><p><span>$r^{down} + r^{min} x^{stop}_t \leq x_t - x_{t-1} \leq r^{up} + r^{max} x^{start}_t, \forall t \geq 2$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>rate_data::Tuple{Vector{String}, Vector{UpDown}, Vector{MinMax}} : (1) gives name                                                                    (2) gives min/max ramp rates                                                                    (3) gives min/max for &#39;variable&#39;</li><li>initial_conditions::Vector{InitialCondition} : for time zero &#39;variable&#39;</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables</li><li>: var_names[1] : &#39;variable&#39;</li><li>: var_names[2] : &#39;varstart&#39;</li><li>: var_names[3] : &#39;varstop&#39;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/rateofchange_constraints.jl#L107-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_multistart_range!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.RangeConstraintSpecInternal}" href="#PowerSimulations.device_multistart_range!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.RangeConstraintSpecInternal}"><code>PowerSimulations.device_multistart_range!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs min/max range constraint from device variable and on/off decision variable.</p><p><strong>Constraints</strong></p><pre><code class="language-varcts">        - max(limits.max - lag_ramp_limits.startup, 0) * var_on[name, t] ```
</code></pre><p>varcts[name, t] &lt;= (limits.max-limits.min)*varbin[name, t])         - max(limits.max - lag<em>ramp</em>limits.shutdown, 0) * var_off[name, t] ```</p><p>where limits and lag<em>ramp</em>limits is in range_data.</p><p><strong>LaTeX</strong></p><p><span>$x^{cts} \leq (limits^{max}-limits^{min}) x^{bin} - max(limits^{max} - lag^{startup}, 0) x^{on}$</span></p><p><span>$x^{cts} \leq (limits^{max}-limits^{min}) x^{bin} - max(limits^{max} - lag^{shutdown}, 0) x^{off}$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>range_data::Vector{DeviceRange} : contains names and vector of min/max</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol : the name of the continuous variable</li><li>binvar_names::Symbol : the names of the binary variables</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/range_constraint.jl#L227-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_multistart_range_ic!-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceMultiStartRangeConstraintsInfo,1},Array{InitialCondition,2},Symbol,Symbol}" href="#PowerSimulations.device_multistart_range_ic!-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceMultiStartRangeConstraintsInfo,1},Array{InitialCondition,2},Symbol,Symbol}"><code>PowerSimulations.device_multistart_range_ic!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs min/max range constraint from device variable and on/off decision variable.</p><p><strong>Constraints</strong></p><p><code>max(limits.max - lag_ramp_limits.shutdown, 0) var_off[name, 1] &lt;= initial_power[ix].value         - (limits.max - limits.min)initial_status[ix].value</code></p><p>where limits in range_data.</p><p><strong>LaTeX</strong></p><p><span>$max(limits^{max} - lag^{shutdown}, 0) x^{off} \leq initial_condition^{power} - (limits^{max} - limits^{min}) initial_condition^{status}$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>range_data::Vector{DeviceRange} : contains names and vector of min/max</li><li>initial_conditions::Matrix{InitialCondition} :</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol : name of the shutdown variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/range_constraint.jl#L309-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_multistart_rateofchange!-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRampConstraintInfo,1},Symbol,Symbol}" href="#PowerSimulations.device_multistart_rateofchange!-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRampConstraintInfo,1},Symbol,Symbol}"><code>PowerSimulations.device_multistart_rateofchange!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs allowed rate-of-change constraints from variables, initial condtions, start/stop status, and rate data</p><p><strong>Equations</strong></p><p>If t = 1:</p><p><code>variable[name, 1] - initial_conditions[ix].value &lt;= rate_data[1][ix].up</code></p><p><code>initial_conditions[ix].value - variable[name, 1] &lt;= rate_data[1][ix].down</code></p><p>If t &gt; 1:</p><p><code>variable[name, t] - variable[name, t-1] &lt;= rate_data[1][ix].up</code></p><p><code>variable[name, t-1] - variable[name, t] &lt;= rate_data[1][ix].down</code></p><p><strong>LaTeX</strong></p><p><span>$r^{down}  \leq x_1 - x_{init} \leq r^{up}  \text{ for } t = 1$</span></p><p><span>$r^{down} \leq x_t - x_{t-1} \leq r^{up}  \forall t \geq 2$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>rate_data::Tuple{Vector{String}, Vector{UpDown}, Vector{MinMax}} : (1) gives name                                                                    (2) gives min/max ramp rates                                                                    (3) gives min/max for &#39;variable&#39;</li><li>initial_conditions::Vector{InitialCondition} : for time zero &#39;variable&#39;</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables</li><li>: var_name : &#39;variable&#39;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/rateofchange_constraints.jl#L224-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_range!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.RangeConstraintSpecInternal}" href="#PowerSimulations.device_range!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.RangeConstraintSpecInternal}"><code>PowerSimulations.device_range!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs min/max range constraint from device variable.</p><p><strong>Constraints</strong></p><p>If min and max within an epsilon width:</p><p><code>variable[name, t] == limits.max</code></p><p>Otherwise:</p><p><code>limits.min &lt;= variable[name, t] &lt;= limits.max</code></p><p>where limits in constraint_infos.</p><p><strong>LaTeX</strong></p><p><span>$x = limits^{max}, \text{ for } |limits^{max} - limits^{min}| &lt; \varepsilon$</span></p><p><span>$limits^{min} \leq x \leq limits^{max}, \text{ otherwise }$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/range_constraint.jl#L21-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_semicontinuousrange!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.RangeConstraintSpecInternal}" href="#PowerSimulations.device_semicontinuousrange!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.RangeConstraintSpecInternal}"><code>PowerSimulations.device_semicontinuousrange!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs min/max range constraint from device variable and on/off decision variable.</p><p><strong>Constraints</strong></p><p>If device min = 0:</p><p><code>varcts[name, t] &lt;= limits.max*varbin[name, t])</code></p><p><code>varcts[name, t] &gt;= 0.0</code></p><p>Otherwise:</p><p><code>varcts[name, t] &lt;= limits.max*varbin[name, t]</code></p><p><code>varcts[name, t] &gt;= limits.min*varbin[name, t]</code></p><p>where limits in constraint_infos.</p><p><strong>LaTeX</strong></p><p><span>$0 \leq x^{cts} \leq limits^{max} x^{bin}, \text{ for } limits^{min} = 0$</span></p><p><span>$limits^{min} x^{bin} \leq x^{cts} \leq limits^{max} x^{bin}, \text{ otherwise }$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/range_constraint.jl#L80-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_start_type_constraint-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceStartTypesConstraintInfo,1},Symbol,Symbol,Tuple{Symbol,Symbol,Symbol}}" href="#PowerSimulations.device_start_type_constraint-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceStartTypesConstraintInfo,1},Symbol,Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_start_type_constraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">device_start_type_constraint(psi_container::PSIContainer,
                        data::Vector{DeviceStartTypesConstraintInfo},
                        cons_name::Symbol,
                        var_start::Symbol,
                        var_names::Tuple{Symbol, Symbol, Symbol},)</code></pre><p>Constructs contraints that restricts devices to one type of start at a time</p><p><strong>Equations</strong></p><p><code>sum(var_starts[name, s, t] for s in starts) = var_start[name, t]</code></p><p><strong>LaTeX</strong></p><p><span>$\sum^{S_g}_{s=1} δ^{s}(t)  \eq  x^{start}(t)$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>data::Vector{DeviceStartTypesConstraintInfo},</li><li>cons_name::Symbol : name of the constraint</li><li>var_start::Symbol : name of the startup variable</li><li>var_starts::Tuple{Symbol, Symbol} : the names of the different start variables</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/thermal_generation.jl#L625-L648">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_startup_initial_condition-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceStartUpConstraintInfo,1},Array{InitialCondition,1},Symbol,Tuple{Symbol,Symbol},Symbol}" href="#PowerSimulations.device_startup_initial_condition-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceStartUpConstraintInfo,1},Array{InitialCondition,1},Symbol,Tuple{Symbol,Symbol},Symbol}"><code>PowerSimulations.device_startup_initial_condition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">device_startup_initial_condition(psi_container::PSIContainer,
                        data::Vector{DeviceStartUpConstraintInfo},
                        initial_conditions::Vector{InitialCondition},
                        cons_name::Symbol,
                        var_names::Tuple{Symbol, Symbol},
                        bin_name::Symbol,)</code></pre><p>Constructs contraints that restricts devices to one type of start at a time</p><p><strong>Equations</strong></p><p>ub: <code>(time_limits[st+1]-1)*δ^{s}(t) + (1 - δ^{s}(t)) * M_VALUE &gt;= sum(1-varbin[name, i]) for i in 1:t) + initial_condition_offtime</code> lb: <code>(time_limits[st]-1)*δ^{s}(t) =&lt; sum(1-varbin[name, i]) for i in 1:t) + initial_condition_offtime</code></p><p><strong>LaTeX</strong></p><p><span>$TS^{s+1}_{g} δ^{s}(t) + (1-δ^{s}(t)) M_VALUE   \geq  \sum^{t}_{i=1} x^{status}(i)  +  DT_{g}^{0}  \forall t in \{1, \ldots,  TS^{s+1}_{g}$</span></p><p><span>$TS^{s}_{g} δ^{s}(t) \leq  \sum^{t}_{i=1} x^{status}(i)  +  DT_{g}^{0}  \forall t in \{1, \ldots,  TS^{s+1}_{g}$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>data::Vector{DeviceStartTypesConstraintInfo},</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol} : the names of the different start variables</li><li>bin_name::Symbol : name of the status variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/thermal_generation.jl#L678-L706">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_timeseries_lb!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.TimeSeriesConstraintSpecInternal}" href="#PowerSimulations.device_timeseries_lb!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.TimeSeriesConstraintSpecInternal}"><code>PowerSimulations.device_timeseries_lb!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs lower bound for given variable subject to time series data and a multiplier.</p><p><strong>Constraint</strong></p><p><code>constraint_infos[name].multiplier * ts_data[name].timeseries[t] &lt;= variable[name, t]</code></p><p><strong>LaTeX</strong></p><p><span>$r^{val} r_t \leq x_t, \forall t$</span></p><p>where (name, data) in range_data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/timeseries_constraint.jl#L90-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_timeseries_param_lb!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.TimeSeriesConstraintSpecInternal}" href="#PowerSimulations.device_timeseries_param_lb!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.TimeSeriesConstraintSpecInternal}"><code>PowerSimulations.device_timeseries_param_lb!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs lower bound for given variable using a parameter. The constraint is     built with a time series data vector and a multiplier</p><p><strong>Constraint</strong></p><p><code>constraint_infos[name].multiplier * param[name, t] &lt;= variable[name, t]</code></p><p><strong>LaTeX</strong></p><p><span>$r^{val} x^{param}_t \leq x^{var}_t, \forall t$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/timeseries_constraint.jl#L189-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_timeseries_param_ub!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.TimeSeriesConstraintSpecInternal}" href="#PowerSimulations.device_timeseries_param_ub!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.TimeSeriesConstraintSpecInternal}"><code>PowerSimulations.device_timeseries_param_ub!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs upper bound for given variable using a parameter. The constraint is     built with a time series data vector and a multiplier</p><p><strong>Constraint</strong></p><p><code>variable[name, t] &lt;= constraint_infos[name].multiplier * param[name, t]</code></p><p><strong>LaTeX</strong></p><p><span>$x^{var}_t \leq r^{val} x^{param}_t, \forall t$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/timeseries_constraint.jl#L133-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_timeseries_ub!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.TimeSeriesConstraintSpecInternal}" href="#PowerSimulations.device_timeseries_ub!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.TimeSeriesConstraintSpecInternal}"><code>PowerSimulations.device_timeseries_ub!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs upper bound for given variable and time series data and a multiplier.</p><p><strong>Constraint</strong></p><p><code>variable[name, t] &lt;= constraint_infos[name].multiplier * ts_data[name].timeseries[t]</code></p><p><strong>LaTeX</strong></p><p><span>$x_t \leq r^{val} r_t, \forall t$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/timeseries_constraint.jl#L41-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_timeseries_ub_bigM!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.TimeSeriesConstraintSpecInternal}" href="#PowerSimulations.device_timeseries_ub_bigM!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.TimeSeriesConstraintSpecInternal}"><code>PowerSimulations.device_timeseries_ub_bigM!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs upper bound for variable and time series and a multiplier or confines to 0 depending on binary variable.     Uses BigM constraint type to allow for parameter since ParameterJuMP doesn&#39;t support var*parameter</p><p><strong>constraint_infos</strong></p><p><code>varcts[name, t] - constraint_infos[name].multipliers * param[name, t] &lt;= (1 - varbin[name, t]) * M_value</code></p><p><code>varcts[name, t] &lt;= varbin[name, t]*M_value</code></p><p><strong>LaTeX</strong></p><p><span>$x^{cts}_t - r^{val} x^{param}_t \leq M(1 - x^{bin}_t ), forall t$</span></p><p><span>$x^{cts}_t \leq M x^{bin}_t, \forall t$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/timeseries_constraint.jl#L284-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_timeseries_ub_bin!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.TimeSeriesConstraintSpecInternal}" href="#PowerSimulations.device_timeseries_ub_bin!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.TimeSeriesConstraintSpecInternal}"><code>PowerSimulations.device_timeseries_ub_bin!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs upper bound for variable and time series or confines to 0 depending on binary variable.     The upper bound is defined by a time series and a multiplier.</p><p><strong>constraint_infos</strong></p><p><code>varcts[name, t] &lt;= varbin[name, t]* constraint_infos[name].multiplier * ts_data[name].timeseries[t]</code></p><p>where (name, data) in range_data.</p><p><strong>LaTeX</strong></p><p><span>$x^{cts}_t \leq r^{val} r_t x^{bin}_t, \forall t$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/timeseries_constraint.jl#L239-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.energy_balance-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Tuple{Array{String,1},Array{NamedTuple{(:in, :out),Tuple{Float64,Float64}},1}},Symbol,Tuple{Symbol,Symbol,Symbol}}" href="#PowerSimulations.energy_balance-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Tuple{Array{String,1},Array{NamedTuple{(:in, :out),Tuple{Float64,Float64}},1}},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.energy_balance</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs multi-timestep constraint from initial condition, efficiency data, and variable tuple</p><p><strong>Constraints</strong></p><p>If t = 1:</p><p><code>varenergy[name, 1] == initial_conditions[ix].value + varin[name, 1]*eff_in*fraction_of_hour - varout[name, 1]*fraction_of_hour/eff_out</code></p><p>If t &gt; 1:</p><p><code>varenergy[name, t] == varenergy[name, t-1] + varin[name, t]*eff_in*fraction_of_hour - varout[name, t]*fraction_of_hour/eff_out</code></p><p><strong>LaTeX</strong></p><p><span>$x^{energy}_1 == x^{energy}_{init} + frhr \eta^{in} x^{in}_1 - \frac{frhr}{\eta^{out}} x^{out}_1, \text{ for } t = 1$</span></p><p><span>$x^{energy}_t == x^{energy}_{t-1} + frhr \eta^{in} x^{in}_t - \frac{frhr}{\eta^{out}} x^{out}_t, \forall t \geq 2$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>initial_conditions::Vector{InitialCondition} : for time zero &#39;varenergy&#39;</li><li>efficiency_data::Tuple{Vector{String}, Vector{InOut}} :: charging/discharging efficiencies</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables</li><li>: var_names[1] : varin</li><li>: var_names[2] : varout</li><li>: var_names[3] : varenergy</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/energy_balance_constraint.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.energy_balance_constraint!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{H},DeviceModel{H,S},Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:Union{HydroDispatchPumpedStorage, HydroDispatchPumpedStoragewReservation} where H&lt;:HydroPumpedStorage" href="#PowerSimulations.energy_balance_constraint!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{H},DeviceModel{H,S},Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:Union{HydroDispatchPumpedStorage, HydroDispatchPumpedStoragewReservation} where H&lt;:HydroPumpedStorage"><code>PowerSimulations.energy_balance_constraint!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function defines the constraints for the water level (or state of charge) for the HydroPumpedStorage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/hydro_generation.jl#L484-L487">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.energy_balance_constraint!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{H},DeviceModel{H,S},Type{#s119} where #s119&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:Union{HydroCommitmentReservoirStorage, HydroDispatchReservoirStorage} where H&lt;:HydroEnergyReservoir" href="#PowerSimulations.energy_balance_constraint!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{H},DeviceModel{H,S},Type{#s119} where #s119&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:Union{HydroCommitmentReservoirStorage, HydroDispatchReservoirStorage} where H&lt;:HydroEnergyReservoir"><code>PowerSimulations.energy_balance_constraint!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function defines the constraints for the water level (or state of charge) for the Hydro Reservoir.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/hydro_generation.jl#L397-L400">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.energy_balance_hydro!-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Tuple{Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1},Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1}},Tuple{Symbol,Symbol},NTuple{5,Symbol}}" href="#PowerSimulations.energy_balance_hydro!-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Tuple{Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1},Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1}},Tuple{Symbol,Symbol},NTuple{5,Symbol}}"><code>PowerSimulations.energy_balance_hydro!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs multi-timestep constraint from initial condition, efficiency data, and variable tuple for pumped hydro</p><p><strong>Constraints</strong></p><p>If t = 1: <code>varenergy[name, 1] == initial_conditions[ix].value + (paraminflow[name, t] + varin[name, 1] - varspill[name, 1] - varout[name, 1])*fraction_of_hour</code> If t &gt; 1: <code>varenergy[name, t] == varenergy[name, t-1] + (paraminflow[name, t] + varin[name, t] - varspill[name, t] - varout[name, t])*fraction_of_hour</code></p><p><strong>LaTeX</strong></p><p><span>$x^{energy}_1 == x^{energy}_{init} + frhr  (x^{in}_1 + x^{in}_1 - x^{spillage}_1 -  x^{out}_1), \text{ for } t = 1$</span> <span>$x^{energy}_t == x^{energy}_{t-1} + frhr (x^{in}_t + x^{in}_t - x^{spillage}_t - x^{out}_t), \forall t \geq 2$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>initial_conditions::Vector{InitialCondition} : for time zero &#39;varenergy&#39;</li><li>inflow_data::TVector{DeviceTimeSeriesConstraintInfo} :: Inflow energy forecast information</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol, Symbol} : the names of the variables</li><li>: var_names[1] : varspill</li><li>: var_names[2] : varout</li><li>: var_names[3] : varenergy</li><li>: var_names[4] : varin</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/energy_balance_constraint.jl#L410-L430">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.energy_balance_hydro!-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Tuple{Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1},Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1}},Tuple{Symbol,Symbol},Tuple{Symbol,Symbol,Symbol}}" href="#PowerSimulations.energy_balance_hydro!-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Tuple{Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1},Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1}},Tuple{Symbol,Symbol},Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.energy_balance_hydro!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs multi-timestep constraint from initial condition, efficiency data, and variable tuple</p><p><strong>Constraints</strong></p><p>If t = 1: <span>$varenergy[name, 1] == initial_conditions[ix].value + (paraminflow[name, t] - varspill[name, 1] - varout[name, 1])*fraction_of_hour$</span> If t &gt; 1: <span>$varenergy[name, t] == varenergy[name, t-1] + (paraminflow[name, t] - varspill[name, t] - varout[name, t])*fraction_of_hour$</span> `` varenergy[name, end] &gt;= paramenergytarget[name, end]</p><p><strong>LaTeX</strong></p><p><span>$x^{energy}_1 == x^{energy}_{init} + frhr  (x^{in}_1 - x^{spillage}_1 -  x^{out}_1), \text{ for } t = 1$</span> <span>$x^{energy}_t == x^{energy}_{t-1} + frhr (x^{in}_t - x^{spillage}_t - x^{out}_t), \forall t \geq 2$</span> <span>$x^{energy}_t &gt;= x^{energy}_{target} \text{ for } t = end$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>initial_conditions::Vector{InitialCondition} : for time zero &#39;varenergy&#39;</li><li>time<em>series</em>data::Tuple{Vector{DeviceTimeSeriesConstraintInfo}, Vector{DeviceTimeSeriesConstraintInfo}} : forecast information</li><li>: time<em>series</em>data[1] : Inflow energy forecast information</li><li>: time<em>series</em>data[2] : Target reservoir storage forecast information</li><li>cons_names::Tuple{Symbol, Symbol} : name of the constraints</li><li>: cons_names[1] : energy balance constraint name</li><li>: cons_names[2] : energy target constraint name</li><li>var_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables</li><li>: var_names[1] : varspill</li><li>: var_names[2] : varout</li><li>: var_names[3] : varenergy</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/energy_balance_constraint.jl#L190-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.energy_balance_hydro_param!-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Tuple{Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1},Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1}},Tuple{Symbol,Symbol},NTuple{5,Symbol},Tuple{PowerSimulations.UpdateRef,PowerSimulations.UpdateRef}}" href="#PowerSimulations.energy_balance_hydro_param!-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Tuple{Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1},Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1}},Tuple{Symbol,Symbol},NTuple{5,Symbol},Tuple{PowerSimulations.UpdateRef,PowerSimulations.UpdateRef}}"><code>PowerSimulations.energy_balance_hydro_param!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs multi-timestep constraint from initial condition, efficiency data, and variable tuple for pumped hydro</p><p><strong>Constraints</strong></p><p>If t = 1: <code>varenergy_up[name, 1] == initial_conditions[ix].value + (param_inflow[name, t] + varin[name, 1] - varspill[name, 1] - varout[name, 1])*fraction_of_hour</code> If t &gt; 1: <code>varenergy_up[name, t] == varenergy_up[name, t-1] + (param_inflow[name, t] + varin[name, t] - varspill[name, t] - varout[name, t])*fraction_of_hour</code></p><p><strong>LaTeX</strong></p><p><span>$x^{energy}_1 == x^{energy}_{init} + frhr  (x^{in}_1 + x^{in}_1 - x^{spillage}_1 -  x^{out}_1), \text{ for } t = 1$</span> <span>$x^{energy}_t == x^{energy}_{t-1} + frhr (x^{in}_t + x^{in}_t - x^{spillage}_t - x^{out}_t), \forall t \geq 2$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>initial<em>conditions::Vector{InitialCondition} : for time zero &#39;varenergy</em>up&#39;</li><li>inflow_data::Vector{DeviceTimeSeriesConstraintInfo} :: Inflow energy forecast information</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol, Symbol} : the names of the variables</li><li>: var_names[1] : varspill</li><li>: var_names[2] : varout</li><li>: var<em>names[3] : varenergy</em>up</li><li>: var_names[4] : varin</li><li>param_reference::UpdateRef : UpdateRef to access the inflow parameter</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/energy_balance_constraint.jl#L279-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.energy_balance_hydro_param!-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Tuple{Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1},Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1}},Tuple{Symbol,Symbol},Tuple{Symbol,Symbol,Symbol},Tuple{PowerSimulations.UpdateRef,PowerSimulations.UpdateRef}}" href="#PowerSimulations.energy_balance_hydro_param!-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Tuple{Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1},Array{PowerSimulations.DeviceTimeSeriesConstraintInfo,1}},Tuple{Symbol,Symbol},Tuple{Symbol,Symbol,Symbol},Tuple{PowerSimulations.UpdateRef,PowerSimulations.UpdateRef}}"><code>PowerSimulations.energy_balance_hydro_param!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs multi-timestep constraint from initial condition, efficiency data, and variable tuple</p><p><strong>Constraints</strong></p><p>If t = 1: <span>$varenergy[name, 1] == initial_conditions[ix].value + (paraminflow[name, t] - varspill[name, 1] - varout[name, 1])*fraction_of_hour$</span> If t &gt; 1: <span>$varenergy[name, t] == varenergy[name, t-1] + (paraminflow[name, t] - varspill[name, t] - varout[name, t])*fraction_of_hour$</span> `` varenergy[name, end] &gt;= paramenergytarget[name, end]</p><p><strong>LaTeX</strong></p><p><span>$x^{energy}_1 == x^{energy}_{init} + frhr  (x^{in}_1 - x^{spillage}_1 -  x^{out}_1), \text{ for } t = 1$</span> <span>$x^{energy}_t == x^{energy}_{t-1} + frhr (x^{in}_t - x^{spillage}_t - x^{out}_t), \forall t \geq 2$</span> <span>$x^{energy}_t &gt;= x^{energy}_{target} \text{ for } t = end$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>initial_conditions::Vector{InitialCondition} : for time zero &#39;varenergy&#39;</li><li>time<em>series</em>data::Tuple{Vector{DeviceTimeSeriesConstraintInfo}, Vector{DeviceTimeSeriesConstraintInfo}} : forecast information</li><li>: time<em>series</em>data[1] : Inflow energy forecast information</li><li>: time<em>series</em>data[2] : Target reservoir storage forecast information</li><li>cons_names::Tuple{Symbol, Symbol} : name of the constraints</li><li>: cons_names[1] : energy balance constraint name</li><li>: cons_names[2] : energy target constraint name</li><li>var_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables</li><li>: var_names[1] : varspill</li><li>: var_names[2] : varout</li><li>: var_names[3] : varenergy</li><li>param_reference::UpdateRef : UpdateRef to access the inflow parameter</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/energy_balance_constraint.jl#L76-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.energy_budget_constraints!-Union{Tuple{H}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{H},DeviceModel{H,#s118} where #s118&lt;:PowerSimulations.AbstractHydroFormulation,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where H&lt;:HydroGen" href="#PowerSimulations.energy_budget_constraints!-Union{Tuple{H}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{H},DeviceModel{H,#s118} where #s118&lt;:PowerSimulations.AbstractHydroFormulation,Type{#s117} where #s117&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where H&lt;:HydroGen"><code>PowerSimulations.energy_budget_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function define the budget constraint for the active power budget formulation.</p><p><span>$sum(P[t]) &lt;= Budget$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/hydro_generation.jl#L669-L674">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.energy_soft_target-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceEnergyTargetConstraintInfo,1},Symbol,Tuple{Symbol,Symbol}}" href="#PowerSimulations.energy_soft_target-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceEnergyTargetConstraintInfo,1},Symbol,Tuple{Symbol,Symbol}}"><code>PowerSimulations.energy_soft_target</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs constraint energy target data, and variable</p><p><strong>Constraints</strong></p><p><span>$varenergy[name, end] + varslack[name, end] &gt;= paramenergytarget[name, end]$</span></p><p><strong>LaTeX</strong></p><p><span>$x^{energy}_t + x^{slack}_t &gt;= x^{energy}_{target} \text{ for } t = end$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>constriant_data::Vector{DeviceEnergyTargetConstraintInfo}: Target energy storage information</li><li>cons_name::Symbol : energy target constraint name</li><li>var_names::Symbol : the names of the variables</li><li>: var_names[1] : varenergy</li><li>: var_names[2] : varslack</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/energy_management_constraints.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.find_key_with_value-Tuple{Any,Any}" href="#PowerSimulations.find_key_with_value-Tuple{Any,Any}"><code>PowerSimulations.find_key_with_value</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the key for the given value</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/utils.jl#L30-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.frequency_response_constraint!-Tuple{PowerSimulations.PSIContainer,System}" href="#PowerSimulations.frequency_response_constraint!-Tuple{PowerSimulations.PSIContainer,System}"><code>PowerSimulations.frequency_response_constraint!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Expression for the power deviation given deviation in the frequency. This expression allows updating the response of the frequency depending on commitment decisions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/services_models/agc.jl#L147-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.h5_store_open" href="#PowerSimulations.h5_store_open"><code>PowerSimulations.h5_store_open</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Construct and open an HdfSimulationStore.</p><p>When reading or writing results in a program you should use the method that accepts a function in order to guarantee that the file handle gets closed.</p><p><strong>Examples</strong></p><pre><code class="language-julia"># Assumes a simulation has been executed in the &#39;./rts&#39; directory with these parameters.
path = &quot;./rts&quot;
stage = :ED
var_name = :P__ThermalStandard
timestamp = DateTime(&quot;2020-01-01T05:00:00&quot;)
store = h5_store_open(path)
df = PowerSimulations.read_result(DataFrame, store, stage, :variables, var_name, timestamp)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/hdf_simulation_store.jl#L79-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.has_dirty-Tuple{PowerSimulations.ResultCache}" href="#PowerSimulations.has_dirty-Tuple{PowerSimulations.ResultCache}"><code>PowerSimulations.has_dirty</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return true if the cache has data that has not been flushed to storage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/result_cache.jl#L34-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.initial_condition_update!-Tuple{Stage,PowerSimulations.ICKey,Array{InitialCondition,1},InterStageChronology,Simulation}" href="#PowerSimulations.initial_condition_update!-Tuple{Stage,PowerSimulations.ICKey,Array{InitialCondition,1},InterStageChronology,Simulation}"><code>PowerSimulations.initial_condition_update!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Updates the initial conditions of the stage</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/simulation.jl#L693">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.initial_condition_update!-Tuple{Stage,PowerSimulations.ICKey,Array{InitialCondition,1},IntraStageChronology,Simulation}" href="#PowerSimulations.initial_condition_update!-Tuple{Stage,PowerSimulations.ICKey,Array{InitialCondition,1},IntraStageChronology,Simulation}"><code>PowerSimulations.initial_condition_update!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Updates the initial conditions of the stage</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/simulation.jl#L655">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.initial_range_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,D},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractCompactUnitCommitment where T&lt;:ThermalMultiStart" href="#PowerSimulations.initial_range_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,D},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractCompactUnitCommitment where T&lt;:ThermalMultiStart"><code>PowerSimulations.initial_range_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds range constraint for the first time period. Constraint (10) from PGLIB formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/thermal_generation.jl#L258-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.instantiate_bfp_expr-Tuple{PowerModels.AbstractPowerModel}" href="#PowerSimulations.instantiate_bfp_expr-Tuple{PowerModels.AbstractPowerModel}"><code>PowerSimulations.instantiate_bfp_expr</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/network_models/powermodels_interface.jl#L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.instantiate_nip_expr-Tuple{PowerModels.AbstractPowerModel}" href="#PowerSimulations.instantiate_nip_expr-Tuple{PowerModels.AbstractPowerModel}"><code>PowerSimulations.instantiate_nip_expr</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/network_models/powermodels_interface.jl#L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.instantiate_nip_expr_model-Tuple{Dict{String,Any},Any}" href="#PowerSimulations.instantiate_nip_expr_model-Tuple{Dict{String,Any},Any}"><code>PowerSimulations.instantiate_nip_expr_model</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/network_models/powermodels_interface.jl#L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.integral_limit_ff-Tuple{PowerSimulations.PSIContainer,Symbol,PowerSimulations.UpdateRef,Symbol}" href="#PowerSimulations.integral_limit_ff-Tuple{PowerSimulations.PSIContainer,Symbol,PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.integral_limit_ff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    integral_limit_ff(psi_container::PSIContainer,
                    cons_name::Symbol,
                    param_reference::UpdateRef,
                    var_name::Symbol)</code></pre><p>Constructs a parametrized integral limit constraint to implement feedforward from other models. The Parameters are initialized using the upper boundary values of the provided variables.</p><p><strong>Constraints</strong></p><p><code>sum(variable[var_name, t] for t in time_steps)/length(time_steps) &lt;= param_reference[var_name]</code></p><p><strong>LaTeX</strong></p><p><span>$\sum_{t} x \leq param^{max}$</span> TO DO: New formulation when DataStore available <span>$\sum_{t} x * DeltaT_lower \leq param^{max} * DeltaT_upper$</span> TO DO: New formulation when Commitment is considered: SemiContinuousFF     <span>$P_LL - P_max * ON_upper &lt;= 0.0$</span>     <span>$P_LL - P_min * ON_upper &gt;= 0.0$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>cons_name::Symbol : name of the constraint</li><li>param_reference : Reference to the PJ.ParameterRef used to determine the upperbound</li><li>var_name::Symbol : the name of the continuous variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/feedforward.jl#L502-L528">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.is_cached-Tuple{PowerSimulations.ResultCache,Any,Any,Any,Any}" href="#PowerSimulations.is_cached-Tuple{PowerSimulations.ResultCache,Any,Any,Any,Any}"><code>PowerSimulations.is_cached</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return true if the data for <code>timestamp</code> is stored in cache.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/result_cache.jl#L47-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.iterate_initial_conditions-Tuple{PowerSimulations.InitialConditions}" href="#PowerSimulations.iterate_initial_conditions-Tuple{PowerSimulations.InitialConditions}"><code>PowerSimulations.iterate_initial_conditions</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Iterate over the keys and vectors of initial conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/initial_conditions.jl#L38-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.list_fields-Tuple{PowerSimulations.HdfSimulationStore,Symbol,Symbol}" href="#PowerSimulations.list_fields-Tuple{PowerSimulations.HdfSimulationStore,Symbol,Symbol}"><code>PowerSimulations.list_fields</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the fields stored for the <code>stage</code> and <code>container_type</code> (duals/parameters/variables).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/hdf_simulation_store.jl#L142-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.log_cache_hit_percentages-Tuple{PowerSimulations.ResultCache}" href="#PowerSimulations.log_cache_hit_percentages-Tuple{PowerSimulations.ResultCache}"><code>PowerSimulations.log_cache_hit_percentages</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Log the cache hit percentages for all caches.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/result_cache.jl#L56-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.must_run_constraints!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{ThermalMultiStart},DeviceModel{ThermalMultiStart,ThermalMultiStartUnitCommitment},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel" href="#PowerSimulations.must_run_constraints!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{ThermalMultiStart},DeviceModel{ThermalMultiStart,ThermalMultiStartUnitCommitment},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.must_run_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates constraints that keep must run devices online</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/thermal_generation.jl#L889-L891">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.nodal_expression!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},Type{U}}} where U&lt;:PowerModels.AbstractPowerModel where T&lt;:Device" href="#PowerSimulations.nodal_expression!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},Type{U}}} where U&lt;:PowerModels.AbstractPowerModel where T&lt;:Device"><code>PowerSimulations.nodal_expression!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Default implementation to add nodal expressions.</p><p>Users of this function must implement a method for <a href="#PowerSimulations.NodalExpressionSpec-Union{Tuple{U}, Tuple{T}, Tuple{Type{T},Type{U},Bool}} where U&lt;:PowerModels.AbstractPowerModel where T&lt;:Device"><code>NodalExpressionSpec</code></a> for their specific types. Users may also implement custom nodal_expression! methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/nodal_expression.jl#L22-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,Type{S},System}, Tuple{PowerSimulations.PSIContainer,Type{S},System,Any}} where S&lt;:PowerModels.AbstractActivePowerModel" href="#PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,Type{S},System}, Tuple{PowerSimulations.PSIContainer,Type{S},System,Any}} where S&lt;:PowerModels.AbstractActivePowerModel"><code>PowerSimulations.powermodels_network!</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/network_models/powermodels_interface.jl#L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,Type{S},System}, Tuple{PowerSimulations.PSIContainer,Type{S},System,Any}} where S&lt;:PowerModels.AbstractPowerModel" href="#PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,Type{S},System}, Tuple{PowerSimulations.PSIContainer,Type{S},System,Any}} where S&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.powermodels_network!</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/network_models/powermodels_interface.jl#L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.pwl_gencost_linear!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,String,Array{Tuple{Float64,Float64},1},Int64}" href="#PowerSimulations.pwl_gencost_linear!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,String,Array{Tuple{Float64,Float64},1},Int64}"><code>PowerSimulations.pwl_gencost_linear!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns piecewise cost expression using linear implementation for psi_container model.</p><p><strong>Equations</strong></p><p><code>0 &lt;= pwl_var[i] &lt;= (cost_data[2][i] - cost_data[2][i-1])</code></p><p><code>variable = sum(pwl_var[i])</code></p><p><code>gen_cost = sum(pwl_var[i]*cost_data[1][i]/cost_data[2][i])</code></p><p><strong>LaTeX</strong></p><p><span>$0 &lt;= pwl_i &lt;= (c_{2, i} - c_{2, i-1})$</span></p><p><span>$variable = (sum_{i\in I} pwl_i)$</span></p><p><span>$gen_cost = (sum_{i\in I}  pwl_i) c_{1, i}/c_{2, i}$</span></p><p>Returns <code>gen_cost</code></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>variable::JuMP.Containers.DenseAxisArray{JV} : variable array</li><li>cost_data::Vector{NTuple{2, Float64}} : container for quadratic and linear factors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/cost_functions.jl#L262-L287">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.pwl_gencost_sos!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,String,Array{Tuple{Float64,Float64},1},Int64}" href="#PowerSimulations.pwl_gencost_sos!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,String,Array{Tuple{Float64,Float64},1},Int64}"><code>PowerSimulations.pwl_gencost_sos!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns piecewise cost expression using SOS Type-2 implementation for psi_container model.</p><p><strong>Equations</strong></p><p><code>variable = sum(sos_var[i]*cost_data[2][i])</code></p><p><code>gen_cost = sum(sos_var[i]*cost_data[1][i])</code></p><p><strong>LaTeX</strong></p><p><span>$variable = (sum_{i\in I} c_{2, i} sos_i)$</span></p><p><span>$gen_cost = (sum_{i\in I} c_{1, i} sos_i)$</span></p><p>Returns <code>gen_cost</code></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>variable::JuMP.Containers.DenseAxisArray{JV} : variable array</li><li>cost_data::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/cost_functions.jl#L175-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.pwlparamcheck-Tuple{Any}" href="#PowerSimulations.pwlparamcheck-Tuple{Any}"><code>PowerSimulations.pwlparamcheck</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns True/False depending on compatibility of the cost data with the linear implementation method</p><p>Returns <code>flag</code></p><p><strong>Arguments</strong></p><ul><li>cost_ : container for quadratic and linear factors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/cost_functions.jl#L144-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.ramp_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,D},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalUnitCommitment where T&lt;:ThermalGen" href="#PowerSimulations.ramp_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,D},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalUnitCommitment where T&lt;:ThermalGen"><code>PowerSimulations.ramp_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the ramping limits of generators when there are CommitmentVariables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/thermal_generation.jl#L468-L470">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.range_ff-Tuple{PowerSimulations.PSIContainer,Symbol,Array{PowerSimulations.DeviceRangeConstraintInfo,1},Tuple{PowerSimulations.UpdateRef,PowerSimulations.UpdateRef},Symbol}" href="#PowerSimulations.range_ff-Tuple{PowerSimulations.PSIContainer,Symbol,Array{PowerSimulations.DeviceRangeConstraintInfo,1},Tuple{PowerSimulations.UpdateRef,PowerSimulations.UpdateRef},Symbol}"><code>PowerSimulations.range_ff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    range_ff(psi_container::PSIContainer,
                    cons_name::Symbol,
                    param_reference::NTuple{2, UpdateRef},
                    var_name::Symbol)</code></pre><p>Constructs min/max range parametrized constraint from device variable to include feedforward.</p><p><strong>Constraints</strong></p><p><code>param_reference[1][var_name] &lt;= variable[var_name, t]</code> <code>variable[var_name, t] &lt;= param_reference[2][var_name]</code></p><p>where r in range_data.</p><p><strong>LaTeX</strong></p><p><span>$param^{min} \leq x$</span> <span>$x \leq param^{max}$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>param_reference::NTuple{2, UpdateRef} : Tuple with the lower bound and upper bound parameter reference</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol : the name of the continuous variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/feedforward.jl#L314-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.rating_constraint!-Tuple{PowerSimulations.PSIContainer,Array{Tuple{String,Float64},1},Symbol,Tuple{Symbol,Symbol}}" href="#PowerSimulations.rating_constraint!-Tuple{PowerSimulations.PSIContainer,Array{Tuple{String,Float64},1},Symbol,Tuple{Symbol,Symbol}}"><code>PowerSimulations.rating_constraint!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs constraint from rating data and related variable tuple.</p><p><strong>Constraint</strong></p><p><code>var1[r[1], t]^2 + var2[r[1], t]^2 &lt;= r[2]^2</code></p><p>where r in rating data and t in time steps.</p><p><strong>LaTeX</strong></p><p><span>$x_1^2 + x_2^2 \leq r^2$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>rating_data::Vector{Tuple{String, Float64}} : rating data name (1) and value (2)</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol} : the names of the variables</li><li>: var_names[1] : var1</li><li>: var_names[2] : var2</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/rating_constraints.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.read_dataframe-Tuple{AbstractString}" href="#PowerSimulations.read_dataframe-Tuple{AbstractString}"><code>PowerSimulations.read_dataframe</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a DataFrame from a CSV file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/utils.jl#L12-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.read_json-Tuple{AbstractString}" href="#PowerSimulations.read_json-Tuple{AbstractString}"><code>PowerSimulations.read_json</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a decoded JSON file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/utils.jl#L3-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.read_result-Tuple{PowerSimulations.ResultCache,Any,Any,Any,Any}" href="#PowerSimulations.read_result-Tuple{PowerSimulations.ResultCache,Any,Any,Any,Any}"><code>PowerSimulations.read_result</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Read the result from cache. Callers must first call <a href="#PowerSimulations.is_cached-Tuple{PowerSimulations.ResultCache,Any,Any,Any,Any}"><code>is_cached</code></a> to check if the timestamp is present.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/result_cache.jl#L67-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.read_result-Tuple{Type{DataFrames.DataFrame},PowerSimulations.HdfSimulationStore,Any,Any,Any,Dates.DateTime}" href="#PowerSimulations.read_result-Tuple{Type{DataFrames.DataFrame},PowerSimulations.HdfSimulationStore,Any,Any,Any,Dates.DateTime}"><code>PowerSimulations.read_result</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return DataFrame, DenseAxisArray, or Array for a model result at a timestamp.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/hdf_simulation_store.jl#L220-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.remove_chars-Tuple{String,String}" href="#PowerSimulations.remove_chars-Tuple{String,String}"><code>PowerSimulations.remove_chars</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Removes the string <code>char</code> from the original string</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/utils.jl#L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.replace_chars-Tuple{String,String,String}" href="#PowerSimulations.replace_chars-Tuple{String,String,String}"><code>PowerSimulations.replace_chars</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Replaces the string in <code>char</code> with the string<code>replacement</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/utils.jl#L347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.reserve_device_semicontinuousrange!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.RangeConstraintSpecInternal}" href="#PowerSimulations.reserve_device_semicontinuousrange!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.RangeConstraintSpecInternal}"><code>PowerSimulations.reserve_device_semicontinuousrange!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs min/max range constraint from device variable and on/off decision variable.</p><p><strong>Constraints</strong></p><p>If device min = 0:</p><p><code>varcts[name, t] &lt;= limits.max * (1 - varbin[name, t])</code></p><p><code>varcts[name, t] &gt;= 0.0</code></p><p>Otherwise:</p><p><code>varcts[name, t] &lt;= limits.max * (1 - varbin[name, t])</code></p><p><code>varcts[name, t] &gt;= limits.min * (1 - varbin[name, t])</code></p><p>where limits in constraint_infos.</p><p><strong>LaTeX</strong></p><p><span>$0 \leq x^{cts} \leq limits^{max} (1 - x^{bin} ), \text{ for } limits^{min} = 0$</span></p><p><span>$limits^{min} (1 - x^{bin} ) \leq x^{cts} \leq limits^{max} (1 - x^{bin} ), \text{ otherwise }$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/range_constraint.jl#L154-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.semicontinuousrange_ff-Tuple{PowerSimulations.PSIContainer,Symbol,Array{PowerSimulations.DeviceRangeConstraintInfo,1},PowerSimulations.UpdateRef,Symbol}" href="#PowerSimulations.semicontinuousrange_ff-Tuple{PowerSimulations.PSIContainer,Symbol,Array{PowerSimulations.DeviceRangeConstraintInfo,1},PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.semicontinuousrange_ff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">        semicontinuousrange_ff(psi_container::PSIContainer,
                                cons_name::Symbol,
                                var_name::Symbol,
                                param_reference::UpdateRef)</code></pre><p>Constructs min/max range constraint from device variable with parameter setting.</p><p><strong>Constraints</strong></p><p>If device min = 0:</p><p><code>variable[var_name, t] &lt;= r[2].max*param_reference[var_name]</code></p><p>Otherwise:</p><p><code>variable[var_name, t] &lt;= r[2].max*param_reference[var_name]</code></p><p><code>variable[var_name, t] &gt;= r[2].min*param_reference[var_name]</code></p><p>where r in range_data.</p><p><strong>LaTeX</strong></p><p><span>$0.0 \leq x^{var} \leq r^{max} x^{param}, \text{ for } r^{min} = 0$</span></p><p><span>$r^{min} x^{param} \leq x^{var} \leq r^{min} x^{param}, \text{ otherwise }$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol : the name of the continuous variable</li><li>param_reference::UpdateRef : UpdateRef of the parameter</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/feedforward.jl#L400-L432">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.serialize_simulation-Tuple{Simulation}" href="#PowerSimulations.serialize_simulation-Tuple{Simulation}"><code>PowerSimulations.serialize_simulation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">serialize_simulation(sim::Simulation, path = &quot;.&quot;)</code></pre><p>Serialize the simulation to a directory in path.</p><p>Return the serialized simulation directory name that is created.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Simulation</code>: simulation to serialize</li><li><code>path = &quot;.&quot;</code>: path in which to create the serialzed directory</li><li><code>force = false</code>: If true, delete the directory if it already exists. Otherwise, it will  throw an exception.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/simulation.jl#L1264-L1276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.service_requirement_constraint!-Union{Tuple{SR}, Tuple{PowerSimulations.PSIContainer,SR,ServiceModel{SR,GroupReserve},Array{#s119,1} where #s119&lt;:Service}} where SR&lt;:StaticReserveGroup" href="#PowerSimulations.service_requirement_constraint!-Union{Tuple{SR}, Tuple{PowerSimulations.PSIContainer,SR,ServiceModel{SR,GroupReserve},Array{#s119,1} where #s119&lt;:Service}} where SR&lt;:StaticReserveGroup"><code>PowerSimulations.service_requirement_constraint!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the requirement constraint that will be attained by the apropriate services</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/services_models/group_reserve.jl#L17-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.set_variable_bounds!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRangeConstraintInfo,1},AbstractString,Type{T}}} where T&lt;:Component" href="#PowerSimulations.set_variable_bounds!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRangeConstraintInfo,1},AbstractString,Type{T}}} where T&lt;:Component"><code>PowerSimulations.set_variable_bounds!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Adds a bounds to a variable in the optimization model.</p><p><strong>Bounds</strong></p><p><code>bounds.min &lt;= varstart[name, t] &lt;= bounds.max</code></p><p><strong>LaTeX</strong></p><p><span>$x^{device}_t &gt;= bound^{min;} \forall t$</span></p><p><span>$x^{device}_t &lt;= bound^{max} \forall t$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>bounds::DeviceRangeConstraintInfo : contains names and vector of min / max</li><li>var_type::AbstractString : type of the variable</li><li>T: type of the device</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/add_variable.jl#L163-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.sparse_container_spec-Union{Tuple{M}, Tuple{M,Vararg{Any,N} where N}} where M&lt;:JuMP.AbstractModel" href="#PowerSimulations.sparse_container_spec-Union{Tuple{M}, Tuple{M,Vararg{Any,N} where N}} where M&lt;:JuMP.AbstractModel"><code>PowerSimulations.sparse_container_spec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns the correct container spec for the selected type of JuMP Model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/utils.jl#L334">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.startup_initial_condition_constraints!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{ThermalMultiStart},DeviceModel{ThermalMultiStart,ThermalMultiStartUnitCommitment},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel" href="#PowerSimulations.startup_initial_condition_constraints!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{ThermalMultiStart},DeviceModel{ThermalMultiStart,ThermalMultiStartUnitCommitment},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.startup_initial_condition_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the initial conditions for multi-start devices</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/thermal_generation.jl#L859-L861">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.startup_time_constraints!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{ThermalMultiStart},DeviceModel{ThermalMultiStart,ThermalMultiStartUnitCommitment},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel" href="#PowerSimulations.startup_time_constraints!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{ThermalMultiStart},DeviceModel{ThermalMultiStart,ThermalMultiStartUnitCommitment},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.startup_time_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the contraints for different types of starts based on generator down-time</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/thermal_generation.jl#L767-L769">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.startup_type_constraints!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{ThermalMultiStart},DeviceModel{ThermalMultiStart,ThermalMultiStartUnitCommitment},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel" href="#PowerSimulations.startup_type_constraints!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{ThermalMultiStart},DeviceModel{ThermalMultiStart,ThermalMultiStartUnitCommitment},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.startup_type_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates constraints to select a single type of startup based on off-time</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/thermal_generation.jl#L800-L802">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.status_init-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:ThermalGen" href="#PowerSimulations.status_init-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:ThermalGen"><code>PowerSimulations.status_init</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Status Init is always calculated based on the Power Output of the device This is to make it easier to calculate when the previous model doesn&#39;t contain binaries. For instance, looking back on an ED model to find the IC of the UC model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/update_initial_conditions.jl#L192-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.turbine_temperature-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceStartUpConstraintInfo,1},Symbol,Symbol,Tuple{Symbol,Symbol}}" href="#PowerSimulations.turbine_temperature-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceStartUpConstraintInfo,1},Symbol,Symbol,Tuple{Symbol,Symbol}}"><code>PowerSimulations.turbine_temperature</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">turbine_temperature(psi_container::PSIContainer,
                        startup_data::Vector{DeviceStartUpConstraintInfo},
                        cons_name::Symbol,
                        var_stop::Symbol,
                        var_starts::Tuple{Symbol, Symbol})</code></pre><p>Constructs contraints for different types of starts based on generator down-time</p><p><strong>Equations</strong></p><p>for t in time_limits[s+1]:T</p><p><code>var_starts[name, s, t] &lt;= sum( var_stop[name, t-i] for i in time_limits[s]:(time_limits[s+1]-1)</code></p><p><strong>LaTeX</strong></p><p><span>$δ^{s}(t)  \leq \sum_{i=TS^{s}_{g}}^{TS^{s+1}_{g}} x^{stop}(t-i)$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>rate_data::Vector{DeviceStartUpConstraintInfo},</li><li>cons_name::Symbol : name of the constraint</li><li>var_stop::Symbol : name of the stop variable</li><li>var_starts::Tuple{Symbol, Symbol} : the names of the different start variables</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/thermal_generation.jl#L558-L582">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.ub_ff-Tuple{PowerSimulations.PSIContainer,Symbol,Array{PowerSimulations.DeviceRangeConstraintInfo,1},PowerSimulations.UpdateRef,Symbol}" href="#PowerSimulations.ub_ff-Tuple{PowerSimulations.PSIContainer,Symbol,Array{PowerSimulations.DeviceRangeConstraintInfo,1},PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.ub_ff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    ub_ff(psi_container::PSIContainer,
          cons_name::Symbol,
          constraint_infos::Vector{DeviceRangeConstraintInfo},
          param_reference::UpdateRef,
          var_name::Symbol)</code></pre><p>Constructs a parametrized upper bound constraint to implement feedforward from other models. The Parameters are initialized using the uppper boundary values of the provided variables.</p><p><strong>Constraints</strong></p><p><code>variable[var_name, t] &lt;= param_reference[var_name]</code></p><p><strong>LaTeX</strong></p><p><span>$x \leq param^{max}$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>cons_name::Symbol : name of the constraint</li><li>param_reference : Reference to the PJ.ParameterRef used to determine the upperbound</li><li>var_name::Symbol : the name of the continuous variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/feedforward.jl#L252-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.update_parameter!-Tuple{PowerSimulations.UpdateRef{JuMP.VariableRef},PowerSimulations.ParameterContainer,Stage,Simulation}" href="#PowerSimulations.update_parameter!-Tuple{PowerSimulations.UpdateRef{JuMP.VariableRef},PowerSimulations.ParameterContainer,Stage,Simulation}"><code>PowerSimulations.update_parameter!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Updates the forecast parameter value</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/simulation.jl#L891">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.update_stage!-Union{Tuple{M}, Tuple{Stage{M},Simulation}} where M&lt;:PowerSimulations.PowerSimulationsOperationsProblem" href="#PowerSimulations.update_stage!-Union{Tuple{M}, Tuple{Stage{M},Simulation}} where M&lt;:PowerSimulations.PowerSimulationsOperationsProblem"><code>PowerSimulations.update_stage!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Generic Stage update function for most problems with no customization</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/simulation.jl#L948">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.variable_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,String,Nothing,Int64}" href="#PowerSimulations.variable_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,String,Nothing,Int64}"><code>PowerSimulations.variable_cost!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Adds to the cost function cost terms for sum of variables with common factor to be used for cost expression for psi_container model.</p><pre><code class="language-none"># Arguments</code></pre><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>var_name::Symbol: The variable name</li><li>component<em>name::String: The component</em>name of the variable container</li><li>cost_component::PSY.VariableCost{Float64} : container for cost to be associated with variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/cost_functions.jl#L743-L752">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.variable_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,String,VariableCost{Array{Tuple{Float64,Float64},1}},Int64}" href="#PowerSimulations.variable_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,String,VariableCost{Array{Tuple{Float64,Float64},1}},Int64}"><code>PowerSimulations.variable_cost!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates piecewise linear cost function using a sum of variables and expression with sign and time step included.</p><p><strong>Expression</strong></p><p><code>JuMP.add_to_expression!(gen_cost, c)</code></p><p>Returns sign<em>gen_cost</em>dt</p><p><strong>LaTeX</strong></p><p><span>$cost = sign\times dt \sum_{v\in V} c_v$</span></p><p>where <span>$c_v$</span> is given by</p><p><span>$c_v = \sum_{i\in Ix} \frac{y_i - y_{i-1}}{x_i - x_{i-1}} v^{p.w.}_i$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>var_name::Symbol: The variable name</li><li>component<em>name::String: The component</em>name of the variable container</li><li>cost_component::PSY.VariableCost{Vector{NTuple{2, Float64}}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/cost_functions.jl#L848-L871">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.variable_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,String,VariableCost{Float64},Int64}" href="#PowerSimulations.variable_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,String,VariableCost{Float64},Int64}"><code>PowerSimulations.variable_cost!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Adds to the cost function cost terms for sum of variables with common factor to be used for cost expression for psi_container model.</p><pre><code class="language-none"># Arguments</code></pre><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>var_name::Symbol: The variable name</li><li>component<em>name::String: The component</em>name of the variable container</li><li>cost_component::PSY.VariableCost{Float64} : container for cost to be associated with variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/cost_functions.jl#L764-L773">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.variable_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,String,VariableCost{Tuple{Float64,Float64}},Int64}" href="#PowerSimulations.variable_cost!-Tuple{PowerSimulations.PSIContainer,PowerSimulations.AddCostSpec,String,VariableCost{Tuple{Float64,Float64}},Int64}"><code>PowerSimulations.variable_cost!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Adds to the cost function cost terms for sum of variables with common factor to be used for cost expression for psi_container model.</p><p><strong>Equation</strong></p><p><code>gen_cost = dt*sign*(sum(variable.^2)*cost_data[1] + sum(variable)*cost_data[2])</code></p><p><strong>LaTeX</strong></p><p><span>$cost = dt\times sign (sum_{i\in I} c_1 v_i^2 + sum_{i\in I} c_2 v_i )$</span></p><p>for quadratic factor large enough. If the first term of the quadratic objective is 0.0, adds a linear cost term <code>sum(variable)*cost_data[2]</code></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>var_name::Symbol: The variable name</li><li>component<em>name::String: The component</em>name of the variable container</li><li>cost_component::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/devices_models/devices/common/cost_functions.jl#L795-L815">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.variable_reactive_net_injection-Tuple{PowerModels.AbstractActivePowerModel}" href="#PowerSimulations.variable_reactive_net_injection-Tuple{PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.variable_reactive_net_injection</code></a> — <span class="docstring-category">Method</span></header><section><div><p>active power only models ignore reactive power variables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/network_models/powermodels_interface.jl#L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.write_psi_container-Tuple{PowerSimulations.PSIContainer,String}" href="#PowerSimulations.write_psi_container-Tuple{PowerSimulations.PSIContainer,String}"><code>PowerSimulations.write_psi_container</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Exports the OpModel JuMP object in MathOptFormat</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/psi_container.jl#L500">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.write_result!-Tuple{PowerSimulations.HdfSimulationStore,Any,Any,Any,Any,Any}" href="#PowerSimulations.write_result!-Tuple{PowerSimulations.HdfSimulationStore,Any,Any,Any,Any,Any}"><code>PowerSimulations.write_result!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Write a model result for a timestamp to the store.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/ec5b78d1fc357901dc6ec20eca8a60e955d15397/src/core/hdf_simulation_store.jl#L310-L312">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../ref/hydro/">« Hydro Models</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 28 January 2021 12:04">Thursday 28 January 2021</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
