<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>PowerSimulations · PowerSimulations.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="PowerSimulations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">PowerSimulations.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../man/logging/">Logging</a></li><li><a class="tocitem" href="../../man/op_problem/">Operation Model</a></li><li><a class="tocitem" href="../../man/simulation_recorder/">Simulation Recorder</a></li><li><span class="tocitem">Model References</span><ul><li><a class="tocitem" href="../../ref/hydro/">Hydro Models</a></li></ul></li><li><span class="tocitem">API</span><ul><li class="is-active"><a class="tocitem" href>PowerSimulations</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Exported"><span>Exported</span></a></li><li><a class="tocitem" href="#Internal"><span>Internal</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>PowerSimulations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>PowerSimulations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/master/docs/src/api/PowerSimulations.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="PowerSimulations"><a class="docs-heading-anchor" href="#PowerSimulations">PowerSimulations</a><a id="PowerSimulations-1"></a><a class="docs-heading-anchor-permalink" href="#PowerSimulations" title="Permalink"></a></h1><p>API documentation</p><ul><li><a href="#PowerSimulations">PowerSimulations</a></li><ul><li><a href="#Index">Index</a></li><li><a href="#Exported">Exported</a></li><li><a href="#Internal">Internal</a></li></ul></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#PowerSimulations.AGCReserveDeployment-Tuple{System}"><code>PowerSimulations.AGCReserveDeployment</code></a></li><li><a href="#PowerSimulations.AbstractDeviceFormulation"><code>PowerSimulations.AbstractDeviceFormulation</code></a></li><li><a href="#PowerSimulations.AbstractServiceFormulation"><code>PowerSimulations.AbstractServiceFormulation</code></a></li><li><a href="#PowerSimulations.AbstractSimulationStatusEvent"><code>PowerSimulations.AbstractSimulationStatusEvent</code></a></li><li><a href="#PowerSimulations.ActivePowerInVariable"><code>PowerSimulations.ActivePowerInVariable</code></a></li><li><a href="#PowerSimulations.ActivePowerOutVariable"><code>PowerSimulations.ActivePowerOutVariable</code></a></li><li><a href="#PowerSimulations.ActivePowerVariable"><code>PowerSimulations.ActivePowerVariable</code></a></li><li><a href="#PowerSimulations.CacheFlushRules"><code>PowerSimulations.CacheFlushRules</code></a></li><li><a href="#PowerSimulations.DeviceEnergyBalanceConstraintSpec-Union{Tuple{H}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.EnergyBalanceConstraint, Type{PowerSimulations.EnergyVariable}, Type{H}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractHydroFormulation, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}, Bool, Bool}} where H&lt;:HydroEnergyReservoir"><code>PowerSimulations.DeviceEnergyBalanceConstraintSpec</code></a></li><li><a href="#PowerSimulations.DeviceEnergyBalanceConstraintSpec-Union{Tuple{H}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.EnergyBalanceConstraint, Type{PowerSimulations.EnergyVariableUp}, Type{H}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractHydroFormulation, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}, Bool, Bool}} where H&lt;:HydroPumpedStorage"><code>PowerSimulations.DeviceEnergyBalanceConstraintSpec</code></a></li><li><a href="#PowerSimulations.DeviceModel"><code>PowerSimulations.DeviceModel</code></a></li><li><a href="#PowerSimulations.DeviceRangeConstraintInfo"><code>PowerSimulations.DeviceRangeConstraintInfo</code></a></li><li><a href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ActivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractHydroUnitCommitment, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Nothing, Bool, Bool}} where T&lt;:HydroGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a></li><li><a href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ActivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractHydroDispatchFormulation, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}, Bool, Bool}} where T&lt;:HydroGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a></li><li><a href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ActivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractThermalUnitCommitment, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Nothing, Bool, Bool}} where T&lt;:ThermalGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a></li><li><a href="#PowerSimulations.DeviceRangeConstraintSpec-Tuple{}"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a></li><li><a href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ActivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractThermalDispatchFormulation, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Nothing, Bool, Bool}} where T&lt;:ThermalGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a></li><li><a href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ActivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:ThermalMultiStartUnitCommitment, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Nothing, Bool, Bool}} where T&lt;:ThermalMultiStart"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a></li><li><a href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ReactivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractHydroDispatchFormulation, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}, Bool, Bool}} where T&lt;:HydroGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a></li><li><a href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ActivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:ThermalDispatchNoMin, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Nothing, Bool, Bool}} where T&lt;:ThermalGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a></li><li><a href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ActivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractHydroReservoirFormulation, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}, Bool, Bool}} where T&lt;:HydroGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a></li><li><a href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ReactivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractThermalUnitCommitment, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}, Bool, Bool}} where T&lt;:ThermalGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a></li><li><a href="#PowerSimulations.DeviceRangeConstraintSpec-Tuple{Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ReactivePowerVariable}, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:ElectricLoad, Type{var&quot;#s331&quot;} where var&quot;#s331&quot;&lt;:PowerSimulations.AbstractControllablePowerLoadFormulation, Type{var&quot;#s308&quot;} where var&quot;#s308&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}, Bool, Bool}"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a></li><li><a href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ReactivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractThermalDispatchFormulation, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}, Bool, Bool}} where T&lt;:ThermalGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a></li><li><a href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ReactivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractHydroUnitCommitment, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Nothing, Bool, Bool}} where T&lt;:HydroGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a></li><li><a href="#PowerSimulations.EconomicDispatchProblem-Tuple{System}"><code>PowerSimulations.EconomicDispatchProblem</code></a></li><li><a href="#PowerSimulations.FixedOutput"><code>PowerSimulations.FixedOutput</code></a></li><li><a href="#PowerSimulations.FlowActivePowerVariable"><code>PowerSimulations.FlowActivePowerVariable</code></a></li><li><a href="#PowerSimulations.GenericOpProblem"><code>PowerSimulations.GenericOpProblem</code></a></li><li><a href="#PowerSimulations.HdfSimulationStore"><code>PowerSimulations.HdfSimulationStore</code></a></li><li><a href="#PowerSimulations.InMemorySimulationStore"><code>PowerSimulations.InMemorySimulationStore</code></a></li><li><a href="#PowerSimulations.IntraProblemChronology"><code>PowerSimulations.IntraProblemChronology</code></a></li><li><a href="#PowerSimulations.NodalExpressionSpec-Union{Tuple{U}, Tuple{T}, Tuple{Type{T}, Type{U}, Bool}} where {T&lt;:Device, U&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.NodalExpressionSpec</code></a></li><li><a href="#PowerSimulations.OperationsProblem-Union{Tuple{M}, Tuple{Type{M}, OperationsProblemTemplate, System}, Tuple{Type{M}, OperationsProblemTemplate, System, Union{Nothing, JuMP.Model}}} where M&lt;:PowerSimulations.AbstractOperationsProblem"><code>PowerSimulations.OperationsProblem</code></a></li><li><a href="#PowerSimulations.OperationsProblem-Tuple{AbstractString}"><code>PowerSimulations.OperationsProblem</code></a></li><li><a href="#PowerSimulations.OperationsProblem"><code>PowerSimulations.OperationsProblem</code></a></li><li><a href="#PowerSimulations.OperationsProblemTemplate"><code>PowerSimulations.OperationsProblemTemplate</code></a></li><li><a href="#PowerSimulations.OptimizerStats-Tuple{Vector{Float64}}"><code>PowerSimulations.OptimizerStats</code></a></li><li><a href="#PowerSimulations.OptimizerStats-Tuple{Any}"><code>PowerSimulations.OptimizerStats</code></a></li><li><a href="#PowerSimulations.OptimizerStats-Tuple{Any, Any}"><code>PowerSimulations.OptimizerStats</code></a></li><li><a href="#PowerSimulations.ParamResultCache"><code>PowerSimulations.ParamResultCache</code></a></li><li><a href="#PowerSimulations.PowerOutput"><code>PowerSimulations.PowerOutput</code></a></li><li><a href="#PowerSimulations.ProblemData"><code>PowerSimulations.ProblemData</code></a></li><li><a href="#PowerSimulations.ProblemDatasets"><code>PowerSimulations.ProblemDatasets</code></a></li><li><a href="#PowerSimulations.RecedingHorizon"><code>PowerSimulations.RecedingHorizon</code></a></li><li><a href="#PowerSimulations.ResultCache"><code>PowerSimulations.ResultCache</code></a></li><li><a href="#PowerSimulations.ServiceModel"><code>PowerSimulations.ServiceModel</code></a></li><li><a href="#PowerSimulations.Simulation-Tuple{AbstractString, Dict}"><code>PowerSimulations.Simulation</code></a></li><li><a href="#PowerSimulations.Simulation"><code>PowerSimulations.Simulation</code></a></li><li><a href="#PowerSimulations.SimulationProblemResults"><code>PowerSimulations.SimulationProblemResults</code></a></li><li><a href="#PowerSimulations.SimulationProblems"><code>PowerSimulations.SimulationProblems</code></a></li><li><a href="#PowerSimulations.SimulationResults-Tuple{Simulation}"><code>PowerSimulations.SimulationResults</code></a></li><li><a href="#PowerSimulations.SimulationResults"><code>PowerSimulations.SimulationResults</code></a></li><li><a href="#PowerSimulations.SimulationSequence"><code>PowerSimulations.SimulationSequence</code></a></li><li><a href="#PowerSimulations.SimulationStore"><code>PowerSimulations.SimulationStore</code></a></li><li><a href="#PowerSimulations.StaticBranch"><code>PowerSimulations.StaticBranch</code></a></li><li><a href="#PowerSimulations.StaticBranchBounds"><code>PowerSimulations.StaticBranchBounds</code></a></li><li><a href="#PowerSimulations.StaticBranchUnbounded"><code>PowerSimulations.StaticBranchUnbounded</code></a></li><li><a href="#PowerSimulations.Synchronize"><code>PowerSimulations.Synchronize</code></a></li><li><a href="#PowerSimulations.TimeStatusChange"><code>PowerSimulations.TimeStatusChange</code></a></li><li><a href="#PowerSimulations.UnitCommitmentProblem-Tuple{System}"><code>PowerSimulations.UnitCommitmentProblem</code></a></li><li><a href="#PowerSimulations.UpdateRef"><code>PowerSimulations.UpdateRef</code></a></li><li><a href="#Base.show-Tuple{IO, MIME{Symbol(&quot;text/plain&quot;)}, OperationsProblem}"><code>Base.show</code></a></li><li><a href="#PowerSimulations._allocate_execution_order-Tuple{Dict{Int64, Int64}}"><code>PowerSimulations._allocate_execution_order</code></a></li><li><a href="#PowerSimulations._calculate_interval_inner_counts-Tuple{OrderedDict{Symbol, Tuple{Dates.TimePeriod, PowerSimulations.FeedForwardChronology}}}"><code>PowerSimulations._calculate_interval_inner_counts</code></a></li><li><a href="#PowerSimulations._get_data_for_rocc-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}}} where T&lt;:ThermalGen"><code>PowerSimulations._get_data_for_rocc</code></a></li><li><a href="#PowerSimulations._get_data_for_tdc-Tuple{Vector{InitialCondition}, Vector{InitialCondition}, Dates.TimePeriod}"><code>PowerSimulations._get_data_for_tdc</code></a></li><li><a href="#PowerSimulations._get_data_startup_ic-Tuple{Vector{InitialCondition}, Dates.TimePeriod}"><code>PowerSimulations._get_data_startup_ic</code></a></li><li><a href="#PowerSimulations._update_problem!-Tuple{OperationsProblem, Simulation}"><code>PowerSimulations._update_problem!</code></a></li><li><a href="#PowerSimulations.add_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{St}, Tuple{PowerSimulations.OptimizationContainer, Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ReactivePowerVariable}, InfrastructureSystems.FlattenIteratorWrapper{St}, DeviceModel{St, D}, Type{S}, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where {St&lt;:Storage, D&lt;:PowerSimulations.AbstractStorageFormulation, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.add_constraints!</code></a></li><li><a href="#PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where {T&lt;:PowerSimulations.RangeConstraint, U&lt;:PowerSimulations.VariableType, V&lt;:Device, W&lt;:PowerSimulations.AbstractDeviceFormulation, X&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.add_constraints!</code></a></li><li><a href="#PowerSimulations.add_result!-Tuple{PowerSimulations.ParamResultCache, Any, Any, Any}"><code>PowerSimulations.add_result!</code></a></li><li><a href="#PowerSimulations.add_to_cost!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, MarketBidCost, Component}"><code>PowerSimulations.add_to_cost!</code></a></li><li><a href="#PowerSimulations.add_to_cost!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, ThreePartCost, Component}"><code>PowerSimulations.add_to_cost!</code></a></li><li><a href="#PowerSimulations.add_to_cost!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, MultiStartCost, Component}"><code>PowerSimulations.add_to_cost!</code></a></li><li><a href="#PowerSimulations.add_to_cost!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, MarketBidCost, ThermalMultiStart}"><code>PowerSimulations.add_to_cost!</code></a></li><li><a href="#PowerSimulations.add_to_cost!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, TwoPartCost, Component}"><code>PowerSimulations.add_to_cost!</code></a></li><li><a href="#PowerSimulations.add_variable!-Union{Tuple{U}, Tuple{T}, Tuple{D}, Tuple{PowerSimulations.OptimizationContainer, T, U, Any}} where {D&lt;:Component, T&lt;:PowerSimulations.AuxVariableType, U&lt;:Union{Vector{D}, InfrastructureSystems.FlattenIteratorWrapper{D}}}"><code>PowerSimulations.add_variable!</code></a></li><li><a href="#PowerSimulations.add_variable!-Union{Tuple{U}, Tuple{D}, Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.VariableType, U, Any}} where {D&lt;:Component, U&lt;:Union{Vector{D}, InfrastructureSystems.FlattenIteratorWrapper{D}}}"><code>PowerSimulations.add_variable!</code></a></li><li><a href="#PowerSimulations.add_variables!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Union{Vector{U}, InfrastructureSystems.FlattenIteratorWrapper{U}}, Union{PowerSimulations.AbstractDeviceFormulation, PowerSimulations.AbstractServiceFormulation}}} where {T&lt;:PowerSimulations.VariableType, U&lt;:Component}"><code>PowerSimulations.add_variables!</code></a></li><li><a href="#PowerSimulations.add_variables!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, U, Vector{V}, PowerSimulations.AbstractReservesFormulation}} where {T&lt;:PowerSimulations.VariableType, U&lt;:Reserve, V&lt;:Device}"><code>PowerSimulations.add_variables!</code></a></li><li><a href="#PowerSimulations.add_variables!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Union{Vector{U}, InfrastructureSystems.FlattenIteratorWrapper{U}}, Union{PowerSimulations.AbstractDeviceFormulation, PowerSimulations.AbstractServiceFormulation}}} where {T&lt;:PowerSimulations.AuxVariableType, U&lt;:Component}"><code>PowerSimulations.add_variables!</code></a></li><li><a href="#PowerSimulations.add_variables!-Tuple{PowerSimulations.OptimizationContainer, Type{PowerSimulations.SteadyStateFrequencyDeviation}}"><code>PowerSimulations.add_variables!</code></a></li><li><a href="#PowerSimulations.axis_array_to_dataframe"><code>PowerSimulations.axis_array_to_dataframe</code></a></li><li><a href="#PowerSimulations.build!-Tuple{OperationsProblem{var&quot;#s306&quot;} where var&quot;#s306&quot;&lt;:PowerSimulations.AbstractOperationsProblem}"><code>PowerSimulations.build!</code></a></li><li><a href="#PowerSimulations.build!-Tuple{Simulation}"><code>PowerSimulations.build!</code></a></li><li><a href="#PowerSimulations.check_activeservice_variables-Tuple{PowerSimulations.OptimizationContainer, Vector{var&quot;#s2016&quot;} where var&quot;#s2016&quot;&lt;:Service}"><code>PowerSimulations.check_activeservice_variables</code></a></li><li><a href="#PowerSimulations.check_file_integrity-Tuple{String}"><code>PowerSimulations.check_file_integrity</code></a></li><li><a href="#PowerSimulations.commit_hydro_active_power_ub!-Union{Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Any, DeviceModel{V, W}, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where {V&lt;:HydroGen, W&lt;:PowerSimulations.AbstractHydroUnitCommitment}"><code>PowerSimulations.commit_hydro_active_power_ub!</code></a></li><li><a href="#PowerSimulations.commitment_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, D}, Type{S}, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where {T&lt;:ThermalGen, D&lt;:PowerSimulations.AbstractThermalUnitCommitment, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.commitment_constraints!</code></a></li><li><a href="#PowerSimulations.compute_sha256-Tuple{AbstractString}"><code>PowerSimulations.compute_sha256</code></a></li><li><a href="#PowerSimulations.constraint_current_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel, Int64, Int64, Any, Any, Any, Any}"><code>PowerSimulations.constraint_current_balance_ni_expr</code></a></li><li><a href="#PowerSimulations.constraint_current_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel, Int64}"><code>PowerSimulations.constraint_current_balance_ni_expr</code></a></li><li><a href="#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel, Int64, Int64, Any, Any, Any, Any}"><code>PowerSimulations.constraint_power_balance_ni_expr</code></a></li><li><a href="#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel, Int64}"><code>PowerSimulations.constraint_power_balance_ni_expr</code></a></li><li><a href="#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractActivePowerModel, Int64, Int64, Any, Any, Any, Any}"><code>PowerSimulations.constraint_power_balance_ni_expr</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{RegulationDevice{T}, FixedOutput}, Type{S}}} where {T&lt;:StaticInjection, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, HydroDispatchReservoirStorage}, Type{S}}} where {H&lt;:HydroEnergyReservoir, S&lt;:PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, HydroDispatchReservoirBudget}, Type{S}}} where {H&lt;:HydroEnergyReservoir, S&lt;:PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, HydroDispatchPumpedStorage}, Type{S}}} where {H&lt;:HydroPumpedStorage, S&lt;:PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, D}, Type{S}}} where {H&lt;:HydroGen, D&lt;:HydroCommitmentRunOfRiver, S&lt;:PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, D}, Type{S}}} where {H&lt;:HydroGen, D&lt;:HydroCommitmentReservoirBudget, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, HydroDispatchPumpedStoragewReservation}, Type{S}}} where {H&lt;:HydroPumpedStorage, S&lt;:PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, HydroDispatchReservoirBudget}, Type{S}}} where {H&lt;:HydroEnergyReservoir, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{RegulationDevice{T}, DeviceLimitedRegulation}, Type{S}}} where {T&lt;:StaticInjection, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{T, ThermalBasicUnitCommitment}, Type{S}}} where {T&lt;:ThermalGen, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, FixedOutput}, Type{S}}} where {H&lt;:HydroGen, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{T, ThermalRampLimited}, Type{S}}} where {T&lt;:ThermalGen, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, D}, Type{S}}} where {H&lt;:HydroGen, D&lt;:PowerSimulations.AbstractHydroDispatchFormulation, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{T, D}, Type{S}}} where {T&lt;:ThermalGen, D&lt;:PowerSimulations.AbstractStandardUnitCommitment, S&lt;:PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, D}, Type{S}}} where {H&lt;:HydroGen, D&lt;:PowerSimulations.AbstractHydroDispatchFormulation, S&lt;:PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{T, ThermalBasicUnitCommitment}, Type{S}}} where {T&lt;:ThermalGen, S&lt;:PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{RegulationDevice{T}, ReserveLimitedRegulation}, Type{S}}} where {T&lt;:StaticInjection, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, D}, Type{S}}} where {H&lt;:HydroGen, D&lt;:HydroCommitmentRunOfRiver, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, HydroCommitmentReservoirStorage}, Type{S}}} where {H&lt;:HydroEnergyReservoir, S&lt;:PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, HydroCommitmentReservoirStorage}, Type{S}}} where {H&lt;:HydroEnergyReservoir, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{T, ThermalRampLimited}, Type{S}}} where {T&lt;:ThermalGen, S&lt;:PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, D}, Type{S}}} where {H&lt;:HydroGen, D&lt;:HydroCommitmentReservoirBudget, S&lt;:PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, HydroDispatchReservoirStorage}, Type{S}}} where {H&lt;:HydroEnergyReservoir, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{T, D}, Type{S}}} where {T&lt;:ThermalGen, D&lt;:PowerSimulations.AbstractStandardUnitCommitment, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_service!-Union{Tuple{SR}, Tuple{PowerSimulations.OptimizationContainer, Vector{SR}, System, ServiceModel{SR, GroupReserve}, Dict{Symbol, DeviceModel}, Vector{var&quot;#s2016&quot;} where var&quot;#s2016&quot;&lt;:DataType}} where SR&lt;:StaticReserveGroup"><code>PowerSimulations.construct_service!</code></a></li><li><a href="#PowerSimulations.container_spec-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any, N} where N}} where T"><code>PowerSimulations.container_spec</code></a></li><li><a href="#PowerSimulations.cost_function!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, ThermalDispatchNoMin}, Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where T&lt;:ThermalGen"><code>PowerSimulations.cost_function!</code></a></li><li><a href="#PowerSimulations.cost_function!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, U}, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, U}, Type{var&quot;#s331&quot;} where var&quot;#s331&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where {T&lt;:Component, U&lt;:PowerSimulations.AbstractDeviceFormulation}"><code>PowerSimulations.cost_function!</code></a></li><li><a href="#PowerSimulations.device_commitment!-Tuple{PowerSimulations.OptimizationContainer, Vector{InitialCondition}, Symbol, Tuple{Symbol, Symbol, Symbol}}"><code>PowerSimulations.device_commitment!</code></a></li><li><a href="#PowerSimulations.device_duration_compact_retrospective!-Tuple{PowerSimulations.OptimizationContainer, Vector{NamedTuple{(:up, :down), Tuple{Float64, Float64}}}, Matrix{InitialCondition}, Symbol, Tuple{Symbol, Symbol, Symbol}}"><code>PowerSimulations.device_duration_compact_retrospective!</code></a></li><li><a href="#PowerSimulations.device_duration_look_ahead!-Tuple{PowerSimulations.OptimizationContainer, Vector{NamedTuple{(:up, :down), Tuple{Float64, Float64}}}, Matrix{InitialCondition}, Symbol, Tuple{Symbol, Symbol, Symbol}}"><code>PowerSimulations.device_duration_look_ahead!</code></a></li><li><a href="#PowerSimulations.device_duration_parameters!-Tuple{PowerSimulations.OptimizationContainer, Vector{NamedTuple{(:up, :down), Tuple{Float64, Float64}}}, Matrix{InitialCondition}, Symbol, Tuple{Symbol, Symbol, Symbol}}"><code>PowerSimulations.device_duration_parameters!</code></a></li><li><a href="#PowerSimulations.device_duration_retrospective!-Tuple{PowerSimulations.OptimizationContainer, Vector{NamedTuple{(:up, :down), Tuple{Float64, Float64}}}, Matrix{InitialCondition}, Symbol, Tuple{Symbol, Symbol, Symbol}}"><code>PowerSimulations.device_duration_retrospective!</code></a></li><li><a href="#PowerSimulations.device_energy_budget_param_ub-Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceTimeSeriesConstraintInfo}, Symbol, PowerSimulations.UpdateRef, Symbol}"><code>PowerSimulations.device_energy_budget_param_ub</code></a></li><li><a href="#PowerSimulations.device_energy_budget_ub-Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceTimeSeriesConstraintInfo}, Symbol, Symbol}"><code>PowerSimulations.device_energy_budget_ub</code></a></li><li><a href="#PowerSimulations.device_linear_rateofchange!-Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceRampConstraintInfo}, Symbol, Symbol}"><code>PowerSimulations.device_linear_rateofchange!</code></a></li><li><a href="#PowerSimulations.device_mixedinteger_rateofchange!-Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceRampConstraintInfo}, Symbol, Tuple{Symbol, Symbol, Symbol}}"><code>PowerSimulations.device_mixedinteger_rateofchange!</code></a></li><li><a href="#PowerSimulations.device_multistart_range!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.RangeConstraintSpecInternal}"><code>PowerSimulations.device_multistart_range!</code></a></li><li><a href="#PowerSimulations.device_multistart_range_ic!-Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceMultiStartRangeConstraintsInfo}, Matrix{InitialCondition}, Symbol, Symbol}"><code>PowerSimulations.device_multistart_range_ic!</code></a></li><li><a href="#PowerSimulations.device_multistart_rateofchange!-Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceRampConstraintInfo}, Symbol, Symbol}"><code>PowerSimulations.device_multistart_rateofchange!</code></a></li><li><a href="#PowerSimulations.device_range!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.RangeConstraintSpecInternal}"><code>PowerSimulations.device_range!</code></a></li><li><a href="#PowerSimulations.device_semicontinuousrange!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.RangeConstraintSpecInternal}"><code>PowerSimulations.device_semicontinuousrange!</code></a></li><li><a href="#PowerSimulations.device_start_type_constraint-Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceStartTypesConstraintInfo}, Symbol, Symbol, Tuple{Symbol, Symbol, Symbol}}"><code>PowerSimulations.device_start_type_constraint</code></a></li><li><a href="#PowerSimulations.device_startup_initial_condition-Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceStartUpConstraintInfo}, Vector{InitialCondition}, Symbol, Tuple{Symbol, Symbol}, Symbol}"><code>PowerSimulations.device_startup_initial_condition</code></a></li><li><a href="#PowerSimulations.device_timeseries_lb!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.TimeSeriesConstraintSpecInternal}"><code>PowerSimulations.device_timeseries_lb!</code></a></li><li><a href="#PowerSimulations.device_timeseries_param_lb!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.TimeSeriesConstraintSpecInternal}"><code>PowerSimulations.device_timeseries_param_lb!</code></a></li><li><a href="#PowerSimulations.device_timeseries_param_ub!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.TimeSeriesConstraintSpecInternal}"><code>PowerSimulations.device_timeseries_param_ub!</code></a></li><li><a href="#PowerSimulations.device_timeseries_ub!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.TimeSeriesConstraintSpecInternal}"><code>PowerSimulations.device_timeseries_ub!</code></a></li><li><a href="#PowerSimulations.device_timeseries_ub_bigM!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.TimeSeriesConstraintSpecInternal}"><code>PowerSimulations.device_timeseries_ub_bigM!</code></a></li><li><a href="#PowerSimulations.device_timeseries_ub_bin!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.TimeSeriesConstraintSpecInternal}"><code>PowerSimulations.device_timeseries_ub_bin!</code></a></li><li><a href="#PowerSimulations.energy_balance!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.DeviceEnergyBalanceConstraintSpecInternal}"><code>PowerSimulations.energy_balance!</code></a></li><li><a href="#PowerSimulations.energy_balance_param!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.DeviceEnergyBalanceConstraintSpecInternal}"><code>PowerSimulations.energy_balance_param!</code></a></li><li><a href="#PowerSimulations.energy_budget_constraints!-Union{Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{H}, DeviceModel{H, var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractHydroFormulation, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where H&lt;:HydroGen"><code>PowerSimulations.energy_budget_constraints!</code></a></li><li><a href="#PowerSimulations.energy_target!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Vector{T}, Symbol, Tuple{Symbol, Symbol, Symbol}}} where T&lt;:PowerSimulations.DeviceTimeSeriesConstraintInfo"><code>PowerSimulations.energy_target!</code></a></li><li><a href="#PowerSimulations.energy_target_param!-Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceTimeSeriesConstraintInfo}, Symbol, Tuple{Symbol, Symbol, Symbol}, PowerSimulations.UpdateRef}"><code>PowerSimulations.energy_target_param!</code></a></li><li><a href="#PowerSimulations.execute!-Tuple{Simulation}"><code>PowerSimulations.execute!</code></a></li><li><a href="#PowerSimulations.export_results-Tuple{ProblemResults}"><code>PowerSimulations.export_results</code></a></li><li><a href="#PowerSimulations.export_results-Tuple{SimulationResults, Any}"><code>PowerSimulations.export_results</code></a></li><li><a href="#PowerSimulations.find_key_with_value-Tuple{Any, Any}"><code>PowerSimulations.find_key_with_value</code></a></li><li><a href="#PowerSimulations.frequency_response_constraint!-Tuple{PowerSimulations.OptimizationContainer, System}"><code>PowerSimulations.frequency_response_constraint!</code></a></li><li><a href="#PowerSimulations.get_all_constraint_index-Tuple{OperationsProblem}"><code>PowerSimulations.get_all_constraint_index</code></a></li><li><a href="#PowerSimulations.get_all_var_index-Tuple{OperationsProblem}"><code>PowerSimulations.get_all_var_index</code></a></li><li><a href="#PowerSimulations.get_enum_value-Tuple{Any, String}"><code>PowerSimulations.get_enum_value</code></a></li><li><a href="#PowerSimulations.get_system!-Tuple{PowerSimulations.SimulationProblemResults}"><code>PowerSimulations.get_system!</code></a></li><li><a href="#PowerSimulations.has_dirty-Tuple{PowerSimulations.ResultCache}"><code>PowerSimulations.has_dirty</code></a></li><li><a href="#PowerSimulations.initial_condition_update!-Tuple{OperationsProblem, PowerSimulations.ICKey, Vector{InitialCondition}, InterProblemChronology, Simulation}"><code>PowerSimulations.initial_condition_update!</code></a></li><li><a href="#PowerSimulations.initial_condition_update!-Tuple{OperationsProblem, PowerSimulations.ICKey, Vector{InitialCondition}, IntraProblemChronology, Simulation}"><code>PowerSimulations.initial_condition_update!</code></a></li><li><a href="#PowerSimulations.initial_range_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, D}, Type{S}, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where {T&lt;:ThermalMultiStart, D&lt;:PowerSimulations.AbstractCompactUnitCommitment, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.initial_range_constraints!</code></a></li><li><a href="#PowerSimulations.instantiate_nip_expr_model-Tuple{Dict{String, Any}, Any}"><code>PowerSimulations.instantiate_nip_expr_model</code></a></li><li><a href="#PowerSimulations.instantiate_nip_ptdf_expr_model-Tuple{Dict{String, Any}, Any}"><code>PowerSimulations.instantiate_nip_ptdf_expr_model</code></a></li><li><a href="#PowerSimulations.integral_limit_ff-Tuple{PowerSimulations.OptimizationContainer, Symbol, PowerSimulations.UpdateRef, Symbol}"><code>PowerSimulations.integral_limit_ff</code></a></li><li><a href="#PowerSimulations.is_cached-Tuple{PowerSimulations.ResultCache, Any, Any, Any, Any}"><code>PowerSimulations.is_cached</code></a></li><li><a href="#PowerSimulations.iterate_initial_conditions-Tuple{PowerSimulations.InitialConditions}"><code>PowerSimulations.iterate_initial_conditions</code></a></li><li><a href="#PowerSimulations.list_fields-Tuple{PowerSimulations.HdfSimulationStore, Symbol, Symbol}"><code>PowerSimulations.list_fields</code></a></li><li><a href="#PowerSimulations.list_problems-Tuple{PowerSimulations.HdfSimulationStore}"><code>PowerSimulations.list_problems</code></a></li><li><a href="#PowerSimulations.list_problems-Tuple{SimulationResults}"><code>PowerSimulations.list_problems</code></a></li><li><a href="#PowerSimulations.list_simulation_events-Union{Tuple{T}, Tuple{Type{T}, AbstractString}, Tuple{Type{T}, AbstractString, Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent"><code>PowerSimulations.list_simulation_events</code></a></li><li><a href="#PowerSimulations.load_results!-Tuple{PowerSimulations.SimulationProblemResults, Int64}"><code>PowerSimulations.load_results!</code></a></li><li><a href="#PowerSimulations.log_cache_hit_percentages-Tuple{PowerSimulations.ResultCache}"><code>PowerSimulations.log_cache_hit_percentages</code></a></li><li><a href="#PowerSimulations.must_run_constraints!-Union{Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{ThermalMultiStart}, DeviceModel{ThermalMultiStart, ThermalMultiStartUnitCommitment}, Type{S}, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.must_run_constraints!</code></a></li><li><a href="#PowerSimulations.nodal_expression!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{T}, Type{U}}} where {T&lt;:Device, U&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.nodal_expression!</code></a></li><li><a href="#PowerSimulations.open_store"><code>PowerSimulations.open_store</code></a></li><li><a href="#PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, Type{S}, System, OperationsProblemTemplate}, Tuple{PowerSimulations.OptimizationContainer, Type{S}, System, OperationsProblemTemplate, Any}} where S&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.powermodels_network!</code></a></li><li><a href="#PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, Type{S}, System, OperationsProblemTemplate}, Tuple{PowerSimulations.OptimizationContainer, Type{S}, System, OperationsProblemTemplate, Any}} where S&lt;:PowerModels.AbstractActivePowerModel"><code>PowerSimulations.powermodels_network!</code></a></li><li><a href="#PowerSimulations.problem_build!-Tuple{OperationsProblem{var&quot;#s331&quot;} where var&quot;#s331&quot;&lt;:PowerSimulations.PowerSimulationsOperationsProblem}"><code>PowerSimulations.problem_build!</code></a></li><li><a href="#PowerSimulations.pwl_gencost_linear!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, String, Vector{Tuple{Float64, Float64}}, Int64}"><code>PowerSimulations.pwl_gencost_linear!</code></a></li><li><a href="#PowerSimulations.pwl_gencost_sos!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, String, Vector{Tuple{Float64, Float64}}, Int64}"><code>PowerSimulations.pwl_gencost_sos!</code></a></li><li><a href="#PowerSimulations.pwlparamcheck-Tuple{Any}"><code>PowerSimulations.pwlparamcheck</code></a></li><li><a href="#PowerSimulations.ramp_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, D}, Type{S}, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where {T&lt;:ThermalGen, D&lt;:PowerSimulations.AbstractThermalUnitCommitment, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.ramp_constraints!</code></a></li><li><a href="#PowerSimulations.range_ff-Tuple{PowerSimulations.OptimizationContainer, Symbol, Vector{T} where T, Tuple{PowerSimulations.UpdateRef, PowerSimulations.UpdateRef}, Symbol}"><code>PowerSimulations.range_ff</code></a></li><li><a href="#PowerSimulations.rating_constraint!-Tuple{PowerSimulations.OptimizationContainer, Vector{Tuple{String, Float64}}, Symbol, Tuple{Symbol, Symbol}}"><code>PowerSimulations.rating_constraint!</code></a></li><li><a href="#PowerSimulations.read_dataframe-Tuple{AbstractString}"><code>PowerSimulations.read_dataframe</code></a></li><li><a href="#PowerSimulations.read_dual-Tuple{PowerSimulations.SimulationProblemResults, Symbol}"><code>PowerSimulations.read_dual</code></a></li><li><a href="#PowerSimulations.read_duals-Tuple{PowerSimulations.SimulationProblemResults}"><code>PowerSimulations.read_duals</code></a></li><li><a href="#PowerSimulations.read_json-Tuple{AbstractString}"><code>PowerSimulations.read_json</code></a></li><li><a href="#PowerSimulations.read_optimizer_stats-Tuple{PowerSimulations.SimulationProblemResults}"><code>PowerSimulations.read_optimizer_stats</code></a></li><li><a href="#PowerSimulations.read_parameter-Tuple{PowerSimulations.SimulationProblemResults, Symbol}"><code>PowerSimulations.read_parameter</code></a></li><li><a href="#PowerSimulations.read_parameters-Tuple{PowerSimulations.SimulationProblemResults}"><code>PowerSimulations.read_parameters</code></a></li><li><a href="#PowerSimulations.read_problem_optimizer_stats-Tuple{PowerSimulations.HdfSimulationStore, Any}"><code>PowerSimulations.read_problem_optimizer_stats</code></a></li><li><a href="#PowerSimulations.read_problem_optimizer_stats-Tuple{PowerSimulations.HdfSimulationStore, Any, Any, Any}"><code>PowerSimulations.read_problem_optimizer_stats</code></a></li><li><a href="#PowerSimulations.read_realized_duals-Tuple{PowerSimulations.SimulationProblemResults}"><code>PowerSimulations.read_realized_duals</code></a></li><li><a href="#PowerSimulations.read_realized_parameters-Tuple{PowerSimulations.SimulationProblemResults}"><code>PowerSimulations.read_realized_parameters</code></a></li><li><a href="#PowerSimulations.read_realized_variables-Tuple{PowerSimulations.SimulationProblemResults}"><code>PowerSimulations.read_realized_variables</code></a></li><li><a href="#PowerSimulations.read_result-Tuple{PowerSimulations.ResultCache, Any, Any, Any, Any}"><code>PowerSimulations.read_result</code></a></li><li><a href="#PowerSimulations.read_result-Tuple{Type{DataFrames.DataFrame}, PowerSimulations.HdfSimulationStore, Any, Any, Any, Dates.DateTime}"><code>PowerSimulations.read_result</code></a></li><li><a href="#PowerSimulations.read_variable-Tuple{PowerSimulations.SimulationProblemResults, Symbol}"><code>PowerSimulations.read_variable</code></a></li><li><a href="#PowerSimulations.read_variables-Tuple{PowerSimulations.SimulationProblemResults}"><code>PowerSimulations.read_variables</code></a></li><li><a href="#PowerSimulations.remove_chars-Tuple{String, String}"><code>PowerSimulations.remove_chars</code></a></li><li><a href="#PowerSimulations.replace_chars-Tuple{String, String, String}"><code>PowerSimulations.replace_chars</code></a></li><li><a href="#PowerSimulations.reserve_device_semicontinuousrange!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.RangeConstraintSpecInternal}"><code>PowerSimulations.reserve_device_semicontinuousrange!</code></a></li><li><a href="#PowerSimulations.run_economic_dispatch-Tuple{System}"><code>PowerSimulations.run_economic_dispatch</code></a></li><li><a href="#PowerSimulations.semicontinuousrange_ff-Tuple{PowerSimulations.OptimizationContainer, Symbol, Vector{PowerSimulations.DeviceRangeConstraintInfo}, PowerSimulations.UpdateRef, Symbol}"><code>PowerSimulations.semicontinuousrange_ff</code></a></li><li><a href="#PowerSimulations.serialize_optimization_model-Tuple{PowerSimulations.OptimizationContainer, String}"><code>PowerSimulations.serialize_optimization_model</code></a></li><li><a href="#PowerSimulations.serialize_simulation-Tuple{Simulation}"><code>PowerSimulations.serialize_simulation</code></a></li><li><a href="#PowerSimulations.service_requirement_constraint!-Union{Tuple{SR}, Tuple{PowerSimulations.OptimizationContainer, SR, ServiceModel{SR, GroupReserve}, Vector{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:Service}} where SR&lt;:StaticReserveGroup"><code>PowerSimulations.service_requirement_constraint!</code></a></li><li><a href="#PowerSimulations.set_device_model!-Tuple{OperationsProblemTemplate, Type{var&quot;#s31&quot;} where var&quot;#s31&quot;&lt;:Device, Type{var&quot;#s30&quot;} where var&quot;#s30&quot;&lt;:PowerSimulations.AbstractDeviceFormulation}"><code>PowerSimulations.set_device_model!</code></a></li><li><a href="#PowerSimulations.set_device_model!-Tuple{OperationsProblemTemplate, DeviceModel{var&quot;#s31&quot;, var&quot;#s30&quot;} where {var&quot;#s31&quot;&lt;:Device, var&quot;#s30&quot;&lt;:PowerSimulations.AbstractDeviceFormulation}}"><code>PowerSimulations.set_device_model!</code></a></li><li><a href="#PowerSimulations.set_service_model!-Tuple{OperationsProblemTemplate, String, Type{var&quot;#s31&quot;} where var&quot;#s31&quot;&lt;:Service, Type{var&quot;#s30&quot;} where var&quot;#s30&quot;&lt;:PowerSimulations.AbstractServiceFormulation}"><code>PowerSimulations.set_service_model!</code></a></li><li><a href="#PowerSimulations.set_service_model!-Tuple{OperationsProblemTemplate, Type{var&quot;#s31&quot;} where var&quot;#s31&quot;&lt;:Service, Type{var&quot;#s30&quot;} where var&quot;#s30&quot;&lt;:PowerSimulations.AbstractServiceFormulation}"><code>PowerSimulations.set_service_model!</code></a></li><li><a href="#PowerSimulations.set_system!-Tuple{PowerSimulations.SimulationProblemResults, System}"><code>PowerSimulations.set_system!</code></a></li><li><a href="#PowerSimulations.set_transmission_model!-Tuple{OperationsProblemTemplate, Type{var&quot;#s32&quot;} where var&quot;#s32&quot;&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.set_transmission_model!</code></a></li><li><a href="#PowerSimulations.set_variable_bounds!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceRangeConstraintInfo}, AbstractString, Type{T}}} where T&lt;:Component"><code>PowerSimulations.set_variable_bounds!</code></a></li><li><a href="#PowerSimulations.show_recorder_events-Union{Tuple{T}, Tuple{Type{T}, AbstractString}, Tuple{Type{T}, AbstractString, Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent"><code>PowerSimulations.show_recorder_events</code></a></li><li><a href="#PowerSimulations.show_simulation_events-Union{Tuple{T}, Tuple{Type{T}, AbstractString}, Tuple{Type{T}, AbstractString, Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent"><code>PowerSimulations.show_simulation_events</code></a></li><li><a href="#PowerSimulations.solve!-Tuple{OperationsProblem{var&quot;#s306&quot;} where var&quot;#s306&quot;&lt;:PowerSimulations.PowerSimulationsOperationsProblem}"><code>PowerSimulations.solve!</code></a></li><li><a href="#PowerSimulations.solve!-Tuple{Int64, OperationsProblem{var&quot;#s306&quot;} where var&quot;#s306&quot;&lt;:PowerSimulations.AbstractOperationsProblem, Dates.DateTime, PowerSimulations.SimulationStore}"><code>PowerSimulations.solve!</code></a></li><li><a href="#PowerSimulations.sparse_container_spec-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any, N} where N}} where T"><code>PowerSimulations.sparse_container_spec</code></a></li><li><a href="#PowerSimulations.startup_initial_condition_constraints!-Union{Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{ThermalMultiStart}, DeviceModel{ThermalMultiStart, ThermalMultiStartUnitCommitment}, Type{S}, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.startup_initial_condition_constraints!</code></a></li><li><a href="#PowerSimulations.startup_time_constraints!-Union{Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{ThermalMultiStart}, DeviceModel{ThermalMultiStart, ThermalMultiStartUnitCommitment}, Type{S}, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.startup_time_constraints!</code></a></li><li><a href="#PowerSimulations.startup_type_constraints!-Union{Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{ThermalMultiStart}, DeviceModel{ThermalMultiStart, ThermalMultiStartUnitCommitment}, Type{S}, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.startup_type_constraints!</code></a></li><li><a href="#PowerSimulations.status_initial_condition!-Union{Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{T}, D}} where {T&lt;:ThermalGen, D&lt;:PowerSimulations.AbstractThermalFormulation}"><code>PowerSimulations.status_initial_condition!</code></a></li><li><a href="#PowerSimulations.template_agc_reserve_deployment-Tuple{}"><code>PowerSimulations.template_agc_reserve_deployment</code></a></li><li><a href="#PowerSimulations.template_economic_dispatch-Tuple{}"><code>PowerSimulations.template_economic_dispatch</code></a></li><li><a href="#PowerSimulations.template_unit_commitment-Tuple{}"><code>PowerSimulations.template_unit_commitment</code></a></li><li><a href="#PowerSimulations.to_array-Tuple{PowerSimulations.OptimizerStats}"><code>PowerSimulations.to_array</code></a></li><li><a href="#PowerSimulations.turbine_temperature-Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceStartUpConstraintInfo}, Symbol, Symbol, Tuple{Symbol, Symbol}}"><code>PowerSimulations.turbine_temperature</code></a></li><li><a href="#PowerSimulations.ub_ff-Tuple{PowerSimulations.OptimizationContainer, Symbol, Vector{PowerSimulations.DeviceRangeConstraintInfo}, PowerSimulations.UpdateRef, Symbol}"><code>PowerSimulations.ub_ff</code></a></li><li><a href="#PowerSimulations.update_parameter!-Tuple{PowerSimulations.UpdateRef{JuMP.VariableRef}, PowerSimulations.ParameterContainer, OperationsProblem, Simulation}"><code>PowerSimulations.update_parameter!</code></a></li><li><a href="#PowerSimulations.update_problem!-Union{Tuple{M}, Tuple{OperationsProblem{M}, Simulation}} where M&lt;:PowerSimulations.PowerSimulationsOperationsProblem"><code>PowerSimulations.update_problem!</code></a></li><li><a href="#PowerSimulations.variable_cost!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, String, VariableCost{Float64}, Int64}"><code>PowerSimulations.variable_cost!</code></a></li><li><a href="#PowerSimulations.variable_cost!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, String, Nothing, Int64}"><code>PowerSimulations.variable_cost!</code></a></li><li><a href="#PowerSimulations.variable_cost!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, String, VariableCost{Vector{Tuple{Float64, Float64}}}, Int64}"><code>PowerSimulations.variable_cost!</code></a></li><li><a href="#PowerSimulations.variable_cost!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, String, VariableCost{Tuple{Float64, Float64}}, Int64}"><code>PowerSimulations.variable_cost!</code></a></li><li><a href="#PowerSimulations.variable_reactive_net_injection-Tuple{PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.variable_reactive_net_injection</code></a></li><li><a href="#PowerSimulations.write_result!"><code>PowerSimulations.write_result!</code></a></li></ul><h2 id="Exported"><a class="docs-heading-anchor" href="#Exported">Exported</a><a id="Exported-1"></a><a class="docs-heading-anchor-permalink" href="#Exported" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.AGCReserveDeployment-Tuple{System}" href="#PowerSimulations.AGCReserveDeployment-Tuple{System}"><code>PowerSimulations.AGCReserveDeployment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">AGCReserveDeployment(system::PSY.System; kwargs...)</code></pre><p>Creates an <code>OperationsProblemTemplate</code> with default DeviceModels for an AGC Reserve Deplyoment Problem. Uses the template to create an <code>OperationsProblem</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">agc_problem = AGCReserveDeployment(system)</code></pre><p><strong>Accepted Key Words</strong></p><ul><li>Key word arguments supported by <code>OperationsProblem</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/operations_problems.jl#L72-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceModel" href="#PowerSimulations.DeviceModel"><code>PowerSimulations.DeviceModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Establishes the model for a particular device specified by type. Uses the keyword argument feedforward to enable passing values between operation model at simulation time</p><p><strong>Arguments</strong></p><p>-<code>::Type{D}</code>: Power System Device Type -<code>::Type{B}</code>: Abstract Device Formulation</p><p><strong>Accepted Key Words</strong></p><ul><li><code>feedforward::Array{&lt;:AbstractAffectFeedForward}</code> : use to pass parameters between models</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">thermal_gens = DeviceModel(ThermalStandard, ThermalBasicUnitCommitment),</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/device_models.jl#L28-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.EconomicDispatchProblem-Tuple{System}" href="#PowerSimulations.EconomicDispatchProblem-Tuple{System}"><code>PowerSimulations.EconomicDispatchProblem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">EconomicDispatchProblem(system::PSY.System; kwargs...)</code></pre><p>Creates an <code>OperationsProblemTemplate</code> with default DeviceModels for an EconomicDispatch problem. Uses the template to create an <code>OperationsProblem</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">ed_problem = EconomicDispatchProblem(system)</code></pre><p><strong>Accepted Key Words</strong></p><ul><li><code>network::Type{&lt;:PM.AbstractPowerModel}</code> : override default network model settings</li><li><code>devices::Dict{String, DeviceModel}</code> : override default <code>DeviceModel</code> settings</li><li><code>services::Dict{String, ServiceModel}</code> : override default <code>ServiceModel</code> settings</li><li>Key word arguments supported by <code>OperationsProblem</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/operations_problems.jl#L12-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.FixedOutput" href="#PowerSimulations.FixedOutput"><code>PowerSimulations.FixedOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Formulation that fixes the injection values of devices</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/device_models.jl#L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.GenericOpProblem" href="#PowerSimulations.GenericOpProblem"><code>PowerSimulations.GenericOpProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Default PowerSimulations Operation Problem Type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/operations_problem.jl#L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.IntraProblemChronology" href="#PowerSimulations.IntraProblemChronology"><code>PowerSimulations.IntraProblemChronology</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InterProblemChronology()

Type struct to select an information sharing model between stages that uses results from the same recent stage to calculate the initial conditions. This model ignores solutions from stages defined finer resolutions.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/initial_condition_types.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.OperationsProblem" href="#PowerSimulations.OperationsProblem"><code>PowerSimulations.OperationsProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OperationsProblem(::Type{M},
template::OperationsProblemTemplate,
sys::PSY.System,
jump_model::Union{Nothing, JuMP.Model}=nothing;
kwargs...) where {M&lt;:AbstractOperationsProblem,
                  T&lt;:PM.AbstractPowerFormulation}</code></pre><p>This builds the optimization problem of type M with the specific system and template.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{M} where M&lt;:AbstractOperationsProblem</code>: The abstract operation model type</li><li><code>template::OperationsProblemTemplate</code>: The model reference made up of transmission, devices,                                         branches, and services.</li><li><code>sys::PSY.System</code>: the system created using Power Systems</li><li><code>jump_model::Union{Nothing, JuMP.Model}</code>: Enables passing a custom JuMP model. Use with care</li></ul><p><strong>Output</strong></p><ul><li><code>problem::OperationsProblem</code>: The operation model containing the model type, built JuMP model, Power</li></ul><p>Systems system.</p><p><strong>Example</strong></p><pre><code class="language-julia">template = OperationsProblemTemplate(CopperPlatePowerModel, devices, branches, services)
OpModel = OperationsProblem(MockOperationProblem, template, system)</code></pre><p><strong>Accepted Key Words</strong></p><ul><li><code>optimizer</code>: The optimizer that will be used in the optimization model.</li><li><code>PTDF::PTDF</code>: Passes the PTDF matrix into the optimization model for StandardPTDFModel networks.</li><li><code>horizon::Int</code>: Manually specify the length of the forecast Horizon</li><li><code>warm_start::Bool</code>: True will use the current operation point in the system to initialize variable values. False initializes all variables to zero. Default is true</li><li><code>balance_slack_variables::Bool</code>: True will add slacks to the system balance constraints</li><li><code>services_slack_variables::Bool</code>: True will add slacks to the services requirement constraints</li><li><code>constraint_duals::Vector{Symbol}</code>: Vector with the duals to query from the optimization model</li><li><code>system_to_file::Bool:</code>: True to create a copy of the system used in the model. Default true.</li><li><code>export_pwl_vars::Bool</code>: True to export all the pwl intermediate variables. It can slow down significantly the solve time. Default to false.</li><li><code>allow_fails::Bool</code>: True to allow the simulation to continue even if the optimization step fails. Use with care, default to false.</li><li><code>optimizer_log_print::Bool</code>: True to print the optimizer solve log. Default to false.</li><li><code>direct_mode_optimizer::Bool</code> True to use the solver in direct mode. Creates a <a href="https://jump.dev/JuMP.jl/dev/reference/models/#JuMP.direct_model">JuMP.direct_model</a>. Default to false.</li><li><code>use_parameters::Bool</code>: True will substitute will implement formulations using ParameterJuMP parameters. Default is false.</li><li><code>use_forecast_data::Bool</code>: If true uses the data in the system forecasts. If false uses the data for current operating point in the system.</li><li><code>initial_time::Dates.DateTime</code>: Initial Time for the model solve</li><li><code>time_series_cache_size::Int</code>: Size in bytes to cache for each time array. Default is 1 MiB. Set to 0 to disable.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/operations_problem.jl#L68-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.OperationsProblem-Tuple{AbstractString}" href="#PowerSimulations.OperationsProblem-Tuple{AbstractString}"><code>PowerSimulations.OperationsProblem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">OperationsProblem(filename::AbstractString)</code></pre><p>Construct an OperationsProblem from a serialized file.</p><p><strong>Arguments</strong></p><ul><li><code>filename::AbstractString</code>: path to serialized file</li><li><code>jump_model::Union{Nothing, JuMP.Model}</code> = nothing: The JuMP model does not get  serialized. Callers should pass whatever they passed to the original problem.</li><li><code>optimizer::Union{Nothing,MOI.OptimizerWithAttributes}</code> = nothing: The optimizer does  not get serialized. Callers should pass whatever they passed to the original problem.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/operations_problem.jl#L229-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.OperationsProblem-Union{Tuple{M}, Tuple{Type{M}, OperationsProblemTemplate, System}, Tuple{Type{M}, OperationsProblemTemplate, System, Union{Nothing, JuMP.Model}}} where M&lt;:PowerSimulations.AbstractOperationsProblem" href="#PowerSimulations.OperationsProblem-Union{Tuple{M}, Tuple{Type{M}, OperationsProblemTemplate, System}, Tuple{Type{M}, OperationsProblemTemplate, System, Union{Nothing, JuMP.Model}}} where M&lt;:PowerSimulations.AbstractOperationsProblem"><code>PowerSimulations.OperationsProblem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">OperationsProblem(::Type{M},
template::OperationsProblemTemplate,
sys::PSY.System,
optimizer::MOI.OptimizerWithAttributes,
jump_model::Union{Nothing, JuMP.Model}=nothing;
kwargs...) where {M&lt;:AbstractOperationsProblem}</code></pre><p>This builds the optimization problem of type M with the specific system and template</p><p><strong>Arguments</strong></p><ul><li><code>::Type{M} where M&lt;:AbstractOperationsProblem</code>: The abstract operation model type</li><li><code>template::OperationsProblemTemplate</code>: The model reference made up of transmission, devices,                                         branches, and services.</li><li><code>sys::PSY.System</code>: the system created using Power Systems</li><li><code>jump_model::Union{Nothing, JuMP.Model}</code>: Enables passing a custom JuMP model. Use with care</li></ul><p><strong>Output</strong></p><ul><li><code>Stage::OperationsProblem</code>: The operation model containing the model type, unbuilt JuMP model, Power</li></ul><p>Systems system.</p><p><strong>Example</strong></p><pre><code class="language-julia">template = OperationsProblemTemplate(CopperPlatePowerModel, devices, branches, services)
problem = OperationsProblem(MyOpProblemType template, system, optimizer)</code></pre><p><strong>Accepted Key Words</strong></p><ul><li><code>initial_time::Dates.DateTime</code>: Initial Time for the model solve</li><li><code>PTDF::PTDF</code>: Passes the PTDF matrix into the optimization model for StandardPTDFModel networks.</li><li><code>warm_start::Bool</code> True will use the current operation point in the system to initialize variable values. False initializes all variables to zero. Default is true</li><li><code>balance_slack_variables::Bool</code> True will add slacks to the system balance constraints</li><li><code>services_slack_variables::Bool</code> True will add slacks to the services requirement constraints</li><li><code>export_pwl_vars::Bool</code> True will write the results of the piece-wise-linear intermediate variables. Slows down the simulation process significantly</li><li><code>allow_fails::Bool</code> True will allow the simulation to continue if the optimizer can&#39;t find a solution. Use with care, can lead to unwanted behaviour or results</li><li><code>optimizer_log_print::Bool</code> Uses JuMP.unset_silent() to print the optimizer&#39;s log. By default all solvers are set to <code>MOI.Silent()</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/operations_problem.jl#L178-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.OperationsProblemTemplate" href="#PowerSimulations.OperationsProblemTemplate"><code>PowerSimulations.OperationsProblemTemplate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OperationsProblemTemplate(::Type{T}) where {T&lt;:PM.AbstractPowerFormulation}</code></pre><p>Creates a model reference of the PowerSimulations Optimization Problem.</p><p><strong>Arguments</strong></p><ul><li><code>model::Type{T&lt;:PM.AbstractPowerFormulation}</code>:</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">template = OperationsProblemTemplate(CopperPlatePowerModel)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/operations_problem_template.jl#L5-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.RecedingHorizon" href="#PowerSimulations.RecedingHorizon"><code>PowerSimulations.RecedingHorizon</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RecedingHorizon(period::Int)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/feedforward_chronologies.jl#L51-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.ServiceModel" href="#PowerSimulations.ServiceModel"><code>PowerSimulations.ServiceModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Establishes the model for a particular services specified by type. Uses the keyword argument <code>use_service_name</code> to assign the model to a service with the same name as the label in the template. Uses the keyword argument feedforward to enable passing values between operation model at simulation time</p><p><strong>Arguments</strong></p><p>-<code>::Type{D}</code>: Power System Service Type -<code>::Type{B}</code>: Abstract Service Formulation</p><p><strong>Accepted Key Words</strong></p><ul><li><code>feedforward::Array{&lt;:AbstractAffectFeedForward}</code> : use to pass parameters between models</li><li><code>use_service_name::Bool</code> : use the label as the name for the service</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">reserves = ServiceModel(PSY.VariableReserve{PSY.ReserveUp}, RangeReserve)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/service_models.jl#L26-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.Simulation" href="#PowerSimulations.Simulation"><code>PowerSimulations.Simulation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Simulation(steps::Int
            problems::Dict{String, OperationsProblem{&lt;:AbstractOperationsProblem}}
            sequence::Union{Nothing, SimulationSequence}
            simulation_folder::String
            name::String
            internal::Union{Nothing, SimulationInternal}
            )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/simulation.jl#L214-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.Simulation-Tuple{AbstractString, Dict}" href="#PowerSimulations.Simulation-Tuple{AbstractString, Dict}"><code>PowerSimulations.Simulation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Simulation(directory::AbstractString)</code></pre><p>Constructs Simulation from a serialized directory. Callers should pass any kwargs here that they passed to the original Simulation.</p><p><strong>Arguments</strong></p><ul><li><code>directory::AbstractString</code>: the directory returned from the call to serialize</li><li><code>problem_info::Dict</code>: Two-level dictionary containing problem parameters that cannot be serialized. The outer dict should be keyed by the problem name. The inner dict must contain &#39;optimizer&#39; and may contain &#39;jump_model&#39;. These should be the same values used for the original simulation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/simulation.jl#L261-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.SimulationProblems" href="#PowerSimulations.SimulationProblems"><code>PowerSimulations.SimulationProblems</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Stores the OperationProblem definitions to be used in the simulation. When creating the SimulationProblems, the order in which the problems are created determines the order on which the simulation is executed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/simulation_problems.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.SimulationResults" href="#PowerSimulations.SimulationResults"><code>PowerSimulations.SimulationResults</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Construct SimulationResults from a simulation output directory.</p><p><strong>Arguments</strong></p><ul><li><code>path::AbstractString</code>: Simulation output directory</li><li><code>execution::AbstractString</code>: Execution number. Default is the most recent.</li><li><code>ignore_status::Bool</code>: If true, return results even if the simulation failed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/simulation_results.jl#L24-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.SimulationResults-Tuple{Simulation}" href="#PowerSimulations.SimulationResults-Tuple{Simulation}"><code>PowerSimulations.SimulationResults</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct SimulationResults from a simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/simulation_results.jl#L81-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.SimulationSequence" href="#PowerSimulations.SimulationSequence"><code>PowerSimulations.SimulationSequence</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SimulationSequence(horizons::Dict{String, Int}
                    step_resolution::Dates.TimePeriod
                    intervals::Dict{String, &lt;:Tuple{&lt;:Dates.TimePeriod, &lt;:FeedForwardChronology}}
                    order::Dict{Int, String}
                    feedforward_chronologies::Dict{Pair{String, String}, &lt;:FeedForwardChronology}
                    feedforward::Dict{Tuple{String, Symbol, Symbol}, &lt;:AbstractAffectFeedForward}
                    ini_cond_chronology::Dict{String, &lt;:FeedForwardChronology}
                    cache::Dict{String, AbstractCache}
                    )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/simulation_sequence.jl#L138-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.StaticBranch" href="#PowerSimulations.StaticBranch"><code>PowerSimulations.StaticBranch</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Branch type to add unbounded flow variables and use flow constraints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/AC_branches.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.StaticBranchBounds" href="#PowerSimulations.StaticBranchBounds"><code>PowerSimulations.StaticBranchBounds</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Branch type to add bounded flow variables and use flow constraints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/AC_branches.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.StaticBranchUnbounded" href="#PowerSimulations.StaticBranchUnbounded"><code>PowerSimulations.StaticBranchUnbounded</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Branch type to avoid flow constraints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/AC_branches.jl#L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.Synchronize" href="#PowerSimulations.Synchronize"><code>PowerSimulations.Synchronize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Synchronize(periods::Int)</code></pre><p>Defines the co-ordination of time between Two problems.</p><p><strong>Arguments</strong></p><ul><li><code>periods::Int</code>: Number of time periods to grab data from</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/feedforward_chronologies.jl#L35-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.TimeStatusChange" href="#PowerSimulations.TimeStatusChange"><code>PowerSimulations.TimeStatusChange</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Tracks the last time status of a device changed in a simulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/cache.jl#L10-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.UnitCommitmentProblem-Tuple{System}" href="#PowerSimulations.UnitCommitmentProblem-Tuple{System}"><code>PowerSimulations.UnitCommitmentProblem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">UnitCommitmentProblem(system::PSY.System; kwargs...)</code></pre><p>Creates an <code>OperationsProblemTemplate</code> with default DeviceModels for a Unit Commitment problem. Uses the template to create an <code>OperationsProblem</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">uc_problem = UnitCommitmentProblem(system)</code></pre><p><strong>Accepted Key Words</strong></p><ul><li><code>network::Type{&lt;:PM.AbstractPowerModel}</code> : override default network model settings</li><li><code>devices::Dict{String, DeviceModel}</code> : override default <code>DeviceModel</code> settings</li><li><code>services::Dict{String, ServiceModel}</code> : override default <code>ServiceModel</code> settings</li><li>Key word arguments supported by <code>OperationsProblem</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/operations_problems.jl#L42-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.build!-Tuple{OperationsProblem{var&quot;#s306&quot;} where var&quot;#s306&quot;&lt;:PowerSimulations.AbstractOperationsProblem}" href="#PowerSimulations.build!-Tuple{OperationsProblem{var&quot;#s306&quot;} where var&quot;#s306&quot;&lt;:PowerSimulations.AbstractOperationsProblem}"><code>PowerSimulations.build!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Implementation of build for any OperationsProblem</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/operations_problem.jl#L491">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.build!-Tuple{Simulation}" href="#PowerSimulations.build!-Tuple{Simulation}"><code>PowerSimulations.build!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">build!(sim::Simulation)</code></pre><p>Build the Simulation, problems and the related folder structure</p><p><strong>Arguments</strong></p><ul><li><code>sim::Simulation</code>: simulation object</li><li><code>output_dir</code> = nothing: Name of the output directory for the simulation. If nothing, the  folder will have the same name as the simulation</li><li><code>serialize::Bool = true</code>: serializes the simulation objects in the simulation</li><li><code>recorders::Vector{Symbol} = []</code>: recorder names to register</li><li><code>console_level = Logging.Error</code>:</li><li><code>file_level = Logging.Info</code>:</li></ul><p>Throws an exception if label is passed and the directory already exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/simulation.jl#L601-L616">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.execute!-Tuple{Simulation}" href="#PowerSimulations.execute!-Tuple{Simulation}"><code>PowerSimulations.execute!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">execute!(sim::Simulation; kwargs...)</code></pre><p>Solves the simulation model for sequential Simulations.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Simulation=sim</code>: simulation object created by Simulation()</li></ul><p>The optional keyword argument <code>exports</code> controls exporting of results to CSV files as the simulation runs. Refer to <a href="#PowerSimulations.export_results-Tuple{ProblemResults}"><code>export_results</code></a> for a description of this argument.</p><p><strong>Example</strong></p><pre><code class="language-julia">sim = Simulation(&quot;Test&quot;, 7, problems, &quot;/Users/folder&quot;)
execute!(sim::Simulation; kwargs...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/simulation.jl#L969-L985">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.export_results-Tuple{ProblemResults}" href="#PowerSimulations.export_results-Tuple{ProblemResults}"><code>PowerSimulations.export_results</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Exports all results from the operations problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/operations_problem_results.jl#L53-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.export_results-Tuple{SimulationResults, Any}" href="#PowerSimulations.export_results-Tuple{SimulationResults, Any}"><code>PowerSimulations.export_results</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Export results to files in the results directory.</p><p><strong>Arguments</strong></p><ul><li><code>results::SimulationResults</code>: simulation results</li><li><code>exports</code>: SimulationResultsExport or anything that can be passed to its constructor. (such as Dict or path to JSON file)</li></ul><p>An example JSON file demonstrating possible options is below. Note that <code>start_time</code>, <code>end_time</code>, <code>path</code>, and <code>format</code> are optional.</p><pre><code class="language-none">{
  &quot;problems&quot;: [
    {
      &quot;name&quot;: &quot;ED&quot;,
      &quot;variables&quot;: [
        &quot;P__ThermalStandard&quot;,
        &quot;E__HydroEnergyReservoir&quot;
      ],
      &quot;parameters&quot;: [
        &quot;all&quot;
      ]
    },
    {
      &quot;name&quot;: &quot;UC&quot;,
      &quot;variables&quot;: [
        &quot;On__ThermalStandard&quot;
      ],
      &quot;parameters&quot;: [
        &quot;all&quot;
      ],
      &quot;duals&quot;: [
        &quot;all&quot;
      ]
    }
  ],
  &quot;start_time&quot;: &quot;2020-01-01T04:00:00&quot;,
  &quot;end_time&quot;: null,
  &quot;path&quot;: null,
  &quot;format&quot;: &quot;csv&quot;
}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/simulation_results.jl#L133-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.get_all_constraint_index-Tuple{OperationsProblem}" href="#PowerSimulations.get_all_constraint_index-Tuple{OperationsProblem}"><code>PowerSimulations.get_all_constraint_index</code></a> — <span class="docstring-category">Method</span></header><section><div><p>&quot;Each Tuple corresponds to (con<em>name, internal</em>index, moi_index)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/operations_problem.jl#L1013">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.get_all_var_index-Tuple{OperationsProblem}" href="#PowerSimulations.get_all_var_index-Tuple{OperationsProblem}"><code>PowerSimulations.get_all_var_index</code></a> — <span class="docstring-category">Method</span></header><section><div><p>&quot;Each Tuple corresponds to (con<em>name, internal</em>index, moi_index)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/operations_problem.jl#L1026">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.get_system!-Tuple{PowerSimulations.SimulationProblemResults}" href="#PowerSimulations.get_system!-Tuple{PowerSimulations.SimulationProblemResults}"><code>PowerSimulations.get_system!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the system used for the problem. If the system hasn&#39;t already been deserialized or set with <a href="#PowerSimulations.set_system!-Tuple{PowerSimulations.SimulationProblemResults, System}"><code>set_system!</code></a> then deserialize and store it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/problem_results.jl#L100-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.list_problems-Tuple{PowerSimulations.HdfSimulationStore}" href="#PowerSimulations.list_problems-Tuple{PowerSimulations.HdfSimulationStore}"><code>PowerSimulations.list_problems</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the problem names in order of execution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/hdf_simulation_store.jl#L150-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.list_problems-Tuple{SimulationResults}" href="#PowerSimulations.list_problems-Tuple{SimulationResults}"><code>PowerSimulations.list_problems</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the problem names in the simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/simulation_results.jl#L128-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.list_simulation_events-Union{Tuple{T}, Tuple{Type{T}, AbstractString}, Tuple{Type{T}, AbstractString, Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent" href="#PowerSimulations.list_simulation_events-Union{Tuple{T}, Tuple{Type{T}, AbstractString}, Tuple{Type{T}, AbstractString, Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent"><code>PowerSimulations.list_simulation_events</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">list_simulation_events(
    ::Type{T},
    output_dir::AbstractString,
    filter_func::Union{Nothing, Function} = nothing;
    step = nothing,
    problem = nothing,
) where {T &lt;: IS.AbstractRecorderEvent}</code></pre><p>List simulation events of type T in a simulation output directory.</p><p><strong>Arguments</strong></p><ul><li><code>output_dir::AbstractString</code>: Simulation output directory</li><li><code>filter_func::Union{Nothing, Function} = nothing</code>: Refer to <a href="#PowerSimulations.show_simulation_events-Union{Tuple{T}, Tuple{Type{T}, AbstractString}, Tuple{Type{T}, AbstractString, Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent"><code>show_simulation_events</code></a>.</li><li><code>step::Int = nothing</code>: Filter events by step. Required if problem is passed.</li><li><code>problem::Int = nothing</code>: Filter events by problem.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/recorder_events.jl#L180-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.load_results!-Tuple{PowerSimulations.SimulationProblemResults, Int64}" href="#PowerSimulations.load_results!-Tuple{PowerSimulations.SimulationProblemResults, Int64}"><code>PowerSimulations.load_results!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Loads the simulation results into memory for repeated reads. Running this function twice
overwrites the previously loaded results. This is useful when loading results from remote
locations over network connections

# Required Key Words
- `initial_time::Dates.DateTime` : initial of the requested results
- `count::Int`: Number of results
# Accepted Key Words
- `variables::Vector{Symbol}`: Variables names to load into results
- `duals::Vector{Symbol}`: Dual names to load into results
- `parameters::Vector{Symbol}`: Parameter names to load into results</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/problem_results.jl#L611-L623">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.read_dual-Tuple{PowerSimulations.SimulationProblemResults, Symbol}" href="#PowerSimulations.read_dual-Tuple{PowerSimulations.SimulationProblemResults, Symbol}"><code>PowerSimulations.read_dual</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Returns the values for the requested dual name. It keeps requests when performing multiple retrievals. Accepts a dual name to return the result.
# Accepted Key Words
- `initial_time::Dates.DateTime` : initial of the requested results
- `count::Int`: Number of results
- `store::SimulationStore`: a store that has been opened for reading</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/problem_results.jl#L373-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.read_duals-Tuple{PowerSimulations.SimulationProblemResults}" href="#PowerSimulations.read_duals-Tuple{PowerSimulations.SimulationProblemResults}"><code>PowerSimulations.read_duals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Returns the values for the requested dual names. It must match the duals requested in the simulation problem definition.
It keeps requests when performing multiple retrievals. Accepts a vector of names for the return of the values

# Accepted Key Words
- `names::Vector{Symbol}` : names of desired results
- `initial_time::Dates.DateTime` : initial of the requested results
- `count::Int`: Number of results
- `store::SimulationStore`: a store that has been opened for reading</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/problem_results.jl#L286-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.read_optimizer_stats-Tuple{PowerSimulations.SimulationProblemResults}" href="#PowerSimulations.read_optimizer_stats-Tuple{PowerSimulations.SimulationProblemResults}"><code>PowerSimulations.read_optimizer_stats</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns the optimizer stats for the problem as a DataFrame.</p><p><strong>Accepted keywords</strong></p><ul><li><code>store::SimulationStore</code>: a store that has been opened for reading</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/problem_results.jl#L394-L399">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.read_parameter-Tuple{PowerSimulations.SimulationProblemResults, Symbol}" href="#PowerSimulations.read_parameter-Tuple{PowerSimulations.SimulationProblemResults, Symbol}"><code>PowerSimulations.read_parameter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Returns the values for the requested parameter name. It keeps requests when performing multiple retrievals. Accepts a parameter name to return the result.
# Accepted Key Words
- `initial_time::Dates.DateTime` : initial of the requested results
- `count::Int`: Number of results</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/problem_results.jl#L384-L389">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.read_parameters-Tuple{PowerSimulations.SimulationProblemResults}" href="#PowerSimulations.read_parameters-Tuple{PowerSimulations.SimulationProblemResults}"><code>PowerSimulations.read_parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Returns the values for the parameters used in the simulation. It keeps requests when performing multiple retrievals. Accepts a vector of names for the return of the values

# Accepted Key Words
- `names::Vector{Symbol}` : names of desired results
- `initial_time::Dates.DateTime` : initial time of the requested results
- `count::Int`: Number of results
- `store::SimulationStore`: a store that has been opened for reading</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/problem_results.jl#L335-L343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.read_realized_duals-Tuple{PowerSimulations.SimulationProblemResults}" href="#PowerSimulations.read_realized_duals-Tuple{PowerSimulations.SimulationProblemResults}"><code>PowerSimulations.read_realized_duals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Returns the final values for the requested dual names for each time step for a problem.
Accepts a vector of names for the return of the values. If the time stamps and names are
loaded using the [load_results!](@ref) function it will read from memory.

# Accepted Key Words
- `names::Vector{Symbol}` : names of desired results
- `initial_time::Dates.DateTime` : initial time of the requested results
- `len::Int`: length of results</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/problem_results.jl#L587-L596">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.read_realized_parameters-Tuple{PowerSimulations.SimulationProblemResults}" href="#PowerSimulations.read_realized_parameters-Tuple{PowerSimulations.SimulationProblemResults}"><code>PowerSimulations.read_realized_parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Returns the final values for the requested parameter names for each time step for a problem.
Accepts a vector of names for the return of the values. If the time stamps and names are
loaded using the [load_results!](@ref) function it will read from memory.

# Accepted Key Words
- `names::Vector{Symbol}` : names of desired results
- `initial_time::Dates.DateTime` : initial time of the requested results
- `len::Int`: length of results</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/problem_results.jl#L559-L568">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.read_realized_variables-Tuple{PowerSimulations.SimulationProblemResults}" href="#PowerSimulations.read_realized_variables-Tuple{PowerSimulations.SimulationProblemResults}"><code>PowerSimulations.read_realized_variables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Returns the final values for the requested variable names for each time step for a problem.
Accepts a vector of names for the return of the values. If the time stamps and names are
loaded using the [load_results!](@ref) function it will read from memory.

# Accepted Key Words
- `names::Vector{Symbol}` : names of desired results
- `initial_time::Dates.DateTime` : initial time of the requested results
- `len::Int`: length of results</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/problem_results.jl#L531-L540">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.read_variable-Tuple{PowerSimulations.SimulationProblemResults, Symbol}" href="#PowerSimulations.read_variable-Tuple{PowerSimulations.SimulationProblemResults, Symbol}"><code>PowerSimulations.read_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Returns the values for the requested variable name. It keeps requests when performing multiple retrievals. Accepts a variable name to return the result.

# Accepted Key Words
- `initial_time::Dates.DateTime` : initial of the requested results
- `count::Int`: Number of results
- `store::SimulationStore`: a store that has been opened for reading</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/problem_results.jl#L361-L368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.read_variables-Tuple{PowerSimulations.SimulationProblemResults}" href="#PowerSimulations.read_variables-Tuple{PowerSimulations.SimulationProblemResults}"><code>PowerSimulations.read_variables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Returns the values for the requested variable names. Accepts a vector of names for the
return of the values. If the time stamps and names are loaded using the [load_results!](@ref)
function it will read from memory.

# Accepted Key Words
- `names::Vector{Symbol}` : names of desired results
- `initial_time::Dates.DateTime` : initial of the requested results
- `count::Int`: Number of results
- `store::SimulationStore`: a store that has been opened for reading</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/problem_results.jl#L236-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.run_economic_dispatch-Tuple{System}" href="#PowerSimulations.run_economic_dispatch-Tuple{System}"><code>PowerSimulations.run_economic_dispatch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">run_economic_dispatch(system::PSY.System; kwargs...)</code></pre><p>Creates an <code>OperationsProblemTemplate</code> with default DeviceModels for an EconomicDispatch problem. Uses the template to create an <code>OperationsProblem</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">results = run_economic_dispatch(system; optimizer = optimizer)</code></pre><p><strong>Accepted Key Words</strong></p><ul><li><code>network::Type{&lt;:PM.AbstractPowerModel}</code> : override default network model settings</li><li><code>devices::Dict{String, DeviceModel}</code> : override default <code>DeviceModel</code> settings</li><li><code>services::Dict{String, ServiceModel}</code> : override default <code>ServiceModel</code> settings</li><li><code>optimizer::JuMP optimizer</code> : a JuMP optimizer is a required key word</li><li><code>output_dir::AbstractString</code>  : Path to save outputs</li><li>Key word arguments supported by <code>OperationsProblem</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/operations_problems.jl#L125-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.serialize_optimization_model-Tuple{PowerSimulations.OptimizationContainer, String}" href="#PowerSimulations.serialize_optimization_model-Tuple{PowerSimulations.OptimizationContainer, String}"><code>PowerSimulations.serialize_optimization_model</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Exports the OpModel JuMP object in MathOptFormat</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/optimization_container.jl#L601">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.set_device_model!-Tuple{OperationsProblemTemplate, DeviceModel{var&quot;#s31&quot;, var&quot;#s30&quot;} where {var&quot;#s31&quot;&lt;:Device, var&quot;#s30&quot;&lt;:PowerSimulations.AbstractDeviceFormulation}}" href="#PowerSimulations.set_device_model!-Tuple{OperationsProblemTemplate, DeviceModel{var&quot;#s31&quot;, var&quot;#s30&quot;} where {var&quot;#s31&quot;&lt;:Device, var&quot;#s30&quot;&lt;:PowerSimulations.AbstractDeviceFormulation}}"><code>PowerSimulations.set_device_model!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Sets the device model in a template using a DeviceModel instance</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/operations_problem_template.jl#L54-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.set_device_model!-Tuple{OperationsProblemTemplate, Type{var&quot;#s31&quot;} where var&quot;#s31&quot;&lt;:Device, Type{var&quot;#s30&quot;} where var&quot;#s30&quot;&lt;:PowerSimulations.AbstractDeviceFormulation}" href="#PowerSimulations.set_device_model!-Tuple{OperationsProblemTemplate, Type{var&quot;#s31&quot;} where var&quot;#s31&quot;&lt;:Device, Type{var&quot;#s30&quot;} where var&quot;#s30&quot;&lt;:PowerSimulations.AbstractDeviceFormulation}"><code>PowerSimulations.set_device_model!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Sets the device model in a template using the component type and formulation.
Builds a default DeviceModel</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/operations_problem_template.jl#L41-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.set_service_model!-Tuple{OperationsProblemTemplate, String, Type{var&quot;#s31&quot;} where var&quot;#s31&quot;&lt;:Service, Type{var&quot;#s30&quot;} where var&quot;#s30&quot;&lt;:PowerSimulations.AbstractServiceFormulation}" href="#PowerSimulations.set_service_model!-Tuple{OperationsProblemTemplate, String, Type{var&quot;#s31&quot;} where var&quot;#s31&quot;&lt;:Service, Type{var&quot;#s30&quot;} where var&quot;#s30&quot;&lt;:PowerSimulations.AbstractServiceFormulation}"><code>PowerSimulations.set_service_model!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Sets the service model in a template using a name and the service type and formulation. Builds a default ServiceModel with use_service_name set to true.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/operations_problem_template.jl#L73-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.set_service_model!-Tuple{OperationsProblemTemplate, Type{var&quot;#s31&quot;} where var&quot;#s31&quot;&lt;:Service, Type{var&quot;#s30&quot;} where var&quot;#s30&quot;&lt;:PowerSimulations.AbstractServiceFormulation}" href="#PowerSimulations.set_service_model!-Tuple{OperationsProblemTemplate, Type{var&quot;#s31&quot;} where var&quot;#s31&quot;&lt;:Service, Type{var&quot;#s30&quot;} where var&quot;#s30&quot;&lt;:PowerSimulations.AbstractServiceFormulation}"><code>PowerSimulations.set_service_model!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Sets the service model in a template using a ServiceModel instance.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/operations_problem_template.jl#L90-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.set_system!-Tuple{PowerSimulations.SimulationProblemResults, System}" href="#PowerSimulations.set_system!-Tuple{PowerSimulations.SimulationProblemResults, System}"><code>PowerSimulations.set_system!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set the system in the results instance.</p><p>Throws InvalidValue if the system UUID is incorrect.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/problem_results.jl#L114-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.set_transmission_model!-Tuple{OperationsProblemTemplate, Type{var&quot;#s32&quot;} where var&quot;#s32&quot;&lt;:PowerModels.AbstractPowerModel}" href="#PowerSimulations.set_transmission_model!-Tuple{OperationsProblemTemplate, Type{var&quot;#s32&quot;} where var&quot;#s32&quot;&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.set_transmission_model!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Sets the transmission model in a template</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/operations_problem_template.jl#L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.show_recorder_events-Union{Tuple{T}, Tuple{Type{T}, AbstractString}, Tuple{Type{T}, AbstractString, Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent" href="#PowerSimulations.show_recorder_events-Union{Tuple{T}, Tuple{Type{T}, AbstractString}, Tuple{Type{T}, AbstractString, Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent"><code>PowerSimulations.show_recorder_events</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">show_recorder_events(
    ::Type{T},
    filename::AbstractString,
    filter_func::Union{Nothing, Function} = nothing;
    wall_time = false,
    kwargs...,
) where {T &lt;: IS.AbstractRecorderEvent}</code></pre><p>Show the events of type T in a recorder file.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Recorder event type</li><li><code>filename::AbstractString</code>: recorder filename</li><li><code>filter_func::Union{Nothing, Function} = nothing</code>: Optional function that accepts an event  of type T and returns a Bool. Apply this function to each event and only return events  where the result is true.</li><li><code>wall_time = false</code>: If true, show the wall_time timestamp.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/recorder_events.jl#L322-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.show_simulation_events-Union{Tuple{T}, Tuple{Type{T}, AbstractString}, Tuple{Type{T}, AbstractString, Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent" href="#PowerSimulations.show_simulation_events-Union{Tuple{T}, Tuple{Type{T}, AbstractString}, Tuple{Type{T}, AbstractString, Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent"><code>PowerSimulations.show_simulation_events</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">show_simulation_events(
    ::Type{T},
    output_dir::AbstractString,
    filter_func::Union{Nothing,Function} = nothing;
    step = nothing,
    problem = nothing,
    wall_time = false,
    kwargs...,
) where { T &lt;: IS.AbstractRecorderEvent}</code></pre><p>Show all simulation events of type T in a simulation output directory.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Recorder event type</li><li><code>output_dir::AbstractString</code>: Simulation output directory</li><li><code>filter_func::Union{Nothing, Function} = nothing</code>: Refer to <a href="#PowerSimulations.show_recorder_events-Union{Tuple{T}, Tuple{Type{T}, AbstractString}, Tuple{Type{T}, AbstractString, Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent"><code>show_recorder_events</code></a>.</li><li><code>step::Int = nothing</code>: Filter events by step. Required if problem is passed.</li><li><code>problem::Int = nothing</code>: Filter events by problem.</li><li><code>wall_time = false</code>: If true, show the wall_time timestamp.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/recorder_events.jl#L236-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.solve!-Tuple{Int64, OperationsProblem{var&quot;#s306&quot;} where var&quot;#s306&quot;&lt;:PowerSimulations.AbstractOperationsProblem, Dates.DateTime, PowerSimulations.SimulationStore}" href="#PowerSimulations.solve!-Tuple{Int64, OperationsProblem{var&quot;#s306&quot;} where var&quot;#s306&quot;&lt;:PowerSimulations.AbstractOperationsProblem, Dates.DateTime, PowerSimulations.SimulationStore}"><code>PowerSimulations.solve!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Default solve method for an operational model used inside of a Simulation. Solves problems that conform to the requirements of OperationsProblem{&lt;: PowerSimulationsOperationsProblem}</p><p><strong>Arguments</strong></p><ul><li><code>step::Int</code>: Simulation Step</li><li><code>op_problem::OperationModel</code>: operation model</li><li><code>start_time::Dates.DateTime</code>: Initial Time of the simulation step in Simulation time.</li><li><code>store::SimulationStore</code>: Simulation output store</li></ul><p><strong>Accepted Key Words</strong></p><ul><li><code>exports</code>: realtime export of output. Use wisely, it can have negative impacts in the simulation times</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/operations_problem.jl#L681-L692">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.solve!-Tuple{OperationsProblem{var&quot;#s306&quot;} where var&quot;#s306&quot;&lt;:PowerSimulations.PowerSimulationsOperationsProblem}" href="#PowerSimulations.solve!-Tuple{OperationsProblem{var&quot;#s306&quot;} where var&quot;#s306&quot;&lt;:PowerSimulations.PowerSimulationsOperationsProblem}"><code>PowerSimulations.solve!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Default solve method the operational model for a single instance. Solves problems     that conform to the requirements of OperationsProblem{&lt;: PowerSimulationsOperationsProblem}</p><p><strong>Arguments</strong></p><ul><li><code>op_problem::OperationModel = op_problem</code>: operation model</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">results = solve!(OpModel)</code></pre><p><strong>Accepted Key Words</strong></p><ul><li><code>output_dir::String</code>: If a file path is provided the results</li></ul><p>automatically get written to feather files</p><ul><li><code>optimizer::MOI.OptimizerWithAttributes</code>: The optimizer that is used to solve the model</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/operations_problem.jl#L637-L650">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.template_agc_reserve_deployment-Tuple{}" href="#PowerSimulations.template_agc_reserve_deployment-Tuple{}"><code>PowerSimulations.template_agc_reserve_deployment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">template_agc_reserve_deployment(; kwargs...)</code></pre><p>Creates an <code>OperationsProblemTemplate</code> with default DeviceModels for an AGC Reserve Deplyment Problem. This model doesn&#39;t support customization</p><p><strong>Example</strong></p><pre><code class="language-julia">template = agc_reserve_deployment()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/operations_problem_templates.jl#L94-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.template_economic_dispatch-Tuple{}" href="#PowerSimulations.template_economic_dispatch-Tuple{}"><code>PowerSimulations.template_economic_dispatch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">template_economic_dispatch(; kwargs...)</code></pre><p>Creates an <code>OperationsProblemTemplate</code> with default DeviceModels for an Economic Dispatch problem.</p><p><strong>Example</strong></p><pre><code class="language-julia">template = template_economic_dispatch()</code></pre><p><strong>Accepted Key Words</strong></p><ul><li><code>network::Type{&lt;:PM.AbstractPowerModel}</code> : override default network model settings</li><li><code>devices::Vector{DeviceModel}</code> : override default <code>DeviceModel</code> settings</li><li><code>services::Vector{ServiceModel}</code> : override default <code>ServiceModel</code> settings</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/operations_problem_templates.jl#L64-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.template_unit_commitment-Tuple{}" href="#PowerSimulations.template_unit_commitment-Tuple{}"><code>PowerSimulations.template_unit_commitment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">template_unit_commitment(; kwargs...)</code></pre><p>Creates an <code>OperationsProblemTemplate</code> with default DeviceModels for a Unit Commitment problem.</p><p><strong>Example</strong></p><pre><code class="language-julia">template = template_unit_commitment()</code></pre><p><strong>Accepted Key Words</strong></p><ul><li><code>network::Type{&lt;:PM.AbstractPowerModel}</code> : override default network model settings</li><li><code>devices::Vector{DeviceModel}</code> : override default <code>DeviceModel</code> settings</li><li><code>services::Vector{ServiceModel}</code> : override default <code>ServiceModel</code> settings</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/operations_problem_templates.jl#L35-L50">source</a></section></article><h2 id="Internal"><a class="docs-heading-anchor" href="#Internal">Internal</a><a id="Internal-1"></a><a class="docs-heading-anchor-permalink" href="#Internal" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.AbstractDeviceFormulation" href="#PowerSimulations.AbstractDeviceFormulation"><code>PowerSimulations.AbstractDeviceFormulation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for Device Formulations (a.k.a Models)</p><p><strong>Example</strong></p><pre><code class="language-julia">import PowerSimulations
const PSI = PowerSimulations
struct MyCustomFormulation &lt;: PSI.AbstractDeviceFormulation</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/device_models.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.AbstractServiceFormulation" href="#PowerSimulations.AbstractServiceFormulation"><code>PowerSimulations.AbstractServiceFormulation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for Service Formulations (a.k.a Models)</p><p><strong>Example</strong></p><pre><code class="language-julia">import PowerSimulations
const PSI = PowerSimulations
struct MyServiceFormulation &lt;: PSI.AbstractServiceFormulation</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/service_models.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.AbstractSimulationStatusEvent" href="#PowerSimulations.AbstractSimulationStatusEvent"><code>PowerSimulations.AbstractSimulationStatusEvent</code></a> — <span class="docstring-category">Type</span></header><section><div><p>All events subtyped from this need to be recorded under :simulation_status.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/recorder_events.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.ActivePowerInVariable" href="#PowerSimulations.ActivePowerInVariable"><code>PowerSimulations.ActivePowerInVariable</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Struct to dispatch the creation of Active Power Input Variables for 2-directional devices. for instance storage or pump-hydro</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/variables.jl#L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.ActivePowerOutVariable" href="#PowerSimulations.ActivePowerOutVariable"><code>PowerSimulations.ActivePowerOutVariable</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Struct to dispatch the creation of Active Power Output Variables for 2-directional devices. for instance storage or pump-hydro</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/variables.jl#L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.ActivePowerVariable" href="#PowerSimulations.ActivePowerVariable"><code>PowerSimulations.ActivePowerVariable</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Struct to dispatch the creation of Active Power Variables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/variables.jl#L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.CacheFlushRules" href="#PowerSimulations.CacheFlushRules"><code>PowerSimulations.CacheFlushRules</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Informs the flusher on what data to keep in cache.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/cache_utils.jl#L15-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceEnergyBalanceConstraintSpec-Union{Tuple{H}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.EnergyBalanceConstraint, Type{PowerSimulations.EnergyVariableUp}, Type{H}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractHydroFormulation, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}, Bool, Bool}} where H&lt;:HydroPumpedStorage" href="#PowerSimulations.DeviceEnergyBalanceConstraintSpec-Union{Tuple{H}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.EnergyBalanceConstraint, Type{PowerSimulations.EnergyVariableUp}, Type{H}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractHydroFormulation, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}, Bool, Bool}} where H&lt;:HydroPumpedStorage"><code>PowerSimulations.DeviceEnergyBalanceConstraintSpec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function defines the constraints for the water level (or state of charge) for the HydroPumpedStorage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/hydro_generation.jl#L426-L429">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceEnergyBalanceConstraintSpec-Union{Tuple{H}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.EnergyBalanceConstraint, Type{PowerSimulations.EnergyVariable}, Type{H}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractHydroFormulation, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}, Bool, Bool}} where H&lt;:HydroEnergyReservoir" href="#PowerSimulations.DeviceEnergyBalanceConstraintSpec-Union{Tuple{H}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.EnergyBalanceConstraint, Type{PowerSimulations.EnergyVariable}, Type{H}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractHydroFormulation, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}, Bool, Bool}} where H&lt;:HydroEnergyReservoir"><code>PowerSimulations.DeviceEnergyBalanceConstraintSpec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function defines the constraints for the water level (or state of charge) for the Hydro Reservoir.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/hydro_generation.jl#L397-L400">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceRangeConstraintInfo" href="#PowerSimulations.DeviceRangeConstraintInfo"><code>PowerSimulations.DeviceRangeConstraintInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Data Container to construct range constraints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/constraints_structs.jl#L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceRangeConstraintSpec-Tuple{Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ReactivePowerVariable}, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:ElectricLoad, Type{var&quot;#s331&quot;} where var&quot;#s331&quot;&lt;:PowerSimulations.AbstractControllablePowerLoadFormulation, Type{var&quot;#s308&quot;} where var&quot;#s308&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}, Bool, Bool}" href="#PowerSimulations.DeviceRangeConstraintSpec-Tuple{Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ReactivePowerVariable}, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:ElectricLoad, Type{var&quot;#s331&quot;} where var&quot;#s331&quot;&lt;:PowerSimulations.AbstractControllablePowerLoadFormulation, Type{var&quot;#s308&quot;} where var&quot;#s308&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}, Bool, Bool}"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Reactive Power Constraints on Controllable Loads Assume Constant power_factor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/electric_loads.jl#L38-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceRangeConstraintSpec-Tuple{}" href="#PowerSimulations.DeviceRangeConstraintSpec-Tuple{}"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct inputs for creating range constraints.</p><p><strong>Arguments</strong></p><p><code>range_constraint_spec::Vector{RangeConstraintSpec}</code>: May be emtpy. <code>timeseries_range_constraint_spec::Vector{TimeSeriesConstraintSpec}</code>: May be empty. <code>custom_optimization_container_func::Union{Nothing, Function}</code>: Optional function to add custom  constraints to the internals of a OptimizationContainer. Must accept OptimizationContainer, devices iterable,  and a subtype of AbstractDeviceFormulation. <code>devices_filter_func::Union{Nothing, Function}</code>: Optional function to filter the devices on</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/device_range_constraints.jl#L98-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ActivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractHydroDispatchFormulation, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}, Bool, Bool}} where T&lt;:HydroGen" href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ActivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractHydroDispatchFormulation, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}, Bool, Bool}} where T&lt;:HydroGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function define the range constraint specs for the active power for dispatch Run of River formulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/hydro_generation.jl#L139-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ActivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractHydroReservoirFormulation, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}, Bool, Bool}} where T&lt;:HydroGen" href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ActivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractHydroReservoirFormulation, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}, Bool, Bool}} where T&lt;:HydroGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function define the range constraint specs for the active power for dispatch Reservoir formulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/hydro_generation.jl#L182-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ActivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractHydroUnitCommitment, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Nothing, Bool, Bool}} where T&lt;:HydroGen" href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ActivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractHydroUnitCommitment, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Nothing, Bool, Bool}} where T&lt;:HydroGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function define the range constraint specs for the active power for commitment formulations (semi continuous).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/hydro_generation.jl#L207-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ActivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractThermalDispatchFormulation, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Nothing, Bool, Bool}} where T&lt;:ThermalGen" href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ActivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractThermalDispatchFormulation, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Nothing, Bool, Bool}} where T&lt;:ThermalGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the active power limits of generators when there are no CommitmentVariables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/thermal_generation.jl#L77-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ActivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractThermalUnitCommitment, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Nothing, Bool, Bool}} where T&lt;:ThermalGen" href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ActivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractThermalUnitCommitment, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Nothing, Bool, Bool}} where T&lt;:ThermalGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the active power limits of generators when there are CommitmentVariables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/thermal_generation.jl#L101-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ActivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:ThermalDispatchNoMin, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Nothing, Bool, Bool}} where T&lt;:ThermalGen" href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ActivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:ThermalDispatchNoMin, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Nothing, Bool, Bool}} where T&lt;:ThermalGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the active power limits of generators when there are no CommitmentVariables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/thermal_generation.jl#L126-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ActivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:ThermalMultiStartUnitCommitment, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Nothing, Bool, Bool}} where T&lt;:ThermalMultiStart" href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ActivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:ThermalMultiStartUnitCommitment, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Nothing, Bool, Bool}} where T&lt;:ThermalMultiStart"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the active power limits of generators. Constraint (17) &amp; (18) from PGLIB</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/thermal_generation.jl#L166-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ReactivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractHydroDispatchFormulation, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}, Bool, Bool}} where T&lt;:HydroGen" href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ReactivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractHydroDispatchFormulation, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}, Bool, Bool}} where T&lt;:HydroGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function define the range constraint specs for the reactive power for dispatch formulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/hydro_generation.jl#L110-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ReactivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractHydroUnitCommitment, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Nothing, Bool, Bool}} where T&lt;:HydroGen" href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ReactivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractHydroUnitCommitment, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Nothing, Bool, Bool}} where T&lt;:HydroGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function define the range constraint specs for the reactive power for commitment formulations (semi continuous).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/hydro_generation.jl#L233-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ReactivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractThermalDispatchFormulation, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}, Bool, Bool}} where T&lt;:ThermalGen" href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ReactivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractThermalDispatchFormulation, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}, Bool, Bool}} where T&lt;:ThermalGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the reactive  power limits of generators when there are CommitmentVariables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/thermal_generation.jl#L297-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ReactivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractThermalUnitCommitment, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}, Bool, Bool}} where T&lt;:ThermalGen" href="#PowerSimulations.DeviceRangeConstraintSpec-Union{Tuple{T}, Tuple{Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ReactivePowerVariable}, Type{T}, Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractThermalUnitCommitment, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}, Bool, Bool}} where T&lt;:ThermalGen"><code>PowerSimulations.DeviceRangeConstraintSpec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the reactive power limits of generators when there CommitmentVariables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/thermal_generation.jl#L338-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.FlowActivePowerVariable" href="#PowerSimulations.FlowActivePowerVariable"><code>PowerSimulations.FlowActivePowerVariable</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Struct to dispatch the creation of Flow Active Power Variables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/variables.jl#L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.HdfSimulationStore" href="#PowerSimulations.HdfSimulationStore"><code>PowerSimulations.HdfSimulationStore</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Stores simulation data in an HDF file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/hdf_simulation_store.jl#L41-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.InMemorySimulationStore" href="#PowerSimulations.InMemorySimulationStore"><code>PowerSimulations.InMemorySimulationStore</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Stores simulation data in memory</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/in_memory_simulation_store.jl#L18-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.NodalExpressionSpec-Union{Tuple{U}, Tuple{T}, Tuple{Type{T}, Type{U}, Bool}} where {T&lt;:Device, U&lt;:PowerModels.AbstractPowerModel}" href="#PowerSimulations.NodalExpressionSpec-Union{Tuple{U}, Tuple{T}, Tuple{Type{T}, Type{U}, Bool}} where {T&lt;:Device, U&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.NodalExpressionSpec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct NodalExpressionSpec for specific types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/nodal_expression.jl#L11-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.OptimizerStats-Tuple{Any, Any}" href="#PowerSimulations.OptimizerStats-Tuple{Any, Any}"><code>PowerSimulations.OptimizerStats</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct OptimizerStats when the OperationsProblem is part of a simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/optimizer_stats.jl#L17-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.OptimizerStats-Tuple{Any}" href="#PowerSimulations.OptimizerStats-Tuple{Any}"><code>PowerSimulations.OptimizerStats</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct OptimizerStats when the OperationsProblem is not part of a simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/optimizer_stats.jl#L39-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.OptimizerStats-Tuple{Vector{Float64}}" href="#PowerSimulations.OptimizerStats-Tuple{Vector{Float64}}"><code>PowerSimulations.OptimizerStats</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct OptimizerStats from a vector that was serialized to HDF5.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/optimizer_stats.jl#L60-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.ParamResultCache" href="#PowerSimulations.ParamResultCache"><code>PowerSimulations.ParamResultCache</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Cache for a single parameter/variable/dual. Stores arrays chronologically by simulation timestamp.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/param_result_cache.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.PowerOutput" href="#PowerSimulations.PowerOutput"><code>PowerSimulations.PowerOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Auxiliary Variable for Thermal Generation Models that solve for power above min</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/auxiliary_variables.jl#L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.ProblemData" href="#PowerSimulations.ProblemData"><code>PowerSimulations.ProblemData</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Stores simulation data for one problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/in_memory_simulation_store.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.ProblemDatasets" href="#PowerSimulations.ProblemDatasets"><code>PowerSimulations.ProblemDatasets</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Stores HDF5 datasets for one problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/hdf_simulation_store.jl#L24-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.ResultCache" href="#PowerSimulations.ResultCache"><code>PowerSimulations.ResultCache</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Cache for all model results</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/result_cache.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.SimulationProblemResults" href="#PowerSimulations.SimulationProblemResults"><code>PowerSimulations.SimulationProblemResults</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Holds the results of a simulation problem for plotting or exporting</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/problem_results.jl#L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.SimulationStore" href="#PowerSimulations.SimulationStore"><code>PowerSimulations.SimulationStore</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Provides storage of simulation data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/simulation_store.jl#L7-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.UpdateRef" href="#PowerSimulations.UpdateRef"><code>PowerSimulations.UpdateRef</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Reference for parameters update when present</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/aux_structs.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO, MIME{Symbol(&quot;text/plain&quot;)}, OperationsProblem}" href="#Base.show-Tuple{IO, MIME{Symbol(&quot;text/plain&quot;)}, OperationsProblem}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.show(io::IO, ::MIME&quot;text/plain&quot;, op_problem::OperationsProblem)</code></pre><p>This function goes through the fields in OperationsProblem and then in OperationsProblemTemplate, if the field contains a Device model dictionary, it calls organize<em>device</em>model() &amp; prints the data by field, key, value. If the field is not a Device model dictionary, and a value exists for that field it prints the value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/printing.jl#L36-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations._allocate_execution_order-Tuple{Dict{Int64, Int64}}" href="#PowerSimulations._allocate_execution_order-Tuple{Dict{Int64, Int64}}"><code>PowerSimulations._allocate_execution_order</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function calculates the total number of problem executions in the simulation and allocates the appropiate vector</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/simulation_sequence.jl#L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations._calculate_interval_inner_counts-Tuple{OrderedDict{Symbol, Tuple{Dates.TimePeriod, PowerSimulations.FeedForwardChronology}}}" href="#PowerSimulations._calculate_interval_inner_counts-Tuple{OrderedDict{Symbol, Tuple{Dates.TimePeriod, PowerSimulations.FeedForwardChronology}}}"><code>PowerSimulations._calculate_interval_inner_counts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_calculate_interval_inner_counts(order::Dict{Int,String},
                                      intervals::OrderedDict{String,&lt;:Dates.TimePeriod},
                                      step_resolution::Dates.TimePeriod)</code></pre><p>Calculates how many times a problem is executed for every interval of the previous problem</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/simulation_sequence.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations._get_data_for_rocc-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}}} where T&lt;:ThermalGen" href="#PowerSimulations._get_data_for_rocc-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}}} where T&lt;:ThermalGen"><code>PowerSimulations._get_data_for_rocc</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function gets the data for the generators for ramping constraints of thermal generators</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/thermal_generation.jl#L626-L628">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations._get_data_for_tdc-Tuple{Vector{InitialCondition}, Vector{InitialCondition}, Dates.TimePeriod}" href="#PowerSimulations._get_data_for_tdc-Tuple{Vector{InitialCondition}, Vector{InitialCondition}, Dates.TimePeriod}"><code>PowerSimulations._get_data_for_tdc</code></a> — <span class="docstring-category">Method</span></header><section><div><p>If the fraction of hours that a generator has a duration constraint is less than the fraction of hours that a single time_step represents then it is not binding.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/thermal_generation.jl#L1152-L1155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations._get_data_startup_ic-Tuple{Vector{InitialCondition}, Dates.TimePeriod}" href="#PowerSimulations._get_data_startup_ic-Tuple{Vector{InitialCondition}, Dates.TimePeriod}"><code>PowerSimulations._get_data_startup_ic</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function gets the data for startup initial condition</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/thermal_generation.jl#L1064-L1066">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations._update_problem!-Tuple{OperationsProblem, Simulation}" href="#PowerSimulations._update_problem!-Tuple{OperationsProblem, Simulation}"><code>PowerSimulations._update_problem!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Required update problem function call</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/simulation.jl#L951">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.add_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{St}, Tuple{PowerSimulations.OptimizationContainer, Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ReactivePowerVariable}, InfrastructureSystems.FlattenIteratorWrapper{St}, DeviceModel{St, D}, Type{S}, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where {St&lt;:Storage, D&lt;:PowerSimulations.AbstractStorageFormulation, S&lt;:PowerModels.AbstractPowerModel}" href="#PowerSimulations.add_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{St}, Tuple{PowerSimulations.OptimizationContainer, Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ReactivePowerVariable}, InfrastructureSystems.FlattenIteratorWrapper{St}, DeviceModel{St, D}, Type{S}, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where {St&lt;:Storage, D&lt;:PowerSimulations.AbstractStorageFormulation, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.add_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the reactive  power limits of generators when there are CommitmentVariables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/storage.jl#L164-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where {T&lt;:PowerSimulations.RangeConstraint, U&lt;:PowerSimulations.VariableType, V&lt;:Device, W&lt;:PowerSimulations.AbstractDeviceFormulation, X&lt;:PowerModels.AbstractPowerModel}" href="#PowerSimulations.add_constraints!-Union{Tuple{X}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Type{U}, InfrastructureSystems.FlattenIteratorWrapper{V}, DeviceModel{V, W}, Type{X}, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where {T&lt;:PowerSimulations.RangeConstraint, U&lt;:PowerSimulations.VariableType, V&lt;:Device, W&lt;:PowerSimulations.AbstractDeviceFormulation, X&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.add_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Default implementation to add range constraints.</p><p>Users of this function must implement a method for <a href="#PowerSimulations.DeviceRangeConstraintSpec-Tuple{Type{var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.RangeConstraint, Type{PowerSimulations.ReactivePowerVariable}, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:ElectricLoad, Type{var&quot;#s331&quot;} where var&quot;#s331&quot;&lt;:PowerSimulations.AbstractControllablePowerLoadFormulation, Type{var&quot;#s308&quot;} where var&quot;#s308&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}, Bool, Bool}"><code>DeviceRangeConstraintSpec</code></a> for their specific types. Users may also implement custom active<em>power</em>constraints! methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/device_range_constraints.jl#L68-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.add_result!-Tuple{PowerSimulations.ParamResultCache, Any, Any, Any}" href="#PowerSimulations.add_result!-Tuple{PowerSimulations.ParamResultCache, Any, Any, Any}"><code>PowerSimulations.add_result!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Adds thrame result to the cache. Return true if the cache needs to be flushed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/param_result_cache.jl#L50-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.add_to_cost!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, MarketBidCost, Component}" href="#PowerSimulations.add_to_cost!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, MarketBidCost, Component}"><code>PowerSimulations.add_to_cost!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Adds to the models costs represented by PowerSystems Market-Bid costs. Default implementation for any PSY.Component. Uses by default the cost in of the cold stages for start up costs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/cost_functions.jl#L658-L661">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.add_to_cost!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, MarketBidCost, ThermalMultiStart}" href="#PowerSimulations.add_to_cost!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, MarketBidCost, ThermalMultiStart}"><code>PowerSimulations.add_to_cost!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Adds to the models costs represented by PowerSystems Market-Bid costs. Implementation for devices PSY.ThermalMultiStart</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/cost_functions.jl#L562-L565">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.add_to_cost!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, MultiStartCost, Component}" href="#PowerSimulations.add_to_cost!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, MultiStartCost, Component}"><code>PowerSimulations.add_to_cost!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Adds to the models costs represented by PowerSystems Multi-Start costs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/cost_functions.jl#L472-L474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.add_to_cost!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, ThreePartCost, Component}" href="#PowerSimulations.add_to_cost!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, ThreePartCost, Component}"><code>PowerSimulations.add_to_cost!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Adds to the models costs represented by PowerSystems ThreePart costs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/cost_functions.jl#L389-L391">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.add_to_cost!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, TwoPartCost, Component}" href="#PowerSimulations.add_to_cost!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, TwoPartCost, Component}"><code>PowerSimulations.add_to_cost!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Adds to the models costs represented by PowerSystems TwoPart costs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/cost_functions.jl#L338-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.add_variable!-Union{Tuple{U}, Tuple{D}, Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.VariableType, U, Any}} where {D&lt;:Component, U&lt;:Union{Vector{D}, InfrastructureSystems.FlattenIteratorWrapper{D}}}" href="#PowerSimulations.add_variable!-Union{Tuple{U}, Tuple{D}, Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.VariableType, U, Any}} where {D&lt;:Component, U&lt;:Union{Vector{D}, InfrastructureSystems.FlattenIteratorWrapper{D}}}"><code>PowerSimulations.add_variable!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Adds a variable to the optimization model and to the affine expressions contained in the optimization_container model according to the specified sign. Based on the inputs, the variable can be specified as binary.</p><p><strong>Bounds</strong></p><p><code>lb_value_function &lt;= varstart[name, t] &lt;= ub_value_function</code></p><p>If binary = true:</p><p><code>varstart[name, t] in {0,1}</code></p><p><strong>LaTeX</strong></p><p><span>$lb \ge x^{device}_t \le ub \forall t$</span></p><p><span>$x^{device}_t \in {0,1} \forall t iff \text{binary = true}$</span></p><p><strong>Arguments</strong></p><ul><li>optimization<em>container::OptimizationContainer : the optimization</em>container model built in PowerSimulations</li><li>devices : Vector or Iterator with the devices</li><li>var_name::Symbol : Base Name for the variable</li><li>binary::Bool : Select if the variable is binary</li><li>expression<em>name::Symbol : Expression</em>name name stored in optimization_container.expressions to add the variable</li><li>sign::Float64 : sign of the addition of the variable to the expression_name. Default Value is 1.0</li></ul><p><strong>Accepted Keyword Arguments</strong></p><ul><li>ub<em>value : Provides the function over device to obtain the value for a upper</em>bound</li><li>lb<em>value : Provides the function over device to obtain the value for a lower</em>bound. If the variable is meant to be positive define lb = x -&gt; 0.0</li><li>initial_value : Provides the function over device to obtain the warm start value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/add_variable.jl#L26-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.add_variable!-Union{Tuple{U}, Tuple{T}, Tuple{D}, Tuple{PowerSimulations.OptimizationContainer, T, U, Any}} where {D&lt;:Component, T&lt;:PowerSimulations.AuxVariableType, U&lt;:Union{Vector{D}, InfrastructureSystems.FlattenIteratorWrapper{D}}}" href="#PowerSimulations.add_variable!-Union{Tuple{U}, Tuple{T}, Tuple{D}, Tuple{PowerSimulations.OptimizationContainer, T, U, Any}} where {D&lt;:Component, T&lt;:PowerSimulations.AuxVariableType, U&lt;:Union{Vector{D}, InfrastructureSystems.FlattenIteratorWrapper{D}}}"><code>PowerSimulations.add_variable!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Default implementation of adding auxiliary variable to the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/add_auxiliary_variable.jl#L13-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.add_variables!-Tuple{PowerSimulations.OptimizationContainer, Type{PowerSimulations.SteadyStateFrequencyDeviation}}" href="#PowerSimulations.add_variables!-Tuple{PowerSimulations.OptimizationContainer, Type{PowerSimulations.SteadyStateFrequencyDeviation}}"><code>PowerSimulations.add_variables!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Steady State deviation of the frequency</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/services_models/agc.jl#L6-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.add_variables!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Union{Vector{U}, InfrastructureSystems.FlattenIteratorWrapper{U}}, Union{PowerSimulations.AbstractDeviceFormulation, PowerSimulations.AbstractServiceFormulation}}} where {T&lt;:PowerSimulations.AuxVariableType, U&lt;:Component}" href="#PowerSimulations.add_variables!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Union{Vector{U}, InfrastructureSystems.FlattenIteratorWrapper{U}}, Union{PowerSimulations.AbstractDeviceFormulation, PowerSimulations.AbstractServiceFormulation}}} where {T&lt;:PowerSimulations.AuxVariableType, U&lt;:Component}"><code>PowerSimulations.add_variables!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add variables to the OptimizationContainer for any component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/add_auxiliary_variable.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.add_variables!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Union{Vector{U}, InfrastructureSystems.FlattenIteratorWrapper{U}}, Union{PowerSimulations.AbstractDeviceFormulation, PowerSimulations.AbstractServiceFormulation}}} where {T&lt;:PowerSimulations.VariableType, U&lt;:Component}" href="#PowerSimulations.add_variables!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, Union{Vector{U}, InfrastructureSystems.FlattenIteratorWrapper{U}}, Union{PowerSimulations.AbstractDeviceFormulation, PowerSimulations.AbstractServiceFormulation}}} where {T&lt;:PowerSimulations.VariableType, U&lt;:Component}"><code>PowerSimulations.add_variables!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add variables to the OptimizationContainer for any component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/add_variable.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.add_variables!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, U, Vector{V}, PowerSimulations.AbstractReservesFormulation}} where {T&lt;:PowerSimulations.VariableType, U&lt;:Reserve, V&lt;:Device}" href="#PowerSimulations.add_variables!-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Type{T}, U, Vector{V}, PowerSimulations.AbstractReservesFormulation}} where {T&lt;:PowerSimulations.VariableType, U&lt;:Reserve, V&lt;:Device}"><code>PowerSimulations.add_variables!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add variables to the OptimizationContainer for a service.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/add_variable.jl#L13-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.axis_array_to_dataframe" href="#PowerSimulations.axis_array_to_dataframe"><code>PowerSimulations.axis_array_to_dataframe</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Creates a DataFrame from a JuMP DenseAxisArray or SparseAxisArray.</p><p><strong>Arguments</strong></p><ul><li><code>input_array</code>: JuMP DenseAxisArray or SparseAxisArray to convert</li><li><code>columns::Vector{Symbol}</code>: Required when there is only one axis which is data. Ignored if <code>input_array</code> includes an axis for device names.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/utils.jl#L138-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.check_activeservice_variables-Tuple{PowerSimulations.OptimizationContainer, Vector{var&quot;#s2016&quot;} where var&quot;#s2016&quot;&lt;:Service}" href="#PowerSimulations.check_activeservice_variables-Tuple{PowerSimulations.OptimizationContainer, Vector{var&quot;#s2016&quot;} where var&quot;#s2016&quot;&lt;:Service}"><code>PowerSimulations.check_activeservice_variables</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function checks if the variables for reserves were created</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/services_models/group_reserve.jl#L3-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.check_file_integrity-Tuple{String}" href="#PowerSimulations.check_file_integrity-Tuple{String}"><code>PowerSimulations.check_file_integrity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_file_integrity(path::String)</code></pre><p>Checks the hash value for each file made with the file is written with the new hash_value to verify the file hasn&#39;t been tampered with since written</p><p><strong>Arguments</strong></p><ul><li><code>path::String</code>: this is the folder path that contains the results and the check.sha256 file</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/utils.jl#L383-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.commit_hydro_active_power_ub!-Union{Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Any, DeviceModel{V, W}, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where {V&lt;:HydroGen, W&lt;:PowerSimulations.AbstractHydroUnitCommitment}" href="#PowerSimulations.commit_hydro_active_power_ub!-Union{Tuple{W}, Tuple{V}, Tuple{PowerSimulations.OptimizationContainer, Any, DeviceModel{V, W}, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where {V&lt;:HydroGen, W&lt;:PowerSimulations.AbstractHydroUnitCommitment}"><code>PowerSimulations.commit_hydro_active_power_ub!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function define the range constraint specs for the reactive power for Commitment Run of River formulation.     <span>$P &lt;= multiplier * P_max$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/hydro_generation.jl#L366-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.commitment_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, D}, Type{S}, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where {T&lt;:ThermalGen, D&lt;:PowerSimulations.AbstractThermalUnitCommitment, S&lt;:PowerModels.AbstractPowerModel}" href="#PowerSimulations.commitment_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, D}, Type{S}, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where {T&lt;:ThermalGen, D&lt;:PowerSimulations.AbstractThermalUnitCommitment, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.commitment_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the Commitment Status constraint when there are CommitmentVariables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/thermal_generation.jl#L381-L383">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.compute_sha256-Tuple{AbstractString}" href="#PowerSimulations.compute_sha256-Tuple{AbstractString}"><code>PowerSimulations.compute_sha256</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the SHA 256 hash of a file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/utils.jl#L19-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.constraint_current_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel, Int64, Int64, Any, Any, Any, Any}" href="#PowerSimulations.constraint_current_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel, Int64, Int64, Any, Any, Any, Any}"><code>PowerSimulations.constraint_current_balance_ni_expr</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/network_models/powermodels_interface.jl#L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.constraint_current_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel, Int64}" href="#PowerSimulations.constraint_current_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel, Int64}"><code>PowerSimulations.constraint_current_balance_ni_expr</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/network_models/powermodels_interface.jl#L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractActivePowerModel, Int64, Int64, Any, Any, Any, Any}" href="#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractActivePowerModel, Int64, Int64, Any, Any, Any, Any}"><code>PowerSimulations.constraint_power_balance_ni_expr</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/network_models/powermodels_interface.jl#L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel, Int64, Int64, Any, Any, Any, Any}" href="#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel, Int64, Int64, Any, Any, Any, Any}"><code>PowerSimulations.constraint_power_balance_ni_expr</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/network_models/powermodels_interface.jl#L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel, Int64}" href="#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel, Int64}"><code>PowerSimulations.constraint_power_balance_ni_expr</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/network_models/powermodels_interface.jl#L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, D}, Type{S}}} where {H&lt;:HydroGen, D&lt;:HydroCommitmentReservoirBudget, S&lt;:PowerModels.AbstractActivePowerModel}" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, D}, Type{S}}} where {H&lt;:HydroGen, D&lt;:HydroCommitmentReservoirBudget, S&lt;:PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct model for HydroGen with ReservoirBudget Commitment Formulation with only Active Power.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/device_constructors/hydrogeneration_constructor.jl#L581-L584">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, D}, Type{S}}} where {H&lt;:HydroGen, D&lt;:HydroCommitmentReservoirBudget, S&lt;:PowerModels.AbstractPowerModel}" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, D}, Type{S}}} where {H&lt;:HydroGen, D&lt;:HydroCommitmentReservoirBudget, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct model for HydroGen with ReservoirBudget Commitment Formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/device_constructors/hydrogeneration_constructor.jl#L525-L527">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, D}, Type{S}}} where {H&lt;:HydroGen, D&lt;:HydroCommitmentRunOfRiver, S&lt;:PowerModels.AbstractActivePowerModel}" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, D}, Type{S}}} where {H&lt;:HydroGen, D&lt;:HydroCommitmentRunOfRiver, S&lt;:PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct model for HydroGen with RunOfRiver Commitment Formulation with only Active Power.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/device_constructors/hydrogeneration_constructor.jl#L477-L480">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, D}, Type{S}}} where {H&lt;:HydroGen, D&lt;:HydroCommitmentRunOfRiver, S&lt;:PowerModels.AbstractPowerModel}" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, D}, Type{S}}} where {H&lt;:HydroGen, D&lt;:HydroCommitmentRunOfRiver, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct model for HydroGen with RunOfRiver Commitment Formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/device_constructors/hydrogeneration_constructor.jl#L424-L426">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, D}, Type{S}}} where {H&lt;:HydroGen, D&lt;:PowerSimulations.AbstractHydroDispatchFormulation, S&lt;:PowerModels.AbstractActivePowerModel}" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, D}, Type{S}}} where {H&lt;:HydroGen, D&lt;:PowerSimulations.AbstractHydroDispatchFormulation, S&lt;:PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct model for HydroGen with RunOfRiver Dispatch Formulation with only Active Power.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/device_constructors/hydrogeneration_constructor.jl#L71-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, D}, Type{S}}} where {H&lt;:HydroGen, D&lt;:PowerSimulations.AbstractHydroDispatchFormulation, S&lt;:PowerModels.AbstractPowerModel}" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, D}, Type{S}}} where {H&lt;:HydroGen, D&lt;:PowerSimulations.AbstractHydroDispatchFormulation, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct model for HydroGen with RunOfRiver Dispatch Formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/device_constructors/hydrogeneration_constructor.jl#L21-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{T, D}, Type{S}}} where {T&lt;:ThermalGen, D&lt;:PowerSimulations.AbstractStandardUnitCommitment, S&lt;:PowerModels.AbstractActivePowerModel}" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{T, D}, Type{S}}} where {T&lt;:ThermalGen, D&lt;:PowerSimulations.AbstractStandardUnitCommitment, S&lt;:PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the model for a full thermal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/device_constructors/thermalgeneration_constructor.jl#L87-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{T, D}, Type{S}}} where {T&lt;:ThermalGen, D&lt;:PowerSimulations.AbstractStandardUnitCommitment, S&lt;:PowerModels.AbstractPowerModel}" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{T, D}, Type{S}}} where {T&lt;:ThermalGen, D&lt;:PowerSimulations.AbstractStandardUnitCommitment, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the model for a full thermal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/device_constructors/thermalgeneration_constructor.jl#L18-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, FixedOutput}, Type{S}}} where {H&lt;:HydroGen, S&lt;:PowerModels.AbstractPowerModel}" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, FixedOutput}, Type{S}}} where {H&lt;:HydroGen, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct model for HydroGen with FixedOutput Formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/device_constructors/hydrogeneration_constructor.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, HydroCommitmentReservoirStorage}, Type{S}}} where {H&lt;:HydroEnergyReservoir, S&lt;:PowerModels.AbstractActivePowerModel}" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, HydroCommitmentReservoirStorage}, Type{S}}} where {H&lt;:HydroEnergyReservoir, S&lt;:PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct model for HydroGen with ReservoirStorage Dispatch Formulation with only Active Power</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/device_constructors/hydrogeneration_constructor.jl#L741-L744">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, HydroCommitmentReservoirStorage}, Type{S}}} where {H&lt;:HydroEnergyReservoir, S&lt;:PowerModels.AbstractPowerModel}" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, HydroCommitmentReservoirStorage}, Type{S}}} where {H&lt;:HydroEnergyReservoir, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct model for HydroGen with ReservoirStorage Commitment Formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/device_constructors/hydrogeneration_constructor.jl#L632-L634">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, HydroDispatchPumpedStoragewReservation}, Type{S}}} where {H&lt;:HydroPumpedStorage, S&lt;:PowerModels.AbstractActivePowerModel}" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, HydroDispatchPumpedStoragewReservation}, Type{S}}} where {H&lt;:HydroPumpedStorage, S&lt;:PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct model for HydroPumpedStorage with PumpedStorage Dispatch Formulation with reservation constraint with only Active Power</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/device_constructors/hydrogeneration_constructor.jl#L938-L941">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, HydroDispatchPumpedStorage}, Type{S}}} where {H&lt;:HydroPumpedStorage, S&lt;:PowerModels.AbstractActivePowerModel}" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, HydroDispatchPumpedStorage}, Type{S}}} where {H&lt;:HydroPumpedStorage, S&lt;:PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct model for HydroPumpedStorage with PumpedStorage Dispatch Formulation with only Active Power</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/device_constructors/hydrogeneration_constructor.jl#L836-L839">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, HydroDispatchReservoirBudget}, Type{S}}} where {H&lt;:HydroEnergyReservoir, S&lt;:PowerModels.AbstractActivePowerModel}" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, HydroDispatchReservoirBudget}, Type{S}}} where {H&lt;:HydroEnergyReservoir, S&lt;:PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct model for HydroGen with ReservoirBudget Dispatch Formulation with only Active Power.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/device_constructors/hydrogeneration_constructor.jl#L178-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, HydroDispatchReservoirBudget}, Type{S}}} where {H&lt;:HydroEnergyReservoir, S&lt;:PowerModels.AbstractPowerModel}" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, HydroDispatchReservoirBudget}, Type{S}}} where {H&lt;:HydroEnergyReservoir, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct model for HydroGen with ReservoirBudget Dispatch Formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/device_constructors/hydrogeneration_constructor.jl#L112-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, HydroDispatchReservoirStorage}, Type{S}}} where {H&lt;:HydroEnergyReservoir, S&lt;:PowerModels.AbstractActivePowerModel}" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, HydroDispatchReservoirStorage}, Type{S}}} where {H&lt;:HydroEnergyReservoir, S&lt;:PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct model for HydroGen with ReservoirStorage Dispatch Formulation with only Active Power</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/device_constructors/hydrogeneration_constructor.jl#L334-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, HydroDispatchReservoirStorage}, Type{S}}} where {H&lt;:HydroEnergyReservoir, S&lt;:PowerModels.AbstractPowerModel}" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{H, HydroDispatchReservoirStorage}, Type{S}}} where {H&lt;:HydroEnergyReservoir, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct model for HydroGen with ReservoirStorage Dispatch Formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/device_constructors/hydrogeneration_constructor.jl#L230-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{RegulationDevice{T}, DeviceLimitedRegulation}, Type{S}}} where {T&lt;:StaticInjection, S&lt;:PowerModels.AbstractPowerModel}" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{RegulationDevice{T}, DeviceLimitedRegulation}, Type{S}}} where {T&lt;:StaticInjection, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the model for a full thermal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/device_constructors/regulationdevice_constructor.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{RegulationDevice{T}, FixedOutput}, Type{S}}} where {T&lt;:StaticInjection, S&lt;:PowerModels.AbstractPowerModel}" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{RegulationDevice{T}, FixedOutput}, Type{S}}} where {T&lt;:StaticInjection, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the model for a full thermal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/device_constructors/regulationdevice_constructor.jl#L142-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{RegulationDevice{T}, ReserveLimitedRegulation}, Type{S}}} where {T&lt;:StaticInjection, S&lt;:PowerModels.AbstractPowerModel}" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{RegulationDevice{T}, ReserveLimitedRegulation}, Type{S}}} where {T&lt;:StaticInjection, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the model for a full thermal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/device_constructors/regulationdevice_constructor.jl#L72-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{T, ThermalBasicUnitCommitment}, Type{S}}} where {T&lt;:ThermalGen, S&lt;:PowerModels.AbstractActivePowerModel}" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{T, ThermalBasicUnitCommitment}, Type{S}}} where {T&lt;:ThermalGen, S&lt;:PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the model for a full thermal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/device_constructors/thermalgeneration_constructor.jl#L232-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{T, ThermalBasicUnitCommitment}, Type{S}}} where {T&lt;:ThermalGen, S&lt;:PowerModels.AbstractPowerModel}" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{T, ThermalBasicUnitCommitment}, Type{S}}} where {T&lt;:ThermalGen, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the model for a full thermal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/device_constructors/thermalgeneration_constructor.jl#L146-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{T, ThermalRampLimited}, Type{S}}} where {T&lt;:ThermalGen, S&lt;:PowerModels.AbstractActivePowerModel}" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{T, ThermalRampLimited}, Type{S}}} where {T&lt;:ThermalGen, S&lt;:PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the model for a full thermal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/device_constructors/thermalgeneration_constructor.jl#L361-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{T, ThermalRampLimited}, Type{S}}} where {T&lt;:ThermalGen, S&lt;:PowerModels.AbstractPowerModel}" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, System, DeviceModel{T, ThermalRampLimited}, Type{S}}} where {T&lt;:ThermalGen, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the model for a full thermal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/device_constructors/thermalgeneration_constructor.jl#L301-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_service!-Union{Tuple{SR}, Tuple{PowerSimulations.OptimizationContainer, Vector{SR}, System, ServiceModel{SR, GroupReserve}, Dict{Symbol, DeviceModel}, Vector{var&quot;#s2016&quot;} where var&quot;#s2016&quot;&lt;:DataType}} where SR&lt;:StaticReserveGroup" href="#PowerSimulations.construct_service!-Union{Tuple{SR}, Tuple{PowerSimulations.OptimizationContainer, Vector{SR}, System, ServiceModel{SR, GroupReserve}, Dict{Symbol, DeviceModel}, Vector{var&quot;#s2016&quot;} where var&quot;#s2016&quot;&lt;:DataType}} where SR&lt;:StaticReserveGroup"><code>PowerSimulations.construct_service!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Constructs a service for StaticReserveGroup.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/services_models/services_constructor.jl#L215-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.container_spec-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any, N} where N}} where T" href="#PowerSimulations.container_spec-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any, N} where N}} where T"><code>PowerSimulations.container_spec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns the correct container spec for the selected type of JuMP Model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/utils.jl#L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.cost_function!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, ThermalDispatchNoMin}, Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where T&lt;:ThermalGen" href="#PowerSimulations.cost_function!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, ThermalDispatchNoMin}, Type{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where T&lt;:ThermalGen"><code>PowerSimulations.cost_function!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Cost function for generators formulated as No-Min</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/thermal_generation.jl#L1453-L1455">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.cost_function!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, U}, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, U}, Type{var&quot;#s331&quot;} where var&quot;#s331&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where {T&lt;:Component, U&lt;:PowerSimulations.AbstractDeviceFormulation}" href="#PowerSimulations.cost_function!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, U}, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, U}, Type{var&quot;#s331&quot;} where var&quot;#s331&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where {T&lt;:Component, U&lt;:PowerSimulations.AbstractDeviceFormulation}"><code>PowerSimulations.cost_function!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add variables to the OptimizationContainer for a service.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/cost_functions.jl#L68-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_commitment!-Tuple{PowerSimulations.OptimizationContainer, Vector{InitialCondition}, Symbol, Tuple{Symbol, Symbol, Symbol}}" href="#PowerSimulations.device_commitment!-Tuple{PowerSimulations.OptimizationContainer, Vector{InitialCondition}, Symbol, Tuple{Symbol, Symbol, Symbol}}"><code>PowerSimulations.device_commitment!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs multi-timestep constraint from initial conditions and binary variable tuple.</p><p><strong>Constraints</strong></p><p><code>varstart + varstop &lt;= 1.0</code></p><p>If t = 1:</p><p><code>varon[name, 1] == ic.value + varstart[name, 1] - varstop[name, 1]</code></p><p>where ic in initial_condtions.</p><p>If t &gt; 1:</p><p><code>varon[name, t] == varon[name, t-1] + varstart[name, t] - varstop[name, t]</code></p><p><strong>LaTeX</strong></p><p><span>$x^{on}_t + x^{off}_t \leq 1.0 \forall t$</span></p><p><span>$x^{on}_1 = x^{on}_{init} + x^{start}_1 - x^{stop}_1, \text{ for } t = 1$</span></p><p><span>$x^{on}_t = x^{on}_{t-1} + x^{start}_t - x^{stop}_t, \forall t \geq 2$</span></p><p><strong>Arguments</strong></p><ul><li>optimization<em>container::OptimizationContainer : the optimization</em>container model built in PowerSimulations</li><li>initial_conditions::Vector{InitialCondition} : for time zero &#39;varon&#39;</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables</li><li>: var_names[1] : varstart</li><li>: var_names[2] : varstop</li><li>: var_names[3] : varon</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/commitment_constraint.jl#L1-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_duration_compact_retrospective!-Tuple{PowerSimulations.OptimizationContainer, Vector{NamedTuple{(:up, :down), Tuple{Float64, Float64}}}, Matrix{InitialCondition}, Symbol, Tuple{Symbol, Symbol, Symbol}}" href="#PowerSimulations.device_duration_compact_retrospective!-Tuple{PowerSimulations.OptimizationContainer, Vector{NamedTuple{(:up, :down), Tuple{Float64, Float64}}}, Matrix{InitialCondition}, Symbol, Tuple{Symbol, Symbol, Symbol}}"><code>PowerSimulations.device_duration_compact_retrospective!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This formulation of the duration constraints adds over the start times looking backwards.</p><p><strong>LaTeX</strong></p><ul><li>Minimum up-time constraint:</li></ul><p><span>$\sum_{i=t-min(d_{min}^{up}, T)+ 1}^t x_i^{start} - x_t^{on} \leq 0$</span></p><p>for i in the set of time steps.</p><ul><li>Minimum down-time constraint:</li></ul><p><span>$\sum_{i=t-min(d_{min}^{down}, T) + 1}^t x_i^{stop} + x_t^{on} \leq 1$</span></p><p>for i in the set of time steps.</p><p><strong>Arguments</strong></p><ul><li>optimization<em>container::OptimizationContainer : the optimization</em>container model built in PowerSimulations</li><li>duration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down</li><li>initial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol}) : names of the variables</li><li>: var_names[1] : varon</li><li>: var_names[2] : varstart</li><li>: var_names[3] : varstop</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/duration_constraints.jl#L323-L350">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_duration_look_ahead!-Tuple{PowerSimulations.OptimizationContainer, Vector{NamedTuple{(:up, :down), Tuple{Float64, Float64}}}, Matrix{InitialCondition}, Symbol, Tuple{Symbol, Symbol, Symbol}}" href="#PowerSimulations.device_duration_look_ahead!-Tuple{PowerSimulations.OptimizationContainer, Vector{NamedTuple{(:up, :down), Tuple{Float64, Float64}}}, Matrix{InitialCondition}, Symbol, Tuple{Symbol, Symbol, Symbol}}"><code>PowerSimulations.device_duration_look_ahead!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This formulation of the duration constraints looks ahead in the time frame of the model.</p><p><strong>LaTeX</strong></p><ul><li>Minimum up-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{up}$</span></p><p><span>$d_{min}^{down}x_t^{stop} - \sum_{i=t-d_{min}^{up} + 1}^t x_i^{on} - x_{init}^{up} \leq 0$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$d_{min}^{down}x_t^{stop} - \sum_{i=t-d_{min}^{up} + 1}^t x_i^{on} \leq 0$</span></p><p>for i in the set of time steps.</p><ul><li>Minimum down-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{down}$</span></p><p><span>$d_{min}^{up}x_t^{start} - \sum_{i=t-d_{min^{down} + 1}^t (1 - x_i^{on}) - x_{init}^{down} \leq 0$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$d_{min}^{up}x_t^{start} - \sum_{i=t-d_{min^{down} + 1}^t (1 - x_i^{on}) \leq 0$</span></p><p>for i in the set of time steps.</p><p><strong>Arguments</strong></p><ul><li>optimization<em>container::OptimizationContainer : the optimization</em>container model built in PowerSimulations</li><li>duration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down</li><li>initial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol}) : names of the variables</li><li>: var_names[1] : varon</li><li>: var_names[2] : varstart</li><li>: var_names[3] : varstop</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/duration_constraints.jl#L101-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_duration_parameters!-Tuple{PowerSimulations.OptimizationContainer, Vector{NamedTuple{(:up, :down), Tuple{Float64, Float64}}}, Matrix{InitialCondition}, Symbol, Tuple{Symbol, Symbol, Symbol}}" href="#PowerSimulations.device_duration_parameters!-Tuple{PowerSimulations.OptimizationContainer, Vector{NamedTuple{(:up, :down), Tuple{Float64, Float64}}}, Matrix{InitialCondition}, Symbol, Tuple{Symbol, Symbol, Symbol}}"><code>PowerSimulations.device_duration_parameters!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This formulation of the duration constraints considers parameters.</p><p><strong>LaTeX</strong></p><ul><li>Minimum up-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{up}$</span></p><p><span>$d_{min}^{down}x_t^{stop} - \sum_{i=t-d_{min}^{up} + 1}^t x_i^{on} - x_{init}^{up} \leq 0$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$\sum_{i=t-d_{min}^{up} + 1}^t x_i^{start} - x_t^{on} \leq 0$</span></p><p>for i in the set of time steps.</p><ul><li>Minimum down-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{down}$</span></p><p><span>$d_{min}^{up}x_t^{start} - \sum_{i=t-d_{min^{down} + 1}^t (1 - x_i^{on}) - x_{init}^{down} \leq 0$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$\sum_{i=t-d_{min}^{down} + 1}^t x_i^{stop} + x_t^{on} \leq 1$</span></p><p>for i in the set of time steps.</p><p><strong>Arguments</strong></p><ul><li>optimization<em>container::OptimizationContainer : the optimization</em>container model built in PowerSimulations</li><li>duration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down</li><li>initial<em>duration</em>on::Vector{InitialCondition} : gives initial number of time steps variable is up</li><li>initial<em>duration</em>off::Vector{InitialCondition} : gives initial number of time steps variable is down</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol}) : names of the variables</li><li>: var_names[1] : varon</li><li>: var_names[2] : varstart</li><li>: var_names[3] : varstop</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/duration_constraints.jl#L202-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_duration_retrospective!-Tuple{PowerSimulations.OptimizationContainer, Vector{NamedTuple{(:up, :down), Tuple{Float64, Float64}}}, Matrix{InitialCondition}, Symbol, Tuple{Symbol, Symbol, Symbol}}" href="#PowerSimulations.device_duration_retrospective!-Tuple{PowerSimulations.OptimizationContainer, Vector{NamedTuple{(:up, :down), Tuple{Float64, Float64}}}, Matrix{InitialCondition}, Symbol, Tuple{Symbol, Symbol, Symbol}}"><code>PowerSimulations.device_duration_retrospective!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This formulation of the duration constraints adds over the start times looking backwards.</p><p><strong>LaTeX</strong></p><ul><li>Minimum up-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{up} - d_{init}^{up}$</span> and <span>$d_{init}^{up} &gt; 0$</span></p><p><span>$1 + \sum_{i=t-d_{min}^{up} + 1}^t x_i^{start} - x_t^{on} \leq 0$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$\sum_{i=t-d_{min}^{up} + 1}^t x_i^{start} - x_t^{on} \leq 0$</span></p><p>for i in the set of time steps.</p><ul><li>Minimum down-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{down} - d_{init}^{down}$</span> and <span>$d_{init}^{down} &gt; 0$</span></p><p><span>$1 + \sum_{i=t-d_{min}^{down} + 1}^t x_i^{stop} + x_t^{on} \leq 1$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$\sum_{i=t-d_{min}^{down} + 1}^t x_i^{stop} + x_t^{on} \leq 1$</span></p><p>for i in the set of time steps.</p><p><strong>Arguments</strong></p><ul><li>optimization<em>container::OptimizationContainer : the optimization</em>container model built in PowerSimulations</li><li>duration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down</li><li>initial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol}) : names of the variables</li><li>: var_names[1] : varon</li><li>: var_names[2] : varstart</li><li>: var_names[3] : varstop</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/duration_constraints.jl#L1-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_energy_budget_param_ub-Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceTimeSeriesConstraintInfo}, Symbol, PowerSimulations.UpdateRef, Symbol}" href="#PowerSimulations.device_energy_budget_param_ub-Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceTimeSeriesConstraintInfo}, Symbol, PowerSimulations.UpdateRef, Symbol}"><code>PowerSimulations.device_energy_budget_param_ub</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function define the budget constraint (using params) for the active power budget formulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/hydro_generation.jl#L786-L789">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_energy_budget_ub-Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceTimeSeriesConstraintInfo}, Symbol, Symbol}" href="#PowerSimulations.device_energy_budget_ub-Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceTimeSeriesConstraintInfo}, Symbol, Symbol}"><code>PowerSimulations.device_energy_budget_ub</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function define the budget constraint for the active power budget formulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/hydro_generation.jl#L825-L828">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_linear_rateofchange!-Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceRampConstraintInfo}, Symbol, Symbol}" href="#PowerSimulations.device_linear_rateofchange!-Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceRampConstraintInfo}, Symbol, Symbol}"><code>PowerSimulations.device_linear_rateofchange!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs allowed rate-of-change constraints from variables, initial condtions, and rate data.</p><p><strong>Constraints</strong></p><p>If t = 1:</p><p><code>variable[name, 1] - initial_conditions[ix].value &lt;= rate_data[1][ix].up</code></p><p><code>initial_conditions[ix].value - variable[name, 1] &lt;= rate_data[1][ix].down</code></p><p>If t &gt; 1:</p><p><code>variable[name, t] - variable[name, t-1] &lt;= rate_data[1][ix].up</code></p><p><code>variable[name, t-1] - variable[name, t] &lt;= rate_data[1][ix].down</code></p><p><strong>LaTeX</strong></p><p><span>$r^{down} \leq x_1 - x_{init} \leq r^{up}, \text{ for } t = 1$</span></p><p><span>$r^{down} \leq x_t - x_{t-1} \leq r^{up}, \forall t \geq 2$</span></p><p><strong>Arguments</strong></p><ul><li>optimization<em>container::OptimizationContainer : the optimization</em>container model built in PowerSimulations</li><li>rate_data::Tuple{Vector{String}, Vector{UpDown}} : gives name (1) and max ramp up/down rates (2)</li><li>initial_conditions::Vector{InitialCondition} : for time zero &#39;variable&#39;</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Tuple{Symbol, Symbol, Symbol} : the name of the variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/rateofchange_constraints.jl#L1-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_mixedinteger_rateofchange!-Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceRampConstraintInfo}, Symbol, Tuple{Symbol, Symbol, Symbol}}" href="#PowerSimulations.device_mixedinteger_rateofchange!-Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceRampConstraintInfo}, Symbol, Tuple{Symbol, Symbol, Symbol}}"><code>PowerSimulations.device_mixedinteger_rateofchange!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs allowed rate-of-change constraints from variables, initial condtions, start/stop status, and rate data</p><p><strong>Equations</strong></p><p>If t = 1:</p><p><code>variable[name, 1] - initial_conditions[ix].value &lt;= rate_data[1][ix].up + rate_data[2][ix].max*varstart[name, 1]</code></p><p><code>initial_conditions[ix].value - variable[name, 1] &lt;= rate_data[1][ix].down + rate_data[2][ix].min*varstop[name, 1]</code></p><p>If t &gt; 1:</p><p><code>variable[name, t] - variable[name, t-1] &lt;= rate_data[1][ix].up + rate_data[2][ix].max*varstart[name, t]</code></p><p><code>variable[name, t-1] - variable[name, t] &lt;= rate_data[1][ix].down + rate_data[2][ix].min*varstop[name, t]</code></p><p><strong>LaTeX</strong></p><p><span>$r^{down} + r^{min} x^{stop}_1 \leq x_1 - x_{init} \leq r^{up} + r^{max} x^{start}_1, \text{ for } t = 1$</span></p><p><span>$r^{down} + r^{min} x^{stop}_t \leq x_t - x_{t-1} \leq r^{up} + r^{max} x^{start}_t, \forall t \geq 2$</span></p><p><strong>Arguments</strong></p><ul><li>optimization<em>container::OptimizationContainer : the optimization</em>container model built in PowerSimulations</li><li>rate_data::Tuple{Vector{String}, Vector{UpDown}, Vector{MinMax}} : (1) gives name                                                                    (2) gives min/max ramp rates                                                                    (3) gives min/max for &#39;variable&#39;</li><li>initial_conditions::Vector{InitialCondition} : for time zero &#39;variable&#39;</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables</li><li>: var_names[1] : &#39;variable&#39;</li><li>: var_names[2] : &#39;varstart&#39;</li><li>: var_names[3] : &#39;varstop&#39;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/rateofchange_constraints.jl#L107-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_multistart_range!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.RangeConstraintSpecInternal}" href="#PowerSimulations.device_multistart_range!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.RangeConstraintSpecInternal}"><code>PowerSimulations.device_multistart_range!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs min/max range constraint from device variable and on/off decision variable.</p><p><strong>Constraints</strong></p><pre><code class="language-varcts">        - max(limits.max - lag_ramp_limits.startup, 0) * var_on[name, t] ```
</code></pre><p>varcts[name, t] &lt;= (limits.max-limits.min)*varbin[name, t])         - max(limits.max - lag<em>ramp</em>limits.shutdown, 0) * var_off[name, t] ```</p><p>where limits and lag<em>ramp</em>limits is in range_data.</p><p><strong>LaTeX</strong></p><p><span>$x^{cts} \leq (limits^{max}-limits^{min}) x^{bin} - max(limits^{max} - lag^{startup}, 0) x^{on}$</span></p><p><span>$x^{cts} \leq (limits^{max}-limits^{min}) x^{bin} - max(limits^{max} - lag^{shutdown}, 0) x^{off}$</span></p><p><strong>Arguments</strong></p><ul><li>optimization<em>container::OptimizationContainer : the optimization</em>container model built in PowerSimulations</li><li>range_data::Vector{DeviceRange} : contains names and vector of min/max</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol : the name of the continuous variable</li><li>binvar_names::Symbol : the names of the binary variables</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/range_constraint.jl#L230-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_multistart_range_ic!-Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceMultiStartRangeConstraintsInfo}, Matrix{InitialCondition}, Symbol, Symbol}" href="#PowerSimulations.device_multistart_range_ic!-Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceMultiStartRangeConstraintsInfo}, Matrix{InitialCondition}, Symbol, Symbol}"><code>PowerSimulations.device_multistart_range_ic!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs min/max range constraint from device variable and on/off decision variable.</p><p><strong>Constraints</strong></p><p><code>max(limits.max - lag_ramp_limits.shutdown, 0) var_off[name, 1] &lt;= initial_power[ix].value         - (limits.max - limits.min)initial_status[ix].value</code></p><p>where limits in range_data.</p><p><strong>LaTeX</strong></p><p><span>$max(limits^{max} - lag^{shutdown}, 0) x^{off} \leq initial_condition^{power} - (limits^{max} - limits^{min}) initial_condition^{status}$</span></p><p><strong>Arguments</strong></p><ul><li>optimization<em>container::OptimizationContainer : the optimization</em>container model built in PowerSimulations</li><li>range_data::Vector{DeviceRange} : contains names and vector of min/max</li><li>initial_conditions::Matrix{InitialCondition} :</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol : name of the shutdown variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/range_constraint.jl#L322-L342">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_multistart_rateofchange!-Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceRampConstraintInfo}, Symbol, Symbol}" href="#PowerSimulations.device_multistart_rateofchange!-Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceRampConstraintInfo}, Symbol, Symbol}"><code>PowerSimulations.device_multistart_rateofchange!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs allowed rate-of-change constraints from variables, initial condtions, start/stop status, and rate data</p><p><strong>Equations</strong></p><p>If t = 1:</p><p><code>variable[name, 1] - initial_conditions[ix].value &lt;= rate_data[1][ix].up</code></p><p><code>initial_conditions[ix].value - variable[name, 1] &lt;= rate_data[1][ix].down</code></p><p>If t &gt; 1:</p><p><code>variable[name, t] - variable[name, t-1] &lt;= rate_data[1][ix].up</code></p><p><code>variable[name, t-1] - variable[name, t] &lt;= rate_data[1][ix].down</code></p><p><strong>LaTeX</strong></p><p><span>$r^{down}  \leq x_1 - x_{init} \leq r^{up}  \text{ for } t = 1$</span></p><p><span>$r^{down} \leq x_t - x_{t-1} \leq r^{up}  \forall t \geq 2$</span></p><p><strong>Arguments</strong></p><ul><li>optimization<em>container::OptimizationContainer : the optimization</em>container model built in PowerSimulations</li><li>rate_data::Tuple{Vector{String}, Vector{UpDown}, Vector{MinMax}} : (1) gives name                                                                    (2) gives min/max ramp rates                                                                    (3) gives min/max for &#39;variable&#39;</li><li>initial_conditions::Vector{InitialCondition} : for time zero &#39;variable&#39;</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables</li><li>: var_name : &#39;variable&#39;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/rateofchange_constraints.jl#L224-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_range!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.RangeConstraintSpecInternal}" href="#PowerSimulations.device_range!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.RangeConstraintSpecInternal}"><code>PowerSimulations.device_range!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs min/max range constraint from device variable.</p><p><strong>Constraints</strong></p><p>If min and max within an epsilon width:</p><p><code>variable[name, t] == limits.max</code></p><p>Otherwise:</p><p><code>limits.min &lt;= variable[name, t] &lt;= limits.max</code></p><p>where limits in constraint_infos.</p><p><strong>LaTeX</strong></p><p><span>$x = limits^{max}, \text{ for } |limits^{max} - limits^{min}| &lt; \varepsilon$</span></p><p><span>$limits^{min} \leq x \leq limits^{max}, \text{ otherwise }$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/range_constraint.jl#L21-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_semicontinuousrange!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.RangeConstraintSpecInternal}" href="#PowerSimulations.device_semicontinuousrange!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.RangeConstraintSpecInternal}"><code>PowerSimulations.device_semicontinuousrange!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs min/max range constraint from device variable and on/off decision variable.</p><p><strong>Constraints</strong></p><p>If device min = 0:</p><p><code>varcts[name, t] &lt;= limits.max*varbin[name, t])</code></p><p><code>varcts[name, t] &gt;= 0.0</code></p><p>Otherwise:</p><p><code>varcts[name, t] &lt;= limits.max*varbin[name, t]</code></p><p><code>varcts[name, t] &gt;= limits.min*varbin[name, t]</code></p><p>where limits in constraint_infos.</p><p><strong>LaTeX</strong></p><p><span>$0 \leq x^{cts} \leq limits^{max} x^{bin}, \text{ for } limits^{min} = 0$</span></p><p><span>$limits^{min} x^{bin} \leq x^{cts} \leq limits^{max} x^{bin}, \text{ otherwise }$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/range_constraint.jl#L83-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_start_type_constraint-Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceStartTypesConstraintInfo}, Symbol, Symbol, Tuple{Symbol, Symbol, Symbol}}" href="#PowerSimulations.device_start_type_constraint-Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceStartTypesConstraintInfo}, Symbol, Symbol, Tuple{Symbol, Symbol, Symbol}}"><code>PowerSimulations.device_start_type_constraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">device_start_type_constraint(optimization_container::OptimizationContainer,
                        data::Vector{DeviceStartTypesConstraintInfo},
                        cons_name::Symbol,
                        var_start::Symbol,
                        var_names::Tuple{Symbol, Symbol, Symbol},)</code></pre><p>Constructs contraints that restricts devices to one type of start at a time</p><p><strong>Equations</strong></p><p><code>sum(var_starts[name, s, t] for s in starts) = var_start[name, t]</code></p><p><strong>LaTeX</strong></p><p><span>$\sum^{S_g}_{s=1} δ^{s}(t)  \eq  x^{start}(t)$</span></p><p><strong>Arguments</strong></p><ul><li>optimization<em>container::OptimizationContainer : the optimization</em>container model built in PowerSimulations</li><li>data::Vector{DeviceStartTypesConstraintInfo},</li><li>cons_name::Symbol : name of the constraint</li><li>var_start::Symbol : name of the startup variable</li><li>var_starts::Tuple{Symbol, Symbol} : the names of the different start variables</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/thermal_generation.jl#L857-L880">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_startup_initial_condition-Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceStartUpConstraintInfo}, Vector{InitialCondition}, Symbol, Tuple{Symbol, Symbol}, Symbol}" href="#PowerSimulations.device_startup_initial_condition-Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceStartUpConstraintInfo}, Vector{InitialCondition}, Symbol, Tuple{Symbol, Symbol}, Symbol}"><code>PowerSimulations.device_startup_initial_condition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">device_startup_initial_condition(optimization_container::OptimizationContainer,
                        data::Vector{DeviceStartUpConstraintInfo},
                        initial_conditions::Vector{InitialCondition},
                        cons_name::Symbol,
                        var_names::Tuple{Symbol, Symbol},
                        bin_name::Symbol,)</code></pre><p>Constructs contraints that restricts devices to one type of start at a time</p><p><strong>Equations</strong></p><p>ub: <code>(time_limits[st+1]-1)*δ^{s}(t) + (1 - δ^{s}(t)) * M_VALUE &gt;= sum(1-varbin[name, i]) for i in 1:t) + initial_condition_offtime</code> lb: <code>(time_limits[st]-1)*δ^{s}(t) =&lt; sum(1-varbin[name, i]) for i in 1:t) + initial_condition_offtime</code></p><p><strong>LaTeX</strong></p><p><span>$TS^{s+1}_{g} δ^{s}(t) + (1-δ^{s}(t)) M_VALUE   \geq  \sum^{t}_{i=1} x^{status}(i)  +  DT_{g}^{0}  \forall t in \{1, \ldots,  TS^{s+1}_{g}$</span></p><p><span>$TS^{s}_{g} δ^{s}(t) \leq  \sum^{t}_{i=1} x^{status}(i)  +  DT_{g}^{0}  \forall t in \{1, \ldots,  TS^{s+1}_{g}$</span></p><p><strong>Arguments</strong></p><ul><li>optimization<em>container::OptimizationContainer : the optimization</em>container model built in PowerSimulations</li><li>data::Vector{DeviceStartTypesConstraintInfo},</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol} : the names of the different start variables</li><li>bin_name::Symbol : name of the status variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/thermal_generation.jl#L909-L937">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_timeseries_lb!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.TimeSeriesConstraintSpecInternal}" href="#PowerSimulations.device_timeseries_lb!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.TimeSeriesConstraintSpecInternal}"><code>PowerSimulations.device_timeseries_lb!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs lower bound for given variable subject to time series data and a multiplier.</p><p><strong>Constraint</strong></p><p><code>constraint_infos[name].multiplier * ts_data[name].timeseries[t] &lt;= variable[name, t]</code></p><p><strong>LaTeX</strong></p><p><span>$r^{val} r_t \leq x_t, \forall t$</span></p><p>where (name, data) in range_data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/timeseries_constraint.jl#L93-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_timeseries_param_lb!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.TimeSeriesConstraintSpecInternal}" href="#PowerSimulations.device_timeseries_param_lb!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.TimeSeriesConstraintSpecInternal}"><code>PowerSimulations.device_timeseries_param_lb!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs lower bound for given variable using a parameter. The constraint is     built with a time series data vector and a multiplier</p><p><strong>Constraint</strong></p><p><code>constraint_infos[name].multiplier * param[name, t] &lt;= variable[name, t]</code></p><p><strong>LaTeX</strong></p><p><span>$r^{val} x^{param}_t \leq x^{var}_t, \forall t$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/timeseries_constraint.jl#L198-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_timeseries_param_ub!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.TimeSeriesConstraintSpecInternal}" href="#PowerSimulations.device_timeseries_param_ub!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.TimeSeriesConstraintSpecInternal}"><code>PowerSimulations.device_timeseries_param_ub!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs upper bound for given variable using a parameter. The constraint is     built with a time series data vector and a multiplier</p><p><strong>Constraint</strong></p><p><code>variable[name, t] &lt;= constraint_infos[name].multiplier * param[name, t]</code></p><p><strong>LaTeX</strong></p><p><span>$x^{var}_t \leq r^{val} x^{param}_t, \forall t$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/timeseries_constraint.jl#L136-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_timeseries_ub!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.TimeSeriesConstraintSpecInternal}" href="#PowerSimulations.device_timeseries_ub!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.TimeSeriesConstraintSpecInternal}"><code>PowerSimulations.device_timeseries_ub!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs upper bound for given variable and time series data and a multiplier.</p><p><strong>Constraint</strong></p><p><code>variable[name, t] &lt;= constraint_infos[name].multiplier * ts_data[name].timeseries[t]</code></p><p><strong>LaTeX</strong></p><p><span>$x_t \leq r^{val} r_t, \forall t$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/timeseries_constraint.jl#L44-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_timeseries_ub_bigM!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.TimeSeriesConstraintSpecInternal}" href="#PowerSimulations.device_timeseries_ub_bigM!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.TimeSeriesConstraintSpecInternal}"><code>PowerSimulations.device_timeseries_ub_bigM!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs upper bound for variable and time series and a multiplier or confines to 0 depending on binary variable.     Uses BigM constraint type to allow for parameter since ParameterJuMP doesn&#39;t support var*parameter</p><p><strong>constraint_infos</strong></p><p><code>varcts[name, t] - constraint_infos[name].multipliers * param[name, t] &lt;= (1 - varbin[name, t]) * M_value</code></p><p><code>varcts[name, t] &lt;= varbin[name, t]*M_value</code></p><p><strong>LaTeX</strong></p><p><span>$x^{cts}_t - r^{val} x^{param}_t \leq M(1 - x^{bin}_t ), forall t$</span></p><p><span>$x^{cts}_t \leq M x^{bin}_t, \forall t$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/timeseries_constraint.jl#L299-L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_timeseries_ub_bin!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.TimeSeriesConstraintSpecInternal}" href="#PowerSimulations.device_timeseries_ub_bin!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.TimeSeriesConstraintSpecInternal}"><code>PowerSimulations.device_timeseries_ub_bin!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs upper bound for variable and time series or confines to 0 depending on binary variable.     The upper bound is defined by a time series and a multiplier.</p><p><strong>constraint_infos</strong></p><p><code>varcts[name, t] &lt;= varbin[name, t]* constraint_infos[name].multiplier * ts_data[name].timeseries[t]</code></p><p>where (name, data) in range_data.</p><p><strong>LaTeX</strong></p><p><span>$x^{cts}_t \leq r^{val} r_t x^{bin}_t, \forall t$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/timeseries_constraint.jl#L254-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.energy_balance!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.DeviceEnergyBalanceConstraintSpecInternal}" href="#PowerSimulations.energy_balance!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.DeviceEnergyBalanceConstraintSpecInternal}"><code>PowerSimulations.energy_balance!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs multi-timestep constraint from initial condition, efficiency data, and variable tuple</p><p><strong>Constraints</strong></p><p>If t = 1: <code>varenergy[name, 1] == initial_conditions[ix].value + varin[name, 1]*eff_in*fraction_of_hour - varout[name, 1]*fraction_of_hour/eff_out</code> If t &gt; 1: <code>varenergy[name, t] == varenergy[name, t-1] + varin[name, t]*eff_in*fraction_of_hour - varout[name, t]*fraction_of_hour/eff_out</code></p><p><strong>LaTeX</strong></p><p><span>$x^{energy}_1 == x^{energy}_{init} + frhr \eta^{in} x^{in}_1 - \frac{frhr}{\eta^{out}} x^{out}_1, \text{ for } t = 1$</span> <span>$x^{energy}_t == x^{energy}_{t-1} + frhr \eta^{in} x^{in}_t - \frac{frhr}{\eta^{out}} x^{out}_t, \forall t \geq 2$</span></p><p><strong>Arguments</strong></p><ul><li>optimization<em>container::OptimizationContainer : the optimization</em>container model built in PowerSimulations</li><li>inputs::Vector{DeviceEnergyBalanceConstraintSpecInternal} : stores constraint information </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/energy_balance_constraint.jl#L143-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.energy_balance_param!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.DeviceEnergyBalanceConstraintSpecInternal}" href="#PowerSimulations.energy_balance_param!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.DeviceEnergyBalanceConstraintSpecInternal}"><code>PowerSimulations.energy_balance_param!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs multi-timestep constraint from initial condition, efficiency data, and variable tuple</p><p><strong>Constraints</strong></p><p>If t = 1: <code>varenergy[name, 1] == initial_conditions[ix].value + varin[name, 1]*eff_in*fraction_of_hour - varout[name, 1]*fraction_of_hour/eff_out</code> If t &gt; 1: <code>varenergy[name, t] == varenergy[name, t-1] + varin[name, t]*eff_in*fraction_of_hour - varout[name, t]*fraction_of_hour/eff_out</code></p><p><strong>LaTeX</strong></p><p><span>$x^{energy}_1 == x^{energy}_{init} + frhr \eta^{in} x^{in}_1 - \frac{frhr}{\eta^{out}} x^{out}_1, \text{ for } t = 1$</span> <span>$x^{energy}_t == x^{energy}_{t-1} + frhr \eta^{in} x^{in}_t - \frac{frhr}{\eta^{out}} x^{out}_t, \forall t \geq 2$</span></p><p><strong>Arguments</strong></p><ul><li>optimization<em>container::OptimizationContainer : the optimization</em>container model built in PowerSimulations</li><li>inputs::Vector{DeviceEnergyBalanceConstraintSpecInternal} : stores constraint information </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/energy_balance_constraint.jl#L220-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.energy_budget_constraints!-Union{Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{H}, DeviceModel{H, var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractHydroFormulation, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where H&lt;:HydroGen" href="#PowerSimulations.energy_budget_constraints!-Union{Tuple{H}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{H}, DeviceModel{H, var&quot;#s2014&quot;} where var&quot;#s2014&quot;&lt;:PowerSimulations.AbstractHydroFormulation, Type{var&quot;#s332&quot;} where var&quot;#s332&quot;&lt;:PowerModels.AbstractPowerModel, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where H&lt;:HydroGen"><code>PowerSimulations.energy_budget_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function define the budget constraint for the active power budget formulation.</p><p><span>$sum(P[t]) &lt;= Budget$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/hydro_generation.jl#L745-L750">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.energy_target!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Vector{T}, Symbol, Tuple{Symbol, Symbol, Symbol}}} where T&lt;:PowerSimulations.DeviceTimeSeriesConstraintInfo" href="#PowerSimulations.energy_target!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Vector{T}, Symbol, Tuple{Symbol, Symbol, Symbol}}} where T&lt;:PowerSimulations.DeviceTimeSeriesConstraintInfo"><code>PowerSimulations.energy_target!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs constraint energy target data, and variable</p><p><strong>Constraints</strong></p><p><span>$varenergy[name, end]  &gt;= paramenergytarget[name, end]$</span></p><p><strong>LaTeX</strong></p><p><span>$x^{energy}_t  &gt;= x^{energy}_{target} \text{ for } t = end$</span></p><p><strong>Arguments</strong></p><ul><li>optimization<em>container::OptimizationContainer : the optimization</em>container model built in PowerSimulations</li><li>time<em>series</em>data::Vector{DeviceTimeSeriesConstraintInfo} : Target reservoir storage forecast information</li><li>cons_name::Symbol : energy target constraint name</li><li>var_name::Symbol : the name of the Energy  variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/energy_management_constraints.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.energy_target_param!-Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceTimeSeriesConstraintInfo}, Symbol, Tuple{Symbol, Symbol, Symbol}, PowerSimulations.UpdateRef}" href="#PowerSimulations.energy_target_param!-Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceTimeSeriesConstraintInfo}, Symbol, Tuple{Symbol, Symbol, Symbol}, PowerSimulations.UpdateRef}"><code>PowerSimulations.energy_target_param!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs constraint energy target data, and variable</p><p><strong>Constraints</strong></p><p><span>$varenergy[name, end]  &gt;= paramenergytarget[name, end]$</span></p><p><strong>LaTeX</strong></p><p><span>$x^{energy}_t  &gt;= x^{energy}_{target} \text{ for } t = end$</span></p><p><strong>Arguments</strong></p><ul><li>optimization<em>container::OptimizationContainer : the optimization</em>container model built in PowerSimulations</li><li>time<em>series</em>data::Vector{DeviceTimeSeriesConstraintInfo} : Target reservoir storage forecast information</li><li>cons_names::Symbol : name of the constraint</li><li>var_names::Symbol : the name of the energy variable</li><li>param_reference::UpdateRef : UpdateRef to access the target parameter</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/energy_management_constraints.jl#L40-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.find_key_with_value-Tuple{Any, Any}" href="#PowerSimulations.find_key_with_value-Tuple{Any, Any}"><code>PowerSimulations.find_key_with_value</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the key for the given value</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/utils.jl#L28-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.frequency_response_constraint!-Tuple{PowerSimulations.OptimizationContainer, System}" href="#PowerSimulations.frequency_response_constraint!-Tuple{PowerSimulations.OptimizationContainer, System}"><code>PowerSimulations.frequency_response_constraint!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Expression for the power deviation given deviation in the frequency. This expression allows updating the response of the frequency depending on commitment decisions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/services_models/agc.jl#L179-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.get_enum_value-Tuple{Any, String}" href="#PowerSimulations.get_enum_value-Tuple{Any, String}"><code>PowerSimulations.get_enum_value</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the enum value for the string. Case insensitive.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/definitions.jl#L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.has_dirty-Tuple{PowerSimulations.ResultCache}" href="#PowerSimulations.has_dirty-Tuple{PowerSimulations.ResultCache}"><code>PowerSimulations.has_dirty</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return true if the cache has data that has not been flushed to storage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/result_cache.jl#L34-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.initial_condition_update!-Tuple{OperationsProblem, PowerSimulations.ICKey, Vector{InitialCondition}, InterProblemChronology, Simulation}" href="#PowerSimulations.initial_condition_update!-Tuple{OperationsProblem, PowerSimulations.ICKey, Vector{InitialCondition}, InterProblemChronology, Simulation}"><code>PowerSimulations.initial_condition_update!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Updates the initial conditions of the problem</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/simulation.jl#L714">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.initial_condition_update!-Tuple{OperationsProblem, PowerSimulations.ICKey, Vector{InitialCondition}, IntraProblemChronology, Simulation}" href="#PowerSimulations.initial_condition_update!-Tuple{OperationsProblem, PowerSimulations.ICKey, Vector{InitialCondition}, IntraProblemChronology, Simulation}"><code>PowerSimulations.initial_condition_update!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Updates the initial conditions of the problem</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/simulation.jl#L670">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.initial_range_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, D}, Type{S}, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where {T&lt;:ThermalMultiStart, D&lt;:PowerSimulations.AbstractCompactUnitCommitment, S&lt;:PowerModels.AbstractPowerModel}" href="#PowerSimulations.initial_range_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, D}, Type{S}, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where {T&lt;:ThermalMultiStart, D&lt;:PowerSimulations.AbstractCompactUnitCommitment, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.initial_range_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds range constraint for the first time period. Constraint (10) from PGLIB formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/thermal_generation.jl#L252-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.instantiate_nip_expr_model-Tuple{Dict{String, Any}, Any}" href="#PowerSimulations.instantiate_nip_expr_model-Tuple{Dict{String, Any}, Any}"><code>PowerSimulations.instantiate_nip_expr_model</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/network_models/powermodels_interface.jl#L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.instantiate_nip_ptdf_expr_model-Tuple{Dict{String, Any}, Any}" href="#PowerSimulations.instantiate_nip_ptdf_expr_model-Tuple{Dict{String, Any}, Any}"><code>PowerSimulations.instantiate_nip_ptdf_expr_model</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/network_models/powermodels_interface.jl#L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.integral_limit_ff-Tuple{PowerSimulations.OptimizationContainer, Symbol, PowerSimulations.UpdateRef, Symbol}" href="#PowerSimulations.integral_limit_ff-Tuple{PowerSimulations.OptimizationContainer, Symbol, PowerSimulations.UpdateRef, Symbol}"><code>PowerSimulations.integral_limit_ff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    integral_limit_ff(optimization_container::OptimizationContainer,
                    cons_name::Symbol,
                    param_reference::UpdateRef,
                    var_name::Symbol)</code></pre><p>Constructs a parametrized integral limit constraint to implement feedforward from other models. The Parameters are initialized using the upper boundary values of the provided variables.</p><p><strong>Constraints</strong></p><p><code>sum(variable[var_name, t] for t in time_steps)/length(time_steps) &lt;= param_reference[var_name]</code></p><p><strong>LaTeX</strong></p><p><span>$\sum_{t} x \leq param^{max}$</span> <span>$\sum_{t} x * DeltaT_lower \leq param^{max} * DeltaT_upper$</span>     <span>$P_LL - P_max * ON_upper &lt;= 0.0$</span>     <span>$P_LL - P_min * ON_upper &gt;= 0.0$</span></p><p><strong>Arguments</strong></p><ul><li>optimization<em>container::OptimizationContainer : the optimization</em>container model built in PowerSimulations</li><li>cons_name::Symbol : name of the constraint</li><li>param_reference : Reference to the PJ.ParameterRef used to determine the upperbound</li><li>var_name::Symbol : the name of the continuous variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/feedforward.jl#L423-L447">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.is_cached-Tuple{PowerSimulations.ResultCache, Any, Any, Any, Any}" href="#PowerSimulations.is_cached-Tuple{PowerSimulations.ResultCache, Any, Any, Any, Any}"><code>PowerSimulations.is_cached</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return true if the data for <code>timestamp</code> is stored in cache.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/result_cache.jl#L47-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.iterate_initial_conditions-Tuple{PowerSimulations.InitialConditions}" href="#PowerSimulations.iterate_initial_conditions-Tuple{PowerSimulations.InitialConditions}"><code>PowerSimulations.iterate_initial_conditions</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Iterate over the keys and vectors of initial conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/initial_conditions.jl#L39-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.list_fields-Tuple{PowerSimulations.HdfSimulationStore, Symbol, Symbol}" href="#PowerSimulations.list_fields-Tuple{PowerSimulations.HdfSimulationStore, Symbol, Symbol}"><code>PowerSimulations.list_fields</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the fields stored for the <code>problem</code> and <code>container_type</code> (duals/parameters/variables).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/hdf_simulation_store.jl#L155-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.log_cache_hit_percentages-Tuple{PowerSimulations.ResultCache}" href="#PowerSimulations.log_cache_hit_percentages-Tuple{PowerSimulations.ResultCache}"><code>PowerSimulations.log_cache_hit_percentages</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Log the cache hit percentages for all caches.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/result_cache.jl#L56-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.must_run_constraints!-Union{Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{ThermalMultiStart}, DeviceModel{ThermalMultiStart, ThermalMultiStartUnitCommitment}, Type{S}, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel" href="#PowerSimulations.must_run_constraints!-Union{Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{ThermalMultiStart}, DeviceModel{ThermalMultiStart, ThermalMultiStartUnitCommitment}, Type{S}, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.must_run_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates constraints that keep must run devices online</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/thermal_generation.jl#L1121-L1123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.nodal_expression!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{T}, Type{U}}} where {T&lt;:Device, U&lt;:PowerModels.AbstractPowerModel}" href="#PowerSimulations.nodal_expression!-Union{Tuple{U}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{T}, Type{U}}} where {T&lt;:Device, U&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.nodal_expression!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Default implementation to add nodal expressions.</p><p>Users of this function must implement a method for <a href="#PowerSimulations.NodalExpressionSpec-Union{Tuple{U}, Tuple{T}, Tuple{Type{T}, Type{U}, Bool}} where {T&lt;:Device, U&lt;:PowerModels.AbstractPowerModel}"><code>NodalExpressionSpec</code></a> for their specific types. Users may also implement custom nodal_expression! methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/nodal_expression.jl#L22-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.open_store" href="#PowerSimulations.open_store"><code>PowerSimulations.open_store</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Construct and open an HdfSimulationStore.</p><p>When reading or writing results in a program you should use the method that accepts a function in order to guarantee that the file handle gets closed.</p><p><strong>Examples</strong></p><pre><code class="language-julia"># Assumes a simulation has been executed in the &#39;./rts&#39; directory with these parameters.
path = &quot;./rts&quot;
problem = :ED
var_name = :P__ThermalStandard
timestamp = DateTime(&quot;2020-01-01T05:00:00&quot;)
store = open_store(HdfSimulationStore, path)
df = PowerSimulations.read_result(DataFrame, store, problem, :variables, var_name, timestamp)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/hdf_simulation_store.jl#L86-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, Type{S}, System, OperationsProblemTemplate}, Tuple{PowerSimulations.OptimizationContainer, Type{S}, System, OperationsProblemTemplate, Any}} where S&lt;:PowerModels.AbstractActivePowerModel" href="#PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, Type{S}, System, OperationsProblemTemplate}, Tuple{PowerSimulations.OptimizationContainer, Type{S}, System, OperationsProblemTemplate, Any}} where S&lt;:PowerModels.AbstractActivePowerModel"><code>PowerSimulations.powermodels_network!</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/network_models/powermodels_interface.jl#L325">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, Type{S}, System, OperationsProblemTemplate}, Tuple{PowerSimulations.OptimizationContainer, Type{S}, System, OperationsProblemTemplate, Any}} where S&lt;:PowerModels.AbstractPowerModel" href="#PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, Type{S}, System, OperationsProblemTemplate}, Tuple{PowerSimulations.OptimizationContainer, Type{S}, System, OperationsProblemTemplate, Any}} where S&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.powermodels_network!</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/network_models/powermodels_interface.jl#L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.problem_build!-Tuple{OperationsProblem{var&quot;#s331&quot;} where var&quot;#s331&quot;&lt;:PowerSimulations.PowerSimulationsOperationsProblem}" href="#PowerSimulations.problem_build!-Tuple{OperationsProblem{var&quot;#s331&quot;} where var&quot;#s331&quot;&lt;:PowerSimulations.PowerSimulationsOperationsProblem}"><code>PowerSimulations.problem_build!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Default implementation of build method for Operational Problems for models conforming with PowerSimulationsOperationsProblem specification. Overload this function to implement a custom build method</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/operations_problem.jl#L516-L518">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.pwl_gencost_linear!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, String, Vector{Tuple{Float64, Float64}}, Int64}" href="#PowerSimulations.pwl_gencost_linear!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, String, Vector{Tuple{Float64, Float64}}, Int64}"><code>PowerSimulations.pwl_gencost_linear!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns piecewise cost expression using linear implementation for optimization_container model.</p><p><strong>Equations</strong></p><p><code>0 &lt;= pwl_var[i] &lt;= (cost_data[2][i] - cost_data[2][i-1])</code></p><p><code>variable = sum(pwl_var[i])</code></p><p><code>gen_cost = sum(pwl_var[i]*cost_data[1][i]/cost_data[2][i])</code></p><p><strong>LaTeX</strong></p><p><span>$0 &lt;= pwl_i &lt;= (c_{2, i} - c_{2, i-1})$</span></p><p><span>$variable = (sum_{i\in I} pwl_i)$</span></p><p><span>$gen_cost = (sum_{i\in I}  pwl_i) c_{1, i}/c_{2, i}$</span></p><p>Returns <code>gen_cost</code></p><p><strong>Arguments</strong></p><ul><li>optimization<em>container::OptimizationContainer : the optimization</em>container model built in PowerSimulations</li><li>variable::JuMP.Containers.DenseAxisArray{JV} : variable array</li><li>cost_data::Vector{NTuple{2, Float64}} : container for quadratic and linear factors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/cost_functions.jl#L274-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.pwl_gencost_sos!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, String, Vector{Tuple{Float64, Float64}}, Int64}" href="#PowerSimulations.pwl_gencost_sos!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, String, Vector{Tuple{Float64, Float64}}, Int64}"><code>PowerSimulations.pwl_gencost_sos!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns piecewise cost expression using SOS Type-2 implementation for optimization_container model.</p><p><strong>Equations</strong></p><p><code>variable = sum(sos_var[i]*cost_data[2][i])</code></p><p><code>gen_cost = sum(sos_var[i]*cost_data[1][i])</code></p><p><strong>LaTeX</strong></p><p><span>$variable = (sum_{i\in I} c_{2, i} sos_i)$</span></p><p><span>$gen_cost = (sum_{i\in I} c_{1, i} sos_i)$</span></p><p>Returns <code>gen_cost</code></p><p><strong>Arguments</strong></p><ul><li>optimization<em>container::OptimizationContainer : the optimization</em>container model built in PowerSimulations</li><li>variable::JuMP.Containers.DenseAxisArray{JV} : variable array</li><li>cost_data::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/cost_functions.jl#L187-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.pwlparamcheck-Tuple{Any}" href="#PowerSimulations.pwlparamcheck-Tuple{Any}"><code>PowerSimulations.pwlparamcheck</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns True/False depending on compatibility of the cost data with the linear implementation method</p><p>Returns <code>flag</code></p><p><strong>Arguments</strong></p><ul><li>cost_ : container for quadratic and linear factors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/cost_functions.jl#L156-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.ramp_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, D}, Type{S}, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where {T&lt;:ThermalGen, D&lt;:PowerSimulations.AbstractThermalUnitCommitment, S&lt;:PowerModels.AbstractPowerModel}" href="#PowerSimulations.ramp_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{T}, DeviceModel{T, D}, Type{S}, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where {T&lt;:ThermalGen, D&lt;:PowerSimulations.AbstractThermalUnitCommitment, S&lt;:PowerModels.AbstractPowerModel}"><code>PowerSimulations.ramp_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the ramping limits of generators when there are CommitmentVariables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/thermal_generation.jl#L672-L674">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.range_ff-Tuple{PowerSimulations.OptimizationContainer, Symbol, Vector{T} where T, Tuple{PowerSimulations.UpdateRef, PowerSimulations.UpdateRef}, Symbol}" href="#PowerSimulations.range_ff-Tuple{PowerSimulations.OptimizationContainer, Symbol, Vector{T} where T, Tuple{PowerSimulations.UpdateRef, PowerSimulations.UpdateRef}, Symbol}"><code>PowerSimulations.range_ff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    range_ff(optimization_container::OptimizationContainer,
                    cons_name::Symbol,
                    param_reference::NTuple{2, UpdateRef},
                    var_name::Symbol)</code></pre><p>Constructs min/max range parametrized constraint from device variable to include feedforward.</p><p><strong>Constraints</strong></p><p><code>param_reference[1][var_name] &lt;= variable[var_name, t]</code> <code>variable[var_name, t] &lt;= param_reference[2][var_name]</code></p><p>where r in range_data.</p><p><strong>LaTeX</strong></p><p><span>$param^{min} \leq x$</span> <span>$x \leq param^{max}$</span></p><p><strong>Arguments</strong></p><ul><li>optimization<em>container::OptimizationContainer : the optimization</em>container model built in PowerSimulations</li><li>param_reference::NTuple{2, UpdateRef} : Tuple with the lower bound and upper bound parameter reference</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol : the name of the continuous variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/feedforward.jl#L238-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.rating_constraint!-Tuple{PowerSimulations.OptimizationContainer, Vector{Tuple{String, Float64}}, Symbol, Tuple{Symbol, Symbol}}" href="#PowerSimulations.rating_constraint!-Tuple{PowerSimulations.OptimizationContainer, Vector{Tuple{String, Float64}}, Symbol, Tuple{Symbol, Symbol}}"><code>PowerSimulations.rating_constraint!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs constraint from rating data and related variable tuple.</p><p><strong>Constraint</strong></p><p><code>var1[r[1], t]^2 + var2[r[1], t]^2 &lt;= r[2]^2</code></p><p>where r in rating data and t in time steps.</p><p><strong>LaTeX</strong></p><p><span>$x_1^2 + x_2^2 \leq r^2$</span></p><p><strong>Arguments</strong></p><ul><li>optimization<em>container::OptimizationContainer : the optimization</em>container model built in PowerSimulations</li><li>rating_data::Vector{Tuple{String, Float64}} : rating data name (1) and value (2)</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol} : the names of the variables</li><li>: var_names[1] : var1</li><li>: var_names[2] : var2</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/rating_constraints.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.read_dataframe-Tuple{AbstractString}" href="#PowerSimulations.read_dataframe-Tuple{AbstractString}"><code>PowerSimulations.read_dataframe</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a DataFrame from a CSV file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/utils.jl#L10-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.read_json-Tuple{AbstractString}" href="#PowerSimulations.read_json-Tuple{AbstractString}"><code>PowerSimulations.read_json</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a decoded JSON file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/utils.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.read_problem_optimizer_stats-Tuple{PowerSimulations.HdfSimulationStore, Any, Any, Any}" href="#PowerSimulations.read_problem_optimizer_stats-Tuple{PowerSimulations.HdfSimulationStore, Any, Any, Any}"><code>PowerSimulations.read_problem_optimizer_stats</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Read the optimizer stats for a problem execution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/hdf_simulation_store.jl#L181-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.read_problem_optimizer_stats-Tuple{PowerSimulations.HdfSimulationStore, Any}" href="#PowerSimulations.read_problem_optimizer_stats-Tuple{PowerSimulations.HdfSimulationStore, Any}"><code>PowerSimulations.read_problem_optimizer_stats</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the optimizer stats for a problem as a DataFrame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/hdf_simulation_store.jl#L196-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.read_result-Tuple{PowerSimulations.ResultCache, Any, Any, Any, Any}" href="#PowerSimulations.read_result-Tuple{PowerSimulations.ResultCache, Any, Any, Any, Any}"><code>PowerSimulations.read_result</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Read the result from cache. Callers must first call <a href="#PowerSimulations.is_cached-Tuple{PowerSimulations.ResultCache, Any, Any, Any, Any}"><code>is_cached</code></a> to check if the timestamp is present.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/result_cache.jl#L67-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.read_result-Tuple{Type{DataFrames.DataFrame}, PowerSimulations.HdfSimulationStore, Any, Any, Any, Dates.DateTime}" href="#PowerSimulations.read_result-Tuple{Type{DataFrames.DataFrame}, PowerSimulations.HdfSimulationStore, Any, Any, Any, Dates.DateTime}"><code>PowerSimulations.read_result</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return DataFrame, DenseAxisArray, or Array for a model result at a timestamp.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/hdf_simulation_store.jl#L259-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.remove_chars-Tuple{String, String}" href="#PowerSimulations.remove_chars-Tuple{String, String}"><code>PowerSimulations.remove_chars</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Removes the string <code>char</code> from the original string</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/utils.jl#L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.replace_chars-Tuple{String, String, String}" href="#PowerSimulations.replace_chars-Tuple{String, String, String}"><code>PowerSimulations.replace_chars</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Replaces the string in <code>char</code> with the string<code>replacement</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/utils.jl#L356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.reserve_device_semicontinuousrange!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.RangeConstraintSpecInternal}" href="#PowerSimulations.reserve_device_semicontinuousrange!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.RangeConstraintSpecInternal}"><code>PowerSimulations.reserve_device_semicontinuousrange!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs min/max range constraint from device variable and on/off decision variable.</p><p><strong>Constraints</strong></p><p>If device min = 0:</p><p><code>varcts[name, t] &lt;= limits.max * (1 - varbin[name, t])</code></p><p><code>varcts[name, t] &gt;= 0.0</code></p><p>Otherwise:</p><p><code>varcts[name, t] &lt;= limits.max * (1 - varbin[name, t])</code></p><p><code>varcts[name, t] &gt;= limits.min * (1 - varbin[name, t])</code></p><p>where limits in constraint_infos.</p><p><strong>LaTeX</strong></p><p><span>$0 \leq x^{cts} \leq limits^{max} (1 - x^{bin} ), \text{ for } limits^{min} = 0$</span></p><p><span>$limits^{min} (1 - x^{bin} ) \leq x^{cts} \leq limits^{max} (1 - x^{bin} ), \text{ otherwise }$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/range_constraint.jl#L157-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.semicontinuousrange_ff-Tuple{PowerSimulations.OptimizationContainer, Symbol, Vector{PowerSimulations.DeviceRangeConstraintInfo}, PowerSimulations.UpdateRef, Symbol}" href="#PowerSimulations.semicontinuousrange_ff-Tuple{PowerSimulations.OptimizationContainer, Symbol, Vector{PowerSimulations.DeviceRangeConstraintInfo}, PowerSimulations.UpdateRef, Symbol}"><code>PowerSimulations.semicontinuousrange_ff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">        semicontinuousrange_ff(optimization_container::OptimizationContainer,
                                cons_name::Symbol,
                                var_name::Symbol,
                                param_reference::UpdateRef)</code></pre><p>Constructs min/max range constraint from device variable with parameter setting.</p><p><strong>Constraints</strong></p><p>If device min = 0:</p><p><code>variable[var_name, t] &lt;= r[2].max*param_reference[var_name]</code></p><p>Otherwise:</p><p><code>variable[var_name, t] &lt;= r[2].max*param_reference[var_name]</code></p><p><code>variable[var_name, t] &gt;= r[2].min*param_reference[var_name]</code></p><p>where r in range_data.</p><p><strong>LaTeX</strong></p><p><span>$0.0 \leq x^{var} \leq r^{max} x^{param}, \text{ for } r^{min} = 0$</span></p><p><span>$r^{min} x^{param} \leq x^{var} \leq r^{min} x^{param}, \text{ otherwise }$</span></p><p><strong>Arguments</strong></p><ul><li>optimization<em>container::OptimizationContainer : the optimization</em>container model built in PowerSimulations</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol : the name of the continuous variable</li><li>param_reference::UpdateRef : UpdateRef of the parameter</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/feedforward.jl#L321-L353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.serialize_simulation-Tuple{Simulation}" href="#PowerSimulations.serialize_simulation-Tuple{Simulation}"><code>PowerSimulations.serialize_simulation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">serialize_simulation(sim::Simulation, path = &quot;.&quot;)</code></pre><p>Serialize the simulation to a directory in path.</p><p>Return the serialized simulation directory name that is created.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Simulation</code>: simulation to serialize</li><li><code>path = &quot;.&quot;</code>: path in which to create the serialzed directory</li><li><code>force = false</code>: If true, delete the directory if it already exists. Otherwise, it will  throw an exception.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/simulation.jl#L1314-L1326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.service_requirement_constraint!-Union{Tuple{SR}, Tuple{PowerSimulations.OptimizationContainer, SR, ServiceModel{SR, GroupReserve}, Vector{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:Service}} where SR&lt;:StaticReserveGroup" href="#PowerSimulations.service_requirement_constraint!-Union{Tuple{SR}, Tuple{PowerSimulations.OptimizationContainer, SR, ServiceModel{SR, GroupReserve}, Vector{var&quot;#s2015&quot;} where var&quot;#s2015&quot;&lt;:Service}} where SR&lt;:StaticReserveGroup"><code>PowerSimulations.service_requirement_constraint!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the requirement constraint that will be attained by the apropriate services</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/services_models/group_reserve.jl#L17-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.set_variable_bounds!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceRangeConstraintInfo}, AbstractString, Type{T}}} where T&lt;:Component" href="#PowerSimulations.set_variable_bounds!-Union{Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceRangeConstraintInfo}, AbstractString, Type{T}}} where T&lt;:Component"><code>PowerSimulations.set_variable_bounds!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Adds a bounds to a variable in the optimization model.</p><p><strong>Bounds</strong></p><p><code>bounds.min &lt;= varstart[name, t] &lt;= bounds.max</code></p><p><strong>LaTeX</strong></p><p><span>$x^{device}_t &gt;= bound^{min;} \forall t$</span></p><p><span>$x^{device}_t &lt;= bound^{max} \forall t$</span></p><p><strong>Arguments</strong></p><ul><li>optimization<em>container::OptimizationContainer : the optimization</em>container model built in PowerSimulations</li><li>bounds::DeviceRangeConstraintInfo : contains names and vector of min / max</li><li>var_type::AbstractString : type of the variable</li><li>T: type of the device</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/add_variable.jl#L182-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.sparse_container_spec-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any, N} where N}} where T" href="#PowerSimulations.sparse_container_spec-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any, N} where N}} where T"><code>PowerSimulations.sparse_container_spec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns the correct container spec for the selected type of JuMP Model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/utils.jl#L343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.startup_initial_condition_constraints!-Union{Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{ThermalMultiStart}, DeviceModel{ThermalMultiStart, ThermalMultiStartUnitCommitment}, Type{S}, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel" href="#PowerSimulations.startup_initial_condition_constraints!-Union{Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{ThermalMultiStart}, DeviceModel{ThermalMultiStart, ThermalMultiStartUnitCommitment}, Type{S}, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.startup_initial_condition_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the initial conditions for multi-start devices</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/thermal_generation.jl#L1092-L1094">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.startup_time_constraints!-Union{Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{ThermalMultiStart}, DeviceModel{ThermalMultiStart, ThermalMultiStartUnitCommitment}, Type{S}, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel" href="#PowerSimulations.startup_time_constraints!-Union{Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{ThermalMultiStart}, DeviceModel{ThermalMultiStart, ThermalMultiStartUnitCommitment}, Type{S}, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.startup_time_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the contraints for different types of starts based on generator down-time</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/thermal_generation.jl#L997-L999">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.startup_type_constraints!-Union{Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{ThermalMultiStart}, DeviceModel{ThermalMultiStart, ThermalMultiStartUnitCommitment}, Type{S}, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel" href="#PowerSimulations.startup_type_constraints!-Union{Tuple{S}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{ThermalMultiStart}, DeviceModel{ThermalMultiStart, ThermalMultiStartUnitCommitment}, Type{S}, Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.startup_type_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates constraints to select a single type of startup based on off-time</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/thermal_generation.jl#L1032-L1034">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.status_initial_condition!-Union{Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{T}, D}} where {T&lt;:ThermalGen, D&lt;:PowerSimulations.AbstractThermalFormulation}" href="#PowerSimulations.status_initial_condition!-Union{Tuple{D}, Tuple{T}, Tuple{PowerSimulations.OptimizationContainer, InfrastructureSystems.FlattenIteratorWrapper{T}, D}} where {T&lt;:ThermalGen, D&lt;:PowerSimulations.AbstractThermalFormulation}"><code>PowerSimulations.status_initial_condition!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Status Init is always calculated based on the Power Output of the device This is to make it easier to calculate when the previous model doesn&#39;t contain binaries. For instance, looking back on an ED model to find the IC of the UC model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/thermal_generation.jl#L440-L445">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.to_array-Tuple{PowerSimulations.OptimizerStats}" href="#PowerSimulations.to_array-Tuple{PowerSimulations.OptimizerStats}"><code>PowerSimulations.to_array</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert OptimizerStats to an array of floats that can be serialized to HDF5.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/optimizer_stats.jl#L67-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.turbine_temperature-Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceStartUpConstraintInfo}, Symbol, Symbol, Tuple{Symbol, Symbol}}" href="#PowerSimulations.turbine_temperature-Tuple{PowerSimulations.OptimizationContainer, Vector{PowerSimulations.DeviceStartUpConstraintInfo}, Symbol, Symbol, Tuple{Symbol, Symbol}}"><code>PowerSimulations.turbine_temperature</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">turbine_temperature(optimization_container::OptimizationContainer,
                        startup_data::Vector{DeviceStartUpConstraintInfo},
                        cons_name::Symbol,
                        var_stop::Symbol,
                        var_starts::Tuple{Symbol, Symbol})</code></pre><p>Constructs contraints for different types of starts based on generator down-time</p><p><strong>Equations</strong></p><p>for t in time_limits[s+1]:T</p><p><code>var_starts[name, s, t] &lt;= sum( var_stop[name, t-i] for i in time_limits[s]:(time_limits[s+1]-1)</code></p><p><strong>LaTeX</strong></p><p><span>$δ^{s}(t)  \leq \sum_{i=TS^{s}_{g}}^{TS^{s+1}_{g}} x^{stop}(t-i)$</span></p><p><strong>Arguments</strong></p><ul><li>optimization<em>container::OptimizationContainer : the optimization</em>container model built in PowerSimulations</li><li>rate_data::Vector{DeviceStartUpConstraintInfo},</li><li>cons_name::Symbol : name of the constraint</li><li>var_stop::Symbol : name of the stop variable</li><li>var_starts::Tuple{Symbol, Symbol} : the names of the different start variables</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/thermal_generation.jl#L777-L801">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.ub_ff-Tuple{PowerSimulations.OptimizationContainer, Symbol, Vector{PowerSimulations.DeviceRangeConstraintInfo}, PowerSimulations.UpdateRef, Symbol}" href="#PowerSimulations.ub_ff-Tuple{PowerSimulations.OptimizationContainer, Symbol, Vector{PowerSimulations.DeviceRangeConstraintInfo}, PowerSimulations.UpdateRef, Symbol}"><code>PowerSimulations.ub_ff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    ub_ff(optimization_container::OptimizationContainer,
          cons_name::Symbol,
          constraint_infos::Vector{DeviceRangeConstraintInfo},
          param_reference::UpdateRef,
          var_name::Symbol)</code></pre><p>Constructs a parametrized upper bound constraint to implement feedforward from other models. The Parameters are initialized using the uppper boundary values of the provided variables.</p><p><strong>Constraints</strong></p><p><code>variable[var_name, t] &lt;= param_reference[var_name]</code></p><p><strong>LaTeX</strong></p><p><span>$x \leq param^{max}$</span></p><p><strong>Arguments</strong></p><ul><li>optimization<em>container::OptimizationContainer : the optimization</em>container model built in PowerSimulations</li><li>cons_name::Symbol : name of the constraint</li><li>param_reference : Reference to the PJ.ParameterRef used to determine the upperbound</li><li>var_name::Symbol : the name of the continuous variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/feedforward.jl#L176-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.update_parameter!-Tuple{PowerSimulations.UpdateRef{JuMP.VariableRef}, PowerSimulations.ParameterContainer, OperationsProblem, Simulation}" href="#PowerSimulations.update_parameter!-Tuple{PowerSimulations.UpdateRef{JuMP.VariableRef}, PowerSimulations.ParameterContainer, OperationsProblem, Simulation}"><code>PowerSimulations.update_parameter!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Updates the forecast parameter value</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/simulation.jl#L902">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.update_problem!-Union{Tuple{M}, Tuple{OperationsProblem{M}, Simulation}} where M&lt;:PowerSimulations.PowerSimulationsOperationsProblem" href="#PowerSimulations.update_problem!-Union{Tuple{M}, Tuple{OperationsProblem{M}, Simulation}} where M&lt;:PowerSimulations.PowerSimulationsOperationsProblem"><code>PowerSimulations.update_problem!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Generic problem update function for most problems with no customization</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/simulation.jl#L960">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.variable_cost!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, String, Nothing, Int64}" href="#PowerSimulations.variable_cost!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, String, Nothing, Int64}"><code>PowerSimulations.variable_cost!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Adds to the cost function cost terms for sum of variables with common factor to be used for cost expression for optimization_container model.</p><pre><code class="language-none"># Arguments</code></pre><ul><li>optimization<em>container::OptimizationContainer : the optimization</em>container model built in PowerSimulations</li><li>var_name::Symbol: The variable name</li><li>component<em>name::String: The component</em>name of the variable container</li><li>cost_component::PSY.VariableCost{Float64} : container for cost to be associated with variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/cost_functions.jl#L874-L883">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.variable_cost!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, String, VariableCost{Float64}, Int64}" href="#PowerSimulations.variable_cost!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, String, VariableCost{Float64}, Int64}"><code>PowerSimulations.variable_cost!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Adds to the cost function cost terms for sum of variables with common factor to be used for cost expression for optimization_container model.</p><pre><code class="language-none"># Arguments</code></pre><ul><li>optimization<em>container::OptimizationContainer : the optimization</em>container model built in PowerSimulations</li><li>var_name::Symbol: The variable name</li><li>component<em>name::String: The component</em>name of the variable container</li><li>cost_component::PSY.VariableCost{Float64} : container for cost to be associated with variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/cost_functions.jl#L895-L904">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.variable_cost!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, String, VariableCost{Tuple{Float64, Float64}}, Int64}" href="#PowerSimulations.variable_cost!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, String, VariableCost{Tuple{Float64, Float64}}, Int64}"><code>PowerSimulations.variable_cost!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Adds to the cost function cost terms for sum of variables with common factor to be used for cost expression for optimization_container model.</p><p><strong>Equation</strong></p><p><code>gen_cost = dt*sign*(sum(variable.^2)*cost_data[1] + sum(variable)*cost_data[2])</code></p><p><strong>LaTeX</strong></p><p><span>$cost = dt\times sign (sum_{i\in I} c_1 v_i^2 + sum_{i\in I} c_2 v_i )$</span></p><p>for quadratic factor large enough. If the first term of the quadratic objective is 0.0, adds a linear cost term <code>sum(variable)*cost_data[2]</code></p><p><strong>Arguments</strong></p><ul><li>optimization<em>container::OptimizationContainer : the optimization</em>container model built in PowerSimulations</li><li>var_name::Symbol: The variable name</li><li>component<em>name::String: The component</em>name of the variable container</li><li>cost_component::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/cost_functions.jl#L926-L946">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.variable_cost!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, String, VariableCost{Vector{Tuple{Float64, Float64}}}, Int64}" href="#PowerSimulations.variable_cost!-Tuple{PowerSimulations.OptimizationContainer, PowerSimulations.AddCostSpec, String, VariableCost{Vector{Tuple{Float64, Float64}}}, Int64}"><code>PowerSimulations.variable_cost!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates piecewise linear cost function using a sum of variables and expression with sign and time step included.</p><p><strong>Expression</strong></p><p><code>JuMP.add_to_expression!(gen_cost, c)</code></p><p>Returns sign<em>gen_cost</em>dt</p><p><strong>LaTeX</strong></p><p><span>$cost = sign\times dt \sum_{v\in V} c_v$</span></p><p>where <span>$c_v$</span> is given by</p><p><span>$c_v = \sum_{i\in Ix} \frac{y_i - y_{i-1}}{x_i - x_{i-1}} v^{p.w.}_i$</span></p><p><strong>Arguments</strong></p><ul><li>optimization<em>container::OptimizationContainer : the optimization</em>container model built in PowerSimulations</li><li>var_name::Symbol: The variable name</li><li>component<em>name::String: The component</em>name of the variable container</li><li>cost_component::PSY.VariableCost{Vector{NTuple{2, Float64}}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/devices_models/devices/common/cost_functions.jl#L980-L1003">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.variable_reactive_net_injection-Tuple{PowerModels.AbstractActivePowerModel}" href="#PowerSimulations.variable_reactive_net_injection-Tuple{PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.variable_reactive_net_injection</code></a> — <span class="docstring-category">Method</span></header><section><div><p>active power only models ignore reactive power variables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/network_models/powermodels_interface.jl#L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.write_result!" href="#PowerSimulations.write_result!"><code>PowerSimulations.write_result!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Write a model result for a timestamp to the store.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/3a21abdba73bff98c3c54a93da1293cb0ec647f5/src/core/hdf_simulation_store.jl#L349-L351">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../ref/hydro/">« Hydro Models</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 4 August 2021 21:34">Wednesday 4 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
